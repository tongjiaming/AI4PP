<s> from django . utils . translation import ugettext_lazy as _ <EOL> from horizon import tabs <EOL> class NetworkProfileTab ( tabs . Tab ) : <EOL> name = _ ( "<STR_LIT>" ) <EOL> slug = "<STR_LIT>" <EOL> template_name = '<STR_LIT>' <EOL> def get_context_data ( self , request ) : <EOL> return None <EOL> class PolicyProfileTab ( tabs . Tab ) : <EOL> name = _ ( "<STR_LIT>" ) <EOL> slug = "<STR_LIT>" <EOL> template_name = '<STR_LIT>' <EOL> preload = False <EOL> class IndexTabs ( tabs . TabGroup ) : <EOL> slug = "<STR_LIT>" <EOL> tabs = ( NetworkProfileTab , PolicyProfileTab ) </s>
<s> """<STR_LIT>""" <EOL> import weakref <EOL> from eventlet import corolocal <EOL> class WeakLocal ( corolocal . local ) : <EOL> def __getattribute__ ( self , attr ) : <EOL> rval = corolocal . local . __getattribute__ ( self , attr ) <EOL> if rval : <EOL> rval = rval ( ) <EOL> return rval <EOL> def __setattr__ ( self , attr , value ) : <EOL> value = weakref . ref ( value ) <EOL> return corolocal . local . __setattr__ ( self , attr , value ) <EOL> store = WeakLocal ( ) <EOL> weak_store = WeakLocal ( ) <EOL> strong_store = corolocal . local </s>
<s> import eventlet <EOL> eventlet . monkey_patch ( ) <EOL> import contextlib <EOL> import sys <EOL> from oslo . config import cfg <EOL> from openstack_dashboard . openstack . common import log as logging <EOL> from openstack_dashboard . openstack . common import rpc <EOL> from openstack_dashboard . openstack . common . rpc import impl_zmq <EOL> CONF = cfg . CONF <EOL> CONF . register_opts ( rpc . rpc_opts ) <EOL> CONF . register_opts ( impl_zmq . zmq_opts ) <EOL> def main ( ) : <EOL> CONF ( sys . argv [ <NUM_LIT:1> : ] , project = '<STR_LIT>' ) <EOL> logging . setup ( "<STR_LIT>" ) <EOL> with contextlib . closing ( impl_zmq . ZmqProxy ( CONF ) ) as reactor : <EOL> reactor . consume_in_thread ( ) <EOL> reactor . wait ( ) </s>
<s> from openstack_dashboard import api <EOL> from openstack_dashboard . test import helpers as test <EOL> from neutronclient . v2_0 import client <EOL> neutronclient = client . Client <EOL> class VPNaasApiTests ( test . APITestCase ) : <EOL> @ test . create_stubs ( { neutronclient : ( '<STR_LIT>' , ) } ) <EOL> def test_vpnservice_create ( self ) : <EOL> vpnservice1 = self . api_vpnservices . first ( ) <EOL> form_data = { <EOL> '<STR_LIT:name>' : vpnservice1 [ '<STR_LIT:name>' ] , <EOL> '<STR_LIT:description>' : vpnservice1 [ '<STR_LIT:description>' ] , <EOL> '<STR_LIT>' : vpnservice1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : vpnservice1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : vpnservice1 [ '<STR_LIT>' ] <EOL> } <EOL> vpnservice = { '<STR_LIT>' : self . api_vpnservices . first ( ) } <EOL> neutronclient . create_vpnservice ( <EOL> { '<STR_LIT>' : form_data } ) . AndReturn ( vpnservice ) <EOL> self . mox . ReplayAll ( ) <EOL> ret_val = api . vpn . vpnservice_create ( self . request , ** form_data ) <EOL> self . assertIsInstance ( ret_val , api . vpn . VPNService ) <EOL> @ test . create_stubs ( { neutronclient : ( '<STR_LIT>' , ) } ) <EOL> def test_vpnservices_get ( self ) : <EOL> vpnservices = { '<STR_LIT>' : self . vpnservices . list ( ) } <EOL> vpnservices_dict = { '<STR_LIT>' : self . api_vpnservices . list ( ) } <EOL> neutronclient . list_vpnservices ( ) . AndReturn ( vpnservices_dict ) <EOL> self . mox . ReplayAll ( ) <EOL> ret_val = api . vpn . vpnservices_get ( self . request ) <EOL> for ( v , d ) in zip ( ret_val , vpnservices [ '<STR_LIT>' ] ) : <EOL> self . assertIsInstance ( v , api . vpn . VPNService ) <EOL> self . assertTrue ( v . name , d . name ) <EOL> self . assertTrue ( v . id ) <EOL> @ test . create_stubs ( { neutronclient : ( '<STR_LIT>' , ) } ) <EOL> def test_vpnservice_get ( self ) : <EOL> vpnservice1 = self . api_vpnservices . first ( ) <EOL> vpnservice = { '<STR_LIT>' : vpnservice1 } <EOL> neutronclient . show_vpnservice ( <EOL> vpnservice [ '<STR_LIT>' ] [ '<STR_LIT:id>' ] ) . AndReturn ( vpnservice ) <EOL> self . mox . ReplayAll ( ) <EOL> ret_val = api . vpn . vpnservice_get ( self . request , <EOL> vpnservice [ '<STR_LIT>' ] [ '<STR_LIT:id>' ] ) <EOL> self . assertIsInstance ( ret_val , api . vpn . VPNService ) <EOL> @ test . create_stubs ( { neutronclient : ( '<STR_LIT>' , ) } ) <EOL> def test_ikepolicy_create ( self ) : <EOL> ikepolicy1 = self . api_ikepolicies . first ( ) <EOL> form_data = { <EOL> '<STR_LIT:name>' : ikepolicy1 [ '<STR_LIT:name>' ] , <EOL> '<STR_LIT:description>' : ikepolicy1 [ '<STR_LIT:description>' ] , <EOL> '<STR_LIT>' : ikepolicy1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ikepolicy1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ikepolicy1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ikepolicy1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ikepolicy1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ikepolicy1 [ '<STR_LIT>' ] <EOL> } <EOL> ikepolicy = { '<STR_LIT>' : self . api_ikepolicies . first ( ) } <EOL> neutronclient . create_ikepolicy ( <EOL> { '<STR_LIT>' : form_data } ) . AndReturn ( ikepolicy ) <EOL> self . mox . ReplayAll ( ) <EOL> ret_val = api . vpn . ikepolicy_create ( self . request , ** form_data ) <EOL> self . assertIsInstance ( ret_val , api . vpn . IKEPolicy ) <EOL> @ test . create_stubs ( { neutronclient : ( '<STR_LIT>' , ) } ) <EOL> def test_ikepolicies_get ( self ) : <EOL> ikepolicies = { '<STR_LIT>' : self . ikepolicies . list ( ) } <EOL> ikepolicies_dict = { '<STR_LIT>' : self . api_ikepolicies . list ( ) } <EOL> neutronclient . list_ikepolicies ( ) . AndReturn ( ikepolicies_dict ) <EOL> self . mox . ReplayAll ( ) <EOL> ret_val = api . vpn . ikepolicies_get ( self . request ) <EOL> for ( v , d ) in zip ( ret_val , ikepolicies [ '<STR_LIT>' ] ) : <EOL> self . assertIsInstance ( v , api . vpn . IKEPolicy ) <EOL> self . assertTrue ( v . name , d . name ) <EOL> self . assertTrue ( v . id ) <EOL> @ test . create_stubs ( { neutronclient : ( '<STR_LIT>' , ) } ) <EOL> def test_ikepolicy_get ( self ) : <EOL> ikepolicy1 = self . api_ikepolicies . first ( ) <EOL> ikepolicy = { '<STR_LIT>' : ikepolicy1 } <EOL> neutronclient . show_ikepolicy ( <EOL> ikepolicy [ '<STR_LIT>' ] [ '<STR_LIT:id>' ] ) . AndReturn ( ikepolicy ) <EOL> self . mox . ReplayAll ( ) <EOL> ret_val = api . vpn . ikepolicy_get ( self . request , <EOL> ikepolicy [ '<STR_LIT>' ] [ '<STR_LIT:id>' ] ) <EOL> self . assertIsInstance ( ret_val , api . vpn . IKEPolicy ) <EOL> @ test . create_stubs ( { neutronclient : ( '<STR_LIT>' , ) } ) <EOL> def test_ipsecpolicy_create ( self ) : <EOL> ipsecpolicy1 = self . api_ipsecpolicies . first ( ) <EOL> form_data = { <EOL> '<STR_LIT:name>' : ipsecpolicy1 [ '<STR_LIT:name>' ] , <EOL> '<STR_LIT:description>' : ipsecpolicy1 [ '<STR_LIT:description>' ] , <EOL> '<STR_LIT>' : ipsecpolicy1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ipsecpolicy1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ipsecpolicy1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ipsecpolicy1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ipsecpolicy1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ipsecpolicy1 [ '<STR_LIT>' ] <EOL> } <EOL> ipsecpolicy = { '<STR_LIT>' : self . api_ipsecpolicies . first ( ) } <EOL> neutronclient . create_ipsecpolicy ( <EOL> { '<STR_LIT>' : form_data } ) . AndReturn ( ipsecpolicy ) <EOL> self . mox . ReplayAll ( ) <EOL> ret_val = api . vpn . ipsecpolicy_create ( self . request , ** form_data ) <EOL> self . assertIsInstance ( ret_val , api . vpn . IPSecPolicy ) <EOL> @ test . create_stubs ( { neutronclient : ( '<STR_LIT>' , ) } ) <EOL> def test_ipsecpolicies_get ( self ) : <EOL> ipsecpolicies = { '<STR_LIT>' : self . ipsecpolicies . list ( ) } <EOL> ipsecpolicies_dict = { '<STR_LIT>' : self . api_ipsecpolicies . list ( ) } <EOL> neutronclient . list_ipsecpolicies ( ) . AndReturn ( ipsecpolicies_dict ) <EOL> self . mox . ReplayAll ( ) <EOL> ret_val = api . vpn . ipsecpolicies_get ( self . request ) <EOL> for ( v , d ) in zip ( ret_val , ipsecpolicies [ '<STR_LIT>' ] ) : <EOL> self . assertIsInstance ( v , api . vpn . IPSecPolicy ) <EOL> self . assertTrue ( v . name , d . name ) <EOL> self . assertTrue ( v . id ) <EOL> @ test . create_stubs ( { neutronclient : ( '<STR_LIT>' , ) } ) <EOL> def test_ipsecpolicy_get ( self ) : <EOL> ipsecpolicy1 = self . api_ipsecpolicies . first ( ) <EOL> ipsecpolicy = { '<STR_LIT>' : ipsecpolicy1 } <EOL> neutronclient . show_ipsecpolicy ( <EOL> ipsecpolicy [ '<STR_LIT>' ] [ '<STR_LIT:id>' ] ) . AndReturn ( ipsecpolicy ) <EOL> self . mox . ReplayAll ( ) <EOL> ret_val = api . vpn . ipsecpolicy_get ( self . request , <EOL> ipsecpolicy [ '<STR_LIT>' ] [ '<STR_LIT:id>' ] ) <EOL> self . assertIsInstance ( ret_val , api . vpn . IPSecPolicy ) <EOL> @ test . create_stubs ( { neutronclient : ( '<STR_LIT>' , ) } ) <EOL> def test_ipsecsiteconnection_create ( self ) : <EOL> ipsecsiteconnection1 = self . api_ipsecsiteconnections . first ( ) <EOL> form_data = { <EOL> '<STR_LIT:name>' : ipsecsiteconnection1 [ '<STR_LIT:name>' ] , <EOL> '<STR_LIT:description>' : ipsecsiteconnection1 [ '<STR_LIT:description>' ] , <EOL> '<STR_LIT>' : ipsecsiteconnection1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ipsecsiteconnection1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ipsecsiteconnection1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ipsecsiteconnection1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ipsecsiteconnection1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ipsecsiteconnection1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ipsecsiteconnection1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ipsecsiteconnection1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ipsecsiteconnection1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ipsecsiteconnection1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ipsecsiteconnection1 [ '<STR_LIT>' ] <EOL> } <EOL> ipsecsiteconnection = { '<STR_LIT>' : <EOL> self . api_ipsecsiteconnections . first ( ) } <EOL> neutronclient . create_ipsec_site_connection ( <EOL> { '<STR_LIT>' : <EOL> form_data } ) . AndReturn ( ipsecsiteconnection ) <EOL> self . mox . ReplayAll ( ) <EOL> ret_val = api . vpn . ipsecsiteconnection_create ( <EOL> self . request , ** form_data ) <EOL> self . assertIsInstance ( ret_val , api . vpn . IPSecSiteConnection ) <EOL> @ test . create_stubs ( { neutronclient : ( '<STR_LIT>' , ) } ) <EOL> def test_ipsecsiteconnections_get ( self ) : <EOL> ipsecsiteconnections = { <EOL> '<STR_LIT>' : self . ipsecsiteconnections . list ( ) } <EOL> ipsecsiteconnections_dict = { <EOL> '<STR_LIT>' : self . api_ipsecsiteconnections . list ( ) } <EOL> neutronclient . list_ipsec_site_connections ( ) . AndReturn ( <EOL> ipsecsiteconnections_dict ) <EOL> self . mox . ReplayAll ( ) <EOL> ret_val = api . vpn . ipsecsiteconnections_get ( self . request ) <EOL> for ( v , d ) in zip ( ret_val , <EOL> ipsecsiteconnections [ '<STR_LIT>' ] ) : <EOL> self . assertIsInstance ( v , api . vpn . IPSecSiteConnection ) <EOL> self . assertTrue ( v . name , d . name ) <EOL> self . assertTrue ( v . id ) <EOL> @ test . create_stubs ( { neutronclient : ( '<STR_LIT>' , ) } ) <EOL> def test_ipsecsiteconnection_get ( self ) : <EOL> ipsecsiteconnection1 = self . api_ipsecsiteconnections . first ( ) <EOL> ipsecsiteconnection = { '<STR_LIT>' : ipsecsiteconnection1 } <EOL> neutronclient . show_ipsec_site_connection ( <EOL> ipsecsiteconnection [ '<STR_LIT>' ] [ '<STR_LIT:id>' ] ) . AndReturn ( <EOL> ipsecsiteconnection ) <EOL> self . mox . ReplayAll ( ) <EOL> ret_val = api . vpn . ipsecsiteconnection_get ( self . request , <EOL> ipsecsiteconnection [ '<STR_LIT>' ] [ '<STR_LIT:id>' ] ) <EOL> self . assertIsInstance ( ret_val , api . vpn . IPSecSiteConnection ) </s>
<s> from horizon import tables <EOL> from openstack_dashboard . usage import base <EOL> class UsageView ( tables . DataTableView ) : <EOL> usage_class = None <EOL> show_terminated = True <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( UsageView , self ) . __init__ ( * args , ** kwargs ) <EOL> if not issubclass ( self . usage_class , base . BaseUsage ) : <EOL> raise AttributeError ( "<STR_LIT>" <EOL> "<STR_LIT>" ) <EOL> def get_template_names ( self ) : <EOL> if self . request . GET . get ( '<STR_LIT>' , '<STR_LIT:html>' ) == '<STR_LIT>' : <EOL> return "<STR_LIT:.>" . join ( ( self . template_name . rsplit ( '<STR_LIT:.>' , <NUM_LIT:1> ) [ <NUM_LIT:0> ] , '<STR_LIT>' ) ) <EOL> return self . template_name <EOL> def get_content_type ( self ) : <EOL> if self . request . GET . get ( '<STR_LIT>' , '<STR_LIT:html>' ) == '<STR_LIT>' : <EOL> return "<STR_LIT>" <EOL> return "<STR_LIT>" <EOL> def get_data ( self ) : <EOL> project_id = self . kwargs . get ( '<STR_LIT>' , self . request . user . tenant_id ) <EOL> self . usage = self . usage_class ( self . request , project_id ) <EOL> self . usage . summarize ( * self . usage . get_date_range ( ) ) <EOL> self . usage . get_limits ( ) <EOL> self . kwargs [ '<STR_LIT>' ] = self . usage <EOL> return self . usage . usage_list <EOL> def get_context_data ( self , ** kwargs ) : <EOL> context = super ( UsageView , self ) . get_context_data ( ** kwargs ) <EOL> context [ '<STR_LIT>' ] . kwargs [ '<STR_LIT>' ] = self . usage <EOL> context [ '<STR_LIT>' ] = self . usage . form <EOL> context [ '<STR_LIT>' ] = self . usage <EOL> return context <EOL> def render_to_response ( self , context , ** response_kwargs ) : <EOL> if self . request . GET . get ( '<STR_LIT>' , '<STR_LIT:html>' ) == '<STR_LIT>' : <EOL> render_class = self . csv_response_class <EOL> response_kwargs . setdefault ( "<STR_LIT:filename>" , "<STR_LIT>" ) <EOL> else : <EOL> render_class = self . response_class <EOL> resp = render_class ( request = self . request , <EOL> template = self . get_template_names ( ) , <EOL> context = context , <EOL> content_type = self . get_content_type ( ) , <EOL> ** response_kwargs ) <EOL> return resp </s>
<s> from enum import IntEnum <EOL> from . component import Component <EOL> from . object import field <EOL> class ReflectionProbeUsage ( IntEnum ) : <EOL> Off = <NUM_LIT:0> <EOL> BlendProbes = <NUM_LIT:1> <EOL> BlendProbesAndSkybox = <NUM_LIT:2> <EOL> Simple = <NUM_LIT:3> <EOL> class ShadowCastingMode ( IntEnum ) : <EOL> Off = <NUM_LIT:0> <EOL> On = <NUM_LIT:1> <EOL> TwoSided = <NUM_LIT:2> <EOL> ShadowsOnly = <NUM_LIT:3> <EOL> class Renderer ( Component ) : <EOL> enabled = field ( "<STR_LIT>" , bool ) <EOL> lightmap_index = field ( "<STR_LIT>" ) <EOL> materials = field ( "<STR_LIT>" ) <EOL> probe_anchor = field ( "<STR_LIT>" ) <EOL> receive_shadows = field ( "<STR_LIT>" , bool ) <EOL> reflection_probe_usage = field ( "<STR_LIT>" , ReflectionProbeUsage ) <EOL> shadow_casting_mode = field ( "<STR_LIT>" , ShadowCastingMode ) <EOL> sorting_layer_id = field ( "<STR_LIT>" ) <EOL> sorting_order = field ( "<STR_LIT>" ) <EOL> use_light_probes = field ( "<STR_LIT>" , bool ) <EOL> lightmap_index_dynamic = field ( "<STR_LIT>" ) <EOL> lightmap_tiling_offset = field ( "<STR_LIT>" ) <EOL> lightmap_tiling_offset_dynamic = field ( "<STR_LIT>" ) <EOL> static_batch_root = field ( "<STR_LIT>" ) <EOL> subset_indices = field ( "<STR_LIT>" ) <EOL> @ property <EOL> def material ( self ) : <EOL> return self . materials [ <NUM_LIT:0> ] <EOL> class ParticleSystemRenderMode ( IntEnum ) : <EOL> Billboard = <NUM_LIT:0> <EOL> Stretch = <NUM_LIT:1> <EOL> HorizontalBillboard = <NUM_LIT:2> <EOL> VerticalBillboard = <NUM_LIT:3> <EOL> Mesh = <NUM_LIT:4> <EOL> class ParticleSystemSortMode ( IntEnum ) : <EOL> None_ = <NUM_LIT:0> <EOL> Distance = <NUM_LIT:1> <EOL> OldestInFront = <NUM_LIT:2> <EOL> YoungestInFront = <NUM_LIT:3> <EOL> class MeshRenderer ( Component ) : <EOL> pass <EOL> class ParticleRenderer ( Renderer ) : <EOL> camera_velocity_scale = field ( "<STR_LIT>" ) <EOL> length_scale = field ( "<STR_LIT>" ) <EOL> max_particle_size = field ( "<STR_LIT>" ) <EOL> velocity_scale = field ( "<STR_LIT>" ) <EOL> stretch_particles = field ( "<STR_LIT>" ) <EOL> uv_animation = field ( "<STR_LIT>" ) <EOL> class ParticleSystemRenderer ( Renderer ) : <EOL> camera_velocity_scale = field ( "<STR_LIT>" ) <EOL> length_scale = field ( "<STR_LIT>" ) <EOL> max_particle_size = field ( "<STR_LIT>" ) <EOL> mesh = field ( "<STR_LIT>" ) <EOL> mesh1 = field ( "<STR_LIT>" ) <EOL> mesh2 = field ( "<STR_LIT>" ) <EOL> mesh3 = field ( "<STR_LIT>" ) <EOL> normal_direction = field ( "<STR_LIT>" ) <EOL> render_mode = field ( "<STR_LIT>" , ParticleSystemRenderMode ) <EOL> sort_mode = field ( "<STR_LIT>" , ParticleSystemSortMode ) <EOL> sorting_fudge = field ( "<STR_LIT>" ) <EOL> velocity_scale = field ( "<STR_LIT>" ) </s>
<s> from ConfigParser import * <EOL> from StringIO import * <EOL> from Log import Log <EOL> import datetime <EOL> class Config : <EOL> @ staticmethod <EOL> def LoadConfig ( ) : <EOL> Config . parser = ConfigParser ( ) <EOL> try : <EOL> sconff = open ( CONFIG_FILE , "<STR_LIT:r>" ) <EOL> except : <EOL> Log . warn ( "<STR_LIT>" ) <EOL> return <EOL> sconf = StringIO ( ) <EOL> sconf . write ( "<STR_LIT>" ) <EOL> sconf . write ( sconff . read ( ) ) <EOL> sconf . seek ( <NUM_LIT:0> ) <EOL> Config . parser . readfp ( sconf ) <EOL> sconff . close ( ) <EOL> sconf . close ( ) <EOL> return <EOL> @ staticmethod <EOL> def GetBoardsFile ( ) : <EOL> return BOARDS_FILE <EOL> @ staticmethod <EOL> def GetInt ( name , defval ) : <EOL> if ( Config . parser . has_option ( '<STR_LIT>' , name ) ) : <EOL> return Config . parser . getint ( '<STR_LIT>' , name ) <EOL> else : <EOL> return defval <EOL> @ staticmethod <EOL> def GetString ( name , defval ) : <EOL> if ( Config . parser . has_option ( '<STR_LIT>' , name ) ) : <EOL> val = Config . parser . get ( '<STR_LIT>' , name ) <EOL> if ( val [ <NUM_LIT:0> ] == '<STR_LIT:">' and val . endswith ( '<STR_LIT:">' ) ) : <EOL> val = val [ <NUM_LIT:1> : - <NUM_LIT:1> ] <EOL> return val . decode ( '<STR_LIT>' ) <EOL> else : <EOL> return defval <EOL> BBS_ROOT = '<STR_LIT>' <EOL> BBS_XMPP_CERT_FILE = BBS_ROOT + "<STR_LIT>" <EOL> BBS_XMPP_KEY_FILE = BBS_ROOT + "<STR_LIT>" <EOL> BOARDS_FILE = BBS_ROOT + '<STR_LIT>' <EOL> STRLEN = <NUM_LIT> <EOL> ARTICLE_TITLE_LEN = <NUM_LIT> <EOL> BM_LEN = <NUM_LIT> <EOL> MAXBOARD = <NUM_LIT> <EOL> CONFIG_FILE = BBS_ROOT + '<STR_LIT>' <EOL> FILENAME_LEN = <NUM_LIT:20> <EOL> OWNER_LEN = <NUM_LIT:30> <EOL> SESSIONID_LEN = <NUM_LIT:32> <EOL> REFRESH_TOKEN_LEN = <NUM_LIT> <EOL> NAMELEN = <NUM_LIT> <EOL> IDLEN = <NUM_LIT:12> <EOL> MD5PASSLEN = <NUM_LIT:16> <EOL> OLDPASSLEN = <NUM_LIT> <EOL> MOBILE_NUMBER_LEN = <NUM_LIT> <EOL> MAXCLUB = <NUM_LIT> <EOL> MAXUSERS = <NUM_LIT> <EOL> MAX_MSG_SIZE = <NUM_LIT> <EOL> MAXFRIENDS = <NUM_LIT> <EOL> MAXMESSAGE = <NUM_LIT:5> <EOL> MAXSIGLINES = <NUM_LIT:6> <EOL> IPLEN = <NUM_LIT:16> <EOL> DEFAULTBOARD = "<STR_LIT>" <EOL> BLESS_BOARD = "<STR_LIT>" <EOL> QUOTED_LINES = <NUM_LIT:10> <EOL> MAXACTIVE = <NUM_LIT> <EOL> USHM_SIZE = MAXACTIVE + <NUM_LIT:10> <EOL> UTMP_HASHSIZE = USHM_SIZE * <NUM_LIT:4> <EOL> UCACHE_SEMLOCK = <NUM_LIT:0> <EOL> LEN_FRIEND_EXP = <NUM_LIT:15> <EOL> REFRESH_TIME = <NUM_LIT:30> <EOL> USER_TITLE_LEN = <NUM_LIT> <EOL> SESSION_TIMEOUT = datetime . timedelta ( <NUM_LIT:30> ) <EOL> SESSION_TIMEOUT_SECONDS = <NUM_LIT> * <NUM_LIT:30> <EOL> XMPP_IDLE_TIME = <NUM_LIT> <EOL> XMPP_LONG_IDLE_TIME = <NUM_LIT> <EOL> XMPP_UPDATE_TIME_INTERVAL = <NUM_LIT:10> <EOL> XMPP_PING_TIME_INTERVAL = <NUM_LIT> <EOL> PUBLIC_SHMKEY = <NUM_LIT> <EOL> MAX_ATTACHSIZE = <NUM_LIT:20> * <NUM_LIT> * <NUM_LIT> <EOL> BMDEL_DECREASE = True <EOL> SYSMAIL_BOARD = "<STR_LIT>" <EOL> ADD_EDITMARK = True <EOL> SEARCH_COUNT_LIMIT = <NUM_LIT:20> <EOL> MAIL_SIZE_LIMIT = - <NUM_LIT:1> <EOL> SEC_DELETED_OLDHOME = <NUM_LIT> * <NUM_LIT> * <NUM_LIT:3> <EOL> SELF_INTRO_MAX_LEN = <NUM_LIT> </s>
<s> import re <EOL> import os <EOL> import stat <EOL> import json <EOL> import struct <EOL> import time <EOL> import Config <EOL> import Board <EOL> import Post <EOL> import BoardManager <EOL> from Util import Util <EOL> from Log import Log <EOL> from errors import * <EOL> DEFAULT_DIGEST_LIST_COUNT = <NUM_LIT:20> <EOL> class DigestItem : <EOL> def __init__ ( self , basepath ) : <EOL> self . basepath = basepath <EOL> self . title = '<STR_LIT>' <EOL> self . host = '<STR_LIT>' <EOL> self . port = <NUM_LIT:0> <EOL> self . attachpos = <NUM_LIT:0> <EOL> self . fname = '<STR_LIT>' <EOL> self . mtitle = '<STR_LIT>' <EOL> self . items = [ ] <EOL> self . update_time = <NUM_LIT:0> <EOL> self . id = <NUM_LIT:0> <EOL> self . sysop_only = <NUM_LIT:0> <EOL> self . bms_only = <NUM_LIT:0> <EOL> self . zixia_only = <NUM_LIT:0> <EOL> def IsDir ( self ) : <EOL> try : <EOL> st = os . stat ( self . realpath ( ) ) <EOL> return stat . S_ISDIR ( st . st_mode ) <EOL> except : <EOL> return False <EOL> def IsFile ( self ) : <EOL> try : <EOL> st = os . stat ( self . realpath ( ) ) <EOL> return stat . S_ISREG ( st . st_mode ) <EOL> except : <EOL> return False <EOL> def GetModTime ( self ) : <EOL> try : <EOL> st = os . stat ( self . realpath ( ) ) <EOL> mtime = st . st_mtime <EOL> except : <EOL> mtime = time . time ( ) <EOL> return mtime <EOL> def names_path ( self ) : <EOL> return "<STR_LIT>" % self . realpath ( ) <EOL> def realpath ( self ) : <EOL> return "<STR_LIT>" % ( Config . BBS_ROOT , self . path ( ) ) <EOL> def path ( self ) : <EOL> if ( self . fname ) : <EOL> return "<STR_LIT>" % ( self . basepath , self . fname ) <EOL> else : <EOL> return self . basepath <EOL> def CheckUpdate ( self ) : <EOL> try : <EOL> stat = os . stat ( self . names_path ( ) ) <EOL> if ( stat . st_mtime > self . update_time ) : <EOL> self . LoadNames ( ) <EOL> except : <EOL> return False <EOL> return True <EOL> def LoadNames ( self ) : <EOL> try : <EOL> f = open ( self . names_path ( ) , "<STR_LIT:r>" ) <EOL> except IOError : <EOL> return <NUM_LIT:0> <EOL> stat = os . fstat ( f . fileno ( ) ) <EOL> self . update_time = stat . st_mtime <EOL> item = DigestItem ( self . path ( ) ) <EOL> hostname = '<STR_LIT>' <EOL> _id = <NUM_LIT:0> <EOL> bms_only = <NUM_LIT:0> <EOL> sysop_only = <NUM_LIT:0> <EOL> zixia_only = <NUM_LIT:0> <EOL> while ( True ) : <EOL> line = f . readline ( ) <EOL> if ( line == "<STR_LIT>" ) : break <EOL> npos = line . find ( "<STR_LIT:\n>" ) <EOL> if ( npos != - <NUM_LIT:1> ) : line = line [ : npos ] <EOL> if ( line [ : <NUM_LIT:1> ] == '<STR_LIT:#>' ) : <EOL> if ( line [ : <NUM_LIT:8> ] == "<STR_LIT>" ) : <EOL> if ( not self . mtitle ) : <EOL> self . mtitle = line [ <NUM_LIT:8> : ] <EOL> result = re . match ( '<STR_LIT>' , line ) <EOL> if ( result ) : <EOL> key = result . group ( <NUM_LIT:1> ) <EOL> value = result . group ( <NUM_LIT:2> ) <EOL> if ( key == "<STR_LIT:Name>" ) : <EOL> item . title = value <EOL> item . attachpos = <NUM_LIT:0> <EOL> elif ( key == "<STR_LIT>" ) : <EOL> if ( value [ : <NUM_LIT:2> ] == "<STR_LIT>" ) : <EOL> item . fname = value [ <NUM_LIT:2> : ] <EOL> else : <EOL> item . fname = value <EOL> if ( item . fname . find ( "<STR_LIT:..>" ) != - <NUM_LIT:1> ) : <EOL> continue <EOL> if ( item . title . find ( "<STR_LIT>" ) != - <NUM_LIT:1> ) : <EOL> bms_only += <NUM_LIT:1> <EOL> elif ( item . title . find ( "<STR_LIT>" ) != - <NUM_LIT:1> ) : <EOL> sysop_only += <NUM_LIT:1> <EOL> elif ( item . title . find ( "<STR_LIT>" ) != - <NUM_LIT:1> ) : <EOL> zixia_only += <NUM_LIT:1> <EOL> if ( item . fname . find ( "<STR_LIT>" ) != - <NUM_LIT:1> ) : <EOL> parts = re . split ( '<STR_LIT>' , item . fname ) <EOL> newparts = [ ] <EOL> for part in parts : <EOL> if ( part ) : <EOL> newparts += [ part ] <EOL> hostname = newparts [ <NUM_LIT:0> ] <EOL> item . fname = newparts [ <NUM_LIT:1> ] <EOL> try : <EOL> item . port = int ( newparts [ <NUM_LIT:2> ] ) <EOL> except : <EOL> item . port = <NUM_LIT:0> <EOL> item . id = _id <EOL> _id += <NUM_LIT:1> <EOL> item . bms_only = bms_only <EOL> item . sysop_only = sysop_only <EOL> item . zixia_only = zixia_only <EOL> item . host = hostname <EOL> self . items += [ item ] <EOL> item = DigestItem ( self . path ( ) ) <EOL> hostname = '<STR_LIT>' <EOL> elif ( key == "<STR_LIT>" ) : <EOL> hostname = value <EOL> elif ( key == "<STR_LIT>" ) : <EOL> try : <EOL> item . port = int ( value ) <EOL> except : <EOL> item . port = <NUM_LIT:0> <EOL> elif ( key == "<STR_LIT>" ) : <EOL> try : <EOL> item . attachpos = int ( value ) <EOL> except : <EOL> item . attachpos = <NUM_LIT:0> <EOL> f . close ( ) <EOL> return <NUM_LIT:1> <EOL> def GetItem ( self , user , route , has_perm = False , need_perm = False ) : <EOL> self . CheckUpdate ( ) <EOL> if ( self . mtitle . find ( "<STR_LIT>" ) != - <NUM_LIT:1> ) : <EOL> if ( Board . Board . IsBM ( user , self . mtitle [ <NUM_LIT:4> : ] , ) or user . IsSysop ( ) ) : <EOL> has_perm = True <EOL> elif ( need_perm and not has_perm ) : <EOL> return None <EOL> if ( self . mtitle . find ( "<STR_LIT>" ) != - <NUM_LIT:1> <EOL> or self . mtitle . find ( "<STR_LIT>" ) != - <NUM_LIT:1> <EOL> or self . mtitle . find ( "<STR_LIT>" ) != - <NUM_LIT:1> ) : <EOL> need_perm = True <EOL> if ( len ( route ) == <NUM_LIT:0> ) : <EOL> return self <EOL> target = route [ <NUM_LIT:0> ] - <NUM_LIT:1> <EOL> _id = target <EOL> if ( _id >= len ( self . items ) ) : <EOL> return None <EOL> while ( self . items [ _id ] . EffectiveId ( user ) < target ) : <EOL> _id += <NUM_LIT:1> <EOL> if ( _id >= len ( self . items ) ) : <EOL> return None <EOL> item = self . items [ _id ] <EOL> item . mtitle = item . title <EOL> if ( len ( route ) == <NUM_LIT:1> ) : <EOL> return item <EOL> else : <EOL> if ( item . IsDir ( ) ) : <EOL> if ( not item . CheckUpdate ( ) ) : <EOL> return None <EOL> return item . GetItem ( user , route [ <NUM_LIT:1> : ] , has_perm , need_perm ) <EOL> else : <EOL> return None <EOL> def GetRange ( self , user , route , start , end , has_perm = False , need_perm = False ) : <EOL> self . CheckUpdate ( ) <EOL> firstitem = self . GetItem ( user , route + [ start ] , has_perm , need_perm ) <EOL> if ( not firstitem ) : <EOL> return [ ] <EOL> parent = self . GetItem ( user , route , has_perm , need_perm ) <EOL> if ( not parent ) : <EOL> return [ ] <EOL> if ( not parent . IsDir ( ) ) : <EOL> return [ ] <EOL> result = [ ] <EOL> _id = start - <NUM_LIT:1> <EOL> for i in range ( start , end + <NUM_LIT:1> ) : <EOL> target = i - <NUM_LIT:1> <EOL> if ( _id >= len ( parent . items ) ) : <EOL> return [ ] <EOL> while ( parent . items [ _id ] . EffectiveId ( user ) < target ) : <EOL> _id += <NUM_LIT:1> <EOL> if ( _id >= len ( parent . items ) ) : <EOL> return result <EOL> item = parent . items [ _id ] <EOL> item . mtitle = item . title <EOL> result += [ item ] <EOL> return result <EOL> def EffectiveId ( self , user ) : <EOL> _id = self . id <EOL> if ( user . IsSysop ( ) ) : <EOL> return _id <EOL> if ( not user . IsSysop ( ) ) : <EOL> _id -= self . sysop_only <EOL> if ( not user . IsBM ( ) ) : <EOL> _id -= self . bms_only <EOL> if ( not user . IsSECANC ( ) ) : <EOL> _id -= self . zixia_only <EOL> return _id <EOL> def GetInfo ( self ) : <EOL> info = { } <EOL> info [ '<STR_LIT>' ] = Util . gbkDec ( self . mtitle ) <EOL> info [ '<STR_LIT:title>' ] = Util . gbkDec ( self . title ) <EOL> info [ '<STR_LIT>' ] = self . attachpos <EOL> if ( self . host != '<STR_LIT>' ) : <EOL> info [ '<STR_LIT:host>' ] = self . host <EOL> info [ '<STR_LIT:port>' ] = self . port <EOL> info [ '<STR_LIT:type>' ] = '<STR_LIT>' <EOL> elif ( self . IsDir ( ) ) : <EOL> info [ '<STR_LIT:type>' ] = '<STR_LIT>' <EOL> elif ( self . IsFile ( ) ) : <EOL> info [ '<STR_LIT:type>' ] = '<STR_LIT:file>' <EOL> else : <EOL> info [ '<STR_LIT:type>' ] = '<STR_LIT>' <EOL> info [ '<STR_LIT>' ] = int ( self . GetModTime ( ) ) <EOL> return info <EOL> def GetInfoForUser ( self , user ) : <EOL> info = self . GetInfo ( ) <EOL> info [ '<STR_LIT:id>' ] = self . EffectiveId ( user ) + <NUM_LIT:1> <EOL> return info <EOL> def GetAttachLink ( self , session ) : <EOL> _hash = Util . HashGen ( self . path ( ) , "<STR_LIT>" ) <EOL> filename = '<STR_LIT>' <EOL> for i in range ( <NUM_LIT:2> ) : <EOL> filename += "<STR_LIT>" % struct . unpack ( '<STR_LIT>' , _hash [ i * <NUM_LIT:4> : ( i + <NUM_LIT:1> ) * <NUM_LIT:4> ] ) <EOL> link = "<STR_LIT>" % ( session . GetMirror ( Config . Config . GetInt ( '<STR_LIT>' , <NUM_LIT> ) ) , filename ) <EOL> linkfile = "<STR_LIT>" % ( Config . BBS_ROOT , filename ) <EOL> target = "<STR_LIT>" % self . path ( ) <EOL> try : <EOL> os . symlink ( target , linkfile ) <EOL> except : <EOL> pass <EOL> return link <EOL> class Digest : <EOL> root = DigestItem ( "<STR_LIT>" ) <EOL> def __init__ ( self , board , path ) : <EOL> self . board = board <EOL> self . path = path <EOL> self . root = DigestItem ( self . path ) <EOL> @ staticmethod <EOL> def GET ( svc , session , params , action ) : <EOL> if ( session is None ) : raise Unauthorized ( '<STR_LIT>' ) <EOL> if not session . CheckScope ( '<STR_LIT>' ) : raise NoPerm ( "<STR_LIT>" ) <EOL> user = session . GetUser ( ) <EOL> boardname = svc . get_str ( params , '<STR_LIT>' , '<STR_LIT>' ) <EOL> if ( boardname ) : <EOL> board = BoardManager . BoardManager . GetBoard ( boardname ) <EOL> if ( board is None ) : raise NotFound ( '<STR_LIT>' % boardname ) <EOL> if ( not board . CheckReadPerm ( user ) ) : <EOL> raise NoPerm ( '<STR_LIT>' ) <EOL> basenode = board . digest . root <EOL> has_perm = user . IsDigestMgr ( ) or user . IsSysop ( ) or user . IsSuperBM ( ) <EOL> else : <EOL> basenode = Digest . root <EOL> has_perm = user . IsDigestMgr ( ) <EOL> if ( action == "<STR_LIT:list>" ) : <EOL> route = svc . get_str ( params , '<STR_LIT>' ) <EOL> start = svc . get_int ( params , '<STR_LIT:start>' , <NUM_LIT:1> ) <EOL> end = svc . get_int ( params , '<STR_LIT:end>' , start + DEFAULT_DIGEST_LIST_COUNT - <NUM_LIT:1> ) <EOL> Digest . List ( svc , basenode , route , start , end , session , has_perm ) <EOL> return <EOL> elif ( action == "<STR_LIT>" ) : <EOL> route = svc . get_str ( params , '<STR_LIT>' ) <EOL> start = svc . get_int ( params , '<STR_LIT:start>' , <NUM_LIT:0> ) <EOL> count = svc . get_int ( params , '<STR_LIT:count>' , <NUM_LIT:0> ) <EOL> Digest . View ( svc , basenode , route , session , has_perm , start , count ) <EOL> return <EOL> else : <EOL> raise WrongArgs ( '<STR_LIT>' % action ) <EOL> @ staticmethod <EOL> def ParseRoute ( route ) : <EOL> ret = [ ] <EOL> items = re . split ( '<STR_LIT:->' , route ) <EOL> items = items [ <NUM_LIT:1> : ] <EOL> for item in items : <EOL> try : <EOL> ret += [ int ( item ) ] <EOL> except : <EOL> raise WrongArgs ( '<STR_LIT>' % item ) <EOL> return ret <EOL> @ staticmethod <EOL> def List ( svc , basenode , route , start , end , session , has_perm ) : <EOL> route_array = Digest . ParseRoute ( route ) <EOL> parent = basenode . GetItem ( session . GetUser ( ) , route_array , has_perm ) <EOL> if ( not parent ) : <EOL> raise WrongArgs ( '<STR_LIT>' % route ) <EOL> if ( not parent . IsDir ( ) ) : <EOL> raise WrongArgs ( '<STR_LIT>' % route ) <EOL> items = basenode . GetRange ( session . GetUser ( ) , route_array , start , end , has_perm ) <EOL> result = { } <EOL> result [ '<STR_LIT>' ] = parent . GetInfoForUser ( session . GetUser ( ) ) <EOL> result [ '<STR_LIT:count>' ] = len ( items ) <EOL> result_list = [ ] <EOL> for item in items : <EOL> result_list += [ item . GetInfoForUser ( session . GetUser ( ) ) ] <EOL> result [ '<STR_LIT>' ] = result_list <EOL> svc . writedata ( json . dumps ( result ) ) <EOL> @ staticmethod <EOL> def View ( svc , basenode , route , session , has_perm , start , count ) : <EOL> route_array = Digest . ParseRoute ( route ) <EOL> item = basenode . GetItem ( session . GetUser ( ) , route_array , has_perm ) <EOL> if ( not item ) : <EOL> raise WrongArgs ( '<STR_LIT>' % route ) <EOL> if ( not item . IsFile ( ) ) : <EOL> raise WrongArgs ( '<STR_LIT>' % route ) <EOL> result = { } <EOL> result [ '<STR_LIT>' ] = item . GetInfoForUser ( session . GetUser ( ) ) <EOL> postinfo = Post . Post ( item . realpath ( ) , None ) <EOL> ( result [ '<STR_LIT:content>' ] , result [ '<STR_LIT>' ] ) = postinfo . GetContent ( start , count ) <EOL> attachlist = postinfo . GetAttachListByType ( ) <EOL> result [ '<STR_LIT>' ] = attachlist [ <NUM_LIT:0> ] <EOL> result [ '<STR_LIT>' ] = attachlist [ <NUM_LIT:1> ] <EOL> if ( attachlist [ <NUM_LIT:0> ] or attachlist [ <NUM_LIT:1> ] ) : <EOL> result [ '<STR_LIT>' ] = item . GetAttachLink ( session ) <EOL> svc . writedata ( json . dumps ( result ) ) </s>
<s> import time <EOL> import UserManager <EOL> import UserInfo <EOL> from Session import Session <EOL> from Log import Log <EOL> import UCache <EOL> import Config <EOL> import MsgBox <EOL> import xmpp <EOL> import modes <EOL> import Util <EOL> import traceback <EOL> import os <EOL> from xmpp . features import NoRoute <EOL> __disco_info_ns__ = '<STR_LIT>' <EOL> __disco_items_ns__ = '<STR_LIT>' <EOL> __vcard_ns__ = '<STR_LIT>' <EOL> STEAL_AFTER_SEEN = <NUM_LIT:3> <EOL> def elem_to_str ( elem ) : <EOL> return "<STR_LIT>" % ( elem . tag , elem . attrib , elem . text ) <EOL> class XMPPServer ( xmpp . Plugin ) : <EOL> """<STR_LIT>""" <EOL> def __init__ ( self , rosters , host ) : <EOL> self . probed = False <EOL> self . _closed = False <EOL> self . rosters = rosters <EOL> self . _session = None <EOL> self . rosters . set_resources ( self . get_resources ( ) ) <EOL> self . _fixedjid = UCache . UCache . formalize_jid ( unicode ( self . authJID ) ) <EOL> self . _userid = self . _fixedjid . partition ( '<STR_LIT:@>' ) [ <NUM_LIT:0> ] . encode ( "<STR_LIT>" ) <EOL> if ( not self . rosters . allow_login ( self . authJID . bare ) ) : <EOL> Log . warn ( "<STR_LIT>" % self . _userid ) <EOL> self . stream_error ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> return <EOL> Log . info ( "<STR_LIT>" % unicode ( self . authJID ) ) <EOL> if self . authJID . resource [ : - <NUM_LIT:8> ] != "<STR_LIT>" and len ( self . authJID . resource ) > <NUM_LIT:8> : <EOL> try : <EOL> routes = self . routes ( self . authJID . bare ) <EOL> for route in routes : <EOL> jid = route [ <NUM_LIT:0> ] <EOL> if jid . resource [ : - <NUM_LIT:8> ] == self . authJID . resource [ : - <NUM_LIT:8> ] : <EOL> if jid . resource != self . authJID . resource : <EOL> Log . info ( "<STR_LIT>" % ( jid . full , route [ <NUM_LIT:1> ] ) ) <EOL> route [ <NUM_LIT:1> ] . stream_error ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> else : <EOL> Log . info ( "<STR_LIT>" % ( jid . full , route [ <NUM_LIT:1> ] ) ) <EOL> except NoRoute : <EOL> pass <EOL> Log . debug ( "<STR_LIT>" % self . authJID . full ) <EOL> self . _user = UserManager . UserManager . LoadUser ( self . _userid ) <EOL> if ( self . _user == None ) : <EOL> raise Exception ( "<STR_LIT>" ) <EOL> self . _peer_addr = self . getpeername ( ) <EOL> self . _session = Session ( self . _user , self . _peer_addr [ <NUM_LIT:0> ] ) <EOL> self . _session . RecordLogin ( ) <EOL> self . _userinfo = self . _session . Register ( ) <EOL> self . _loginid = self . _session . utmpent <EOL> self . _hostname = host <EOL> self . bind ( xmpp . ReceivedCloseStream , self . recv_close ) <EOL> self . bind ( xmpp . StreamClosed , self . stream_closed ) <EOL> self . bind ( xmpp . SentCloseStream , self . sent_close ) <EOL> self . rosters . register_conn ( self ) <EOL> msgbox = MsgBox . MsgBox ( self . _userid ) <EOL> if self . rosters . get_xmpp_read ( self . _user . GetUID ( ) ) is None : <EOL> self . rosters . set_xmpp_read ( self . _user . GetUID ( ) , msgbox . GetMsgCount ( all = False ) - msgbox . GetUnreadCount ( ) ) <EOL> self . check_msg ( ) <EOL> def get_loginid ( self ) : <EOL> return self . _loginid <EOL> def recv_close ( self ) : <EOL> Log . debug ( "<STR_LIT>" % self . authJID . full ) <EOL> return self . close ( ) <EOL> def stream_closed ( self ) : <EOL> Log . debug ( "<STR_LIT>" % self . authJID . full ) <EOL> return self . close ( ) <EOL> def sent_close ( self ) : <EOL> Log . debug ( "<STR_LIT>" % self . authJID . full ) <EOL> return self . close ( ) <EOL> def close ( self ) : <EOL> if ( self . _closed ) : <EOL> Log . debug ( "<STR_LIT>" ) <EOL> return <EOL> self . _closed = True <EOL> Log . info ( "<STR_LIT>" % unicode ( self . authJID ) ) <EOL> if ( self . _session ) : <EOL> self . _session . Unregister ( ) <EOL> self . unbind_res ( ) <EOL> self . rosters . unregister_conn ( self ) <EOL> @ xmpp . iq ( '<STR_LIT>' ) <EOL> def ping ( self , iq ) : <EOL> """<STR_LIT>""" <EOL> self . refresh ( ) <EOL> return self . iq ( '<STR_LIT:result>' , iq ) <EOL> @ xmpp . stanza ( '<STR_LIT:message>' ) <EOL> def message ( self , elem ) : <EOL> """<STR_LIT>""" <EOL> to_jid = elem . get ( '<STR_LIT:to>' ) <EOL> from_jid = elem . get ( '<STR_LIT>' ) <EOL> if ( from_jid == None ) : <EOL> return <EOL> text_body = None <EOL> for child in elem : <EOL> if ( child . tag . endswith ( '<STR_LIT>' ) ) : <EOL> text_body = child . text <EOL> if ( text_body == None ) : <EOL> return <EOL> ret = self . rosters . send_msg ( from_jid , to_jid , text_body ) <EOL> if ( ret <= <NUM_LIT:0> ) : <EOL> Log . warn ( "<STR_LIT>" % ( to_jid , from_jid , ret ) ) <EOL> errors = { <EOL> - <NUM_LIT:1> : "<STR_LIT>" , <EOL> - <NUM_LIT:11> : "<STR_LIT>" , <EOL> - <NUM_LIT:12> : "<STR_LIT>" , <EOL> - <NUM_LIT> : "<STR_LIT>" , <EOL> - <NUM_LIT> : "<STR_LIT>" , <EOL> - <NUM_LIT:2> : "<STR_LIT>" , <EOL> - <NUM_LIT> : "<STR_LIT>" } <EOL> if ( ret in errors ) : <EOL> elem = self . E . message ( { '<STR_LIT>' : to_jid , <EOL> '<STR_LIT:to>' : from_jid , <EOL> '<STR_LIT:type>' : '<STR_LIT:error>' } , <EOL> self . E . body ( errors [ ret ] ) ) <EOL> self . recv ( from_jid , elem ) <EOL> def make_jid ( self , userid ) : <EOL> return "<STR_LIT>" % ( userid , self . _hostname ) <EOL> def refresh ( self ) : <EOL> self . _userinfo . freshtime = int ( time . time ( ) ) <EOL> self . _userinfo . save ( ) <EOL> def ping_result ( self , iq ) : <EOL> self . refresh ( ) <EOL> def ping_client ( self ) : <EOL> try : <EOL> pingelem = self . E . ping ( xmlns = '<STR_LIT>' ) <EOL> return self . iq ( '<STR_LIT>' , self . ping_result , pingelem ) <EOL> except Exception as e : <EOL> Log . debug ( "<STR_LIT>" % ( self . authJID , e ) ) <EOL> Log . debug ( traceback . format_exc ( ) ) <EOL> return False <EOL> def get_uid ( self ) : <EOL> return self . _user . GetUID ( ) <EOL> def recv_msg ( self , from_ , msgtext ) : <EOL> elem = self . E . message ( { '<STR_LIT>' : from_ , '<STR_LIT:to>' : unicode ( self . authJID ) } , <EOL> self . E . body ( msgtext ) ) <EOL> self . recv ( unicode ( self . authJID ) , elem ) <EOL> def check_msg ( self ) : <EOL> Log . debug ( "<STR_LIT>" % self . _userid ) <EOL> msgbox = MsgBox . MsgBox ( self . _userid ) <EOL> msg_count = msgbox . GetMsgCount ( all = False ) <EOL> my_pid = os . getpid ( ) <EOL> xmpp_read = self . rosters . get_xmpp_read ( self . _user . GetUID ( ) ) <EOL> if xmpp_read > msg_count : <EOL> xmpp_read = <NUM_LIT:0> <EOL> Log . debug ( "<STR_LIT>" % ( msg_count , xmpp_read ) ) <EOL> self . rosters . set_xmpp_read ( self . _user . GetUID ( ) , msg_count ) <EOL> if xmpp_read < msg_count : <EOL> return xmpp_read <EOL> else : <EOL> return - <NUM_LIT:1> <EOL> def deliver_msg ( self , start ) : <EOL> Log . debug ( "<STR_LIT>" % unicode ( self . authJID ) ) <EOL> msgbox = MsgBox . MsgBox ( self . _userid ) <EOL> msg_count = msgbox . GetMsgCount ( all = False ) <EOL> my_pid = os . getpid ( ) <EOL> for i in range ( start , msg_count ) : <EOL> msghead = msgbox . LoadMsgHead ( i , all = False ) <EOL> if msghead . topid == my_pid : <EOL> msgtext = msgbox . LoadMsgText ( msghead ) <EOL> self . recv_msg ( self . make_jid ( msghead . id ) , msgtext ) <EOL> def steal_msg ( self ) : <EOL> Log . debug ( "<STR_LIT>" % self . _userid ) <EOL> msgbox = MsgBox . MsgBox ( self . _userid ) <EOL> msg_count = msgbox . GetMsgCount ( all = False ) <EOL> msg_unread = msgbox . GetUnreadCount ( ) <EOL> read_count = msg_count - msg_unread <EOL> my_pid = os . getpid ( ) <EOL> term_read = self . rosters . get_term_read ( self . get_uid ( ) ) <EOL> term_stealed = self . rosters . get_term_stealed ( self . get_uid ( ) ) <EOL> all_xmpp = True <EOL> new_unread = { } <EOL> for i in range ( read_count - <NUM_LIT:1> , msg_count ) : <EOL> if i < <NUM_LIT:0> : <EOL> continue <EOL> msghead = msgbox . LoadMsgHead ( i , all = False ) <EOL> if i >= read_count and all_xmpp : <EOL> if msghead . topid == my_pid : <EOL> msgbox . GetUnreadMsg ( ) <EOL> else : <EOL> all_xmpp = False <EOL> if msghead . topid == my_pid : <EOL> continue <EOL> if i < read_count : <EOL> session = self . rosters . find_session ( self . authJID . bare , msghead . topid ) <EOL> if session is None or session . get_mode ( ) != modes . MSG : <EOL> continue <EOL> Log . debug ( "<STR_LIT>" % i ) <EOL> if msghead . topid not in new_unread : <EOL> Log . debug ( "<STR_LIT>" % ( msghead . topid , i ) ) <EOL> new_unread [ msghead . topid ] = i <EOL> final_unread = { } <EOL> to_steal = { } <EOL> to_steal_begin = msg_count <EOL> for pid in term_read : <EOL> if pid in new_unread : <EOL> if new_unread [ pid ] == term_read [ pid ] [ <NUM_LIT:0> ] : <EOL> final_unread [ pid ] = ( term_read [ pid ] [ <NUM_LIT:0> ] , term_read [ pid ] [ <NUM_LIT:1> ] + <NUM_LIT:1> ) <EOL> Log . debug ( "<STR_LIT>" % ( new_unread [ pid ] , pid , term_read [ pid ] [ <NUM_LIT:1> ] + <NUM_LIT:1> ) ) <EOL> if final_unread [ pid ] [ <NUM_LIT:1> ] > STEAL_AFTER_SEEN : <EOL> to_steal [ pid ] = final_unread [ pid ] <EOL> Log . debug ( "<STR_LIT>" % ( to_steal [ pid ] [ <NUM_LIT:0> ] , pid ) ) <EOL> if pid in term_stealed : <EOL> steal_begin = max ( final_unread [ pid ] [ <NUM_LIT:0> ] , term_stealed [ pid ] + <NUM_LIT:1> ) <EOL> else : <EOL> steal_begin = final_unread [ pid ] [ <NUM_LIT:0> ] <EOL> if steal_begin < to_steal_begin : <EOL> to_steal_begin = steal_begin <EOL> else : <EOL> final_unread [ pid ] = ( new_unread [ pid ] , <NUM_LIT:1> ) <EOL> Log . debug ( "<STR_LIT>" % ( term_read [ pid ] [ <NUM_LIT:0> ] , new_unread [ pid ] , pid ) ) <EOL> else : <EOL> Log . debug ( "<STR_LIT>" % pid ) <EOL> pass <EOL> for pid in new_unread : <EOL> if pid not in term_read : <EOL> Log . debug ( "<STR_LIT>" % ( new_unread [ pid ] , pid ) ) <EOL> final_unread [ pid ] = ( new_unread [ pid ] , <NUM_LIT:1> ) <EOL> if to_steal : <EOL> Log . debug ( "<STR_LIT>" % to_steal_begin ) <EOL> for i in range ( to_steal_begin , msg_count ) : <EOL> msghead = msgbox . LoadMsgHead ( i , all = False ) <EOL> if msghead . topid == my_pid : <EOL> Log . debug ( "<STR_LIT>" % ( i , msghead . topid ) ) <EOL> msgbox . GetUnreadMsg ( ) <EOL> elif msghead . topid in to_steal : <EOL> if msghead . topid not in term_stealed or i > term_stealed [ msghead . topid ] : <EOL> Log . debug ( "<STR_LIT>" % ( i , msghead . topid ) ) <EOL> msgtext = msgbox . LoadMsgText ( msghead ) <EOL> self . recv_msg ( self . make_jid ( msghead . id ) , msgtext ) <EOL> term_stealed [ msghead . topid ] = i <EOL> else : <EOL> Log . debug ( "<STR_LIT>" % ( i , msghead . topid ) ) <EOL> self . rosters . set_term_read ( self . get_uid ( ) , final_unread ) <EOL> @ xmpp . stanza ( '<STR_LIT>' ) <EOL> def presence ( self , elem ) : <EOL> """<STR_LIT>""" <EOL> Log . warn ( "<STR_LIT>" % ( self . authJID , elem_to_str ( elem ) ) ) <EOL> if self . authJID == elem . get ( '<STR_LIT>' ) : <EOL> if ( elem . get ( '<STR_LIT:to>' ) == None or ( not self . authJID . match_bare ( elem . get ( '<STR_LIT:to>' ) ) ) ) : <EOL> return self . send_presence ( elem ) <EOL> self . recv_presence ( elem ) <EOL> def send_presence ( self , elem ) : <EOL> Log . warn ( "<STR_LIT>" % ( self . authJID , elem_to_str ( elem ) ) ) <EOL> direct = elem . get ( '<STR_LIT:to>' ) <EOL> if not direct : <EOL> self . rosters . broadcast ( self , elem ) <EOL> if elem . get ( '<STR_LIT:type>' ) != '<STR_LIT>' : <EOL> self . recv_presence ( elem ) <EOL> if not self . probed : <EOL> self . probed = True <EOL> self . rosters . probe ( self ) <EOL> elif not self . rosters . send ( self , direct , elem ) : <EOL> self . send ( direct , elem ) <EOL> def recv_presence ( self , elem ) : <EOL> Log . warn ( "<STR_LIT>" % ( self . authJID , elem_to_str ( elem ) ) ) <EOL> if not self . rosters . recv ( self , elem ) : <EOL> Log . warn ( "<STR_LIT>" ) <EOL> self . write ( elem ) <EOL> @ xmpp . iq ( '<STR_LIT>' ) <EOL> def roster ( self , iq ) : <EOL> """<STR_LIT>""" <EOL> roster = self . rosters . get ( self ) <EOL> method = getattr ( self , '<STR_LIT>' % iq . get ( '<STR_LIT:type>' ) ) <EOL> return method and method ( iq , roster ) <EOL> def get_roster ( self , iq , roster ) : <EOL> query = self . E . query ( { '<STR_LIT>' : '<STR_LIT>' } ) <EOL> for item in roster . items ( ) : <EOL> query . append ( item ) <EOL> return self . iq ( '<STR_LIT:result>' , iq , query ) <EOL> def set_roster ( self , iq , roster ) : <EOL> query = self . E . query ( xmlns = '<STR_LIT>' ) <EOL> for item in iq [ <NUM_LIT:0> ] : <EOL> result = roster . set ( item ) <EOL> if result is not None : <EOL> query . append ( result ) <EOL> if len ( query ) > <NUM_LIT:0> : <EOL> self . push ( roster , query ) <EOL> return self . iq ( '<STR_LIT:result>' , iq ) <EOL> def push ( self , roster , query ) : <EOL> """<STR_LIT>""" <EOL> for jid in roster . requests ( ) : <EOL> for ( to , route ) in self . routes ( jid ) : <EOL> route . iq ( '<STR_LIT>' , self . ignore , query ) <EOL> def ignore ( self , iq ) : <EOL> """<STR_LIT>""" <EOL> @ xmpp . iq ( '<STR_LIT>' ) <EOL> def vcard ( self , iq ) : <EOL> """<STR_LIT>""" <EOL> if iq . get ( '<STR_LIT:type>' ) == '<STR_LIT>' : <EOL> if ( iq . get ( '<STR_LIT:to>' ) == None ) : <EOL> target = iq . get ( '<STR_LIT>' ) <EOL> else : <EOL> target = iq . get ( '<STR_LIT:to>' ) <EOL> form_target = UCache . UCache . formalize_jid ( target ) <EOL> name = form_target . partition ( '<STR_LIT:@>' ) [ <NUM_LIT:0> ] <EOL> user = UserManager . UserManager . LoadUser ( name ) <EOL> info = user . GetInfo ( ) <EOL> desc = '''<STR_LIT>''' % ( info [ '<STR_LIT>' ] , info [ '<STR_LIT>' ] , info [ '<STR_LIT>' ] , <EOL> info [ '<STR_LIT>' ] , info [ '<STR_LIT>' ] , info [ '<STR_LIT>' ] , info [ '<STR_LIT>' ] ) <EOL> if ( '<STR_LIT>' in info ) : <EOL> desc += "<STR_LIT>" % ( info [ '<STR_LIT>' ] . replace ( '<STR_LIT:\n>' , '<STR_LIT:\r\n>' ) ) <EOL> vcard = self . E . vCard ( { '<STR_LIT>' : '<STR_LIT>' } , <EOL> self . E ( '<STR_LIT>' , name ) , <EOL> self . E ( '<STR_LIT>' , Util . Util . RemoveTags ( info [ '<STR_LIT>' ] ) ) , <EOL> self . E ( '<STR_LIT>' , Util . Util . RemoveTags ( desc ) ) ) <EOL> if ( iq . get ( '<STR_LIT:to>' ) == None ) : <EOL> return self . iq ( '<STR_LIT:result>' , iq , vcard ) <EOL> else : <EOL> return self . iq ( '<STR_LIT:result>' , iq , vcard , { '<STR_LIT>' : iq . get ( '<STR_LIT:to>' ) } ) <EOL> @ xmpp . iq ( '<STR_LIT>' % __disco_info_ns__ ) <EOL> def disco_info ( self , iq ) : <EOL> """<STR_LIT>""" <EOL> target = iq . get ( '<STR_LIT:to>' ) <EOL> if ( target . find ( '<STR_LIT:@>' ) < <NUM_LIT:0> ) : <EOL> query = self . E . query ( { '<STR_LIT>' : __disco_info_ns__ } , <EOL> self . E . identity ( { '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:type>' : '<STR_LIT>' , <EOL> '<STR_LIT:name>' : Config . Config . GetString ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> } ) ) <EOL> features = [ __disco_info_ns__ , __disco_items_ns__ , __vcard_ns__ ] <EOL> for feature in features : <EOL> query . append ( self . E . feature ( { '<STR_LIT>' : feature } ) ) <EOL> else : <EOL> query = self . E . query ( { '<STR_LIT>' : __disco_info_ns__ } , <EOL> self . E . identity ( { '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:type>' : '<STR_LIT>' , <EOL> '<STR_LIT:name>' : Config . Config . GetString ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> } ) ) <EOL> features = [ __disco_info_ns__ , __disco_items_ns__ , __vcard_ns__ ] <EOL> for feature in features : <EOL> query . append ( self . E . feature ( { '<STR_LIT>' : feature } ) ) <EOL> return self . iq ( '<STR_LIT:result>' , iq , query , { '<STR_LIT>' : target } ) <EOL> @ xmpp . iq ( '<STR_LIT>' % __disco_items_ns__ ) <EOL> def disco_items ( self , iq ) : <EOL> """<STR_LIT>""" <EOL> target = iq . get ( '<STR_LIT:to>' ) <EOL> if ( target . find ( '<STR_LIT:@>' ) < <NUM_LIT:0> ) : <EOL> query = self . E . query ( { '<STR_LIT>' : __disco_items_ns__ } ) <EOL> else : <EOL> query = self . E . query ( { '<STR_LIT>' : __disco_items_ns__ } ) <EOL> return self . iq ( '<STR_LIT:result>' , iq , query , { '<STR_LIT>' : target } ) </s>
<s> from __future__ import print_function <EOL> from __future__ import unicode_literals <EOL> from __future__ import division <EOL> from __future__ import absolute_import <EOL> from builtins import range <EOL> from future import standard_library <EOL> standard_library . install_aliases ( ) <EOL> import sys <EOL> PYTHON_VERSION = sys . version_info [ : <NUM_LIT:3> ] <EOL> PY2 = ( PYTHON_VERSION [ <NUM_LIT:0> ] == <NUM_LIT:2> ) <EOL> if PY2 : <EOL> if PYTHON_VERSION < ( <NUM_LIT:2> , <NUM_LIT:7> , <NUM_LIT:9> ) : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> elif PYTHON_VERSION < ( <NUM_LIT:3> , <NUM_LIT:4> ) : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> import hpOneView as hpov <EOL> from pprint import pprint <EOL> import json <EOL> from hpOneView . common import uri <EOL> import hpOneView . profile as profile <EOL> def acceptEULA ( con ) : <EOL> con . get_eula_status ( ) <EOL> try : <EOL> if con . get_eula_status ( ) is True : <EOL> print ( '<STR_LIT>' ) <EOL> con . set_eula ( '<STR_LIT>' ) <EOL> except Exception as e : <EOL> print ( '<STR_LIT>' ) <EOL> print ( e ) <EOL> def login ( con , credential ) : <EOL> try : <EOL> con . login ( credential ) <EOL> except : <EOL> print ( '<STR_LIT>' ) <EOL> def get_eg_uri_from_arg ( srv , name ) : <EOL> if srv and name : <EOL> if name . startswith ( '<STR_LIT>' ) and uri [ '<STR_LIT>' ] in name : <EOL> return name <EOL> else : <EOL> egs = srv . get_enclosure_groups ( ) <EOL> for eg in egs : <EOL> if eg [ '<STR_LIT:name>' ] == name : <EOL> return eg [ '<STR_LIT>' ] <EOL> return None <EOL> def get_sht_from_arg ( srv , name ) : <EOL> if srv and name : <EOL> if name . startswith ( '<STR_LIT>' ) and uri [ '<STR_LIT>' ] in name : <EOL> return name <EOL> else : <EOL> shts = srv . get_server_hardware_types ( ) <EOL> for sht in shts : <EOL> if sht [ '<STR_LIT:name>' ] == name : <EOL> return sht <EOL> return None <EOL> def define_profile_template ( <EOL> srv , <EOL> name , <EOL> desc , <EOL> sp_desc , <EOL> server_hwt , <EOL> enc_group , <EOL> affinity , <EOL> hide_flexnics , <EOL> conn_list , <EOL> fw_settings , <EOL> boot , <EOL> bootmode ) : <EOL> if conn_list : <EOL> conn = json . loads ( open ( conn_list ) . read ( ) ) <EOL> else : <EOL> conn = [ ] <EOL> profile_template = srv . create_server_profile_template ( <EOL> name = name , <EOL> description = desc , <EOL> serverProfileDescription = sp_desc , <EOL> serverHardwareTypeUri = server_hwt , <EOL> enclosureGroupUri = enc_group , <EOL> affinity = affinity , <EOL> hideUnusedFlexNics = hide_flexnics , <EOL> profileConnectionV4 = conn , <EOL> firmwareSettingsV3 = fw_settings , <EOL> bootSettings = boot , <EOL> bootModeSetting = bootmode ) <EOL> if '<STR_LIT>' in profile_template : <EOL> print ( '<STR_LIT>' , profile_template [ '<STR_LIT:name>' ] ) <EOL> print ( '<STR_LIT>' , profile_template [ '<STR_LIT:type>' ] ) <EOL> print ( '<STR_LIT>' , profile_template [ '<STR_LIT:description>' ] ) <EOL> print ( '<STR_LIT>' , profile_template [ '<STR_LIT>' ] ) <EOL> print ( '<STR_LIT>' ) <EOL> for connection in profile_template [ '<STR_LIT>' ] : <EOL> print ( '<STR_LIT>' , connection [ '<STR_LIT:name>' ] ) <EOL> print ( '<STR_LIT>' , connection [ '<STR_LIT>' ] ) <EOL> print ( '<STR_LIT>' , connection [ '<STR_LIT>' ] ) <EOL> print ( '<STR_LIT>' ) <EOL> print ( '<STR_LIT>' , profile_template [ '<STR_LIT>' ] [ '<STR_LIT>' ] ) <EOL> print ( '<STR_LIT>' , profile_template [ '<STR_LIT>' ] [ '<STR_LIT>' ] ) <EOL> print ( '<STR_LIT>' , profile_template [ '<STR_LIT>' ] [ '<STR_LIT>' ] ) <EOL> print ( '<STR_LIT>' ) <EOL> print ( '<STR_LIT>' , profile_template [ '<STR_LIT>' ] [ '<STR_LIT>' ] ) <EOL> print ( '<STR_LIT>' , profile_template [ '<STR_LIT>' ] [ '<STR_LIT>' ] ) <EOL> print ( '<STR_LIT>' ) <EOL> print ( '<STR_LIT>' , profile_template [ '<STR_LIT>' ] [ '<STR_LIT>' ] ) <EOL> print ( '<STR_LIT>' , profile_template [ '<STR_LIT>' ] [ '<STR_LIT>' ] , '<STR_LIT:\n>' ) <EOL> else : <EOL> pprint ( profile_template ) <EOL> def main ( ) : <EOL> parser = argparse . ArgumentParser ( add_help = True , <EOL> formatter_class = argparse . RawTextHelpFormatter , <EOL> description = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT:host>' , required = True , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT:user>' , required = False , <EOL> default = '<STR_LIT>' , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , required = True , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT:-c>' , dest = '<STR_LIT>' , required = False , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , required = False , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT:name>' , <EOL> required = True , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , <EOL> required = False , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , <EOL> required = False , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , required = True , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , required = True , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , <EOL> required = False , choices = [ '<STR_LIT>' , '<STR_LIT>' ] , <EOL> default = '<STR_LIT>' , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , <EOL> required = False , choices = [ '<STR_LIT:true>' , '<STR_LIT:false>' ] , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , <EOL> required = False , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , required = False , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , <EOL> action = '<STR_LIT:store_true>' , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , required = False , <EOL> nargs = '<STR_LIT:+>' , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , required = False , <EOL> choices = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] , <EOL> default = '<STR_LIT>' , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , required = False , <EOL> choices = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' ] , <EOL> default = '<STR_LIT>' , <EOL> help = '''<STR_LIT>''' ) <EOL> args = parser . parse_args ( ) <EOL> credential = { '<STR_LIT>' : args . user , '<STR_LIT:password>' : args . passwd } <EOL> con = hpov . connection ( args . host ) <EOL> srv = hpov . servers ( con ) <EOL> sts = hpov . settings ( con ) <EOL> if args . proxy : <EOL> con . set_proxy ( args . proxy . split ( '<STR_LIT::>' ) [ <NUM_LIT:0> ] , args . proxy . split ( '<STR_LIT::>' ) [ <NUM_LIT:1> ] ) <EOL> if args . cert : <EOL> con . set_trusted_ssl_bundle ( args . cert ) <EOL> login ( con , credential ) <EOL> acceptEULA ( con ) <EOL> eg_uri = get_eg_uri_from_arg ( srv , args . enc_group ) <EOL> sht = get_sht_from_arg ( srv , args . server_hwt ) <EOL> fw_settings = profile . make_firmware_dict ( sts , args . baseline ) <EOL> boot , bootmode = profile . make_boot_settings_dict ( srv , sht , args . disable_manage_boot , <EOL> args . boot_order , args . boot_mode , args . pxe ) <EOL> define_profile_template ( srv , <EOL> args . name , <EOL> args . desc , <EOL> args . sp_desc , <EOL> sht [ '<STR_LIT>' ] , <EOL> eg_uri , <EOL> args . affinity , <EOL> args . hide_flexnics , <EOL> args . conn_list , <EOL> fw_settings , <EOL> boot , <EOL> bootmode ) <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL> import argparse <EOL> sys . exit ( main ( ) ) </s>
<s> from __future__ import print_function <EOL> from __future__ import unicode_literals <EOL> from __future__ import division <EOL> from __future__ import absolute_import <EOL> from builtins import range <EOL> from future import standard_library <EOL> standard_library . install_aliases ( ) <EOL> import sys <EOL> PYTHON_VERSION = sys . version_info [ : <NUM_LIT:3> ] <EOL> PY2 = ( PYTHON_VERSION [ <NUM_LIT:0> ] == <NUM_LIT:2> ) <EOL> if PY2 : <EOL> if PYTHON_VERSION < ( <NUM_LIT:2> , <NUM_LIT:7> , <NUM_LIT:9> ) : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> elif PYTHON_VERSION < ( <NUM_LIT:3> , <NUM_LIT:4> ) : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> import hpOneView as hpov <EOL> from pprint import pprint <EOL> def acceptEULA ( con ) : <EOL> con . get_eula_status ( ) <EOL> try : <EOL> if con . get_eula_status ( ) is True : <EOL> print ( "<STR_LIT>" ) <EOL> con . set_eula ( '<STR_LIT>' ) <EOL> except Exception as e : <EOL> print ( '<STR_LIT>' ) <EOL> print ( e ) <EOL> def login ( con , credential ) : <EOL> try : <EOL> con . login ( credential ) <EOL> except : <EOL> print ( '<STR_LIT>' ) <EOL> def get_address_pools ( con , srv , types ) : <EOL> if types == '<STR_LIT>' or types == '<STR_LIT>' : <EOL> vmac = srv . get_vmac_pool ( ) <EOL> print ( ) <EOL> for key in sorted ( vmac ) : <EOL> print ( '<STR_LIT>' . format ( key , vmac [ key ] ) ) <EOL> if '<STR_LIT>' in vmac : <EOL> for uri in vmac [ '<STR_LIT>' ] : <EOL> ranges = con . get ( uri ) <EOL> print ( '<STR_LIT>' , ranges [ '<STR_LIT>' ] ) <EOL> print ( '<STR_LIT>' , ranges [ '<STR_LIT>' ] ) <EOL> print ( '<STR_LIT>' , ranges [ '<STR_LIT>' ] ) <EOL> if types == '<STR_LIT>' or types == '<STR_LIT>' : <EOL> vwwn = srv . get_vwwn_pool ( ) <EOL> print ( ) <EOL> for key in sorted ( vwwn ) : <EOL> print ( '<STR_LIT>' . format ( key , vwwn [ key ] ) ) <EOL> if '<STR_LIT>' in vwwn : <EOL> for uri in vwwn [ '<STR_LIT>' ] : <EOL> ranges = con . get ( uri ) <EOL> print ( '<STR_LIT>' , ranges [ '<STR_LIT>' ] ) <EOL> print ( '<STR_LIT>' , ranges [ '<STR_LIT>' ] ) <EOL> print ( '<STR_LIT>' , ranges [ '<STR_LIT>' ] ) <EOL> if types == '<STR_LIT>' or types == '<STR_LIT>' : <EOL> vsn = srv . get_vsn_pool ( ) <EOL> print ( ) <EOL> for key in sorted ( vsn ) : <EOL> print ( '<STR_LIT>' . format ( key , vsn [ key ] ) ) <EOL> if '<STR_LIT>' in vsn : <EOL> for uri in vsn [ '<STR_LIT>' ] : <EOL> ranges = con . get ( uri ) <EOL> print ( '<STR_LIT>' , ranges [ '<STR_LIT>' ] ) <EOL> print ( '<STR_LIT>' , ranges [ '<STR_LIT>' ] ) <EOL> print ( '<STR_LIT>' , ranges [ '<STR_LIT>' ] ) <EOL> def main ( ) : <EOL> parser = argparse . ArgumentParser ( add_help = True , <EOL> formatter_class = argparse . RawTextHelpFormatter , <EOL> description = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT:host>' , required = True , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT:user>' , required = False , <EOL> default = '<STR_LIT>' , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , required = True , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT:-c>' , dest = '<STR_LIT>' , required = False , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , required = False , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , required = False , <EOL> default = '<STR_LIT>' , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , required = False , <EOL> choices = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] , default = '<STR_LIT>' , <EOL> help = '''<STR_LIT>''' ) <EOL> args = parser . parse_args ( ) <EOL> credential = { '<STR_LIT>' : args . domain . upper ( ) , '<STR_LIT>' : args . user , '<STR_LIT:password>' : args . passwd } <EOL> con = hpov . connection ( args . host ) <EOL> srv = hpov . servers ( con ) <EOL> if args . proxy : <EOL> con . set_proxy ( args . proxy . split ( '<STR_LIT::>' ) [ <NUM_LIT:0> ] , args . proxy . split ( '<STR_LIT::>' ) [ <NUM_LIT:1> ] ) <EOL> if args . cert : <EOL> con . set_trusted_ssl_bundle ( args . cert ) <EOL> login ( con , credential ) <EOL> acceptEULA ( con ) <EOL> get_address_pools ( con , srv , args . types ) <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL> import sys <EOL> import argparse <EOL> sys . exit ( main ( ) ) </s>
<s> from __future__ import print_function <EOL> from __future__ import unicode_literals <EOL> from __future__ import division <EOL> from __future__ import absolute_import <EOL> from builtins import range <EOL> from future import standard_library <EOL> standard_library . install_aliases ( ) <EOL> import sys <EOL> import re <EOL> PYTHON_VERSION = sys . version_info [ : <NUM_LIT:3> ] <EOL> PY2 = ( PYTHON_VERSION [ <NUM_LIT:0> ] == <NUM_LIT:2> ) <EOL> if PY2 : <EOL> if PYTHON_VERSION < ( <NUM_LIT:2> , <NUM_LIT:7> , <NUM_LIT:9> ) : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> elif PYTHON_VERSION < ( <NUM_LIT:3> , <NUM_LIT:4> ) : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> import hpOneView as hpov <EOL> from pprint import pprint <EOL> def acceptEULA ( con ) : <EOL> con . get_eula_status ( ) <EOL> try : <EOL> if con . get_eula_status ( ) is True : <EOL> print ( '<STR_LIT>' ) <EOL> con . set_eula ( '<STR_LIT>' ) <EOL> except Exception as e : <EOL> print ( '<STR_LIT>' ) <EOL> print ( e ) <EOL> def login ( con , credential ) : <EOL> try : <EOL> con . login ( credential ) <EOL> except : <EOL> print ( '<STR_LIT>' ) <EOL> def get_managed_sans ( fcs ) : <EOL> sans = fcs . get_managed_sans ( ) <EOL> pprint ( sans ) <EOL> def main ( ) : <EOL> parser = argparse . ArgumentParser ( add_help = True , <EOL> formatter_class = argparse . RawTextHelpFormatter , <EOL> description = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT:host>' , required = True , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT:user>' , required = False , <EOL> default = '<STR_LIT>' , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , required = True , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT:-c>' , dest = '<STR_LIT>' , required = False , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , required = False , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , required = False , <EOL> default = '<STR_LIT>' , <EOL> help = '''<STR_LIT>''' ) <EOL> args = parser . parse_args ( ) <EOL> credential = { '<STR_LIT>' : args . domain . upper ( ) , '<STR_LIT>' : args . user , '<STR_LIT:password>' : args . passwd } <EOL> con = hpov . connection ( args . host ) <EOL> fcs = hpov . fcsans ( con ) <EOL> if args . proxy : <EOL> con . set_proxy ( args . proxy . split ( '<STR_LIT::>' ) [ <NUM_LIT:0> ] , args . proxy . split ( '<STR_LIT::>' ) [ <NUM_LIT:1> ] ) <EOL> if args . cert : <EOL> con . set_trusted_ssl_bundle ( args . cert ) <EOL> login ( con , credential ) <EOL> acceptEULA ( con ) <EOL> get_managed_sans ( fcs ) <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL> import sys <EOL> import argparse <EOL> sys . exit ( main ( ) ) </s>
<s> from __future__ import print_function <EOL> from __future__ import unicode_literals <EOL> from __future__ import division <EOL> from __future__ import absolute_import <EOL> from builtins import range <EOL> from future import standard_library <EOL> standard_library . install_aliases ( ) <EOL> import sys <EOL> PYTHON_VERSION = sys . version_info [ : <NUM_LIT:3> ] <EOL> PY2 = ( PYTHON_VERSION [ <NUM_LIT:0> ] == <NUM_LIT:2> ) <EOL> if PY2 : <EOL> if PYTHON_VERSION < ( <NUM_LIT:2> , <NUM_LIT:7> , <NUM_LIT:9> ) : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> elif PYTHON_VERSION < ( <NUM_LIT:3> , <NUM_LIT:4> ) : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> import hpOneView as hpov <EOL> from pprint import pprint <EOL> def acceptEULA ( con ) : <EOL> con . get_eula_status ( ) <EOL> try : <EOL> if con . get_eula_status ( ) is True : <EOL> print ( '<STR_LIT>' ) <EOL> con . set_eula ( '<STR_LIT>' ) <EOL> except Exception as e : <EOL> print ( '<STR_LIT>' ) <EOL> print ( e ) <EOL> def login ( con , credential ) : <EOL> try : <EOL> con . login ( credential ) <EOL> except : <EOL> print ( '<STR_LIT>' ) <EOL> def getpolicy ( sts ) : <EOL> policy = sts . get_storage_vol_template_policy ( ) <EOL> print ( policy [ '<STR_LIT:value>' ] ) <EOL> def main ( ) : <EOL> parser = argparse . ArgumentParser ( add_help = True , <EOL> formatter_class = argparse . RawTextHelpFormatter , <EOL> description = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT:host>' , required = True , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT:user>' , required = False , <EOL> default = '<STR_LIT>' , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , required = True , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT:-c>' , dest = '<STR_LIT>' , required = False , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , required = False , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , required = False , <EOL> default = '<STR_LIT>' , <EOL> help = '''<STR_LIT>''' ) <EOL> args = parser . parse_args ( ) <EOL> credential = { '<STR_LIT>' : args . domain . upper ( ) , '<STR_LIT>' : args . user , '<STR_LIT:password>' : args . passwd } <EOL> con = hpov . connection ( args . host ) <EOL> sts = hpov . settings ( con ) <EOL> if args . proxy : <EOL> con . set_proxy ( args . proxy . split ( '<STR_LIT::>' ) [ <NUM_LIT:0> ] , args . proxy . split ( '<STR_LIT::>' ) [ <NUM_LIT:1> ] ) <EOL> if args . cert : <EOL> con . set_trusted_ssl_bundle ( args . cert ) <EOL> login ( con , credential ) <EOL> acceptEULA ( con ) <EOL> getpolicy ( sts ) <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL> import sys <EOL> import argparse <EOL> sys . exit ( main ( ) ) </s>
<s> """<STR_LIT>""" <EOL> from __future__ import unicode_literals <EOL> from __future__ import print_function <EOL> from __future__ import division <EOL> from __future__ import absolute_import <EOL> from future import standard_library <EOL> standard_library . install_aliases ( ) <EOL> from pprint import pprint <EOL> __title__ = '<STR_LIT>' <EOL> __version__ = '<STR_LIT>' <EOL> __copyright__ = '<STR_LIT>' '<STR_LIT>' <EOL> __license__ = '<STR_LIT>' <EOL> __status__ = '<STR_LIT>' <EOL> from hpOneView . common import * <EOL> from hpOneView . connection import * <EOL> from hpOneView . activity import * <EOL> from hpOneView . exceptions import * <EOL> class servers ( object ) : <EOL> def __init__ ( self , con ) : <EOL> self . _con = con <EOL> self . _activity = activity ( con ) <EOL> def get_connections ( self , filter = '<STR_LIT>' ) : <EOL> """<STR_LIT>""" <EOL> return get_members ( self . _con . get ( uri [ '<STR_LIT>' ] + filter ) ) <EOL> def get_connection ( self , server ) : <EOL> """<STR_LIT>""" <EOL> body = self . _con . get ( server [ '<STR_LIT>' ] ) <EOL> return body <EOL> def get_server_by_bay ( self , baynum ) : <EOL> servers = get_members ( self . _con . get ( uri [ '<STR_LIT>' ] ) ) <EOL> for server in servers : <EOL> if server [ '<STR_LIT>' ] == baynum : <EOL> return server <EOL> def get_server_by_name ( self , name ) : <EOL> servers = get_members ( self . _con . get ( uri [ '<STR_LIT>' ] ) ) <EOL> for server in servers : <EOL> if server [ '<STR_LIT:name>' ] == name : <EOL> return server <EOL> def get_available_servers ( self , server_hardware_type = None , <EOL> enclosure_group = None , server_profile = None ) : <EOL> filters = [ ] <EOL> if server_hardware_type : <EOL> filters . append ( '<STR_LIT>' + server_hardware_type [ '<STR_LIT>' ] ) <EOL> if enclosure_group : <EOL> filters . append ( '<STR_LIT>' + enclosure_group [ '<STR_LIT>' ] ) <EOL> if server_profile : <EOL> filters . append ( '<STR_LIT>' + server_profile [ '<STR_LIT>' ] ) <EOL> query_string = '<STR_LIT>' <EOL> if filters : <EOL> query_string = '<STR_LIT:?>' + '<STR_LIT:&>' . join ( filters ) <EOL> return self . _con . get ( uri [ '<STR_LIT>' ] + query_string ) <EOL> def get_servers ( self ) : <EOL> return get_members ( self . _con . get ( uri [ '<STR_LIT>' ] ) ) <EOL> def get_utilization ( self , server ) : <EOL> """<STR_LIT>""" <EOL> body = self . _con . get ( server [ '<STR_LIT>' ] + '<STR_LIT>' ) <EOL> return body <EOL> def get_env_conf ( self , server ) : <EOL> """<STR_LIT>""" <EOL> body = self . _con . get ( server [ '<STR_LIT>' ] + '<STR_LIT>' ) <EOL> return body <EOL> def set_server_powerstate ( self , server , state , force = False , blocking = True , <EOL> verbose = False ) : <EOL> if state == '<STR_LIT>' and force is True : <EOL> powerRequest = make_powerstate_dict ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> elif state == '<STR_LIT>' and force is False : <EOL> powerRequest = make_powerstate_dict ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> elif state == '<STR_LIT>' : <EOL> powerRequest = make_powerstate_dict ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> elif state == '<STR_LIT>' : <EOL> powerRequest = make_powerstate_dict ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> task , body = self . _con . put ( server [ '<STR_LIT>' ] + '<STR_LIT>' , powerRequest ) <EOL> if blocking is True : <EOL> task = self . _activity . wait4task ( task , tout = <NUM_LIT> , verbose = verbose ) <EOL> return task <EOL> def delete_server ( self , server , force = False , blocking = True , verbose = False ) : <EOL> if force : <EOL> task , body = self . _con . delete ( server [ '<STR_LIT>' ] + '<STR_LIT>' ) <EOL> else : <EOL> task , body = self . _con . delete ( server [ '<STR_LIT>' ] ) <EOL> if blocking is True : <EOL> task = self . _activity . wait4task ( task , tout = <NUM_LIT> , verbose = verbose ) <EOL> return task <EOL> def update_server ( self , server ) : <EOL> task , body = self . _con . put ( server [ '<STR_LIT>' ] , server ) <EOL> return body <EOL> def add_server ( self , server , blocking = True , verbose = False ) : <EOL> task , body = self . _con . post ( uri [ '<STR_LIT>' ] , server ) <EOL> if blocking is True : <EOL> task = self . _activity . wait4task ( task , tout = <NUM_LIT> , verbose = verbose ) <EOL> if '<STR_LIT:type>' in task and task [ '<STR_LIT:type>' ] . startswith ( '<STR_LIT>' ) : <EOL> entity = self . _activity . get_task_associated_resource ( task ) <EOL> server = self . _con . get ( entity [ '<STR_LIT>' ] ) <EOL> return server <EOL> return task <EOL> def get_server_schema ( self ) : <EOL> """<STR_LIT>""" <EOL> return self . _con . get ( uri [ '<STR_LIT>' ] + '<STR_LIT>' ) <EOL> def get_bios ( self , server ) : <EOL> """<STR_LIT>""" <EOL> return self . _con . get ( server [ '<STR_LIT>' ] + '<STR_LIT>' ) <EOL> def get_ilo_sso_url ( self , server ) : <EOL> """<STR_LIT>""" <EOL> return self . _con . get ( server [ '<STR_LIT>' ] + '<STR_LIT>' ) <EOL> def get_java_remote_console_url ( self , server ) : <EOL> """<STR_LIT>""" <EOL> return self . _con . get ( server [ '<STR_LIT>' ] + '<STR_LIT>' ) <EOL> def get_remote_console_url ( self , server ) : <EOL> """<STR_LIT>""" <EOL> return self . _con . get ( server [ '<STR_LIT>' ] + '<STR_LIT>' ) <EOL> def get_server_hardware_types ( self ) : <EOL> """<STR_LIT>""" <EOL> body = self . _con . get ( uri [ '<STR_LIT>' ] ) <EOL> return get_members ( body ) <EOL> def remove_server_hardware_type ( self , server_hardware_type , force = False , blocking = True , verbose = False ) : <EOL> """<STR_LIT>""" <EOL> if force : <EOL> task , body = self . _con . delete ( server_hardware_type [ '<STR_LIT>' ] + '<STR_LIT>' ) <EOL> else : <EOL> task , body = self . _con . delete ( server_hardware_type [ '<STR_LIT>' ] ) <EOL> if blocking is True : <EOL> task = self . _activity . wait4task ( task , tout = <NUM_LIT> , verbose = verbose ) <EOL> return task <EOL> def get_server_type_schema ( self ) : <EOL> """<STR_LIT>""" <EOL> return self . _con . get ( uri [ '<STR_LIT>' ] + '<STR_LIT>' ) <EOL> def get_server_hardware_type ( self , server_type ) : <EOL> """<STR_LIT>""" <EOL> return self . _con . get ( server_type [ '<STR_LIT>' ] ) <EOL> def set_server_hardware_type ( self , server_hardware_type , name , description ) : <EOL> """<STR_LIT>""" <EOL> request = make_server_type_dict ( name , description ) <EOL> task , body = self . _con . put ( server_hardware_type [ '<STR_LIT>' ] , request ) <EOL> return task <EOL> def create_server_profile ( self , <EOL> affinity = '<STR_LIT>' , <EOL> biosSettings = None , <EOL> bootSettings = None , <EOL> bootModeSetting = None , <EOL> profileConnectionV4 = None , <EOL> description = None , <EOL> firmwareSettingsV3 = None , <EOL> hideUnusedFlexNics = True , <EOL> localStorageSettingsV3 = None , <EOL> macType = '<STR_LIT>' , <EOL> name = None , <EOL> sanStorageV3 = None , <EOL> serialNumber = None , <EOL> serialNumberType = '<STR_LIT>' , <EOL> serverHardwareTypeUri = None , <EOL> serverHardwareUri = None , <EOL> serverProfileTemplateUri = None , <EOL> uuid = None , <EOL> wwnType = '<STR_LIT>' , <EOL> blocking = True , verbose = False ) : <EOL> """<STR_LIT>""" <EOL> profile = make_ServerProfileV5 ( affinity , biosSettings , bootSettings , <EOL> bootModeSetting , profileConnectionV4 , <EOL> description , firmwareSettingsV3 , <EOL> hideUnusedFlexNics , <EOL> localStorageSettingsV3 , macType , name , <EOL> sanStorageV3 , serialNumber , <EOL> serialNumberType , serverHardwareTypeUri , <EOL> serverHardwareUri , <EOL> serverProfileTemplateUri , uuid , wwnType ) <EOL> task , body = self . _con . post ( uri [ '<STR_LIT>' ] , profile ) <EOL> if profile [ '<STR_LIT>' ] is None : <EOL> tout = <NUM_LIT> <EOL> else : <EOL> tout = <NUM_LIT> <EOL> if blocking is True : <EOL> task = self . _activity . wait4task ( task , tout , verbose = verbose ) <EOL> if '<STR_LIT:type>' in task and task [ '<STR_LIT:type>' ] . startswith ( '<STR_LIT>' ) : <EOL> entity = self . _activity . get_task_associated_resource ( task ) <EOL> profile = self . _con . get ( entity [ '<STR_LIT>' ] ) <EOL> return profile <EOL> return task <EOL> def post_server_profile ( self , profile , blocking = True , verbose = False ) : <EOL> """<STR_LIT>""" <EOL> task , body = self . _con . post ( uri [ '<STR_LIT>' ] , profile ) <EOL> if profile [ '<STR_LIT>' ] is None : <EOL> tout = <NUM_LIT> <EOL> else : <EOL> tout = <NUM_LIT> <EOL> if blocking is True : <EOL> task = self . _activity . wait4task ( task , tout , verbose = verbose ) <EOL> if '<STR_LIT:type>' in task and task [ '<STR_LIT:type>' ] . startswith ( '<STR_LIT>' ) : <EOL> entity = self . _activity . get_task_associated_resource ( task ) <EOL> profile = self . _con . get ( entity [ '<STR_LIT>' ] ) <EOL> return profile <EOL> return task <EOL> def remove_server_profile ( self , profile , force = False , blocking = True , verbose = False ) : <EOL> if force : <EOL> task , body = self . _con . delete ( profile [ '<STR_LIT>' ] + '<STR_LIT>' ) <EOL> else : <EOL> task , body = self . _con . delete ( profile [ '<STR_LIT>' ] ) <EOL> if blocking is True : <EOL> task = self . _activity . wait4task ( task , tout = <NUM_LIT> , verbose = verbose ) <EOL> return task <EOL> def get_server_profiles ( self ) : <EOL> body = self . _con . get ( uri [ '<STR_LIT>' ] ) <EOL> return get_members ( body ) <EOL> def update_server_profile ( self , profile , blocking = True , verbose = False ) : <EOL> task , body = self . _con . put ( profile [ '<STR_LIT>' ] , profile ) <EOL> try : <EOL> if profile [ '<STR_LIT>' ] [ '<STR_LIT>' ] is None : <EOL> tout = <NUM_LIT> <EOL> else : <EOL> tout = <NUM_LIT> <EOL> except Exception : <EOL> tout = <NUM_LIT> <EOL> if blocking is True : <EOL> task = self . _activity . wait4task ( task , tout = tout , verbose = verbose ) <EOL> profileResource = self . _activity . get_task_associated_resource ( task ) <EOL> profile = self . _con . get ( profileResource [ '<STR_LIT>' ] ) <EOL> return profile <EOL> def update_server_profile_from_template ( self , profile , blocking = True , verbose = False ) : <EOL> patch_request = [ { '<STR_LIT>' : '<STR_LIT:replace>' , '<STR_LIT:path>' : '<STR_LIT>' , '<STR_LIT:value>' : '<STR_LIT>' } ] <EOL> task , body = self . _con . patch ( profile [ '<STR_LIT>' ] , patch_request ) <EOL> try : <EOL> if profile [ '<STR_LIT>' ] [ '<STR_LIT>' ] is None : <EOL> tout = <NUM_LIT> <EOL> else : <EOL> tout = <NUM_LIT> <EOL> except Exception : <EOL> tout = <NUM_LIT> <EOL> if blocking is True : <EOL> task = self . _activity . wait4task ( task , tout = tout , verbose = verbose ) <EOL> profileResource = self . _activity . get_task_associated_resource ( task ) <EOL> profile = self . _con . get ( profileResource [ '<STR_LIT>' ] ) <EOL> return profile <EOL> def get_server_profile_by_name ( self , name ) : <EOL> body = self . _con . get_entity_byfield ( uri [ '<STR_LIT>' ] , '<STR_LIT:name>' , name ) <EOL> return body <EOL> def get_profile_message ( self , profile ) : <EOL> """<STR_LIT>""" <EOL> message = self . _con . get ( profile [ '<STR_LIT>' ] + '<STR_LIT>' ) <EOL> return message <EOL> def get_profile_compliance_preview ( self , profile ) : <EOL> """<STR_LIT>""" <EOL> return self . _con . get ( profile [ '<STR_LIT>' ] + '<STR_LIT>' ) <EOL> def create_server_profile_template ( <EOL> self , <EOL> name = None , <EOL> description = None , <EOL> serverProfileDescription = None , <EOL> serverHardwareTypeUri = None , <EOL> enclosureGroupUri = None , <EOL> affinity = None , <EOL> hideUnusedFlexNics = None , <EOL> profileConnectionV4 = None , <EOL> firmwareSettingsV3 = None , <EOL> bootSettings = None , <EOL> bootModeSetting = None , <EOL> blocking = True , <EOL> verbose = False ) : <EOL> """<STR_LIT>""" <EOL> profile_template = make_ServerProfileTemplateV1 ( name , <EOL> description , <EOL> serverProfileDescription , <EOL> serverHardwareTypeUri , <EOL> enclosureGroupUri , <EOL> affinity , <EOL> hideUnusedFlexNics , <EOL> profileConnectionV4 , <EOL> firmwareSettingsV3 , <EOL> bootSettings , <EOL> bootModeSetting ) <EOL> task , body = self . _con . post ( uri [ '<STR_LIT>' ] , profile_template ) <EOL> tout = <NUM_LIT> <EOL> if blocking is True : <EOL> task = self . _activity . wait4task ( task , tout , verbose = verbose ) <EOL> if '<STR_LIT:type>' in task and task [ '<STR_LIT:type>' ] . startswith ( '<STR_LIT>' ) : <EOL> entity = self . _activity . get_task_associated_resource ( task ) <EOL> profile_template = self . _con . get ( entity [ '<STR_LIT>' ] ) <EOL> return profile_template <EOL> return task <EOL> def remove_server_profile_template ( self , profile_template , blocking = True , verbose = False ) : <EOL> task , body = self . _con . delete ( profile_template [ '<STR_LIT>' ] ) <EOL> if blocking is True : <EOL> task = self . _activity . wait4task ( task , tout = <NUM_LIT> , verbose = verbose ) <EOL> return task <EOL> return body <EOL> def get_server_profile_templates ( self ) : <EOL> body = self . _con . get ( uri [ '<STR_LIT>' ] ) <EOL> return get_members ( body ) <EOL> def get_server_profile_template_by_name ( self , name ) : <EOL> body = self . _con . get_entity_byfield ( uri [ '<STR_LIT>' ] , '<STR_LIT:name>' , name ) <EOL> return body <EOL> def update_server_profile_template ( self , profile_template , blocking = True , verbose = False ) : <EOL> task , body = self . _con . put ( profile_template [ '<STR_LIT>' ] , profile_template ) <EOL> tout = <NUM_LIT> <EOL> if blocking is True : <EOL> task = self . _activity . wait4task ( task , tout = tout , verbose = verbose ) <EOL> profileTemplateResource = self . _activity . get_task_associated_resource ( task ) <EOL> profile = self . _con . get ( profileTemplateResource [ '<STR_LIT>' ] ) <EOL> return profile_template <EOL> def get_server_profile_from_template ( self , profile_template ) : <EOL> profile = self . _con . get ( profile_template [ '<STR_LIT>' ] + '<STR_LIT>' ) <EOL> return profile <EOL> def get_enclosures ( self ) : <EOL> body = self . _con . get ( uri [ '<STR_LIT>' ] ) <EOL> return get_members ( body ) <EOL> def add_enclosure ( self , enclosure , blocking = True , verbose = False ) : <EOL> task , body = self . _con . post ( uri [ '<STR_LIT>' ] , enclosure ) <EOL> if enclosure [ '<STR_LIT:state>' ] is '<STR_LIT>' : <EOL> tout = <NUM_LIT> <EOL> elif enclosure [ '<STR_LIT>' ] is None : <EOL> tout = <NUM_LIT> <EOL> else : <EOL> tout = <NUM_LIT> <EOL> if blocking is True : <EOL> task = self . _activity . wait4task ( task , tout , verbose = verbose ) <EOL> if '<STR_LIT:type>' in task and task [ '<STR_LIT:type>' ] . startswith ( '<STR_LIT>' ) : <EOL> entity = self . _activity . get_task_associated_resource ( task ) <EOL> enclosure = self . _con . get ( entity [ '<STR_LIT>' ] ) <EOL> return enclosure <EOL> return task <EOL> def remove_enclosure ( self , enclosure , force = False , blocking = True , <EOL> verbose = False ) : <EOL> if force : <EOL> task , body = self . _con . delete ( enclosure [ '<STR_LIT>' ] + '<STR_LIT>' ) <EOL> else : <EOL> task , body = self . _con . delete ( enclosure [ '<STR_LIT>' ] ) <EOL> if blocking is True : <EOL> task = self . _activity . wait4task ( task , tout = <NUM_LIT> , verbose = verbose ) <EOL> return task <EOL> def create_enclosure_group ( self , associatedLIGs , name , <EOL> powerMode = '<STR_LIT>' ) : <EOL> """<STR_LIT>""" <EOL> egroup = make_EnclosureGroupV200 ( associatedLIGs , name , powerMode ) <EOL> task , body = self . _con . post ( uri [ '<STR_LIT>' ] , egroup ) <EOL> return body <EOL> def delete_enclosure_group ( self , egroup ) : <EOL> self . _con . delete ( egroup [ '<STR_LIT>' ] ) <EOL> def get_enclosure_groups ( self ) : <EOL> return get_members ( self . _con . get ( uri [ '<STR_LIT>' ] ) ) <EOL> def update_enclosure_group ( self , enclosuregroup ) : <EOL> task , body = self . _con . put ( enclosuregroup [ '<STR_LIT>' ] , enclosuregroup ) <EOL> return body <EOL> def get_pool ( self , pooltype ) : <EOL> body = self . _con . get ( uri [ '<STR_LIT>' ] + '<STR_LIT:/>' + pooltype ) <EOL> return body <EOL> def get_vmac_pool ( self ) : <EOL> body = self . _con . get ( uri [ '<STR_LIT>' ] ) <EOL> return body <EOL> def get_vwwn_pool ( self ) : <EOL> body = self . _con . get ( uri [ '<STR_LIT>' ] ) <EOL> return body <EOL> def get_vsn_pool ( self ) : <EOL> body = self . _con . get ( uri [ '<STR_LIT>' ] ) <EOL> return body <EOL> def get_profile_networks ( self ) : <EOL> body = self . _con . get ( uri [ '<STR_LIT>' ] ) <EOL> return body <EOL> def get_profile_schema ( self ) : <EOL> return self . _con . get ( uri [ '<STR_LIT>' ] ) <EOL> def get_profile_available_servers ( self ) : <EOL> body = self . _con . get ( uri [ '<STR_LIT>' ] ) <EOL> return body <EOL> def get_profile_available_storage_systems ( self ) : <EOL> body = self . _con . get ( uri [ '<STR_LIT>' ] ) <EOL> return body <EOL> def get_profile_ports ( self ) : <EOL> body = self . _con . get ( uri [ '<STR_LIT>' ] ) <EOL> return body <EOL> def allocate_pool_ids ( self , url , count ) : <EOL> allocatorUrl = '<STR_LIT>' % url <EOL> allocatorBody = { '<STR_LIT:count>' : count } <EOL> task , body = self . _con . put ( allocatorUrl , allocatorBody ) <EOL> return body <EOL> def release_pool_ids ( self , url , idList ) : <EOL> collectorUrl = '<STR_LIT>' % url <EOL> collectorBody = { '<STR_LIT>' : idList } <EOL> task , body = self . _con . put ( collectorUrl , collectorBody ) <EOL> return body <EOL> def allocate_range_ids ( self , allocatorUrl , count ) : <EOL> task , body = self . _con . put ( allocatorUrl , { '<STR_LIT:count>' : count } ) <EOL> return body <EOL> def release_range_ids ( self , collectorUrl , idList ) : <EOL> task , body = self . _con . put ( collectorUrl , { '<STR_LIT>' : idList } ) <EOL> return body <EOL> def enable_range ( self , url ) : <EOL> prange = self . _con . get ( url ) <EOL> prange [ '<STR_LIT>' ] = True <EOL> task , body = self . _con . put ( url , prange ) <EOL> return body <EOL> def disable_range ( self , url ) : <EOL> prange = self . _con . get ( url ) <EOL> prange [ '<STR_LIT>' ] = False <EOL> task , body = self . _con . put ( url , prange ) <EOL> return body </s>
<s> """<STR_LIT>""" <EOL> import os <EOL> import re <EOL> import sys <EOL> import json <EOL> import locale <EOL> import zipfile <EOL> import logging <EOL> import textwrap <EOL> import validictory <EOL> from . sharedtypes import JSONEncoder <EOL> from ilorest . rest . v1_helper import ( RisObject ) <EOL> LOGGER = logging . getLogger ( __name__ ) <EOL> class ValidationError ( Exception ) : <EOL> """<STR_LIT>""" <EOL> pass <EOL> class SchemaValidationError ( ValidationError ) : <EOL> """<STR_LIT>""" <EOL> pass <EOL> class RegistryValidationError ( ValidationError ) : <EOL> """<STR_LIT>""" <EOL> def __init__ ( self , msg , regentry = None , selector = None ) : <EOL> super ( RegistryValidationError , self ) . __init__ ( msg ) <EOL> self . reg = regentry <EOL> self . sel = selector <EOL> class UnknownValidatorError ( Exception ) : <EOL> """<STR_LIT>""" <EOL> """<STR_LIT>""" <EOL> class ValidationManager ( object ) : <EOL> """<STR_LIT>""" <EOL> """<STR_LIT>""" <EOL> def __init__ ( self , local_path , bios_local_path , romfamily = None , biosversion = None , iloversion = None , monolith = None ) : <EOL> super ( ValidationManager , self ) . __init__ ( ) <EOL> defaultilopath = None <EOL> defaultbiospath = None <EOL> schemamainfolder = None <EOL> if float ( iloversion ) < <NUM_LIT> : <EOL> if os . name == '<STR_LIT>' : <EOL> defaultilopath = r"<STR_LIT>" <EOL> defaultbiospath = r"<STR_LIT>" <EOL> schemamainfolder = os . path . dirname ( sys . executable ) <EOL> else : <EOL> defaultilopath = "<STR_LIT>" <EOL> defaultbiospath = "<STR_LIT>" <EOL> schemamainfolder = "<STR_LIT>" <EOL> if not local_path : <EOL> if not os . path . isdir ( defaultilopath ) : <EOL> ilozip = self . getiloziplocation ( schemamainfolder , iloversion ) <EOL> if ilozip and os . path . exists ( ilozip ) : <EOL> with zipfile . ZipFile ( os . path . join ( schemamainfolder , ilozip ) , "<STR_LIT:r>" ) as zfile : <EOL> zfile . extractall ( os . path . join ( schemamainfolder , "<STR_LIT>" ) ) <EOL> local_path = os . path . join ( schemamainfolder , u'<STR_LIT>' ) <EOL> else : <EOL> raise SchemaValidationError ( u'<STR_LIT>' '<STR_LIT>' '<STR_LIT>' '<STR_LIT>' ) <EOL> else : <EOL> local_path = defaultilopath <EOL> else : <EOL> if not os . path . isdir ( local_path ) : <EOL> raise SchemaValidationError ( u"<STR_LIT>" <EOL> "<STR_LIT>" % local_path ) <EOL> if not bios_local_path : <EOL> if not os . path . isdir ( defaultbiospath ) : <EOL> bioszip = self . getbiosziplocation ( romfamily , schemamainfolder , biosversion ) <EOL> if bioszip and os . path . exists ( bioszip ) : <EOL> with zipfile . ZipFile ( <EOL> os . path . join ( schemamainfolder , bioszip ) , "<STR_LIT:r>" ) as zfile : <EOL> zfile . extractall ( os . path . join ( schemamainfolder , "<STR_LIT>" ) ) <EOL> bios_local_path = os . path . join ( schemamainfolder , u'<STR_LIT>' ) <EOL> else : <EOL> raise SchemaValidationError ( u'<STR_LIT>' '<STR_LIT>' '<STR_LIT>' '<STR_LIT>' ) <EOL> else : <EOL> bios_local_path = defaultbiospath <EOL> else : <EOL> if not os . path . isdir ( bios_local_path ) : <EOL> raise SchemaValidationError ( u"<STR_LIT>" "<STR_LIT>" % bios_local_path ) <EOL> else : <EOL> if monolith . is_redfish : <EOL> local_path = "<STR_LIT>" <EOL> bios_local_path = "<STR_LIT>" <EOL> else : <EOL> local_path = "<STR_LIT>" <EOL> bios_local_path = "<STR_LIT>" <EOL> self . _schema_locations = list ( ) <EOL> self . _classes = list ( ) <EOL> self . _registry_locations = list ( ) <EOL> self . _classes_registry = list ( ) <EOL> self . _bios_schema_locations = list ( ) <EOL> self . _bios_classes = list ( ) <EOL> self . _bios_registry_locations = list ( ) <EOL> self . _bios_classes_registry = list ( ) <EOL> self . _ilo_messages = list ( ) <EOL> self . _base_messages = list ( ) <EOL> self . _hpcommon_messages = list ( ) <EOL> self . _iloevents_messages = list ( ) <EOL> self . _errors = list ( ) <EOL> if monolith . is_redfish : <EOL> self . _schemaid = [ "<STR_LIT>" , "<STR_LIT>" ] <EOL> self . _regid = [ "<STR_LIT>" , "<STR_LIT>" ] <EOL> else : <EOL> self . _schemaid = [ "<STR_LIT>" , "<STR_LIT>" ] <EOL> self . _regid = [ "<STR_LIT>" , "<STR_LIT>" ] <EOL> if local_path : <EOL> self . add_location ( schema_path = local_path , monolith = monolith ) <EOL> self . add_location ( registry_path = local_path , monolith = monolith ) <EOL> if bios_local_path : <EOL> self . add_location ( schema_path = bios_local_path , biossection = True , monolith = monolith ) <EOL> self . add_location ( registry_path = bios_local_path , biossection = True , monolith = monolith ) <EOL> def getbiosziplocation ( self , romfamily , schemadir , biosversion ) : <EOL> """<STR_LIT>""" <EOL> foundfile = None <EOL> currentver = None <EOL> tempstr = "<STR_LIT>" + romfamily + "<STR_LIT:->" + biosversion <EOL> for _ , _ , filenames in os . walk ( schemadir ) : <EOL> for filename in filenames : <EOL> if tempstr in filename : <EOL> regentry = re . compile ( '<STR_LIT>' % tempstr ) <EOL> mentry = regentry . search ( filename ) <EOL> if mentry and currentver : <EOL> if currentver < mentry . group ( <NUM_LIT:1> ) : <EOL> foundfile = filename <EOL> currentver = mentry . group ( <NUM_LIT:1> ) <EOL> elif mentry and not currentver : <EOL> foundfile = filename <EOL> currentver = mentry . group ( <NUM_LIT:1> ) <EOL> if foundfile : <EOL> return os . path . join ( schemadir , foundfile ) <EOL> else : <EOL> return None <EOL> def getiloziplocation ( self , schemadir , iloversion ) : <EOL> """<STR_LIT>""" <EOL> if float ( iloversion ) < <NUM_LIT> : <EOL> iloversion = u'<STR_LIT>' <EOL> tempstr = "<STR_LIT>" + iloversion . replace ( "<STR_LIT:.>" , "<STR_LIT>" ) <EOL> for _ , _ , filenames in os . walk ( schemadir ) : <EOL> for filename in filenames : <EOL> if tempstr in filename : <EOL> return os . path . join ( schemadir , filename ) <EOL> return None <EOL> def add_location ( self , schema_path = None , registry_path = None , <EOL> biossection = False , monolith = None ) : <EOL> """<STR_LIT>""" <EOL> """<STR_LIT>""" <EOL> if schema_path : <EOL> if not biossection : <EOL> self . _schema_locations . append ( schema_path ) <EOL> self . _update_location_map ( monolith = monolith ) <EOL> else : <EOL> self . _bios_schema_locations . append ( schema_path ) <EOL> self . _update_location_map ( biossection = True , monolith = monolith ) <EOL> elif registry_path : <EOL> if not biossection : <EOL> self . _registry_locations . append ( registry_path ) <EOL> self . _update_location_map ( registries = True , monolith = monolith ) <EOL> else : <EOL> self . _bios_registry_locations . append ( registry_path ) <EOL> self . _update_location_map ( biossection = True , registries = True , monolith = monolith ) <EOL> else : <EOL> raise ValueError ( u"<STR_LIT>" "<STR_LIT>" ) <EOL> def _update_location_map ( self , biossection = False , registries = False , <EOL> monolith = None ) : <EOL> """<STR_LIT>""" <EOL> locationslist = list ( ) <EOL> pathjoinstr = None <EOL> if not registries : <EOL> pathjoinstr = "<STR_LIT>" <EOL> if not biossection : <EOL> locationslist = self . _schema_locations <EOL> else : <EOL> locationslist = self . _bios_schema_locations <EOL> else : <EOL> pathjoinstr = "<STR_LIT>" <EOL> if not biossection : <EOL> locationslist = self . _registry_locations <EOL> else : <EOL> locationslist = self . _bios_registry_locations <EOL> for location in locationslist : <EOL> if monolith : <EOL> self . new_load_file ( monolith , root = location , biossection = biossection , registries = registries ) <EOL> elif self . _is_local ( location ) : <EOL> for root , _ , filenames in os . walk ( os . path . join ( location , <EOL> pathjoinstr ) ) : <EOL> for filename in filenames : <EOL> fqpath = os . path . abspath ( os . path . join ( os . path . normpath ( root ) , filename ) ) <EOL> if self . load_file ( fqpath , root = location , biossection = biossection , registries = registries ) : <EOL> LOGGER . info ( "<STR_LIT>" , fqpath ) <EOL> def new_load_file ( self , monolith , root = None , biossection = False , registries = False ) : <EOL> """<STR_LIT>""" <EOL> classesdataholder = [ ] <EOL> for itemtype in monolith . types : <EOL> if itemtype . startswith ( "<STR_LIT>" ) or itemtype . startswith ( "<STR_LIT>" ) and u'<STR_LIT>' in monolith . types [ itemtype ] : <EOL> for instance in monolith . types [ itemtype ] [ u'<STR_LIT>' ] : <EOL> if self . _schemaid [ <NUM_LIT:0> ] in instance . resp . request . path . lower ( ) or self . _regid [ <NUM_LIT:0> ] in instance . resp . request . path . lower ( ) : <EOL> if not registries and self . _schemaid [ <NUM_LIT:0> ] in instance . resp . request . path . lower ( ) : <EOL> if classesdataholder : <EOL> if self . _schemaid [ <NUM_LIT:1> ] in instance . resp . dict : <EOL> classesdataholder [ <NUM_LIT:0> ] [ self . _schemaid [ <NUM_LIT:1> ] ] . extend ( instance . resp . dict [ self . _schemaid [ <NUM_LIT:1> ] ] ) <EOL> else : <EOL> classesdataholder . append ( instance . resp . dict ) <EOL> elif registries and self . _regid [ <NUM_LIT:0> ] in instance . resp . request . path . lower ( ) : <EOL> if classesdataholder : <EOL> if monolith . is_redfish : <EOL> classesdataholder [ <NUM_LIT:0> ] [ self . _regid [ <NUM_LIT:1> ] ] . extend ( instance . resp . dict [ self . _regid [ <NUM_LIT:1> ] ] ) <EOL> else : <EOL> classesdataholder . append ( instance . resp . dict ) <EOL> if classesdataholder : <EOL> classesdataholder = classesdataholder [ <NUM_LIT:0> ] <EOL> try : <EOL> if monolith . _typestring in classesdataholder and ( '<STR_LIT>' in classesdataholder [ monolith . _typestring ] or ( '<STR_LIT>' in classesdataholder [ monolith . _typestring ] and monolith . is_redfish ) ) : <EOL> newclass = Classes . parse ( classesdataholder ) <EOL> newclass . set_root ( root ) <EOL> if not registries : <EOL> if not biossection : <EOL> self . _classes . append ( newclass ) <EOL> else : <EOL> self . _bios_classes . append ( newclass ) <EOL> else : <EOL> if not biossection : <EOL> self . _classes_registry . append ( newclass ) <EOL> else : <EOL> self . _bios_classes_registry . append ( newclass ) <EOL> except BaseException : <EOL> pass <EOL> else : <EOL> pass <EOL> def load_file ( self , filepath , root = None , biossection = False , <EOL> registries = False , datareturn = False ) : <EOL> """<STR_LIT>""" <EOL> result = False <EOL> if os . path . isfile ( filepath ) : <EOL> try : <EOL> filehand = open ( filepath , '<STR_LIT:r>' ) <EOL> data = json . load ( filehand ) <EOL> if datareturn : <EOL> return data <EOL> if u'<STR_LIT>' in data and data [ u'<STR_LIT>' ] == '<STR_LIT>' : <EOL> if biossection and registries : <EOL> itemsreturn = self . bios_helper_function ( data , root ) <EOL> data [ "<STR_LIT>" ] = itemsreturn <EOL> newclass = Classes . parse ( data ) <EOL> newclass . set_root ( root ) <EOL> if not registries : <EOL> if not biossection : <EOL> self . _classes . append ( newclass ) <EOL> else : <EOL> self . _bios_classes . append ( newclass ) <EOL> else : <EOL> if not biossection : <EOL> self . _classes_registry . append ( newclass ) <EOL> else : <EOL> self . _bios_classes_registry . append ( newclass ) <EOL> result = True <EOL> except BaseException : <EOL> pass <EOL> else : <EOL> pass <EOL> finally : <EOL> filehand . close ( ) <EOL> return result <EOL> def bios_helper_function ( self , data , root ) : <EOL> """<STR_LIT>""" <EOL> folderentries = data [ "<STR_LIT>" ] <EOL> datareturn = list ( ) <EOL> for entry in folderentries [ "<STR_LIT>" ] : <EOL> joinstr = entry [ "<STR_LIT>" ] <EOL> if os . name == '<STR_LIT>' and joinstr [ <NUM_LIT:0> ] == "<STR_LIT:/>" : <EOL> joinstr = joinstr . replace ( "<STR_LIT:/>" , "<STR_LIT:\\>" ) [ <NUM_LIT:1> : ] <EOL> elif joinstr [ <NUM_LIT:0> ] == "<STR_LIT:/>" : <EOL> joinstr = joinstr [ <NUM_LIT:1> : ] <EOL> for root , _ , filenames in os . walk ( os . path . join ( root , joinstr ) ) : <EOL> for filename in filenames : <EOL> fqpath = os . path . abspath ( os . path . join ( os . path . normpath ( root ) , filename ) ) <EOL> datareturn . append ( self . load_file ( fqpath , root = root , biossection = True , registries = True , datareturn = True ) ) <EOL> LOGGER . info ( "<STR_LIT>" , fqpath ) <EOL> return datareturn <EOL> def validate ( self , item , selector = None , currdict = None , monolith = None , <EOL> newarg = None , checkall = False , regloc = None ) : <EOL> """<STR_LIT>""" <EOL> """<STR_LIT>""" <EOL> if regloc : <EOL> attrreg = RepoRegistryEntry ( regloc ) <EOL> else : <EOL> attrreg = self . find_schema ( schname = item [ monolith . _typestring ] ) <EOL> if attrreg : <EOL> tempvalue = attrreg . validate ( item , self . _errors , selector = selector , <EOL> currdict = currdict , monolith = monolith , <EOL> newarg = newarg , checkall = checkall ) <EOL> if tempvalue is True : <EOL> return False <EOL> elif tempvalue : <EOL> self . _errors = tempvalue <EOL> return True <EOL> def bios_validate ( self , item , regname , selector = None , currdict = None , <EOL> checkall = False , monolith = None ) : <EOL> """<STR_LIT>""" <EOL> """<STR_LIT>""" <EOL> attrreg = self . find_bios_registry ( regname = regname ) <EOL> if attrreg : <EOL> tempvalue = attrreg . validate_bios_version ( item , self . _errors , selector = selector , currdict = currdict , checkall = checkall , monolith = monolith ) <EOL> if tempvalue == '<STR_LIT>' : <EOL> return tempvalue <EOL> elif tempvalue == '<STR_LIT>' : <EOL> return tempvalue <EOL> elif tempvalue : <EOL> self . _errors = tempvalue <EOL> return True <EOL> def bios_info ( self , item , regname , selector ) : <EOL> """<STR_LIT>""" <EOL> """<STR_LIT>""" <EOL> attrreg = self . find_bios_registry ( regname = regname ) <EOL> if attrreg : <EOL> if attrreg . validate_bios_version ( item , self . _errors , selector = selector ) : <EOL> return False <EOL> return True <EOL> def find_schema ( self , schname ) : <EOL> """<STR_LIT>""" <EOL> """<STR_LIT>""" <EOL> for cls in self . _classes : <EOL> found = cls . find_schema ( schname = schname ) <EOL> if found : <EOL> return found <EOL> return None <EOL> def find_registry ( self , regname ) : <EOL> """<STR_LIT>""" <EOL> """<STR_LIT>""" <EOL> for cls in self . _classes_registry : <EOL> found = cls . find_registry ( regname = regname ) <EOL> if found : <EOL> return found <EOL> return None <EOL> def find_bios_registry ( self , regname ) : <EOL> """<STR_LIT>""" <EOL> """<STR_LIT>""" <EOL> for cls in self . _bios_classes_registry : <EOL> found = cls . find_bios_registry ( regname = regname ) <EOL> if found : <EOL> return found <EOL> return None <EOL> def get_errors ( self ) : <EOL> """<STR_LIT>""" <EOL> return self . _errors <EOL> def _is_local ( self , path ) : <EOL> """<STR_LIT>""" <EOL> if u'<STR_LIT>' in path : <EOL> return False <EOL> return True <EOL> class Classes ( RisObject ) : <EOL> """<STR_LIT>""" <EOL> def __init__ ( self , item ) : <EOL> super ( Classes , self ) . __init__ ( item ) <EOL> self . _root = None <EOL> def set_root ( self , newroot ) : <EOL> """<STR_LIT>""" <EOL> self . _root = newroot <EOL> def find_schema ( self , schname ) : <EOL> """<STR_LIT>""" <EOL> result = None <EOL> if hasattr ( self , '<STR_LIT>' ) and isinstance ( self . Items , list ) : <EOL> for entry in self . Items : <EOL> if entry and u'<STR_LIT>' in entry and entry [ u'<STR_LIT>' ] . lower ( ) == schname . lower ( ) : <EOL> regentry = RepoRegistryEntry . parse ( entry ) <EOL> regentry . set_root ( self . _root ) <EOL> result = regentry <EOL> break <EOL> elif hasattr ( self , '<STR_LIT>' ) and isinstance ( self . Members , list ) : <EOL> schname = schname . split ( '<STR_LIT:.>' ) [ - <NUM_LIT:1> ] <EOL> for entry in self . Members : <EOL> schlink = entry [ u'<STR_LIT>' ] . split ( '<STR_LIT:/>' ) <EOL> schlink = schlink [ len ( schlink ) - <NUM_LIT:2> ] <EOL> if schname . lower ( ) == schlink . lower ( ) : <EOL> result = entry <EOL> break <EOL> return result <EOL> def find_registry ( self , regname ) : <EOL> """<STR_LIT>""" <EOL> result = None <EOL> if hasattr ( self , '<STR_LIT>' ) and isinstance ( self . Items , list ) : <EOL> for entry in self . Items : <EOL> if entry and ( u'<STR_LIT>' in entry and <EOL> entry [ u'<STR_LIT>' ] . lower ( ) . startswith ( regname . lower ( ) ) ) : <EOL> regentry = RepoRegistryEntry . parse ( entry ) <EOL> regentry . set_root ( self . _root ) <EOL> result = regentry <EOL> break <EOL> elif hasattr ( self , '<STR_LIT>' ) and isinstance ( self . Members , list ) : <EOL> regname = regname . split ( '<STR_LIT:.>' ) [ - <NUM_LIT:1> ] <EOL> for entry in self . Members : <EOL> reglink = entry [ u'<STR_LIT>' ] . split ( '<STR_LIT:/>' ) <EOL> reglink = reglink [ len ( reglink ) - <NUM_LIT:2> ] <EOL> if regname . lower ( ) == reglink . lower ( ) : <EOL> result = entry <EOL> break <EOL> return result <EOL> def find_bios_schema ( self , schname ) : <EOL> """<STR_LIT>""" <EOL> result = None <EOL> if hasattr ( self , '<STR_LIT>' ) and isinstance ( self . Items , list ) : <EOL> for entry in self . Items : <EOL> if ( u'<STR_LIT>' in entry and entry [ u'<STR_LIT>' ] . lower ( ) == <EOL> schname . lower ( ) ) : <EOL> regentry = RepoRegistryEntry . parse ( entry ) <EOL> regentry . set_root ( self . _root ) <EOL> result = regentry <EOL> break <EOL> return result <EOL> def find_bios_registry ( self , regname ) : <EOL> """<STR_LIT>""" <EOL> result = None <EOL> if hasattr ( self , '<STR_LIT>' ) and isinstance ( self . Items , list ) : <EOL> for entry in self . Items : <EOL> if entry and ( u'<STR_LIT>' in entry and regname . lower ( ) in entry [ u'<STR_LIT>' ] . lower ( ) ) : <EOL> regentry = RepoRegistryEntry . parse ( entry ) <EOL> regentry . set_root ( self . _root ) <EOL> result = regentry <EOL> break <EOL> return result <EOL> class RepoBaseEntry ( RisObject ) : <EOL> """<STR_LIT>""" <EOL> def __init__ ( self , d ) : <EOL> super ( RepoBaseEntry , self ) . __init__ ( d ) <EOL> self . _root = None <EOL> def set_root ( self , newroot ) : <EOL> """<STR_LIT>""" <EOL> self . _root = newroot <EOL> def _read_location_file ( self , currloc , errlist ) : <EOL> """<STR_LIT>""" <EOL> result = None <EOL> if u'<STR_LIT>' in currloc : <EOL> root = os . path . normpath ( self . _root ) <EOL> xref = os . path . normpath ( currloc . Uri . extref ) . lstrip ( os . path . sep ) <EOL> fqpath = os . path . join ( root , xref ) <EOL> if not os . path . isfile ( fqpath ) : <EOL> errlist . append ( SchemaValidationError ( <EOL> u"<STR_LIT>" % fqpath ) ) <EOL> else : <EOL> result = None <EOL> if fqpath . endswith ( '<STR_LIT>' ) : <EOL> result = open ( fqpath ) . read ( ) <EOL> return result <EOL> class RepoRegistryEntry ( RepoBaseEntry ) : <EOL> """<STR_LIT>""" <EOL> def __init__ ( self , d ) : <EOL> super ( RepoRegistryEntry , self ) . __init__ ( d ) <EOL> def validate ( self , tdict , errlist = None , selector = None , currdict = None , checkall = False , monolith = None , newarg = None ) : <EOL> """<STR_LIT>""" <EOL> if not errlist : <EOL> errlist = list ( ) <EOL> reg = self . get_registry_model ( errlist = errlist , currdict = currdict , monolith = monolith , newarg = newarg ) <EOL> if reg and not checkall : <EOL> try : <EOL> if reg [ selector ] . readonly : <EOL> return True <EOL> except BaseException : <EOL> pass <EOL> else : <EOL> pass <EOL> results = reg . validate_attribute_values ( tdict ) <EOL> errlist . extend ( results ) <EOL> elif checkall and selector is None : <EOL> results = reg . validate_attribute_values ( tdict ) <EOL> errlist . extend ( results ) <EOL> else : <EOL> errlist . append ( RegistryValidationError ( u'<STR_LIT>' '<STR_LIT>' ) ) <EOL> if errlist : <EOL> return errlist <EOL> def validate_bios_version ( self , tdict , errlist = None , selector = None , checkall = False , currdict = None , monolith = None ) : <EOL> """<STR_LIT>""" <EOL> if not errlist : <EOL> errlist = list ( ) <EOL> reg = self . get_registry_model_bios_version ( errlist = errlist , currdict = currdict , monolith = monolith ) <EOL> if reg and not checkall : <EOL> for item in reg . Attributes : <EOL> if not item [ "<STR_LIT:Name>" ] == selector : <EOL> continue <EOL> if item [ "<STR_LIT>" ] is True : <EOL> return '<STR_LIT>' <EOL> try : <EOL> if item [ "<STR_LIT>" ] is True : <EOL> return '<STR_LIT>' <EOL> except BaseException : <EOL> continue <EOL> else : <EOL> continue <EOL> results = reg . validate_att_val_bios ( tdict ) <EOL> errlist . extend ( results ) <EOL> elif checkall and selector is None : <EOL> results = reg . validate_att_val_bios ( tdict ) <EOL> errlist . extend ( results ) <EOL> else : <EOL> errlist . append ( RegistryValidationError ( u'<STR_LIT>' '<STR_LIT>' ) ) <EOL> if errlist : <EOL> return errlist <EOL> def validate_deprecated ( self , tdict , errlist = None ) : <EOL> """<STR_LIT>""" <EOL> if not errlist : <EOL> errlist = list ( ) <EOL> if not hasattr ( self , u'<STR_LIT>' ) : <EOL> errlist . append ( RegistryValidationError ( u'<STR_LIT>' '<STR_LIT>' ) ) <EOL> return errlist <EOL> currloc = None <EOL> defloc = None <EOL> langcode = '<STR_LIT>' <EOL> for loc in self . Location : <EOL> for loclang in loc . keys ( ) : <EOL> if loclang . lower ( ) == langcode . lower ( ) : <EOL> currloc = loc [ loclang ] <EOL> break <EOL> elif loclang . lower ( ) == u'<STR_LIT:default>' : <EOL> defloc = loc [ loclang ] <EOL> if not currloc : <EOL> currloc = defloc <EOL> if not currloc : <EOL> errlist . append ( RegistryValidationError ( u'<STR_LIT>' '<STR_LIT>' ) ) <EOL> return <EOL> location_file = self . _read_location_file ( currloc , errlist = errlist ) <EOL> if not location_file : <EOL> errlist . append ( RegistryValidationError ( u'<STR_LIT>' ) ) <EOL> else : <EOL> jsonreg = json . loads ( location_file ) <EOL> if u'<STR_LIT>' in jsonreg : <EOL> if u'<STR_LIT>' in jsonreg and jsonreg [ u'<STR_LIT>' ] == u'<STR_LIT>' : <EOL> reg = HpPropertiesRegistry . parse ( jsonreg [ u'<STR_LIT>' ] ) <EOL> results = reg . validate_attribute_values ( tdict ) <EOL> errlist . extend ( results ) <EOL> def get_registry_model ( self , currdict = None , monolith = None , errlist = None , skipcommit = False , searchtype = None , newarg = None , latestschema = None ) : <EOL> """<STR_LIT>""" <EOL> if not errlist : <EOL> errlist = list ( ) <EOL> if not hasattr ( self , u'<STR_LIT>' ) : <EOL> errlist . append ( RegistryValidationError ( <EOL> u'<STR_LIT>' ) ) <EOL> return None <EOL> currloc = None <EOL> defloc = "<STR_LIT>" <EOL> langcode = list ( locale . getdefaultlocale ( ) ) <EOL> if not langcode [ <NUM_LIT:0> ] : <EOL> langcode [ <NUM_LIT:0> ] = "<STR_LIT>" <EOL> for loc in self . Location : <EOL> locationlanguage = loc [ "<STR_LIT>" ] . lower ( ) <EOL> locationlanguage = locationlanguage . replace ( "<STR_LIT:->" , "<STR_LIT:_>" ) <EOL> if locationlanguage in langcode [ <NUM_LIT:0> ] . lower ( ) : <EOL> currloc = loc <EOL> break <EOL> if not currloc : <EOL> currloc = defloc <EOL> if not currloc : <EOL> errlist . append ( RegistryValidationError ( u'<STR_LIT>' '<STR_LIT:location>' ) ) <EOL> return None <EOL> if not searchtype : <EOL> searchtype = "<STR_LIT>" <EOL> location_file = None <EOL> if currdict and monolith : <EOL> for itemtype in monolith . types : <EOL> if itemtype . lower ( ) . startswith ( searchtype . lower ( ) ) and u'<STR_LIT>' in monolith . types [ itemtype ] : <EOL> for instance in monolith . types [ itemtype ] [ u'<STR_LIT>' ] : <EOL> try : <EOL> if monolith . is_redfish : <EOL> currtype = currdict [ instance . _typestring ] . split ( '<STR_LIT:#>' ) [ - <NUM_LIT:1> ] <EOL> currtype = currtype . split ( '<STR_LIT:.>' ) [ <NUM_LIT:0> ] + '<STR_LIT:.>' <EOL> else : <EOL> currtype = currdict [ instance . _typestring ] <EOL> if latestschema : <EOL> currtype = currdict [ instance . _typestring ] . split ( '<STR_LIT:.>' ) [ : <NUM_LIT:1> ] <EOL> insttype = instance . resp . dict [ "<STR_LIT:title>" ] . split ( '<STR_LIT:.>' ) [ : <NUM_LIT:1> ] <EOL> if currtype == insttype or currtype == instance . resp . dict [ "<STR_LIT>" ] . split ( '<STR_LIT:.>' ) [ : <NUM_LIT:1> ] : <EOL> location_file = instance . resp . dict <EOL> break <EOL> elif searchtype == "<STR_LIT>" and instance . resp . dict [ "<STR_LIT:title>" ] . startswith ( currtype ) or "<STR_LIT>" in instance . resp . dict . keys ( ) and currdict [ instance . _typestring ] == instance . resp . dict [ "<STR_LIT>" ] : <EOL> location_file = instance . resp . dict <EOL> break <EOL> elif searchtype != "<STR_LIT>" and currdict [ instance . _typestring ] in instance . resp . dict [ "<STR_LIT>" ] : <EOL> location_file = instance . resp . dict <EOL> break <EOL> except BaseException : <EOL> pass <EOL> else : <EOL> pass <EOL> if location_file : <EOL> break <EOL> else : <EOL> location_file = self . _read_location_file ( currloc , errlist = errlist ) <EOL> if not location_file : <EOL> errlist . append ( RegistryValidationError ( u'<STR_LIT>' ) ) <EOL> else : <EOL> if currdict and monolith : <EOL> jsonreg = json . loads ( json . dumps ( location_file , indent = <NUM_LIT:2> , cls = JSONEncoder ) ) <EOL> else : <EOL> jsonreg = json . loads ( location_file ) <EOL> if skipcommit : <EOL> return jsonreg [ "<STR_LIT>" ] <EOL> if u'<STR_LIT>' in jsonreg : <EOL> regitem = jsonreg [ u'<STR_LIT>' ] <EOL> reg = HpPropertiesRegistry . parse ( regitem ) <EOL> if newarg : <EOL> regcopy = reg <EOL> for arg in newarg [ : - <NUM_LIT:1> ] : <EOL> try : <EOL> if '<STR_LIT>' in regcopy [ arg ] . iterkeys ( ) and ( '<STR_LIT>' in regcopy [ arg ] . iterkeys ( ) ) : <EOL> regcopy [ arg ] [ '<STR_LIT>' ] . update ( regcopy [ arg ] [ '<STR_LIT>' ] ) <EOL> regcopy = regcopy [ arg ] [ "<STR_LIT>" ] <EOL> for pattern in regcopy . iterkeys ( ) : <EOL> test = re . compile ( pattern ) <EOL> nextarg = newarg [ newarg . index ( arg ) + <NUM_LIT:1> ] <EOL> match = test . match ( nextarg ) <EOL> if match : <EOL> regcopy [ nextarg ] = regcopy . pop ( pattern ) <EOL> break <EOL> elif '<STR_LIT>' in regcopy [ arg ] : <EOL> oneof = regcopy [ arg ] [ '<STR_LIT>' ] <EOL> for item in oneof : <EOL> regcopy = item [ '<STR_LIT>' ] <EOL> if not arg == newarg [ - <NUM_LIT:1> ] : <EOL> try : <EOL> nextitem = newarg [ newarg . index ( arg ) + <NUM_LIT:1> ] <EOL> regcopy [ nextitem ] <EOL> break <EOL> except Exception : <EOL> continue <EOL> else : <EOL> regcopy = regcopy [ arg ] [ "<STR_LIT>" ] <EOL> except Exception : <EOL> try : <EOL> regcopy = regcopy [ arg ] [ '<STR_LIT>' ] <EOL> for pattern in regcopy . iterkeys ( ) : <EOL> test = re . compile ( pattern ) <EOL> nextarg = newarg [ newarg . index ( arg ) + <NUM_LIT:1> ] <EOL> match = test . match ( nextarg ) <EOL> if match : <EOL> patterninfo = regcopy . pop ( pattern ) <EOL> regcopy [ nextarg ] = patterninfo <EOL> except BaseException : <EOL> return None <EOL> reg = regcopy <EOL> return reg <EOL> return None <EOL> def get_registry_model_bios_version ( self , currdict = None , monolith = None , errlist = None ) : <EOL> """<STR_LIT>""" <EOL> """<STR_LIT>""" <EOL> if not errlist : <EOL> errlist = list ( ) <EOL> if not hasattr ( self , u'<STR_LIT>' ) : <EOL> errlist . append ( RegistryValidationError ( <EOL> u'<STR_LIT>' ) ) <EOL> return None <EOL> currloc = None <EOL> defloc = "<STR_LIT>" <EOL> langcode = list ( locale . getdefaultlocale ( ) ) <EOL> if not langcode [ <NUM_LIT:0> ] : <EOL> langcode [ <NUM_LIT:0> ] = "<STR_LIT>" <EOL> for loc in self . Location : <EOL> locationlanguage = loc [ "<STR_LIT>" ] . lower ( ) <EOL> locationlanguage = locationlanguage . replace ( "<STR_LIT:->" , "<STR_LIT:_>" ) <EOL> if locationlanguage in langcode [ <NUM_LIT:0> ] . lower ( ) : <EOL> currloc = loc <EOL> break <EOL> if not currloc : <EOL> currloc = defloc <EOL> if not currloc : <EOL> errlist . append ( RegistryValidationError ( <EOL> u'<STR_LIT>' ) ) <EOL> return None <EOL> location_file = None <EOL> if currdict and monolith : <EOL> for itemtype in monolith . types : <EOL> if "<STR_LIT>" in itemtype and u'<STR_LIT>' in monolith . types [ itemtype ] : <EOL> for instance in monolith . types [ itemtype ] [ u'<STR_LIT>' ] : <EOL> location_file = instance . resp . dict <EOL> break <EOL> if location_file : <EOL> break <EOL> else : <EOL> location_file = self . _read_location_file ( currloc , errlist = errlist ) <EOL> if not location_file : <EOL> errlist . append ( RegistryValidationError ( u'<STR_LIT>' ) ) <EOL> else : <EOL> if currdict and monolith : <EOL> jsonreg = json . loads ( json . dumps ( location_file , indent = <NUM_LIT:2> , cls = JSONEncoder ) ) <EOL> else : <EOL> jsonreg = json . loads ( location_file ) <EOL> if u'<STR_LIT>' in jsonreg : <EOL> regitem = jsonreg [ u'<STR_LIT>' ] <EOL> reg = HpPropertiesRegistry . parse ( regitem ) <EOL> return reg <EOL> return None <EOL> class RepoSchemaEntry ( RepoBaseEntry ) : <EOL> """<STR_LIT>""" <EOL> def __init__ ( self , item ) : <EOL> super ( RepoSchemaEntry , self ) . __init__ ( item ) <EOL> self . _root = None <EOL> def set_root ( self , newroot ) : <EOL> """<STR_LIT>""" <EOL> self . _root = newroot <EOL> def _read_location_file ( self , currloc , errlist ) : <EOL> """<STR_LIT>""" <EOL> if u'<STR_LIT>' in currloc and u'<STR_LIT>' in currloc : <EOL> fqpath = os . path . join ( self . _root , currloc . ArchiveUri . xref . lstrip ( os . path . sep ) ) <EOL> if not os . path . isfile ( fqpath ) : <EOL> errlist . append ( SchemaValidationError ( u"<STR_LIT>" "<STR_LIT>" % fqpath ) ) <EOL> else : <EOL> archive_file = currloc . ArchiveFile <EOL> archive_fh = None <EOL> result = None <EOL> if fqpath . endswith ( '<STR_LIT>' ) : <EOL> archive_fh = zipfile . ZipFile ( fqpath ) <EOL> infolist = archive_fh . infolist ( ) <EOL> for i in infolist : <EOL> if i . filename . lower ( ) == archive_file . lower ( ) : <EOL> jsonsch_fh = archive_fh . open ( i ) <EOL> result = jsonsch_fh . read ( ) <EOL> jsonsch_fh . close ( ) <EOL> archive_fh . close ( ) <EOL> return result <EOL> def validate ( self , tdict , errlist = None ) : <EOL> """<STR_LIT>""" <EOL> if not errlist : <EOL> errlist = list ( ) <EOL> result = list ( ) <EOL> if not hasattr ( self , u'<STR_LIT>' ) : <EOL> result . append ( SchemaValidationError ( u'<STR_LIT>' '<STR_LIT>' ) ) <EOL> return result <EOL> currloc = None <EOL> defloc = None <EOL> langcode = '<STR_LIT>' <EOL> for loc in self . Location : <EOL> for loclang in loc . keys ( ) : <EOL> if loclang . lower ( ) == langcode . lower ( ) : <EOL> currloc = loc [ loclang ] <EOL> break <EOL> elif loclang . lower ( ) == u'<STR_LIT:default>' : <EOL> defloc = loc [ loclang ] <EOL> if not currloc : <EOL> currloc = defloc <EOL> if not currloc : <EOL> result . append ( SchemaValidationError ( <EOL> u'<STR_LIT>' ) ) <EOL> return <EOL> location_file = self . _read_location_file ( currloc , errlist = result ) <EOL> if not location_file : <EOL> result . append ( SchemaValidationError ( u'<STR_LIT>' ) ) <EOL> else : <EOL> jsonsch = json . loads ( location_file ) <EOL> validictory . validate ( tdict , jsonsch ) <EOL> class HpPropertiesRegistry ( RisObject ) : <EOL> """<STR_LIT>""" <EOL> def __init__ ( self , d ) : <EOL> super ( HpPropertiesRegistry , self ) . __init__ ( d ) <EOL> def validate_attribute_values ( self , tdict ) : <EOL> """<STR_LIT>""" <EOL> result = list ( ) <EOL> for tkey in tdict : <EOL> try : <EOL> if self [ tkey ] and hasattr ( self [ tkey ] , "<STR_LIT:type>" ) : <EOL> temp = self . validate_attribute ( self [ tkey ] , tdict [ tkey ] , tkey ) <EOL> for err in temp : <EOL> if isinstance ( err , RegistryValidationError ) : <EOL> if err . reg : <EOL> err . sel = tkey <EOL> result . extend ( temp ) <EOL> except Exception : <EOL> pass <EOL> return result <EOL> def validate_att_val_bios ( self , tdict ) : <EOL> """<STR_LIT>""" <EOL> result = list ( ) <EOL> for tkey in tdict : <EOL> for item in self . Attributes : <EOL> try : <EOL> if item [ "<STR_LIT:Name>" ] == tkey and hasattr ( item , "<STR_LIT>" ) : <EOL> temp = self . validate_attribute ( item , tdict [ tkey ] , tkey ) <EOL> for err in temp : <EOL> if isinstance ( err , RegistryValidationError ) : <EOL> if err . reg : <EOL> err . sel = tkey <EOL> result . extend ( temp ) <EOL> break <EOL> except Exception : <EOL> pass <EOL> return result <EOL> def get_validator ( self , attrname , newargs = None , oneof = None ) : <EOL> """<STR_LIT>""" <EOL> if oneof : <EOL> self = oneof <EOL> if newargs : <EOL> for arg in newargs : <EOL> try : <EOL> self = self [ '<STR_LIT>' ] <EOL> except Exception : <EOL> pass <EOL> if not hasattr ( self , arg ) : <EOL> return None <EOL> elif not arg == newargs [ - <NUM_LIT:1> ] : <EOL> self = self [ arg ] <EOL> if not hasattr ( self , attrname ) : <EOL> return None <EOL> validator = None <EOL> if EnumValidator . is_type ( self [ attrname ] ) : <EOL> validator = EnumValidator . parse ( self [ attrname ] ) <EOL> elif StringValidator . is_type ( self [ attrname ] ) : <EOL> validator = StringValidator . parse ( self [ attrname ] ) <EOL> elif ObjectValidator . is_type ( self [ attrname ] ) : <EOL> validator = ObjectValidator . parse ( self [ attrname ] ) <EOL> elif IntegerValidator . is_type ( self [ attrname ] ) : <EOL> validator = IntegerValidator . parse ( self [ attrname ] ) <EOL> elif BoolValidator . is_type ( self [ attrname ] ) : <EOL> validator = BoolValidator . parse ( self [ attrname ] ) <EOL> elif PasswordValidator . is_type ( self [ attrname ] ) : <EOL> validator = PasswordValidator . parse ( self [ attrname ] ) <EOL> elif u'<STR_LIT>' in self [ attrname ] . keys ( ) : <EOL> for item in self [ attrname ] [ '<STR_LIT>' ] : <EOL> validator = self . get_validator ( attrname , newargs , HpPropertiesRegistry ( { attrname : item } ) ) <EOL> if validator : <EOL> break <EOL> return validator <EOL> def get_validator_bios ( self , attrname ) : <EOL> """<STR_LIT>""" <EOL> for item in self . Attributes : <EOL> if item [ "<STR_LIT:Name>" ] == attrname : <EOL> validator = None <EOL> if EnumValidator . is_type ( item ) : <EOL> validator = EnumValidator . parse ( item ) <EOL> elif StringValidator . is_type ( item ) : <EOL> validator = StringValidator . parse ( item ) <EOL> elif IntegerValidator . is_type ( item ) : <EOL> validator = IntegerValidator . parse ( item ) <EOL> elif BoolValidator . is_type ( item ) : <EOL> validator = BoolValidator . parse ( item ) <EOL> elif ObjectValidator . is_type ( item ) : <EOL> validator = ObjectValidator . parse ( item ) <EOL> elif PasswordValidator . is_type ( item ) : <EOL> validator = PasswordValidator . parse ( item ) <EOL> return validator <EOL> return None <EOL> def validate_attribute ( self , attrentry , attrval , name ) : <EOL> """<STR_LIT>""" <EOL> result = list ( ) <EOL> validator = None <EOL> if EnumValidator . is_type ( attrentry ) : <EOL> validator = EnumValidator . parse ( attrentry ) <EOL> elif StringValidator . is_type ( attrentry ) : <EOL> validator = StringValidator . parse ( attrentry ) <EOL> elif IntegerValidator . is_type ( attrentry ) : <EOL> validator = IntegerValidator . parse ( attrentry ) <EOL> elif BoolValidator . is_type ( attrentry ) : <EOL> validator = BoolValidator . parse ( attrentry ) <EOL> elif ObjectValidator . is_type ( attrentry ) : <EOL> validator = ObjectValidator . parse ( attrentry ) <EOL> elif PasswordValidator . is_type ( attrentry ) : <EOL> validator = PasswordValidator . parse ( attrentry ) <EOL> else : <EOL> raise UnknownValidatorError ( attrentry ) <EOL> if validator : <EOL> result . extend ( validator . validate ( attrval , name ) ) <EOL> return result <EOL> class BaseValidator ( RisObject ) : <EOL> """<STR_LIT>""" <EOL> def __init__ ( self , d ) : <EOL> super ( BaseValidator , self ) . __init__ ( d ) <EOL> def validate ( self ) : <EOL> """<STR_LIT>""" <EOL> raise RuntimeError ( u'<STR_LIT>' '<STR_LIT:class>' ) <EOL> class EnumValidator ( BaseValidator ) : <EOL> """<STR_LIT>""" <EOL> def __init__ ( self , d ) : <EOL> super ( EnumValidator , self ) . __init__ ( d ) <EOL> @ staticmethod <EOL> def is_type ( attrentry ) : <EOL> """<STR_LIT>""" <EOL> if u'<STR_LIT:type>' in attrentry : <EOL> if isinstance ( attrentry [ u'<STR_LIT:type>' ] , list ) : <EOL> for item in attrentry [ u'<STR_LIT:type>' ] : <EOL> if item . lower ( ) == u'<STR_LIT>' : <EOL> return True <EOL> elif u'<STR_LIT>' in attrentry and item . lower ( ) == u'<STR_LIT:string>' : <EOL> return True <EOL> elif u'<STR_LIT>' in attrentry and attrentry [ u'<STR_LIT:type>' ] == "<STR_LIT>" : <EOL> for key , value in attrentry [ u'<STR_LIT>' ] . iteritems ( ) : <EOL> if key . lower ( ) == "<STR_LIT:type>" and value . lower ( ) == u'<STR_LIT:string>' : <EOL> return True <EOL> else : <EOL> if attrentry [ u'<STR_LIT:type>' ] . lower ( ) == u'<STR_LIT>' : <EOL> return True <EOL> elif u'<STR_LIT>' in attrentry and attrentry [ u'<STR_LIT:type>' ] . lower ( ) == u'<STR_LIT:string>' : <EOL> return True <EOL> elif u'<STR_LIT>' in attrentry : <EOL> if attrentry [ u'<STR_LIT>' ] . lower ( ) == u'<STR_LIT>' : <EOL> return True <EOL> return False <EOL> def validate ( self , newval , name ) : <EOL> """<STR_LIT>""" <EOL> result = list ( ) <EOL> try : <EOL> for possibleval in self . enum : <EOL> if possibleval . lower ( ) == newval . lower ( ) : <EOL> return result <EOL> except Exception : <EOL> for possibleval in self . Value : <EOL> if possibleval . ValueName . lower ( ) == str ( newval ) . lower ( ) : <EOL> return result <EOL> result . append ( RegistryValidationError ( u"<STR_LIT>" <EOL> "<STR_LIT>" % ( newval , name ) , <EOL> regentry = self ) ) <EOL> return result <EOL> def print_help ( self , name , out = sys . stdout ) : <EOL> """<STR_LIT>""" <EOL> wrapper = textwrap . TextWrapper ( ) <EOL> wrapper . initial_indent = '<STR_LIT:U+0020>' * <NUM_LIT:4> <EOL> wrapper . subsequent_indent = '<STR_LIT:U+0020>' * <NUM_LIT:4> <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT:%s>' % name ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT:description>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT:type>' in self and isinstance ( self [ u'<STR_LIT:type>' ] , list ) : <EOL> out . write ( u'<STR_LIT>' ) <EOL> for item in self [ u'<STR_LIT:type>' ] : <EOL> out . write ( '<STR_LIT>' % wrapper . fill ( '<STR_LIT:%s>' % item ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> elif u'<STR_LIT:type>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> elif u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> elif u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> out . write ( u'<STR_LIT>' ) <EOL> try : <EOL> for possibleval in self . enum : <EOL> out . write ( '<STR_LIT>' % possibleval ) <EOL> except Exception : <EOL> for possibleval in self . Value : <EOL> out . write ( '<STR_LIT>' % possibleval ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> class BoolValidator ( BaseValidator ) : <EOL> """<STR_LIT>""" <EOL> def __init__ ( self , d ) : <EOL> super ( BoolValidator , self ) . __init__ ( d ) <EOL> @ staticmethod <EOL> def is_type ( attrentry ) : <EOL> """<STR_LIT>""" <EOL> if u'<STR_LIT:type>' in attrentry : <EOL> if isinstance ( attrentry [ u'<STR_LIT:type>' ] , list ) : <EOL> for item in attrentry [ u'<STR_LIT:type>' ] : <EOL> if item . lower ( ) == u'<STR_LIT>' : <EOL> return True <EOL> elif attrentry [ u'<STR_LIT:type>' ] == "<STR_LIT>" : <EOL> for key , value in attrentry [ u'<STR_LIT>' ] . iteritems ( ) : <EOL> if key . lower ( ) == "<STR_LIT:type>" and value . lower ( ) == u'<STR_LIT>' : <EOL> return True <EOL> else : <EOL> if attrentry [ u'<STR_LIT:type>' ] . lower ( ) == u'<STR_LIT>' : <EOL> return True <EOL> elif u'<STR_LIT>' in attrentry : <EOL> if attrentry [ u'<STR_LIT>' ] . lower ( ) == u'<STR_LIT>' : <EOL> return True <EOL> return False <EOL> def validate ( self , newval , name ) : <EOL> """<STR_LIT>""" <EOL> result = list ( ) <EOL> if newval is False or newval is True : <EOL> return result <EOL> result . append ( <EOL> RegistryValidationError ( <EOL> u"<STR_LIT>" % ( newval , name ) , <EOL> regentry = self <EOL> ) <EOL> ) <EOL> return result <EOL> def print_help ( self , name , out = sys . stdout ) : <EOL> """<STR_LIT>""" <EOL> wrapper = textwrap . TextWrapper ( ) <EOL> wrapper . initial_indent = '<STR_LIT:U+0020>' * <NUM_LIT:4> <EOL> wrapper . subsequent_indent = '<STR_LIT:U+0020>' * <NUM_LIT:4> <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT:%s>' % name ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT:description>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT:type>' in self and isinstance ( self [ u'<STR_LIT:type>' ] , list ) : <EOL> out . write ( u'<STR_LIT>' ) <EOL> for item in self [ u'<STR_LIT:type>' ] : <EOL> out . write ( '<STR_LIT>' % wrapper . fill ( '<STR_LIT:%s>' % item ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> elif u'<STR_LIT:type>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> elif u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> elif u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> class StringValidator ( BaseValidator ) : <EOL> """<STR_LIT>""" <EOL> def __init__ ( self , d ) : <EOL> super ( StringValidator , self ) . __init__ ( d ) <EOL> @ staticmethod <EOL> def is_type ( attrentry ) : <EOL> """<STR_LIT>""" <EOL> if u'<STR_LIT:type>' in attrentry : <EOL> if isinstance ( attrentry [ u'<STR_LIT:type>' ] , list ) : <EOL> for item in attrentry [ u'<STR_LIT:type>' ] : <EOL> if item . lower ( ) == u'<STR_LIT:string>' : <EOL> return True <EOL> elif attrentry [ u'<STR_LIT:type>' ] == "<STR_LIT>" : <EOL> for key , value in attrentry [ u'<STR_LIT>' ] . iteritems ( ) : <EOL> if key . lower ( ) == "<STR_LIT:type>" and u'<STR_LIT:string>' in value : <EOL> return True <EOL> else : <EOL> if attrentry [ u'<STR_LIT:type>' ] . lower ( ) == u'<STR_LIT:string>' : <EOL> return True <EOL> elif u'<STR_LIT>' in attrentry : <EOL> if attrentry [ u'<STR_LIT>' ] . lower ( ) == u'<STR_LIT:string>' : <EOL> return True <EOL> return False <EOL> def validate ( self , newval , name ) : <EOL> """<STR_LIT>""" <EOL> result = list ( ) <EOL> if u'<STR_LIT>' in self : <EOL> if len ( newval ) < int ( self [ u'<STR_LIT>' ] ) : <EOL> result . append ( RegistryValidationError ( <EOL> u"<STR_LIT>" % <EOL> ( self . Name , int ( self [ u'<STR_LIT>' ] ) ) , regentry = self ) ) <EOL> if u'<STR_LIT>' in self : <EOL> if len ( newval ) > int ( self [ u'<STR_LIT>' ] ) : <EOL> result . append ( RegistryValidationError ( <EOL> u"<STR_LIT>" % <EOL> ( self . Name , int ( self [ u'<STR_LIT>' ] ) ) , regentry = self ) ) <EOL> if u'<STR_LIT>' in self : <EOL> if self [ u'<STR_LIT>' ] : <EOL> pat = re . compile ( self [ u'<STR_LIT>' ] ) <EOL> if newval and not pat . match ( newval ) : <EOL> result . append ( RegistryValidationError ( <EOL> u"<STR_LIT>" <EOL> "<STR_LIT>" % ( self ) , regentry = self ) ) <EOL> return result <EOL> def print_help ( self , name , out = sys . stdout ) : <EOL> """<STR_LIT>""" <EOL> wrapper = textwrap . TextWrapper ( ) <EOL> wrapper . initial_indent = '<STR_LIT:U+0020>' * <NUM_LIT:4> <EOL> wrapper . subsequent_indent = '<STR_LIT:U+0020>' * <NUM_LIT:4> <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT:%s>' % name ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT:description>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT:type>' in self and isinstance ( self [ u'<STR_LIT:type>' ] , list ) : <EOL> out . write ( u'<STR_LIT>' ) <EOL> for item in self [ u'<STR_LIT:type>' ] : <EOL> out . write ( '<STR_LIT>' % wrapper . fill ( '<STR_LIT:%s>' % item ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> elif u'<STR_LIT:type>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> elif u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> elif u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> class IntegerValidator ( BaseValidator ) : <EOL> """<STR_LIT>""" <EOL> def __init__ ( self , d ) : <EOL> super ( IntegerValidator , self ) . __init__ ( d ) <EOL> @ staticmethod <EOL> def is_type ( attrentry ) : <EOL> """<STR_LIT>""" <EOL> if u'<STR_LIT:type>' in attrentry : <EOL> if isinstance ( attrentry [ u'<STR_LIT:type>' ] , list ) : <EOL> for item in attrentry [ u'<STR_LIT:type>' ] : <EOL> if item . lower ( ) == u'<STR_LIT>' or item . lower ( ) == u'<STR_LIT>' : <EOL> return True <EOL> elif attrentry [ u'<STR_LIT:type>' ] == "<STR_LIT>" : <EOL> for key , value in attrentry [ u'<STR_LIT>' ] . iteritems ( ) : <EOL> if key . lower ( ) == "<STR_LIT:type>" : <EOL> if value . lower ( ) == u'<STR_LIT>' or value . lower ( ) == u'<STR_LIT>' : <EOL> return True <EOL> else : <EOL> if attrentry [ u'<STR_LIT:type>' ] . lower ( ) == u'<STR_LIT>' or attrentry [ u'<STR_LIT:type>' ] . lower ( ) . lower ( ) == u'<STR_LIT>' : <EOL> return True <EOL> elif u'<STR_LIT>' in attrentry : <EOL> if attrentry [ u'<STR_LIT>' ] . lower ( ) == u'<STR_LIT>' : <EOL> return True <EOL> return False <EOL> def validate ( self , newval , name ) : <EOL> """<STR_LIT>""" <EOL> result = list ( ) <EOL> intval = int ( newval ) <EOL> pat = re . compile ( r'<STR_LIT>' ) <EOL> if newval and not pat . match ( intval ) : <EOL> result . append ( <EOL> RegistryValidationError ( <EOL> u"<STR_LIT>" % ( self ) , <EOL> regentry = self <EOL> ) <EOL> ) <EOL> return result <EOL> if u'<STR_LIT>' in self : <EOL> if intval < int ( self [ u'<STR_LIT>' ] ) : <EOL> result . append ( RegistryValidationError ( u"<STR_LIT>" "<STR_LIT>" % ( self . Name , int ( self [ u'<STR_LIT>' ] ) ) , regentry = self ) ) <EOL> if u'<STR_LIT>' in self : <EOL> if intval > int ( self [ u'<STR_LIT>' ] ) : <EOL> result . append ( RegistryValidationError ( u"<STR_LIT>" "<STR_LIT>" % ( self . Name , int ( self [ u'<STR_LIT>' ] ) ) , regentry = self ) ) <EOL> return result <EOL> def print_help ( self , name , out = sys . stdout ) : <EOL> """<STR_LIT>""" <EOL> wrapper = textwrap . TextWrapper ( ) <EOL> wrapper . initial_indent = '<STR_LIT:U+0020>' * <NUM_LIT:4> <EOL> wrapper . subsequent_indent = '<STR_LIT:U+0020>' * <NUM_LIT:4> <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT:%s>' % name ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT:description>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT:type>' in self and isinstance ( self [ u'<STR_LIT:type>' ] , list ) : <EOL> out . write ( u'<STR_LIT>' ) <EOL> for item in self [ u'<STR_LIT:type>' ] : <EOL> out . write ( '<STR_LIT>' % wrapper . fill ( '<STR_LIT:%s>' % item ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> elif u'<STR_LIT:type>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> elif u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> elif u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> class ObjectValidator ( BaseValidator ) : <EOL> """<STR_LIT>""" <EOL> def __init__ ( self , d ) : <EOL> super ( ObjectValidator , self ) . __init__ ( d ) <EOL> @ staticmethod <EOL> def is_type ( attrentry ) : <EOL> """<STR_LIT>""" <EOL> if u'<STR_LIT:type>' in attrentry : <EOL> if isinstance ( attrentry [ u'<STR_LIT:type>' ] , list ) : <EOL> for item in attrentry [ u'<STR_LIT:type>' ] : <EOL> if item . lower ( ) == u'<STR_LIT:object>' : <EOL> return True <EOL> elif attrentry [ u'<STR_LIT:type>' ] == "<STR_LIT>" : <EOL> for key , value in attrentry [ u'<STR_LIT>' ] . iteritems ( ) : <EOL> if key . lower ( ) == "<STR_LIT:type>" and value . lower ( ) == u'<STR_LIT:object>' : <EOL> return True <EOL> elif key . lower ( ) == "<STR_LIT>" : <EOL> try : <EOL> if value [ <NUM_LIT:0> ] [ u'<STR_LIT:type>' ] == u'<STR_LIT:object>' : <EOL> return True <EOL> except Exception : <EOL> continue <EOL> else : <EOL> if attrentry [ u'<STR_LIT:type>' ] . lower ( ) == u'<STR_LIT:object>' : <EOL> return True <EOL> elif u'<STR_LIT>' in attrentry : <EOL> if attrentry [ u'<STR_LIT>' ] . lower ( ) == u'<STR_LIT:object>' : <EOL> return True <EOL> return False <EOL> def validate ( self , newval , name ) : <EOL> """<STR_LIT>""" <EOL> result = list ( ) <EOL> return result <EOL> def print_help ( self , name , out = sys . stdout ) : <EOL> """<STR_LIT>""" <EOL> wrapper = textwrap . TextWrapper ( ) <EOL> wrapper . initial_indent = '<STR_LIT:U+0020>' * <NUM_LIT:4> <EOL> wrapper . subsequent_indent = '<STR_LIT:U+0020>' * <NUM_LIT:4> <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT:%s>' % name ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT:description>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT:type>' in self and isinstance ( self [ u'<STR_LIT:type>' ] , list ) : <EOL> out . write ( u'<STR_LIT>' ) <EOL> for item in self [ u'<STR_LIT:type>' ] : <EOL> out . write ( '<STR_LIT>' % wrapper . fill ( '<STR_LIT:%s>' % item ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> elif u'<STR_LIT:type>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> elif u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> elif u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> class PasswordValidator ( BaseValidator ) : <EOL> """<STR_LIT>""" <EOL> def __init__ ( self , d ) : <EOL> super ( PasswordValidator , self ) . __init__ ( d ) <EOL> @ staticmethod <EOL> def is_type ( attrentry ) : <EOL> """<STR_LIT>""" <EOL> if u'<STR_LIT:type>' in attrentry : <EOL> if isinstance ( attrentry [ u'<STR_LIT:type>' ] , list ) : <EOL> for item in attrentry [ u'<STR_LIT:type>' ] : <EOL> if item . lower ( ) == u'<STR_LIT:password>' : <EOL> return True <EOL> elif attrentry [ u'<STR_LIT:type>' ] == "<STR_LIT>" : <EOL> for key , value in attrentry [ u'<STR_LIT>' ] . iteritems ( ) : <EOL> if key . lower ( ) == "<STR_LIT:type>" and value . lower ( ) == u'<STR_LIT:password>' : <EOL> return True <EOL> else : <EOL> if attrentry [ u'<STR_LIT:type>' ] . lower ( ) == u'<STR_LIT:password>' : <EOL> return True <EOL> elif u'<STR_LIT>' in attrentry : <EOL> if attrentry [ u'<STR_LIT>' ] . lower ( ) == u'<STR_LIT:password>' : <EOL> return True <EOL> return False <EOL> def validate ( self , newval , name ) : <EOL> """<STR_LIT>""" <EOL> result = list ( ) <EOL> if newval is None : <EOL> return result <EOL> if u'<STR_LIT>' in self : <EOL> if len ( newval ) < int ( self [ u'<STR_LIT>' ] ) : <EOL> result . append ( RegistryValidationError ( u"<STR_LIT>" "<STR_LIT>" % ( self . Name , int ( self [ u'<STR_LIT>' ] ) ) , regentry = self ) ) <EOL> if u'<STR_LIT>' in self : <EOL> if len ( newval ) > int ( self [ u'<STR_LIT>' ] ) : <EOL> result . append ( RegistryValidationError ( u"<STR_LIT>" "<STR_LIT>" % ( self . Name , int ( self [ u'<STR_LIT>' ] ) ) , regentry = self ) ) <EOL> if u'<STR_LIT>' in self : <EOL> if self [ u'<STR_LIT>' ] : <EOL> pat = re . compile ( self [ u'<STR_LIT>' ] ) <EOL> if newval and not pat . match ( newval ) : <EOL> result . append ( RegistryValidationError ( u"<STR_LIT>" "<STR_LIT>" "<STR_LIT>" % ( self ) , regentry = self ) ) <EOL> return result <EOL> def print_help ( self , name , out = sys . stdout ) : <EOL> """<STR_LIT>""" <EOL> wrapper = textwrap . TextWrapper ( ) <EOL> wrapper . initial_indent = '<STR_LIT:U+0020>' * <NUM_LIT:4> <EOL> wrapper . subsequent_indent = '<STR_LIT:U+0020>' * <NUM_LIT:4> <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT:%s>' % name ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT:description>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT:type>' in self and isinstance ( self [ u'<STR_LIT:type>' ] , list ) : <EOL> out . write ( u'<STR_LIT>' ) <EOL> for item in self [ u'<STR_LIT:type>' ] : <EOL> out . write ( '<STR_LIT>' % wrapper . fill ( '<STR_LIT:%s>' % item ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> elif u'<STR_LIT:type>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> elif u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> elif u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) </s>
<s> from . constants import MILLI_MICROS , SECOND_MICROS , MINUTE_MICROS <EOL> import calendar <EOL> from datetime import datetime <EOL> from dateutil import parser <EOL> from dateutil . tz import tzlocal <EOL> from . error import TimeConstructionError <EOL> from . sanedelta import SaneDelta <EOL> import pytz <EOL> MICROS_TRANSLATIONS = ( <EOL> ( ( '<STR_LIT:m>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , MINUTE_MICROS ) , <EOL> ( ( '<STR_LIT:s>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , SECOND_MICROS ) , <EOL> ( ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , MILLI_MICROS ) , <EOL> ( ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , <NUM_LIT:1> ) ) <EOL> MICROS_TRANSLATION_HASH = dict ( ( alt , v ) for k , v in MICROS_TRANSLATIONS for alt in k ) <EOL> class SaneTime ( object ) : <EOL> """<STR_LIT>""" <EOL> """<STR_LIT>""" <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> """<STR_LIT>""" <EOL> super ( time , self ) . __init__ ( ) <EOL> uss = set ( ) <EOL> tzs = set ( ) <EOL> naive_dt = None <EOL> avoid_localize = False <EOL> for k , v in kwargs . iteritems ( ) : <EOL> if k in ( '<STR_LIT>' , '<STR_LIT>' ) : <EOL> tzs . add ( SaneTime . to_timezone ( v ) ) <EOL> elif k in MICROS_TRANSLATION_HASH : <EOL> uss . add ( MICROS_TRANSLATION_HASH [ k ] * v ) <EOL> else : <EOL> raise TimeConstructionError ( "<STR_LIT>" % ( k , v ) ) <EOL> args = list ( args ) <EOL> if len ( args ) > <NUM_LIT:2> and len ( args ) <= <NUM_LIT:8> : <EOL> args = [ datetime ( * args ) ] <EOL> if len ( args ) == <NUM_LIT:2> : <EOL> tzs . add ( SaneTime . to_timezone ( args . pop ( ) ) ) <EOL> if len ( args ) == <NUM_LIT:1> : <EOL> arg = args . pop ( ) <EOL> if hasattr ( arg , '<STR_LIT>' ) : <EOL> uss . add ( int ( arg ) ) <EOL> if hasattr ( arg , '<STR_LIT>' ) : tzs . add ( arg . tz ) <EOL> elif isinstance ( arg , basestring ) : <EOL> parts = arg . strip ( ) . split ( '<STR_LIT:U+0020>' ) <EOL> if len ( parts ) > <NUM_LIT:1> and parts [ - <NUM_LIT:1> ] . startswith ( '<STR_LIT:+>' ) : <EOL> try : <EOL> tzs . add ( SaneTime . to_timezone ( parts [ - <NUM_LIT:1> ] [ <NUM_LIT:1> : ] ) ) <EOL> arg = '<STR_LIT:U+0020>' . join ( parts [ : - <NUM_LIT:1> ] ) <EOL> except : pass <EOL> utc = arg . endswith ( '<STR_LIT>' ) or arg . endswith ( '<STR_LIT>' ) <EOL> arg = parser . parse ( arg ) <EOL> if arg . tzinfo : <EOL> if utc : <EOL> tzs . add ( pytz . utc ) <EOL> arg = arg . replace ( tzinfo = None ) <EOL> elif isinstance ( arg . tzinfo , tzlocal ) : <EOL> arg = arg . replace ( tzinfo = None ) <EOL> else : <EOL> avoid_localize = True <EOL> arg = arg . astimezone ( pytz . utc ) . replace ( tzinfo = None ) <EOL> if type ( arg ) == datetime : <EOL> naive_dt = arg <EOL> if naive_dt . tzinfo : <EOL> tzs . add ( SaneTime . to_timezone ( str ( naive_dt . tzinfo ) ) ) <EOL> naive_dt = naive_dt . replace ( tzinfo = None ) <EOL> if len ( tzs ) > <NUM_LIT:1> : <EOL> raise TimeConstructionError ( "<STR_LIT>" % ( tzs ) ) <EOL> self . tz = len ( tzs ) and tzs . pop ( ) or pytz . utc <EOL> if naive_dt : <EOL> if avoid_localize : <EOL> uss . add ( SaneTime . utc_datetime_to_us ( naive_dt ) ) <EOL> else : <EOL> uss . add ( SaneTime . utc_datetime_to_us ( self . tz . localize ( naive_dt ) . astimezone ( pytz . utc ) ) ) <EOL> if len ( uss ) == <NUM_LIT:0> : <EOL> uss . add ( SaneTime . utc_datetime_to_us ( datetime . utcnow ( ) ) ) <EOL> if len ( uss ) > <NUM_LIT:1> : <EOL> raise TimeConstructionError ( "<STR_LIT>" % ( uss ) ) <EOL> self . us = uss . pop ( ) <EOL> if len ( args ) > <NUM_LIT:0> : <EOL> raise TimeConstructionError ( "<STR_LIT>" ) <EOL> @ property <EOL> def ms ( self ) : return self . us / MILLI_MICROS <EOL> epoch_milliseconds = epoch_millis = milliseconds = millis = ms <EOL> @ property <EOL> def s ( self ) : return self . us / SECOND_MICROS <EOL> epoch_seconds = epoch_secs = seconds = secs = s <EOL> @ property <EOL> def m ( self ) : return self . us / MINUTE_MICROS <EOL> epoch_minutes = epoch_mins = minutes = mins = m <EOL> @ property <EOL> def micros ( self ) : return self . us <EOL> epoch_microseconds = epoch_micros = microseconds = micros <EOL> @ property <EOL> def tz_name ( self ) : return self . tz . zone <EOL> @ property <EOL> def tz_abbr ( self ) : return self . tz . _tzname <EOL> def set_tz ( self , tz ) : <EOL> self . tz = self . __class__ . to_timezone ( tz ) ; return self <EOL> def with_tz ( self , tz ) : <EOL> return self . __class__ ( self . us , tz ) <EOL> @ property <EOL> def _tuple ( self ) : return ( self . us , self . tz ) <EOL> def strftime ( self , * args , ** kwargs ) : return self . datetime . strftime ( * args , ** kwargs ) <EOL> def __cmp__ ( self , other ) : <EOL> if not hasattr ( other , '<STR_LIT>' ) : other = SaneTime ( other ) <EOL> return cmp ( self . us , int ( other ) ) <EOL> def __hash__ ( self ) : return self . us . __hash__ ( ) <EOL> def __add__ ( self , operand ) : <EOL> if not hasattr ( operand , '<STR_LIT>' ) : operand = SaneTime ( operand ) <EOL> return self . __class__ ( self . us + int ( operand ) , tz = self . tz ) <EOL> def __sub__ ( self , operand ) : <EOL> if not hasattr ( operand , '<STR_LIT>' ) : operand = SaneTime ( operand ) <EOL> if isinstance ( operand , SaneTime ) : return SaneDelta ( self . us - int ( operand ) ) <EOL> return self . __add__ ( - int ( operand ) ) <EOL> def __mul__ ( self , operand ) : <EOL> return self . us * int ( operand ) <EOL> def __div__ ( self , operand ) : <EOL> return self . us / int ( operand ) <EOL> def __int__ ( self ) : return int ( self . us ) <EOL> def __long__ ( self ) : return long ( self . us ) <EOL> def __repr__ ( self ) : return u"<STR_LIT>" % ( self . us , repr ( self . tz ) ) <EOL> def __str__ ( self ) : return unicode ( self ) . encode ( '<STR_LIT:utf-8>' ) <EOL> def __unicode__ ( self ) : <EOL> dt = self . datetime <EOL> micros = u"<STR_LIT>" % dt . microsecond if dt . microsecond else '<STR_LIT>' <EOL> time = u"<STR_LIT>" % ( dt . hour , dt . minute , dt . second , micros ) if dt . microsecond or dt . second or dt . minute or dt . hour else '<STR_LIT>' <EOL> return u"<STR_LIT>" % ( dt . year , dt . month , dt . day , time , dt . tzinfo . zone ) <EOL> def clone ( self ) : <EOL> """<STR_LIT>""" <EOL> return self . __class__ ( self . us , self . tz ) <EOL> @ property <EOL> def ny_str ( self ) : <EOL> """<STR_LIT>""" <EOL> return self . ny_ndt . strftime ( '<STR_LIT>' ) <EOL> @ property <EOL> def utc_datetime ( self ) : return SaneTime . us_to_utc_datetime ( self . us ) <EOL> utc_dt = utc_datetime <EOL> @ property <EOL> def utc_naive_datetime ( self ) : return self . utc_datetime . replace ( tzinfo = None ) <EOL> utc_ndt = utc_naive_datetime <EOL> def to_timezoned_datetime ( self , tz ) : return self . utc_datetime . astimezone ( SaneTime . to_timezone ( tz ) ) <EOL> def to_timezoned_naive_datetime ( self , tz ) : return self . to_timezoned_datetime ( tz ) . replace ( tzinfo = None ) <EOL> @ property <EOL> def datetime ( self ) : return self . to_timezoned_datetime ( self . tz ) <EOL> dt = datetime <EOL> @ property <EOL> def naive_datetime ( self ) : return self . to_timezoned_naive_datetime ( self . tz ) <EOL> ndt = naive_datetime <EOL> @ property <EOL> def ny_datetime ( self ) : return self . to_timezoned_datetime ( '<STR_LIT>' ) <EOL> ny_dt = ny_datetime <EOL> @ property <EOL> def ny_naive_datetime ( self ) : return self . to_timezoned_naive_datetime ( '<STR_LIT>' ) <EOL> ny_ndt = ny_naive_datetime <EOL> @ property <EOL> def year ( self ) : return self . dt . year <EOL> @ property <EOL> def month ( self ) : return self . dt . month <EOL> @ property <EOL> def day ( self ) : return self . dt . day <EOL> @ property <EOL> def hour ( self ) : return self . dt . hour <EOL> @ property <EOL> def minute ( self ) : return self . dt . minute <EOL> @ property <EOL> def second ( self ) : return self . dt . second <EOL> @ property <EOL> def microsecond ( self ) : return self . dt . microsecond <EOL> @ classmethod <EOL> def utc_datetime_to_us ( kls , dt ) : <EOL> return calendar . timegm ( dt . timetuple ( ) ) * <NUM_LIT:1000> ** <NUM_LIT:2> + dt . microsecond <EOL> @ classmethod <EOL> def us_to_utc_datetime ( kls , us ) : <EOL> return pytz . utc . localize ( datetime . utcfromtimestamp ( us / <NUM_LIT:10> ** <NUM_LIT:6> ) ) . replace ( microsecond = us % <NUM_LIT:10> ** <NUM_LIT:6> ) <EOL> @ classmethod <EOL> def to_timezone ( kls , tz ) : <EOL> if not isinstance ( tz , basestring ) : return tz <EOL> return pytz . timezone ( tz ) <EOL> def ntime ( * args , ** kwargs ) : <EOL> if args : <EOL> if args [ <NUM_LIT:0> ] is None : return None <EOL> elif kwargs : <EOL> if None in [ v for k , v in kwargs . iteritems ( ) if k != '<STR_LIT>' ] : return None <EOL> return SaneTime ( * args , ** kwargs ) <EOL> time = sanetime = SaneTime <EOL> nsanetime = ntime </s>
<s> from tastypie . authorization import Authorization <EOL> from openpds . authentication import OAuth2Authentication <EOL> from openpds . core . models import Profile , AuditEntry <EOL> import settings <EOL> import pdb <EOL> import traceback <EOL> class PDSAuthorization ( Authorization ) : <EOL> audit_enabled = True <EOL> scope = "<STR_LIT>" <EOL> requester_uuid = "<STR_LIT>" <EOL> def requester ( self ) : <EOL> return self . requester_uuid <EOL> def trustWrapper ( self , datastore_owner ) : <EOL> print "<STR_LIT>" <EOL> def is_authorized ( self , request , object = None ) : <EOL> authenticator = OAuth2Authentication ( self . scope ) <EOL> if "<STR_LIT>" in request . REQUEST : <EOL> authorized = True <EOL> token = request . REQUEST [ "<STR_LIT>" ] if "<STR_LIT>" in request . REQUEST else request . META [ "<STR_LIT>" ] <EOL> datastore_owner_uuid = request . REQUEST [ "<STR_LIT>" ] <EOL> datastore_owner , ds_owner_created = Profile . objects . get_or_create ( uuid = datastore_owner_uuid ) <EOL> self . requester_uuid = authenticator . get_userinfo_from_token ( token , self . scope ) <EOL> if self . requester_uuid is False or self . requester_uuid is None or len ( self . requester_uuid ) == <NUM_LIT:0> : <EOL> self . requester_uuid = "<STR_LIT>" <EOL> authorized = False <EOL> self . trustWrapper ( datastore_owner ) <EOL> try : <EOL> if ( self . audit_enabled ) : <EOL> audit_entry = AuditEntry ( token = token ) <EOL> audit_entry . method = request . method <EOL> audit_entry . scope = self . scope <EOL> audit_entry . purpose = request . REQUEST [ "<STR_LIT>" ] if "<STR_LIT>" in request . REQUEST else "<STR_LIT>" <EOL> audit_entry . system_entity_toggle = request . REQUEST [ "<STR_LIT>" ] if "<STR_LIT>" in request . REQUEST else False <EOL> audit_entry . datastore_owner = datastore_owner <EOL> audit_entry . requester , created = Profile . objects . get_or_create ( uuid = self . requester_uuid ) <EOL> audit_entry . script = request . path <EOL> audit_entry . save ( ) <EOL> except Exception as e : <EOL> print e <EOL> authorized = False <EOL> return authorized <EOL> return False <EOL> def __init__ ( self , scope , audit_enabled = True ) : <EOL> self . scope = scope <EOL> self . audit_enabled = audit_enabled </s>
<s> """<STR_LIT>""" <EOL> from django import template <EOL> register = template . Library ( ) <EOL> class VerbatimNode ( template . Node ) : <EOL> def __init__ ( self , text ) : <EOL> self . text = text <EOL> def render ( self , context ) : <EOL> return self . text <EOL> @ register . tag <EOL> def verbatim ( parser , token ) : <EOL> text = [ ] <EOL> while <NUM_LIT:1> : <EOL> token = parser . tokens . pop ( <NUM_LIT:0> ) <EOL> if token . contents == '<STR_LIT>' : <EOL> break <EOL> if token . token_type == template . TOKEN_VAR : <EOL> text . append ( '<STR_LIT>' ) <EOL> elif token . token_type == template . TOKEN_BLOCK : <EOL> text . append ( '<STR_LIT>' ) <EOL> text . append ( token . contents ) <EOL> if token . token_type == template . TOKEN_VAR : <EOL> text . append ( '<STR_LIT>' ) <EOL> elif token . token_type == template . TOKEN_BLOCK : <EOL> text . append ( '<STR_LIT>' ) <EOL> return VerbatimNode ( '<STR_LIT>' . join ( text ) ) </s>
<s> from django . shortcuts import render_to_response <EOL> from django . template import RequestContext <EOL> import pdb </s>
<s> from werkzeug . utils import cached_property <EOL> from base import db , Base <EOL> from cluster import Cluster <EOL> class Proxy ( Base ) : <EOL> __tablename__ = '<STR_LIT>' <EOL> host = db . Column ( db . String ( <NUM_LIT:255> ) , nullable = False ) <EOL> port = db . Column ( db . Integer , nullable = False ) <EOL> eru_container_id = db . Column ( db . String ( <NUM_LIT:64> ) , index = True ) <EOL> cluster_id = db . Column ( db . ForeignKey ( Cluster . id ) , index = True ) <EOL> suppress_alert = db . Column ( db . Integer , nullable = False , default = <NUM_LIT:1> ) <EOL> __table_args__ = ( db . Index ( '<STR_LIT:address>' , '<STR_LIT:host>' , '<STR_LIT:port>' , unique = True ) , ) <EOL> @ cached_property <EOL> def eru_deployed ( self ) : <EOL> return self . eru_container_id is not None <EOL> @ cached_property <EOL> def eru_info ( self ) : <EOL> import eru_utils <EOL> if eru_utils . eru_client is None or not self . eru_deployed : <EOL> return None <EOL> return eru_utils . eru_client . get_container ( self . eru_container_id ) <EOL> @ cached_property <EOL> def cluster ( self ) : <EOL> return Cluster . query . get ( self . cluster_id ) <EOL> def get_by_host_port ( host , port ) : <EOL> return db . session . query ( Proxy ) . filter ( <EOL> Proxy . host == host , Proxy . port == port ) . first ( ) <EOL> def del_by_host_port ( host , port ) : <EOL> return db . session . query ( Proxy ) . filter ( <EOL> Proxy . host == host , Proxy . port == port ) . delete ( ) <EOL> def get_or_create ( host , port , cluster_id = None ) : <EOL> p = db . session . query ( Proxy ) . filter ( <EOL> Proxy . host == host , Proxy . port == port ) . first ( ) <EOL> if p is None : <EOL> p = Proxy ( host = host , port = port , cluster_id = cluster_id ) <EOL> db . session . add ( p ) <EOL> db . session . flush ( ) <EOL> return p <EOL> def create_eru_instance ( host , port , cluster_id , eru_container_id ) : <EOL> node = Proxy ( host = host , port = port , eru_container_id = eru_container_id , <EOL> cluster_id = cluster_id ) <EOL> db . session . add ( node ) <EOL> db . session . flush ( ) <EOL> return node <EOL> def delete_eru_instance ( eru_container_id ) : <EOL> db . session . query ( Proxy ) . filter ( <EOL> Proxy . eru_container_id == eru_container_id ) . delete ( ) <EOL> def get_eru_by_container_id ( eru_container_id ) : <EOL> return db . session . query ( Proxy ) . filter ( <EOL> Proxy . eru_container_id == eru_container_id ) . first ( ) <EOL> def list_all ( ) : <EOL> return db . session . query ( Proxy ) . all ( ) <EOL> def list_eru_proxies ( offset , limit ) : <EOL> return db . session . query ( Proxy ) . filter ( <EOL> Proxy . eru_container_id != None ) . order_by ( <EOL> Proxy . id . desc ( ) ) . offset ( offset ) . limit ( limit ) . all ( ) <EOL> def list_ip ( ) : <EOL> return db . session . query ( Proxy . host , Proxy . port ) . all ( ) </s>
<s> from ethereum import tester <EOL> import hydrachain . native_contracts as nc <EOL> from fungible_contract import IOU <EOL> import ethereum . slogging as slogging <EOL> log = slogging . get_logger ( '<STR_LIT>' ) <EOL> def test_iou_template ( ) : <EOL> """<STR_LIT>""" <EOL> nc . registry . register ( IOU ) <EOL> state = tester . state ( ) <EOL> logs = [ ] <EOL> issuer_address = tester . a0 <EOL> issuer_key = tester . k0 <EOL> for evt_class in IOU . events : <EOL> nc . listen_logs ( state , evt_class , callback = lambda e : logs . append ( e ) ) <EOL> iou_address = nc . tester_create_native_contract_instance ( state , issuer_key , IOU ) <EOL> iou_as_issuer = nc . tester_nac ( state , issuer_key , iou_address ) <EOL> iou_as_issuer . init ( ) <EOL> assert iou_as_issuer . balanceOf ( issuer_address ) == <NUM_LIT:0> <EOL> amount_issued = <NUM_LIT> <EOL> iou_as_issuer . issue_funds ( amount_issued , '<STR_LIT>' ) <EOL> assert iou_as_issuer . balanceOf ( issuer_address ) == amount_issued <EOL> iou_as_issuer . issue_funds ( amount_issued , '<STR_LIT>' ) <EOL> assert iou_as_issuer . balanceOf ( issuer_address ) == <NUM_LIT:2> * amount_issued <EOL> assert iou_as_issuer . get_issued_amount ( issuer_address ) == <NUM_LIT:2> * amount_issued <EOL> print logs <EOL> while logs and logs . pop ( ) : <EOL> pass <EOL> nc . registry . unregister ( IOU ) </s>
<s> """<STR_LIT>""" <EOL> import json <EOL> import time <EOL> import urllib2 <EOL> import logging <EOL> from view_controls . view import DrawingTool , Event <EOL> from game_objects . item import Item <EOL> from game_objects . state import TrackerState , TrackerStateEncoder <EOL> from log_parser import LogParser <EOL> from options import Options <EOL> class IsaacTracker ( object ) : <EOL> """<STR_LIT>""" <EOL> def __init__ ( self , logging_level = logging . INFO , read_timer = <NUM_LIT:1> ) : <EOL> self . read_timer = read_timer <EOL> self . file_prefix = "<STR_LIT>" <EOL> self . log = logging . getLogger ( "<STR_LIT>" ) <EOL> self . log . addHandler ( logging . FileHandler ( self . file_prefix + "<STR_LIT>" , mode = '<STR_LIT:w>' ) ) <EOL> self . log . setLevel ( logging_level ) <EOL> with open ( self . file_prefix + "<STR_LIT>" , "<STR_LIT:r>" ) as items_file : <EOL> Item . items_info = json . load ( items_file ) <EOL> with open ( self . file_prefix + '<STR_LIT>' , '<STR_LIT:r>' ) as f : <EOL> self . tracker_version = f . read ( ) <EOL> Options ( ) . load_options ( self . file_prefix + "<STR_LIT>" ) <EOL> def __del__ ( self ) : <EOL> Options ( ) . save_options ( self . file_prefix + "<STR_LIT>" ) <EOL> def check_for_update ( self ) : <EOL> """<STR_LIT>""" <EOL> try : <EOL> latest = "<STR_LIT>" <EOL> github_info_json = urllib2 . urlopen ( latest ) . read ( ) <EOL> info = json . loads ( github_info_json ) <EOL> latest_version = info [ "<STR_LIT:name>" ] <EOL> title_text = "<STR_LIT>" + self . tracker_version <EOL> if latest_version != self . tracker_version : <EOL> title_text += "<STR_LIT>" <EOL> return title_text <EOL> except Exception as e : <EOL> self . log . debug ( "<STR_LIT>" + e . message ) <EOL> return "<STR_LIT>" <EOL> def run ( self ) : <EOL> """<STR_LIT>""" <EOL> update_notifier = self . check_for_update ( ) <EOL> framecount = <NUM_LIT:0> <EOL> drawing_tool = DrawingTool ( self . file_prefix ) <EOL> drawing_tool . set_window_title ( update_notifier ) <EOL> parser = LogParser ( self . file_prefix , self . tracker_version ) <EOL> opt = Options ( ) <EOL> log = logging . getLogger ( "<STR_LIT>" ) <EOL> event_result = None <EOL> state = None <EOL> read_from_server = opt . read_from_server <EOL> write_to_server = opt . write_to_server <EOL> state_version = - <NUM_LIT:1> <EOL> twitch_username = None <EOL> new_states_queue = [ ] <EOL> screen_error_message = None <EOL> while event_result != Event . DONE : <EOL> event_result = drawing_tool . handle_events ( ) <EOL> if opt . read_from_server != read_from_server or opt . twitch_name != twitch_username : <EOL> twitch_username = opt . twitch_name <EOL> read_from_server = opt . read_from_server <EOL> new_states_queue = [ ] <EOL> if read_from_server : <EOL> state_version = - <NUM_LIT:1> <EOL> state = None <EOL> drawing_tool . set_window_title ( update_notifier , watching_player = twitch_username , updates_queued = len ( new_states_queue ) ) <EOL> else : <EOL> drawing_tool . set_window_title ( update_notifier ) <EOL> if opt . write_to_server and opt . write_to_server != write_to_server : <EOL> write_to_server = True <EOL> drawing_tool . set_window_title ( update_notifier , uploading = True ) <EOL> if not opt . write_to_server : <EOL> write_to_server = False <EOL> if opt . read_from_server : <EOL> update_timer = <NUM_LIT:2> <EOL> else : <EOL> update_timer = self . read_timer <EOL> if event_result == Event . OPTIONS_UPDATE : <EOL> framecount = <NUM_LIT:0> <EOL> screen_error_message = None <EOL> if state is not None : <EOL> state . modified = True <EOL> if ( framecount % int ( Options ( ) . framerate_limit * update_timer ) == <NUM_LIT:0> ) : <EOL> if opt . read_from_server : <EOL> base_url = opt . trackerserver_url + "<STR_LIT>" + opt . twitch_name <EOL> json_dict = None <EOL> try : <EOL> json_version = urllib2 . urlopen ( base_url + "<STR_LIT>" ) . read ( ) <EOL> if int ( json_version ) > state_version : <EOL> json_state = urllib2 . urlopen ( base_url ) . read ( ) <EOL> json_dict = json . loads ( json_state ) <EOL> new_state = TrackerState . from_json ( json_dict ) <EOL> if new_state is None : <EOL> raise Exception <EOL> state_version = int ( json_version ) <EOL> new_states_queue . append ( ( state_version , new_state ) ) <EOL> drawing_tool . set_window_title ( update_notifier , watching_player = twitch_username , updates_queued = len ( new_states_queue ) , read_delay = opt . read_delay ) <EOL> except Exception : <EOL> state = None <EOL> log . error ( "<STR_LIT>" ) <EOL> import traceback <EOL> log . error ( traceback . format_exc ( ) ) <EOL> if json_dict is not None : <EOL> their_version = "<STR_LIT>" <EOL> if "<STR_LIT>" in json_dict : <EOL> their_version = json_dict [ "<STR_LIT>" ] <EOL> else : <EOL> their_version = "<STR_LIT>" <EOL> if their_version != self . tracker_version : <EOL> screen_error_message = "<STR_LIT>" + their_version + "<STR_LIT>" + self . tracker_version <EOL> else : <EOL> force_draw = state and state . modified <EOL> state = parser . parse ( ) <EOL> if force_draw : <EOL> state . modified = True <EOL> if write_to_server and not opt . trackerserver_authkey : <EOL> screen_error_message = "<STR_LIT>" <EOL> if state is not None and write_to_server and state . modified and screen_error_message is None : <EOL> opener = urllib2 . build_opener ( urllib2 . HTTPHandler ) <EOL> put_url = opt . trackerserver_url + "<STR_LIT>" + opt . trackerserver_authkey <EOL> json_string = json . dumps ( state , cls = TrackerStateEncoder , sort_keys = True ) <EOL> request = urllib2 . Request ( put_url , <EOL> data = json_string ) <EOL> request . add_header ( '<STR_LIT:Content-Type>' , '<STR_LIT:application/json>' ) <EOL> request . get_method = lambda : '<STR_LIT>' <EOL> try : <EOL> result = opener . open ( request ) <EOL> result_json = json . loads ( result . read ( ) ) <EOL> updated_user = result_json [ "<STR_LIT>" ] <EOL> if updated_user is None : <EOL> screen_error_message = "<STR_LIT>" <EOL> else : <EOL> screen_error_message = None <EOL> except Exception as e : <EOL> import traceback <EOL> errmsg = traceback . format_exc ( ) <EOL> log . error ( "<STR_LIT>" ) <EOL> log . error ( errmsg ) <EOL> screen_error_message = "<STR_LIT>" <EOL> if len ( new_states_queue ) > <NUM_LIT:0> : <EOL> ( state_timestamp , new_state ) = new_states_queue [ <NUM_LIT:0> ] <EOL> current_timestamp = int ( time . time ( ) ) <EOL> if current_timestamp - state_timestamp >= opt . read_delay or state is None : <EOL> state = new_state <EOL> new_states_queue . pop ( <NUM_LIT:0> ) <EOL> drawing_tool . set_window_title ( update_notifier , watching_player = twitch_username , updates_queued = len ( new_states_queue ) , read_delay = opt . read_delay ) <EOL> if state is None and screen_error_message is None : <EOL> if read_from_server : <EOL> screen_error_message = "<STR_LIT>" <EOL> else : <EOL> screen_error_message = "<STR_LIT>" <EOL> if screen_error_message is not None : <EOL> drawing_tool . write_error_message ( screen_error_message ) <EOL> else : <EOL> drawing_tool . draw_state ( state ) <EOL> drawing_tool . tick ( ) <EOL> framecount += <NUM_LIT:1> <EOL> drawing_tool . save_window_position ( ) <EOL> def main ( ) : <EOL> """<STR_LIT>""" <EOL> try : <EOL> rt = IsaacTracker ( ) <EOL> rt . run ( ) <EOL> except Exception : <EOL> import traceback <EOL> errmsg = traceback . format_exc ( ) <EOL> print ( errmsg ) <EOL> logging . getLogger ( "<STR_LIT>" ) . error ( errmsg ) <EOL> if __name__ == "<STR_LIT:__main__>" : <EOL> main ( ) </s>
<s> from __future__ import division , print_function , unicode_literals <EOL> from collections import OrderedDict <EOL> from brainstorm . layers . base_layer import Layer <EOL> from brainstorm . structure . buffer_structure import ( BufferStructure , <EOL> StructureTemplate ) <EOL> from brainstorm . structure . construction import ConstructionWrapper <EOL> from brainstorm . utils import flatten_all_but_last <EOL> def BatchNorm ( name = None , decay = <NUM_LIT> , epsilon = <NUM_LIT> ) : <EOL> """<STR_LIT>""" <EOL> return ConstructionWrapper . create ( BatchNormLayerImpl , <EOL> name = name , <EOL> decay = decay , <EOL> epsilon = epsilon ) <EOL> class BatchNormLayerImpl ( Layer ) : <EOL> expected_inputs = { '<STR_LIT:default>' : StructureTemplate ( '<STR_LIT:T>' , '<STR_LIT:B>' , '<STR_LIT>' ) } <EOL> expected_kwargs = { '<STR_LIT>' , '<STR_LIT>' } <EOL> def setup ( self , kwargs , in_shapes ) : <EOL> self . epsilon = kwargs . get ( '<STR_LIT>' , <NUM_LIT> ) <EOL> self . decay = kwargs . get ( '<STR_LIT>' , <NUM_LIT> ) <EOL> assert <NUM_LIT:0.0> <= self . decay <= <NUM_LIT:1.0> , "<STR_LIT>" <EOL> outputs = OrderedDict ( ) <EOL> outputs [ '<STR_LIT:default>' ] = in_shapes [ '<STR_LIT:default>' ] <EOL> parameters = OrderedDict ( ) <EOL> buf = BufferStructure ( self . in_shapes [ '<STR_LIT:default>' ] . feature_shape [ - <NUM_LIT:1> ] ) <EOL> parameters [ '<STR_LIT>' ] = buf <EOL> parameters [ '<STR_LIT>' ] = buf <EOL> parameters [ '<STR_LIT>' ] = buf <EOL> parameters [ '<STR_LIT>' ] = buf <EOL> internals = OrderedDict ( ) <EOL> internals [ '<STR_LIT>' ] = buf <EOL> internals [ '<STR_LIT>' ] = self . in_shapes [ '<STR_LIT:default>' ] <EOL> internals [ '<STR_LIT>' ] = self . in_shapes [ '<STR_LIT:default>' ] <EOL> return outputs , parameters , internals <EOL> def forward_pass ( self , buffers , training_pass = True ) : <EOL> _h = self . handler <EOL> sigma_b , centered , x_hat = buffers . internals <EOL> gamma , beta , mu , sigma = buffers . parameters <EOL> inputs = flatten_all_but_last ( buffers . inputs . default ) <EOL> centered = flatten_all_but_last ( centered ) <EOL> x_hat = flatten_all_but_last ( x_hat ) <EOL> out = flatten_all_but_last ( buffers . outputs . default ) <EOL> m = inputs . shape [ <NUM_LIT:0> ] <EOL> if training_pass : <EOL> mu_b = sigma_b <EOL> _h . sum_t ( inputs , <NUM_LIT:0> , mu_b ) <EOL> _h . mult_st ( - <NUM_LIT:1.0> / m , mu_b , mu_b ) <EOL> _h . mult_st ( self . decay , mu , mu ) <EOL> _h . mult_add_st ( <NUM_LIT:1.0> - self . decay , mu_b , mu ) <EOL> mu = mu_b <EOL> _h . add_mv ( inputs , mu . reshape ( ( <NUM_LIT:1> , mu . size ) ) , centered ) <EOL> if training_pass : <EOL> sigma2 = sigma_b <EOL> centered2 = x_hat <EOL> _h . mult_tt ( centered , centered , centered2 ) <EOL> _h . sum_t ( centered2 , <NUM_LIT:0> , sigma2 ) <EOL> _h . mult_st ( <NUM_LIT:1.0> / m , sigma2 , sigma2 ) <EOL> _h . add_st ( self . epsilon , sigma2 , sigma2 ) <EOL> _h . sqrt_t ( sigma2 , sigma_b ) <EOL> _h . mult_st ( self . decay , sigma , sigma ) <EOL> _h . mult_add_st ( <NUM_LIT:1.0> - self . decay , sigma_b , sigma ) <EOL> sigma = sigma_b <EOL> _h . divide_mv ( centered , sigma . reshape ( ( <NUM_LIT:1> , sigma . size ) ) , x_hat ) <EOL> _h . mult_mv ( x_hat , gamma . reshape ( ( <NUM_LIT:1> , gamma . size ) ) , out ) <EOL> _h . add_mv ( out , beta . reshape ( ( <NUM_LIT:1> , beta . size ) ) , out ) <EOL> def backward_pass ( self , buffers ) : <EOL> _h = self . handler <EOL> sigma_b , centered , x_hat = buffers . internals <EOL> gamma = buffers . parameters . gamma <EOL> dgamma = buffers . gradients . gamma <EOL> dbeta = buffers . gradients . beta <EOL> x_hat = flatten_all_but_last ( x_hat ) <EOL> outdeltas = flatten_all_but_last ( buffers . output_deltas . default ) <EOL> indeltas = flatten_all_but_last ( buffers . input_deltas . default ) <EOL> m = outdeltas . shape [ <NUM_LIT:0> ] <EOL> big_tmp = _h . allocate ( x_hat . shape ) <EOL> small_tmp = _h . allocate ( gamma . shape ) <EOL> tmp = big_tmp <EOL> dgamma_tmp = small_tmp <EOL> _h . mult_tt ( outdeltas , x_hat , tmp ) <EOL> _h . sum_t ( tmp , axis = <NUM_LIT:0> , out = dgamma_tmp ) <EOL> _h . add_tt ( dgamma_tmp , dgamma , dgamma ) <EOL> _h . mult_st ( <NUM_LIT:1> / m , dgamma_tmp , dgamma_tmp ) <EOL> term1 = big_tmp <EOL> _h . mult_mv ( x_hat , dgamma_tmp . reshape ( ( <NUM_LIT:1> , gamma . size ) ) , term1 ) <EOL> dbeta_tmp = small_tmp <EOL> _h . sum_t ( outdeltas , axis = <NUM_LIT:0> , out = dbeta_tmp ) <EOL> _h . add_tt ( dbeta_tmp , dbeta , dbeta ) <EOL> _h . mult_st ( <NUM_LIT:1> / m , dbeta_tmp , dbeta_tmp ) <EOL> term2 = big_tmp <EOL> term3 = big_tmp <EOL> _h . subtract_tt ( outdeltas , term1 , term2 ) <EOL> _h . subtract_mv ( term2 , dbeta_tmp . reshape ( ( <NUM_LIT:1> , dbeta . size ) ) , term3 ) <EOL> coeff = small_tmp <EOL> _h . divide_tt ( gamma , sigma_b , coeff ) <EOL> term4 = big_tmp <EOL> _h . mult_mv ( term3 , coeff . reshape ( ( <NUM_LIT:1> , coeff . size ) ) , term4 ) <EOL> _h . add_tt ( term4 , indeltas , indeltas ) </s>
<s> from __future__ import division , print_function , unicode_literals <EOL> from collections import OrderedDict <EOL> import numpy as np <EOL> from brainstorm . describable import Describable <EOL> class Scorer ( Describable ) : <EOL> def __init__ ( self , out_name = '<STR_LIT>' , targets_name = '<STR_LIT>' , mask_name = '<STR_LIT>' , <EOL> name = None ) : <EOL> self . out_name = out_name <EOL> self . targets_name = targets_name <EOL> self . mask_name = mask_name <EOL> self . __name__ = name if name is not None else self . __class__ . __name__ <EOL> def __call__ ( self , true_labels , predicted , mask = None ) : <EOL> pass <EOL> @ staticmethod <EOL> def aggregate ( errors ) : <EOL> errors = np . array ( errors ) <EOL> assert errors . ndim == <NUM_LIT:2> and errors . shape [ <NUM_LIT:1> ] == <NUM_LIT:2> <EOL> return np . sum ( errors [ : , <NUM_LIT:1> ] ) / np . sum ( errors [ : , <NUM_LIT:0> ] ) <EOL> def gather_losses_and_scores ( net , scorers , scores , out_name = '<STR_LIT>' , <EOL> targets_name = '<STR_LIT>' , mask_name = '<STR_LIT>' ) : <EOL> ls = net . get_loss_values ( ) <EOL> for name , loss in ls . items ( ) : <EOL> scores [ name ] . append ( ( net . _buffer_manager . batch_size , loss ) ) <EOL> for sc in scorers : <EOL> name = sc . __name__ <EOL> predicted = net . get ( sc . out_name or out_name or net . output_name ) <EOL> true_labels = net . get_input ( sc . targets_name ) if sc . targets_name else net . get_input ( targets_name ) <EOL> mask = net . get_input ( sc . mask_name ) if sc . mask_name else ( net . get_input ( mask_name ) if mask_name else None ) <EOL> predicted = _flatten_all_but_last ( predicted ) <EOL> true_labels = _flatten_all_but_last ( true_labels ) <EOL> mask = _flatten_all_but_last ( mask ) <EOL> weight = mask . sum ( ) if mask is not None else predicted . shape [ <NUM_LIT:0> ] <EOL> scores [ name ] . append ( ( weight , sc ( true_labels , predicted , mask ) ) ) <EOL> def aggregate_losses_and_scores ( scores , net , scorers ) : <EOL> results = OrderedDict ( ) <EOL> for name in net . get_loss_values ( ) : <EOL> results [ name ] = _weighted_average ( scores [ name ] ) <EOL> for sc in scorers : <EOL> results [ sc . __name__ ] = sc . aggregate ( scores [ sc . __name__ ] ) <EOL> return results <EOL> class Accuracy ( Scorer ) : <EOL> def __call__ ( self , true_labels , predicted , mask = None ) : <EOL> if predicted . shape [ <NUM_LIT:1> ] > <NUM_LIT:1> : <EOL> predicted = predicted . argmax ( <NUM_LIT:1> ) . reshape ( - <NUM_LIT:1> , <NUM_LIT:1> ) <EOL> correct = ( predicted == true_labels ) . astype ( np . float ) <EOL> if mask is not None : <EOL> correct *= mask <EOL> return np . sum ( correct ) <EOL> class Hamming ( Scorer ) : <EOL> def __init__ ( self , threshold = <NUM_LIT:0.5> , out_name = '<STR_LIT>' , targets_name = '<STR_LIT>' , <EOL> mask_name = '<STR_LIT>' , name = None ) : <EOL> super ( Hamming , self ) . __init__ ( out_name , targets_name , mask_name , name ) <EOL> self . threshold = threshold <EOL> def __call__ ( self , true_labels , predicted , mask = None ) : <EOL> correct = np . logical_xor ( predicted < self . threshold , <EOL> true_labels ) . astype ( np . float ) <EOL> if mask is not None : <EOL> correct *= mask <EOL> return np . sum ( correct ) / true_labels . shape [ <NUM_LIT:1> ] <EOL> class MeanSquaredError ( Scorer ) : <EOL> def __call__ ( self , true_labels , predicted , mask = None ) : <EOL> errors = ( true_labels - predicted ) ** <NUM_LIT:2> <EOL> if mask is not None : <EOL> errors *= mask <EOL> return <NUM_LIT:0.5> * np . sum ( errors ) <EOL> def _flatten_all_but_last ( a ) : <EOL> if a is None : <EOL> return None <EOL> return a . reshape ( - <NUM_LIT:1> , a . shape [ - <NUM_LIT:1> ] ) <EOL> def _weighted_average ( errors ) : <EOL> errors = np . array ( errors ) <EOL> assert errors . ndim == <NUM_LIT:2> and errors . shape [ <NUM_LIT:1> ] == <NUM_LIT:2> <EOL> return np . sum ( errors [ : , <NUM_LIT:1> ] * errors [ : , <NUM_LIT:0> ] / np . sum ( errors [ : , <NUM_LIT:0> ] ) ) </s>
<s> from __future__ import division , print_function , unicode_literals <EOL> import pytest <EOL> import six <EOL> from brainstorm . training . schedules import Exponential , Linear , MultiStep <EOL> def test_linear ( ) : <EOL> sch = Linear ( initial_value = <NUM_LIT:1.0> , final_value = <NUM_LIT:0.5> , num_changes = <NUM_LIT:5> ) <EOL> epochs = [ <NUM_LIT:0> ] * <NUM_LIT:2> + [ <NUM_LIT:1> ] * <NUM_LIT:2> + [ <NUM_LIT:2> ] * <NUM_LIT:2> + [ <NUM_LIT:3> ] * <NUM_LIT:2> + [ <NUM_LIT:4> ] * <NUM_LIT:2> <EOL> updates = range ( <NUM_LIT:10> ) <EOL> values = [ sch ( epoch , update , '<STR_LIT>' , <NUM_LIT:1> , None , None , None ) <EOL> for epoch , update in six . moves . zip ( epochs , updates ) ] <EOL> assert values == [ <NUM_LIT:1.0> , <NUM_LIT:1.0> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ] <EOL> values = [ sch ( epoch , update , '<STR_LIT>' , <NUM_LIT:1> , None , None , None ) <EOL> for epoch , update in six . moves . zip ( epochs , updates ) ] <EOL> assert values == [ <NUM_LIT:1.0> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT:0.5> , <NUM_LIT:0.5> , <NUM_LIT:0.5> , <NUM_LIT:0.5> , <NUM_LIT:0.5> ] <EOL> values = [ sch ( epoch , update , '<STR_LIT>' , <NUM_LIT:3> , None , None , None ) <EOL> for epoch , update in six . moves . zip ( epochs , updates ) ] <EOL> assert values == [ <NUM_LIT:1.0> , <NUM_LIT:1.0> , <NUM_LIT:1.0> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ] <EOL> def test_exponential ( ) : <EOL> sch = Exponential ( initial_value = <NUM_LIT:1.0> , factor = <NUM_LIT> , minimum = <NUM_LIT> ) <EOL> epochs = [ <NUM_LIT:0> ] * <NUM_LIT:4> + [ <NUM_LIT:1> ] * <NUM_LIT:4> + [ <NUM_LIT:2> ] * <NUM_LIT:4> <EOL> updates = range ( <NUM_LIT:12> ) <EOL> values = [ sch ( epoch , update , '<STR_LIT>' , <NUM_LIT:1> , None , None , None ) <EOL> for epoch , update in six . moves . zip ( epochs , updates ) ] <EOL> assert values == [ <NUM_LIT:1.0> ] * <NUM_LIT:4> + [ <NUM_LIT> ] * <NUM_LIT:4> + [ <NUM_LIT> * <NUM_LIT> ] * <NUM_LIT:4> <EOL> values = [ sch ( epoch , update , '<STR_LIT>' , <NUM_LIT:1> , None , None , None ) <EOL> for epoch , update in six . moves . zip ( epochs , updates ) ] <EOL> assert values == [ <NUM_LIT:1.0> * ( <NUM_LIT> ** x ) for x in range ( <NUM_LIT:4> ) ] + [ <NUM_LIT> ] * <NUM_LIT:8> <EOL> values = [ sch ( epoch , update , '<STR_LIT>' , <NUM_LIT:3> , None , None , None ) <EOL> for epoch , update in six . moves . zip ( epochs , updates ) ] <EOL> assert values == [ <NUM_LIT:1.0> ] * <NUM_LIT:3> + [ <NUM_LIT> ] * <NUM_LIT:3> + [ <NUM_LIT> ] * <NUM_LIT:3> + [ <NUM_LIT> ** <NUM_LIT:3> ] * <NUM_LIT:3> <EOL> def test_multistep ( ) : <EOL> sch = MultiStep ( initial_value = <NUM_LIT:1.0> , steps = [ <NUM_LIT:3> , <NUM_LIT:5> , <NUM_LIT:8> ] , <EOL> values = [ <NUM_LIT:0.1> , <NUM_LIT> , <NUM_LIT> ] ) <EOL> epochs = [ <NUM_LIT:0> ] * <NUM_LIT:2> + [ <NUM_LIT:1> ] * <NUM_LIT:2> + [ <NUM_LIT:2> ] * <NUM_LIT:2> + [ <NUM_LIT:3> ] * <NUM_LIT:2> + [ <NUM_LIT:4> ] * <NUM_LIT:2> <EOL> updates = range ( <NUM_LIT:10> ) <EOL> values = [ sch ( epoch , update , '<STR_LIT>' , <NUM_LIT:1> , None , None , None ) <EOL> for epoch , update in six . moves . zip ( epochs , updates ) ] <EOL> assert values == [ <NUM_LIT:1.0> , <NUM_LIT:1.0> , <NUM_LIT:1.0> , <NUM_LIT:1.0> , <NUM_LIT:1.0> , <NUM_LIT:1.0> , <NUM_LIT:0.1> , <NUM_LIT:0.1> , <NUM_LIT:0.1> , <NUM_LIT:0.1> ] <EOL> values = [ sch ( epoch , update , '<STR_LIT>' , <NUM_LIT:1> , None , None , None ) <EOL> for epoch , update in six . moves . zip ( epochs , updates ) ] <EOL> assert values == [ <NUM_LIT:1.0> , <NUM_LIT:1.0> , <NUM_LIT:1.0> , <NUM_LIT:0.1> , <NUM_LIT:0.1> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ] <EOL> with pytest . raises ( AssertionError ) : <EOL> _ = sch ( <NUM_LIT:0> , <NUM_LIT:0> , '<STR_LIT>' , <NUM_LIT:3> , None , None , None ) </s>
<s> import os <EOL> import sys <EOL> try : <EOL> from unittest . mock import MagicMock <EOL> except ImportError : <EOL> from mock import Mock as MagicMock <EOL> class Mock ( MagicMock ) : <EOL> @ classmethod <EOL> def __getattr__ ( cls , name ) : <EOL> return Mock ( ) <EOL> MOCK_MODULES = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> sys . modules . update ( ( mod_name , Mock ( ) ) for mod_name in MOCK_MODULES ) <EOL> cwd = os . getcwd ( ) <EOL> parent = os . path . dirname ( cwd ) <EOL> sys . path . insert ( <NUM_LIT:0> , parent ) <EOL> import brainstorm <EOL> extensions = [ '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' ] <EOL> templates_path = [ '<STR_LIT>' ] <EOL> source_suffix = '<STR_LIT>' <EOL> master_doc = '<STR_LIT:index>' <EOL> project = u'<STR_LIT>' <EOL> copyright = u'<STR_LIT>' <EOL> version = brainstorm . __version__ <EOL> release = brainstorm . __version__ <EOL> exclude_patterns = [ '<STR_LIT>' ] <EOL> pygments_style = '<STR_LIT>' <EOL> on_rtd = os . environ . get ( '<STR_LIT>' , None ) == '<STR_LIT:True>' <EOL> if not on_rtd : <EOL> try : <EOL> import sphinx_rtd_theme <EOL> html_theme = '<STR_LIT>' <EOL> html_theme_path = [ sphinx_rtd_theme . get_html_theme_path ( ) ] <EOL> except ImportError : <EOL> html_theme = '<STR_LIT>' <EOL> html_static_path = [ '<STR_LIT>' ] <EOL> htmlhelp_basename = '<STR_LIT>' <EOL> latex_elements = { <EOL> } <EOL> latex_documents = [ <EOL> ( '<STR_LIT:index>' , '<STR_LIT>' , u'<STR_LIT>' , <EOL> u'<STR_LIT>' , '<STR_LIT>' ) , <EOL> ] <EOL> man_pages = [ <EOL> ( '<STR_LIT:index>' , '<STR_LIT>' , u'<STR_LIT>' , <EOL> [ u'<STR_LIT>' ] , <NUM_LIT:1> ) <EOL> ] <EOL> texinfo_documents = [ <EOL> ( '<STR_LIT:index>' , '<STR_LIT>' , u'<STR_LIT>' , <EOL> u'<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' ) , <EOL> ] </s>
<s> from __future__ import division , print_function , unicode_literals <EOL> from sacred . utils import iter_prefixes , join_paths <EOL> class ConfigSummary ( dict ) : <EOL> def __init__ ( self , added = ( ) , modified = ( ) , typechanged = ( ) , <EOL> ignored_fallbacks = ( ) ) : <EOL> super ( ConfigSummary , self ) . __init__ ( ) <EOL> self . added = set ( added ) <EOL> self . modified = set ( modified ) <EOL> self . typechanged = dict ( typechanged ) <EOL> self . ignored_fallbacks = set ( ignored_fallbacks ) <EOL> self . ensure_coherence ( ) <EOL> def update_from ( self , config_mod , path = '<STR_LIT>' ) : <EOL> added = config_mod . added <EOL> updated = config_mod . modified <EOL> typechanged = config_mod . typechanged <EOL> self . added &= { join_paths ( path , a ) for a in added } <EOL> self . modified |= { join_paths ( path , u ) for u in updated } <EOL> self . typechanged . update ( { join_paths ( path , k ) : v <EOL> for k , v in typechanged . items ( ) } ) <EOL> self . ensure_coherence ( ) <EOL> def update_add ( self , config_mod , path = '<STR_LIT>' ) : <EOL> added = config_mod . added <EOL> updated = config_mod . modified <EOL> typechanged = config_mod . typechanged <EOL> self . added |= { join_paths ( path , a ) for a in added } <EOL> self . modified |= { join_paths ( path , u ) for u in updated } <EOL> self . typechanged . update ( { join_paths ( path , k ) : v <EOL> for k , v in typechanged . items ( ) } ) <EOL> self . ensure_coherence ( ) <EOL> def ensure_coherence ( self ) : <EOL> self . modified |= { p for a in self . added for p in iter_prefixes ( a ) } <EOL> self . modified |= { p for u in self . modified for p in iter_prefixes ( u ) } <EOL> self . modified |= { p for t in self . typechanged <EOL> for p in iter_prefixes ( t ) } <EOL> self . added -= set ( self . typechanged . keys ( ) ) <EOL> self . modified -= set ( self . typechanged . keys ( ) ) <EOL> self . modified -= self . added </s>
<s> from __future__ import division , print_function , unicode_literals <EOL> import pytest <EOL> import sacred . optional as opt <EOL> from sacred . config import ConfigDict <EOL> from sacred . config . custom_containers import DogmaticDict , DogmaticList <EOL> @ pytest . fixture <EOL> def conf_dict ( ) : <EOL> cfg = ConfigDict ( { <EOL> "<STR_LIT:a>" : <NUM_LIT:1> , <EOL> "<STR_LIT:b>" : <NUM_LIT> , <EOL> "<STR_LIT:c>" : True , <EOL> "<STR_LIT:d>" : '<STR_LIT:string>' , <EOL> "<STR_LIT:e>" : [ <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> ] , <EOL> "<STR_LIT:f>" : { '<STR_LIT:a>' : '<STR_LIT:b>' , '<STR_LIT:c>' : '<STR_LIT:d>' } , <EOL> } ) <EOL> return cfg <EOL> def test_config_dict_returns_dict ( conf_dict ) : <EOL> assert isinstance ( conf_dict ( ) , dict ) <EOL> def test_config_dict_result_contains_keys ( conf_dict ) : <EOL> cfg = conf_dict ( ) <EOL> assert set ( cfg . keys ( ) ) == { '<STR_LIT:a>' , '<STR_LIT:b>' , '<STR_LIT:c>' , '<STR_LIT:d>' , '<STR_LIT:e>' , '<STR_LIT:f>' } <EOL> assert cfg [ '<STR_LIT:a>' ] == <NUM_LIT:1> <EOL> assert cfg [ '<STR_LIT:b>' ] == <NUM_LIT> <EOL> assert cfg [ '<STR_LIT:c>' ] <EOL> assert cfg [ '<STR_LIT:d>' ] == '<STR_LIT:string>' <EOL> assert cfg [ '<STR_LIT:e>' ] == [ <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> ] <EOL> assert cfg [ '<STR_LIT:f>' ] == { '<STR_LIT:a>' : '<STR_LIT:b>' , '<STR_LIT:c>' : '<STR_LIT:d>' } <EOL> def test_fixing_values ( conf_dict ) : <EOL> assert conf_dict ( { '<STR_LIT:a>' : <NUM_LIT:100> } ) [ '<STR_LIT:a>' ] == <NUM_LIT:100> <EOL> @ pytest . mark . parametrize ( "<STR_LIT:key>" , [ "<STR_LIT>" , "<STR_LIT>" , <NUM_LIT:12> , "<STR_LIT>" , "<STR_LIT>" ] ) <EOL> def test_config_dict_raises_on_invalid_keys ( key ) : <EOL> with pytest . raises ( KeyError ) : <EOL> ConfigDict ( { key : True } ) <EOL> @ pytest . mark . parametrize ( "<STR_LIT:value>" , [ lambda x : x , pytest , test_fixing_values ] ) <EOL> def test_config_dict_raises_on_invalid_values ( value ) : <EOL> with pytest . raises ( ValueError ) : <EOL> ConfigDict ( { "<STR_LIT>" : value } ) <EOL> def test_fixing_nested_dicts ( conf_dict ) : <EOL> cfg = conf_dict ( { '<STR_LIT:f>' : { '<STR_LIT:c>' : '<STR_LIT:t>' } } ) <EOL> assert cfg [ '<STR_LIT:f>' ] [ '<STR_LIT:a>' ] == '<STR_LIT:b>' <EOL> assert cfg [ '<STR_LIT:f>' ] [ '<STR_LIT:c>' ] == '<STR_LIT:t>' <EOL> def test_adding_values ( conf_dict ) : <EOL> cfg = conf_dict ( { '<STR_LIT:g>' : <NUM_LIT> , '<STR_LIT:h>' : { '<STR_LIT:i>' : <NUM_LIT:10> } } ) <EOL> assert cfg [ '<STR_LIT:g>' ] == <NUM_LIT> <EOL> assert cfg [ '<STR_LIT:h>' ] == { '<STR_LIT:i>' : <NUM_LIT:10> } <EOL> assert cfg . added == { '<STR_LIT:g>' , '<STR_LIT:h>' , '<STR_LIT>' } <EOL> def test_typechange ( conf_dict ) : <EOL> cfg = conf_dict ( { '<STR_LIT:a>' : '<STR_LIT:bar>' , '<STR_LIT:b>' : '<STR_LIT:foo>' , '<STR_LIT:c>' : <NUM_LIT:1> } ) <EOL> assert cfg . typechanged == { '<STR_LIT:a>' : ( int , type ( '<STR_LIT:bar>' ) ) , <EOL> '<STR_LIT:b>' : ( float , type ( '<STR_LIT:foo>' ) ) , <EOL> '<STR_LIT:c>' : ( bool , int ) } <EOL> def test_nested_typechange ( conf_dict ) : <EOL> cfg = conf_dict ( { '<STR_LIT:f>' : { '<STR_LIT:a>' : <NUM_LIT:10> } } ) <EOL> assert cfg . typechanged == { '<STR_LIT>' : ( type ( '<STR_LIT:a>' ) , int ) } <EOL> def is_dogmatic ( a ) : <EOL> if isinstance ( a , ( DogmaticDict , DogmaticList ) ) : <EOL> return True <EOL> elif isinstance ( a , dict ) : <EOL> return any ( is_dogmatic ( v ) for v in a . values ( ) ) <EOL> elif isinstance ( a , ( list , tuple ) ) : <EOL> return any ( is_dogmatic ( v ) for v in a ) <EOL> def test_result_of_conf_dict_is_not_dogmatic ( conf_dict ) : <EOL> cfg = conf_dict ( { '<STR_LIT:e>' : [ <NUM_LIT:1> , <NUM_LIT:1> , <NUM_LIT:1> ] } ) <EOL> assert not is_dogmatic ( cfg ) <EOL> @ pytest . mark . skipif ( not opt . has_numpy , reason = "<STR_LIT>" ) <EOL> def test_conf_scope_handles_numpy_bools ( ) : <EOL> cfg = ConfigDict ( { <EOL> "<STR_LIT:a>" : opt . np . bool_ ( <NUM_LIT:1> ) <EOL> } ) <EOL> assert '<STR_LIT:a>' in cfg ( ) <EOL> assert cfg ( ) [ '<STR_LIT:a>' ] <EOL> def test_conf_scope_contains_presets ( ) : <EOL> conf_dict = ConfigDict ( { <EOL> "<STR_LIT>" : <NUM_LIT> <EOL> } ) <EOL> cfg = conf_dict ( preset = { '<STR_LIT:a>' : <NUM_LIT> , '<STR_LIT>' : True } ) <EOL> assert set ( cfg . keys ( ) ) == { '<STR_LIT:a>' , '<STR_LIT>' , '<STR_LIT>' } <EOL> assert cfg [ '<STR_LIT:a>' ] == <NUM_LIT> <EOL> assert cfg [ '<STR_LIT>' ] == <NUM_LIT> <EOL> assert cfg [ '<STR_LIT>' ] is True <EOL> def test_conf_scope_does_not_contain_fallback ( ) : <EOL> config_dict = ConfigDict ( { <EOL> "<STR_LIT>" : <NUM_LIT> <EOL> } ) <EOL> cfg = config_dict ( fallback = { '<STR_LIT:a>' : <NUM_LIT> , '<STR_LIT:b>' : <NUM_LIT:10> } ) <EOL> assert set ( cfg . keys ( ) ) == { '<STR_LIT>' } <EOL> def test_fixed_subentry_of_preset ( ) : <EOL> config_dict = ConfigDict ( { } ) <EOL> cfg = config_dict ( preset = { '<STR_LIT:d>' : { '<STR_LIT:a>' : <NUM_LIT:1> , '<STR_LIT:b>' : <NUM_LIT:2> } } , fixed = { '<STR_LIT:d>' : { '<STR_LIT:a>' : <NUM_LIT:10> } } ) <EOL> assert set ( cfg . keys ( ) ) == { '<STR_LIT:d>' } <EOL> assert set ( cfg [ '<STR_LIT:d>' ] . keys ( ) ) == { '<STR_LIT:a>' , '<STR_LIT:b>' } <EOL> assert cfg [ '<STR_LIT:d>' ] [ '<STR_LIT:a>' ] == <NUM_LIT:10> <EOL> assert cfg [ '<STR_LIT:d>' ] [ '<STR_LIT:b>' ] == <NUM_LIT:2> </s>
<s> class PID ( object ) : <EOL> def __init__ ( self ) : <EOL> """<STR_LIT>""" <EOL> self . kd = <NUM_LIT:0> <EOL> self . ki = <NUM_LIT:0> <EOL> self . kp = <NUM_LIT:1> <EOL> self . previous_error = <NUM_LIT:0> <EOL> self . integral_error = <NUM_LIT:0> <EOL> def set_k_values ( self , kp , kd , ki ) : <EOL> self . kp = kp <EOL> self . ki = ki <EOL> self . kd = kd <EOL> def clear_error ( self ) : <EOL> self . previous_error = <NUM_LIT:0> <EOL> self . integeral_error = <NUM_LIT:0> <EOL> def pid ( self , target , process_var , timestep ) : <EOL> current_error = ( target - process_var ) <EOL> p_error = self . kp * current_error <EOL> d_error = self . kd * ( current_error - self . previous_error ) / timestep <EOL> self . integral_error = ( <EOL> current_error + self . previous_error ) / <NUM_LIT:2> + self . integral_error <EOL> i_error = self . ki * self . integral_error <EOL> total_error = p_error + d_error + i_error <EOL> self . previous_error = current_error <EOL> return total_error </s>
<s> """<STR_LIT>""" <EOL> import cmd <EOL> import sys <EOL> import os <EOL> import bot . client . ctrl_client as ctrl_client_mod <EOL> import bot . client . sub_client as sub_client_mod <EOL> class CLI ( cmd . Cmd ) : <EOL> """<STR_LIT>""" <EOL> prompt = "<STR_LIT>" <EOL> def __init__ ( self , ctrl_addr , sub_addr ) : <EOL> """<STR_LIT>""" <EOL> cmd . Cmd . __init__ ( self ) <EOL> try : <EOL> self . ctrl_client = ctrl_client_mod . CtrlClient ( ctrl_addr ) <EOL> except Exception , e : <EOL> print "<STR_LIT>" . format ( ctrl_addr , e ) <EOL> sys . exit ( - <NUM_LIT:1> ) <EOL> try : <EOL> self . sub_client = sub_client_mod . SubClient ( sub_addr ) <EOL> except Exception , e : <EOL> print "<STR_LIT>" . format ( sub_addr , e ) <EOL> sys . exit ( - <NUM_LIT:1> ) <EOL> def default ( self , raw_args ) : <EOL> """<STR_LIT>""" <EOL> obj_name , _ , rest = raw_args . partition ( "<STR_LIT:U+0020>" ) <EOL> if obj_name in self . ctrl_client . objects : <EOL> method_name , _ , params = rest . partition ( "<STR_LIT:U+0020>" ) <EOL> if method_name in self . ctrl_client . objects [ obj_name ] : <EOL> try : <EOL> param_dict = { } <EOL> for param in params . split ( ) : <EOL> key , value = param . split ( "<STR_LIT::>" ) <EOL> try : <EOL> if "<STR_LIT:.>" in value : <EOL> value = float ( value ) <EOL> else : <EOL> value = int ( value ) <EOL> except ValueError : <EOL> if value == "<STR_LIT:True>" : <EOL> value = True <EOL> elif value == "<STR_LIT:False>" : <EOL> value = False <EOL> elif value . startswith ( "<STR_LIT:'>" ) and value . endswith ( "<STR_LIT:'>" ) : <EOL> value = value [ <NUM_LIT:1> : - <NUM_LIT:1> ] <EOL> param_dict [ key ] = value <EOL> except IndexError : <EOL> print "<STR_LIT>" <EOL> return <EOL> except ValueError : <EOL> print "<STR_LIT>" <EOL> return <EOL> result = self . ctrl_client . call ( <EOL> obj_name , method_name , param_dict ) <EOL> print "<STR_LIT>" , result <EOL> else : <EOL> print "<STR_LIT>" , method_name <EOL> else : <EOL> print "<STR_LIT>" , obj_name <EOL> def completenames ( self , text , * ignored ) : <EOL> """<STR_LIT>""" <EOL> cmd_match_names = cmd . Cmd . completenames ( self , text , * ignored ) <EOL> obj_names = self . ctrl_client . objects . keys ( ) <EOL> api_match_names = [ x for x in obj_names if x . startswith ( text ) ] <EOL> return cmd_match_names + api_match_names <EOL> def completedefault ( self , text , line , begidx , endidx ) : <EOL> """<STR_LIT>""" <EOL> obj , _ , rest = line . partition ( "<STR_LIT:U+0020>" ) <EOL> if obj in self . ctrl_client . objects : <EOL> method , _ , params = rest . strip ( ) . partition ( "<STR_LIT:U+0020>" ) <EOL> if method == text : <EOL> method_names = self . ctrl_client . objects [ obj ] <EOL> match_names = [ x for x in method_names if x . startswith ( text ) ] <EOL> return match_names <EOL> def do_list ( self , raw_args ) : <EOL> """<STR_LIT>""" <EOL> print <EOL> print "<STR_LIT>" <EOL> print <EOL> for obj_name , methods in sorted ( self . ctrl_client . objects . items ( ) ) : <EOL> print "<STR_LIT>" . format ( obj_name ) <EOL> for method in methods : <EOL> print "<STR_LIT>" . format ( method ) <EOL> print <EOL> def help_list ( self ) : <EOL> """<STR_LIT>""" <EOL> print "<STR_LIT:list>" <EOL> print "<STR_LIT>" <EOL> def do_ping ( self , raw_args ) : <EOL> """<STR_LIT>""" <EOL> reply_time = self . ctrl_client . ping ( ) <EOL> print "<STR_LIT>" . format ( reply_time ) <EOL> def help_ping ( self ) : <EOL> """<STR_LIT>""" <EOL> print "<STR_LIT>" <EOL> print "<STR_LIT>" <EOL> def do_sub_add ( self , raw_args ) : <EOL> """<STR_LIT>""" <EOL> try : <EOL> topic = raw_args . split ( ) [ <NUM_LIT:0> ] <EOL> except ( ValueError , IndexError ) : <EOL> print "<STR_LIT>" <EOL> return <EOL> self . sub_client . add_topic ( topic ) <EOL> def help_sub_add ( self ) : <EOL> """<STR_LIT>""" <EOL> print "<STR_LIT>" <EOL> print "<STR_LIT>" <EOL> def do_sub_del ( self , raw_args ) : <EOL> """<STR_LIT>""" <EOL> try : <EOL> topic = raw_args . split ( ) [ <NUM_LIT:0> ] <EOL> except ( ValueError , IndexError ) : <EOL> print "<STR_LIT>" <EOL> return <EOL> self . sub_client . del_topic ( topic ) <EOL> def help_sub_del ( self ) : <EOL> """<STR_LIT>""" <EOL> print "<STR_LIT>" <EOL> print "<STR_LIT>" <EOL> def do_sub ( self , raw_args ) : <EOL> """<STR_LIT>""" <EOL> self . sub_client . print_msgs ( ) <EOL> def help_sub ( self ) : <EOL> """<STR_LIT>""" <EOL> print "<STR_LIT>" <EOL> print "<STR_LIT>" <EOL> def do_stop ( self , raw_args ) : <EOL> """<STR_LIT>""" <EOL> self . ctrl_client . stop_full ( ) <EOL> def help_stop ( self ) : <EOL> """<STR_LIT>""" <EOL> print "<STR_LIT>" <EOL> print "<STR_LIT>" <EOL> def do_kill ( self , raw_args ) : <EOL> """<STR_LIT>""" <EOL> self . ctrl_client . exit_server ( ) <EOL> def help_kill ( self ) : <EOL> """<STR_LIT>""" <EOL> print "<STR_LIT>" <EOL> print "<STR_LIT>" <EOL> def do_die ( self , raw_args ) : <EOL> """<STR_LIT>""" <EOL> print "<STR_LIT>" <EOL> self . ctrl_client . clean_up ( ) <EOL> self . sub_client . clean_up ( ) <EOL> print "<STR_LIT>" <EOL> return True <EOL> def help_die ( self ) : <EOL> """<STR_LIT>""" <EOL> print "<STR_LIT>" <EOL> print "<STR_LIT>" <EOL> def do_shell ( self , cmd ) : <EOL> """<STR_LIT>""" <EOL> os . system ( cmd ) <EOL> def help_shell ( self ) : <EOL> """<STR_LIT>""" <EOL> print "<STR_LIT>" <EOL> print "<STR_LIT>" <EOL> def do_EOF ( self , raw_args ) : <EOL> """<STR_LIT>""" <EOL> print "<STR_LIT>" <EOL> self . ctrl_client . clean_up ( ) <EOL> self . sub_client . clean_up ( ) <EOL> print "<STR_LIT>" <EOL> return True <EOL> def help_EOF ( self ) : <EOL> """<STR_LIT>""" <EOL> print "<STR_LIT>" <EOL> print "<STR_LIT>" <EOL> def help_help ( self ) : <EOL> """<STR_LIT>""" <EOL> print "<STR_LIT>" <EOL> print "<STR_LIT>" <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL> if len ( sys . argv ) == <NUM_LIT:1> : <EOL> print "<STR_LIT>" <EOL> CLI ( "<STR_LIT>" , "<STR_LIT>" ) . cmdloop ( ) <EOL> elif len ( sys . argv ) == <NUM_LIT:3> : <EOL> ctrl_addr = sys . argv [ <NUM_LIT:1> ] <EOL> sub_addr = sys . argv [ <NUM_LIT:2> ] <EOL> CLI ( ctrl_addr , sub_addr ) . cmdloop ( ) <EOL> else : <EOL> print "<STR_LIT>" </s>
<s> """<STR_LIT>""" <EOL> from random import randint <EOL> from os import path <EOL> import bot . lib . lib as lib <EOL> import bot . hardware . servo as s_mod <EOL> import tests . test_bot as test_bot <EOL> class TestPosition ( test_bot . TestBot ) : <EOL> """<STR_LIT>""" <EOL> def setUp ( self ) : <EOL> """<STR_LIT>""" <EOL> super ( TestPosition , self ) . setUp ( ) <EOL> config = path . dirname ( path . realpath ( __file__ ) ) + "<STR_LIT>" <EOL> self . config = lib . get_config ( config ) <EOL> self . pwm_num = self . config [ '<STR_LIT>' ] <EOL> self . setup_pwm ( self . pwm_num , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ) <EOL> self . servo = s_mod . Servo ( self . pwm_num ) <EOL> def tearDown ( self ) : <EOL> """<STR_LIT>""" <EOL> super ( TestPosition , self ) . tearDown ( ) <EOL> def test_0 ( self ) : <EOL> """<STR_LIT>""" <EOL> self . servo . position = <NUM_LIT:0> <EOL> assert self . servo . position == <NUM_LIT:0> , self . servo . position <EOL> def test_180 ( self ) : <EOL> """<STR_LIT>""" <EOL> self . servo . position = <NUM_LIT> <EOL> assert self . servo . position == <NUM_LIT> , self . servo . position <EOL> def test_middle ( self ) : <EOL> """<STR_LIT>""" <EOL> self . servo . position = <NUM_LIT> <EOL> assert self . servo . position == <NUM_LIT> , self . servo . position <EOL> def test_series ( self ) : <EOL> """<STR_LIT>""" <EOL> for position in range ( <NUM_LIT:0> , <NUM_LIT> , <NUM_LIT> ) : <EOL> self . servo . position = position <EOL> assert self . servo . position == position , self . servo . position <EOL> def test_manually_confirm ( self ) : <EOL> """<STR_LIT>""" <EOL> for i in range ( <NUM_LIT:10> ) : <EOL> test_pos = randint ( <NUM_LIT:0> , <NUM_LIT> ) <EOL> self . servo . position = test_pos <EOL> cur_pwm = self . get_pwm ( self . pwm_num ) <EOL> duty = int ( cur_pwm [ "<STR_LIT>" ] ) <EOL> read_pos = int ( round ( ( ( duty - <NUM_LIT> ) / <NUM_LIT> ) * <NUM_LIT> ) ) <EOL> assert read_pos == test_pos , "<STR_LIT>" . format ( read_pos , test_pos ) <EOL> def test_over_max ( self ) : <EOL> """<STR_LIT>""" <EOL> self . servo . position = <NUM_LIT> <EOL> assert self . servo . position == <NUM_LIT> , "<STR_LIT>" . format ( self . servo . position ) <EOL> def test_under_min ( self ) : <EOL> """<STR_LIT>""" <EOL> self . servo . position = - <NUM_LIT:1> <EOL> assert self . servo . position == <NUM_LIT:0> , "<STR_LIT>" . format ( self . servo . position ) </s>
<s> from django . contrib . syndication . views import Feed as SyndicationFeed <EOL> from django . core . urlresolvers import reverse <EOL> from django . conf import settings <EOL> from lifestream . models import Lifestream , Item <EOL> class RecentItemsFeed ( SyndicationFeed ) : <EOL> title = "<STR_LIT>" <EOL> description = "<STR_LIT>" <EOL> def link ( self , obj ) : <EOL> return reverse ( '<STR_LIT>' , kwargs = { <EOL> '<STR_LIT>' : obj . slug , <EOL> } ) <EOL> def get_object ( self , bits ) : <EOL> return Lifestream . objects . get ( slug = bits [ <NUM_LIT:0> ] ) <EOL> def items ( self , obj ) : <EOL> return Item . objects . published ( ) . filter ( feed__lifestream = obj ) [ : <NUM_LIT:10> ] <EOL> def item_pubdate ( self , item ) : <EOL> return item . date <EOL> def item_categories ( self , item ) : <EOL> def item_categories ( self , item ) : <EOL> if '<STR_LIT>' in settings . INSTALLED_APPS : <EOL> return [ tag . name for tag in item . tag_set ] <EOL> else : <EOL> return [ ] </s>
<s> """<STR_LIT>""" <EOL> from functools import update_wrapper <EOL> from google . appengine . api import users <EOL> from werkzeug import redirect <EOL> from werkzeug . exceptions import Forbidden <EOL> from kay . utils import ( <EOL> create_login_url , create_logout_url <EOL> ) <EOL> from kay . utils . decorators import auto_adapt_to_methods <EOL> def login_required ( func ) : <EOL> def inner ( request , * args , ** kwargs ) : <EOL> if request . user . is_anonymous ( ) : <EOL> if request . is_xhr : <EOL> return Forbidden ( ) <EOL> else : <EOL> return redirect ( create_login_url ( request . url ) ) <EOL> return func ( request , * args , ** kwargs ) <EOL> update_wrapper ( inner , func ) <EOL> return inner <EOL> login_required = auto_adapt_to_methods ( login_required ) <EOL> def admin_required ( func ) : <EOL> def inner ( request , * args , ** kwargs ) : <EOL> if not request . user . is_admin : <EOL> if request . user . is_anonymous ( ) : <EOL> return redirect ( create_login_url ( request . url ) ) <EOL> else : <EOL> raise Forbidden ( <EOL> description = <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' % <EOL> create_logout_url ( request . url ) <EOL> ) <EOL> return func ( request , * args , ** kwargs ) <EOL> update_wrapper ( inner , func ) <EOL> return inner <EOL> admin_required = auto_adapt_to_methods ( admin_required ) </s>
<s> """<STR_LIT>""" <EOL> PARSE_ERROR = - <NUM_LIT> <EOL> INVALID_REQUEST = - <NUM_LIT> <EOL> METHOD_NOT_FOUND = - <NUM_LIT> <EOL> INVALID_PARAMS = - <NUM_LIT> <EOL> INTERNAL_ERROR = - <NUM_LIT> <EOL> errors = { } <EOL> errors [ PARSE_ERROR ] = "<STR_LIT>" <EOL> errors [ INVALID_REQUEST ] = "<STR_LIT>" <EOL> errors [ METHOD_NOT_FOUND ] = "<STR_LIT>" <EOL> errors [ INVALID_PARAMS ] = "<STR_LIT>" <EOL> errors [ INTERNAL_ERROR ] = "<STR_LIT>" <EOL> try : <EOL> import json <EOL> except ImportError : <EOL> try : <EOL> import django . utils . simplejson as json <EOL> except ImportError : <EOL> import simplejson as json <EOL> import sys <EOL> import logging <EOL> import itertools <EOL> from werkzeug import Request , Response <EOL> from werkzeug import exceptions <EOL> class JsonRpcApplication ( object ) : <EOL> def __init__ ( self , methods = None ) : <EOL> if methods is not None : <EOL> self . methods = methods <EOL> else : <EOL> self . methods = { } <EOL> def add_module ( self , mod , namespace = None ) : <EOL> if namespace is None : <EOL> namespace = mod . __name__ <EOL> for k , v in ( ( k , v ) for k , v in mod . __dict__ . iteritems ( ) <EOL> if not k . startswith ( '<STR_LIT:_>' ) and callable ( v ) ) : <EOL> self . add ( namespace + '<STR_LIT:.>' + k , v ) <EOL> def add ( self , name , func ) : <EOL> self . methods [ name ] = func <EOL> def process ( self , data ) : <EOL> if data . get ( '<STR_LIT>' ) != "<STR_LIT>" : <EOL> return { '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:id>' : data . get ( '<STR_LIT:id>' ) , <EOL> '<STR_LIT:error>' : { '<STR_LIT:code>' : INVALID_REQUEST , <EOL> '<STR_LIT:message>' : errors [ INVALID_REQUEST ] } } <EOL> if '<STR_LIT>' not in data : <EOL> return { '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:id>' : data . get ( '<STR_LIT:id>' ) , <EOL> '<STR_LIT:error>' : { '<STR_LIT:code>' : INVALID_REQUEST , <EOL> '<STR_LIT:message>' : errors [ INVALID_REQUEST ] } } <EOL> methodname = data [ '<STR_LIT>' ] <EOL> if not isinstance ( methodname , basestring ) : <EOL> return { '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:id>' : data . get ( '<STR_LIT:id>' ) , <EOL> '<STR_LIT:error>' : { '<STR_LIT:code>' : INVALID_REQUEST , <EOL> '<STR_LIT:message>' : errors [ INVALID_REQUEST ] } } <EOL> if methodname . startswith ( '<STR_LIT:_>' ) : <EOL> return { '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:id>' : data . get ( '<STR_LIT:id>' ) , <EOL> '<STR_LIT:error>' : { '<STR_LIT:code>' : METHOD_NOT_FOUND , <EOL> '<STR_LIT:message>' : errors [ METHOD_NOT_FOUND ] } } <EOL> if methodname not in self . methods : <EOL> return { '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:id>' : data . get ( '<STR_LIT:id>' ) , <EOL> '<STR_LIT:error>' : { '<STR_LIT:code>' : METHOD_NOT_FOUND , <EOL> '<STR_LIT:message>' : errors [ METHOD_NOT_FOUND ] } } <EOL> method = self . methods [ methodname ] <EOL> try : <EOL> params = data . get ( '<STR_LIT>' , [ ] ) <EOL> if isinstance ( params , list ) : <EOL> result = method ( * params ) <EOL> elif isinstance ( params , dict ) : <EOL> result = method ( ** dict ( [ ( str ( k ) , v ) for k , v in params . iteritems ( ) ] ) ) <EOL> else : <EOL> return { '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:id>' : data . get ( '<STR_LIT:id>' ) , <EOL> '<STR_LIT:error>' : { '<STR_LIT:code>' : INVALID_REQUEST , <EOL> '<STR_LIT:message>' : errors [ INVALID_REQUEST ] } } <EOL> resdata = None <EOL> if data . get ( '<STR_LIT:id>' ) : <EOL> resdata = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:id>' : data . get ( '<STR_LIT:id>' ) , <EOL> '<STR_LIT:result>' : result , <EOL> } <EOL> return resdata <EOL> except Exception , e : <EOL> return { '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:id>' : data . get ( '<STR_LIT:id>' ) , <EOL> '<STR_LIT:error>' : { '<STR_LIT:code>' : INTERNAL_ERROR , <EOL> '<STR_LIT:message>' : errors [ INTERNAL_ERROR ] , <EOL> '<STR_LIT:data>' : str ( e ) } } <EOL> def __call__ ( self , environ , start_response ) : <EOL> request = Request ( environ ) <EOL> if request . method != "<STR_LIT:POST>" : <EOL> raise exceptions . MethodNotAllowed <EOL> if not request . content_type . startswith ( '<STR_LIT:application/json>' ) : <EOL> raise exceptions . BadRequest <EOL> try : <EOL> data = json . loads ( request . data ) <EOL> except ValueError , e : <EOL> resdata = { '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:id>' : None , <EOL> '<STR_LIT:error>' : { '<STR_LIT:code>' : PARSE_ERROR , <EOL> '<STR_LIT:message>' : errors [ PARSE_ERROR ] } } <EOL> else : <EOL> if isinstance ( data , dict ) : <EOL> resdata = self . process ( data ) <EOL> elif isinstance ( data , list ) : <EOL> if len ( [ x for x in data if not isinstance ( x , dict ) ] ) : <EOL> resdata = { '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:id>' : None , <EOL> '<STR_LIT:error>' : { '<STR_LIT:code>' : INVALID_REQUEST , <EOL> '<STR_LIT:message>' : errors [ INVALID_REQUEST ] } } <EOL> else : <EOL> resdata = [ d for d in ( self . process ( d ) for d in data ) <EOL> if d is not None ] <EOL> response = Response ( content_type = "<STR_LIT:application/json>" ) <EOL> if resdata : <EOL> response . headers [ "<STR_LIT>" ] = "<STR_LIT>" <EOL> response . headers [ "<STR_LIT>" ] = "<STR_LIT>" <EOL> response . headers [ "<STR_LIT>" ] = "<STR_LIT>" <EOL> response . data = json . dumps ( resdata ) <EOL> return response ( environ , start_response ) <EOL> def getmod ( modname ) : <EOL> try : <EOL> __import__ ( modname ) <EOL> except ImportError , e : <EOL> logging . warn ( "<STR_LIT>" % e ) <EOL> return None <EOL> mod = sys . modules [ modname ] <EOL> return mod <EOL> def HTTPExceptionMiddleware ( app ) : <EOL> def wrap ( environ , start_response ) : <EOL> try : <EOL> return app ( environ , start_response ) <EOL> except exceptions . HTTPException , e : <EOL> return e ( environ , start_response ) <EOL> return wrap <EOL> def make_application ( methods ) : <EOL> app = JsonRpcApplication ( ) <EOL> for name , value in methods . iteritems ( ) : <EOL> if "<STR_LIT::>" in value : <EOL> modname , funcname = value . split ( "<STR_LIT::>" , <NUM_LIT:1> ) <EOL> mod = getmod ( modname ) <EOL> if mod : <EOL> app . add ( name , getattr ( mod , funcname ) ) <EOL> else : <EOL> modname = value <EOL> mod = getmod ( modname ) <EOL> if mod : <EOL> app . add_module ( mod , name ) <EOL> app = HTTPExceptionMiddleware ( app ) <EOL> return app </s>
<s> """<STR_LIT>""" <EOL> import re <EOL> from jinja2 . runtime import Undefined <EOL> __test__ = False <EOL> number_re = re . compile ( r'<STR_LIT>' ) <EOL> regex_type = type ( number_re ) <EOL> try : <EOL> test_callable = callable <EOL> except NameError : <EOL> def test_callable ( x ) : <EOL> return hasattr ( x , '<STR_LIT>' ) <EOL> def test_odd ( value ) : <EOL> """<STR_LIT>""" <EOL> return value % <NUM_LIT:2> == <NUM_LIT:1> <EOL> def test_even ( value ) : <EOL> """<STR_LIT>""" <EOL> return value % <NUM_LIT:2> == <NUM_LIT:0> <EOL> def test_divisibleby ( value , num ) : <EOL> """<STR_LIT>""" <EOL> return value % num == <NUM_LIT:0> <EOL> def test_defined ( value ) : <EOL> """<STR_LIT>""" <EOL> return not isinstance ( value , Undefined ) <EOL> def test_undefined ( value ) : <EOL> """<STR_LIT>""" <EOL> return isinstance ( value , Undefined ) <EOL> def test_none ( value ) : <EOL> """<STR_LIT>""" <EOL> return value is None <EOL> def test_lower ( value ) : <EOL> """<STR_LIT>""" <EOL> return unicode ( value ) . islower ( ) <EOL> def test_upper ( value ) : <EOL> """<STR_LIT>""" <EOL> return unicode ( value ) . isupper ( ) <EOL> def test_string ( value ) : <EOL> """<STR_LIT>""" <EOL> return isinstance ( value , basestring ) <EOL> def test_number ( value ) : <EOL> """<STR_LIT>""" <EOL> return isinstance ( value , ( int , long , float , complex ) ) <EOL> def test_sequence ( value ) : <EOL> """<STR_LIT>""" <EOL> try : <EOL> len ( value ) <EOL> value . __getitem__ <EOL> except : <EOL> return False <EOL> return True <EOL> def test_sameas ( value , other ) : <EOL> """<STR_LIT>""" <EOL> return value is other <EOL> def test_iterable ( value ) : <EOL> """<STR_LIT>""" <EOL> try : <EOL> iter ( value ) <EOL> except TypeError : <EOL> return False <EOL> return True <EOL> def test_escaped ( value ) : <EOL> """<STR_LIT>""" <EOL> return hasattr ( value , '<STR_LIT>' ) <EOL> TESTS = { <EOL> '<STR_LIT>' : test_odd , <EOL> '<STR_LIT>' : test_even , <EOL> '<STR_LIT>' : test_divisibleby , <EOL> '<STR_LIT>' : test_defined , <EOL> '<STR_LIT>' : test_undefined , <EOL> '<STR_LIT:none>' : test_none , <EOL> '<STR_LIT>' : test_lower , <EOL> '<STR_LIT>' : test_upper , <EOL> '<STR_LIT:string>' : test_string , <EOL> '<STR_LIT>' : test_number , <EOL> '<STR_LIT>' : test_sequence , <EOL> '<STR_LIT>' : test_iterable , <EOL> '<STR_LIT>' : test_callable , <EOL> '<STR_LIT>' : test_sameas , <EOL> '<STR_LIT>' : test_escaped <EOL> } </s>
<s> """<STR_LIT>""" <EOL> import re <EOL> import codecs <EOL> import mimetypes <EOL> from werkzeug . _internal import _proxy_repr , _missing , _empty_stream <EOL> _locale_delim_re = re . compile ( r'<STR_LIT>' ) <EOL> def is_immutable ( self ) : <EOL> raise TypeError ( '<STR_LIT>' % self . __class__ . __name__ ) <EOL> def iter_multi_items ( mapping ) : <EOL> """<STR_LIT>""" <EOL> if isinstance ( mapping , MultiDict ) : <EOL> for item in mapping . iteritems ( multi = True ) : <EOL> yield item <EOL> elif isinstance ( mapping , dict ) : <EOL> for key , value in mapping . iteritems ( ) : <EOL> if isinstance ( value , ( tuple , list ) ) : <EOL> for value in value : <EOL> yield key , value <EOL> else : <EOL> yield key , value <EOL> else : <EOL> for item in mapping : <EOL> yield item <EOL> class ImmutableListMixin ( object ) : <EOL> """<STR_LIT>""" <EOL> def __reduce_ex__ ( self , protocol ) : <EOL> return type ( self ) , ( list ( self ) , ) <EOL> def __delitem__ ( self , key ) : <EOL> is_immutable ( self ) <EOL> def __delslice__ ( self , i , j ) : <EOL> is_immutable ( self ) <EOL> def __iadd__ ( self , other ) : <EOL> is_immutable ( self ) <EOL> __imul__ = __iadd__ <EOL> def __setitem__ ( self , key , value ) : <EOL> is_immutable ( self ) <EOL> def __setslice__ ( self , i , j , value ) : <EOL> is_immutable ( self ) <EOL> def append ( self , item ) : <EOL> is_immutable ( self ) <EOL> remove = append <EOL> def extend ( self , iterable ) : <EOL> is_immutable ( self ) <EOL> def insert ( self , pos , value ) : <EOL> is_immutable ( self ) <EOL> def pop ( self , index = - <NUM_LIT:1> ) : <EOL> is_immutable ( self ) <EOL> def reverse ( self ) : <EOL> is_immutable ( self ) <EOL> def sort ( self , cmp = None , key = None , reverse = None ) : <EOL> is_immutable ( self ) <EOL> class ImmutableList ( ImmutableListMixin , list ) : <EOL> """<STR_LIT>""" <EOL> __repr__ = _proxy_repr ( list ) <EOL> class ImmutableDictMixin ( object ) : <EOL> """<STR_LIT>""" <EOL> def __reduce_ex__ ( self , protocol ) : <EOL> return type ( self ) , ( dict ( self ) , ) <EOL> def setdefault ( self , key , default = None ) : <EOL> is_immutable ( self ) <EOL> def update ( self , * args , ** kwargs ) : <EOL> is_immutable ( self ) <EOL> def pop ( self , key , default = None ) : <EOL> is_immutable ( self ) <EOL> def popitem ( self ) : <EOL> is_immutable ( self ) <EOL> def __setitem__ ( self , key , value ) : <EOL> is_immutable ( self ) <EOL> def __delitem__ ( self , key ) : <EOL> is_immutable ( self ) <EOL> def clear ( self ) : <EOL> is_immutable ( self ) <EOL> class ImmutableMultiDictMixin ( ImmutableDictMixin ) : <EOL> """<STR_LIT>""" <EOL> def __reduce_ex__ ( self , protocol ) : <EOL> return type ( self ) , ( self . items ( multi = True ) , ) <EOL> def add ( self , key , value ) : <EOL> is_immutable ( self ) <EOL> def popitemlist ( self ) : <EOL> is_immutable ( self ) <EOL> def poplist ( self , key ) : <EOL> is_immutable ( self ) <EOL> def setlist ( self , key , new_list ) : <EOL> is_immutable ( self ) <EOL> def setlistdefault ( self , key , default_list = None ) : <EOL> is_immutable ( self ) <EOL> class UpdateDictMixin ( object ) : <EOL> """<STR_LIT>""" <EOL> on_update = None <EOL> def calls_update ( name ) : <EOL> def oncall ( self , * args , ** kw ) : <EOL> rv = getattr ( super ( UpdateDictMixin , self ) , name ) ( * args , ** kw ) <EOL> if self . on_update is not None : <EOL> self . on_update ( self ) <EOL> return rv <EOL> oncall . __name__ = name <EOL> return oncall <EOL> __setitem__ = calls_update ( '<STR_LIT>' ) <EOL> __delitem__ = calls_update ( '<STR_LIT>' ) <EOL> clear = calls_update ( '<STR_LIT>' ) <EOL> pop = calls_update ( '<STR_LIT>' ) <EOL> popitem = calls_update ( '<STR_LIT>' ) <EOL> setdefault = calls_update ( '<STR_LIT>' ) <EOL> update = calls_update ( '<STR_LIT>' ) <EOL> del calls_update <EOL> class TypeConversionDict ( dict ) : <EOL> """<STR_LIT>""" <EOL> def get ( self , key , default = None , type = None ) : <EOL> """<STR_LIT>""" <EOL> try : <EOL> rv = self [ key ] <EOL> if type is not None : <EOL> rv = type ( rv ) <EOL> except ( KeyError , ValueError ) : <EOL> rv = default <EOL> return rv <EOL> class ImmutableTypeConversionDict ( ImmutableDictMixin , TypeConversionDict ) : <EOL> """<STR_LIT>""" <EOL> def copy ( self ) : <EOL> """<STR_LIT>""" <EOL> return TypeConversionDict ( self ) <EOL> def __copy__ ( self ) : <EOL> return self <EOL> class MultiDict ( TypeConversionDict ) : <EOL> """<STR_LIT>""" <EOL> KeyError = None <EOL> def __init__ ( self , mapping = None ) : <EOL> if isinstance ( mapping , MultiDict ) : <EOL> dict . __init__ ( self , ( ( k , l [ : ] ) for k , l in mapping . iterlists ( ) ) ) <EOL> elif isinstance ( mapping , dict ) : <EOL> tmp = { } <EOL> for key , value in mapping . iteritems ( ) : <EOL> if isinstance ( value , ( tuple , list ) ) : <EOL> value = list ( value ) <EOL> else : <EOL> value = [ value ] <EOL> tmp [ key ] = value <EOL> dict . __init__ ( self , tmp ) <EOL> else : <EOL> tmp = { } <EOL> for key , value in mapping or ( ) : <EOL> tmp . setdefault ( key , [ ] ) . append ( value ) <EOL> dict . __init__ ( self , tmp ) <EOL> def __getstate__ ( self ) : <EOL> return dict ( self . lists ( ) ) <EOL> def __setstate__ ( self , value ) : <EOL> dict . clear ( self ) <EOL> dict . update ( self , value ) <EOL> def __iter__ ( self ) : <EOL> return self . iterkeys ( ) <EOL> def __getitem__ ( self , key ) : <EOL> """<STR_LIT>""" <EOL> if key in self : <EOL> return dict . __getitem__ ( self , key ) [ <NUM_LIT:0> ] <EOL> raise self . KeyError ( key ) <EOL> def __setitem__ ( self , key , value ) : <EOL> """<STR_LIT>""" <EOL> dict . __setitem__ ( self , key , [ value ] ) <EOL> def add ( self , key , value ) : <EOL> """<STR_LIT>""" <EOL> dict . setdefault ( self , key , [ ] ) . append ( value ) <EOL> def getlist ( self , key , type = None ) : <EOL> """<STR_LIT>""" <EOL> try : <EOL> rv = dict . __getitem__ ( self , key ) <EOL> except KeyError : <EOL> return [ ] <EOL> if type is None : <EOL> return list ( rv ) <EOL> result = [ ] <EOL> for item in rv : <EOL> try : <EOL> result . append ( type ( item ) ) <EOL> except ValueError : <EOL> pass <EOL> return result <EOL> def setlist ( self , key , new_list ) : <EOL> """<STR_LIT>""" <EOL> dict . __setitem__ ( self , key , list ( new_list ) ) <EOL> def setdefault ( self , key , default = None ) : <EOL> """<STR_LIT>""" <EOL> if key not in self : <EOL> self [ key ] = default <EOL> else : <EOL> default = self [ key ] <EOL> return default <EOL> def setlistdefault ( self , key , default_list = None ) : <EOL> """<STR_LIT>""" <EOL> if key not in self : <EOL> default_list = list ( default_list or ( ) ) <EOL> dict . __setitem__ ( self , key , default_list ) <EOL> else : <EOL> default_list = dict . __getitem__ ( self , key ) <EOL> return default_list <EOL> def items ( self , multi = False ) : <EOL> """<STR_LIT>""" <EOL> return list ( self . iteritems ( multi ) ) <EOL> def lists ( self ) : <EOL> """<STR_LIT>""" <EOL> return list ( self . iterlists ( ) ) <EOL> def values ( self ) : <EOL> """<STR_LIT>""" <EOL> return [ self [ key ] for key in self . iterkeys ( ) ] <EOL> def listvalues ( self ) : <EOL> """<STR_LIT>""" <EOL> return list ( self . iterlistvalues ( ) ) <EOL> def iteritems ( self , multi = False ) : <EOL> """<STR_LIT>""" <EOL> for key , values in dict . iteritems ( self ) : <EOL> if multi : <EOL> for value in values : <EOL> yield key , value <EOL> else : <EOL> yield key , values [ <NUM_LIT:0> ] <EOL> def iterlists ( self ) : <EOL> """<STR_LIT>""" <EOL> for key , values in dict . iteritems ( self ) : <EOL> yield key , list ( values ) <EOL> def itervalues ( self ) : <EOL> """<STR_LIT>""" <EOL> for values in dict . itervalues ( self ) : <EOL> yield values [ <NUM_LIT:0> ] <EOL> def iterlistvalues ( self ) : <EOL> """<STR_LIT>""" <EOL> for values in dict . itervalues ( self ) : <EOL> yield list ( values ) <EOL> def copy ( self ) : <EOL> """<STR_LIT>""" <EOL> return self . __class__ ( self ) <EOL> def to_dict ( self , flat = True ) : <EOL> """<STR_LIT>""" <EOL> if flat : <EOL> return dict ( self . iteritems ( ) ) <EOL> return dict ( self . lists ( ) ) <EOL> def update ( self , other_dict ) : <EOL> """<STR_LIT>""" <EOL> for key , value in iter_multi_items ( other_dict ) : <EOL> MultiDict . add ( self , key , value ) <EOL> def pop ( self , key , default = _missing ) : <EOL> """<STR_LIT>""" <EOL> try : <EOL> return dict . pop ( self , key ) [ <NUM_LIT:0> ] <EOL> except KeyError , e : <EOL> if default is not _missing : <EOL> return default <EOL> raise self . KeyError ( str ( e ) ) <EOL> def popitem ( self ) : <EOL> """<STR_LIT>""" <EOL> try : <EOL> item = dict . popitem ( self ) <EOL> return ( item [ <NUM_LIT:0> ] , item [ <NUM_LIT:1> ] [ <NUM_LIT:0> ] ) <EOL> except KeyError , e : <EOL> raise self . KeyError ( str ( e ) ) <EOL> def poplist ( self , key ) : <EOL> """<STR_LIT>""" <EOL> return dict . pop ( self , key , [ ] ) <EOL> def popitemlist ( self ) : <EOL> """<STR_LIT>""" <EOL> try : <EOL> return dict . popitem ( self ) <EOL> except KeyError , e : <EOL> raise self . KeyError ( str ( e ) ) <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % ( self . __class__ . __name__ , self . items ( multi = True ) ) <EOL> class _omd_bucket ( object ) : <EOL> """<STR_LIT>""" <EOL> __slots__ = ( '<STR_LIT>' , '<STR_LIT:key>' , '<STR_LIT:value>' , '<STR_LIT>' ) <EOL> def __init__ ( self , omd , key , value ) : <EOL> self . prev = omd . _last_bucket <EOL> self . key = key <EOL> self . value = value <EOL> self . next = None <EOL> if omd . _first_bucket is None : <EOL> omd . _first_bucket = self <EOL> if omd . _last_bucket is not None : <EOL> omd . _last_bucket . next = self <EOL> omd . _last_bucket = self <EOL> def unlink ( self , omd ) : <EOL> if self . prev : <EOL> self . prev . next = self . next <EOL> if self . next : <EOL> self . next . prev = self . prev <EOL> if omd . _first_bucket is self : <EOL> omd . _first_bucket = self . next <EOL> if omd . _last_bucket is self : <EOL> omd . _last_bucket = self . prev <EOL> class OrderedMultiDict ( MultiDict ) : <EOL> """<STR_LIT>""" <EOL> KeyError = None <EOL> def __init__ ( self , mapping = None ) : <EOL> dict . __init__ ( self ) <EOL> self . _first_bucket = self . _last_bucket = None <EOL> if mapping is not None : <EOL> OrderedMultiDict . update ( self , mapping ) <EOL> def __eq__ ( self , other ) : <EOL> if not isinstance ( other , MultiDict ) : <EOL> return NotImplemented <EOL> if isinstance ( other , OrderedMultiDict ) : <EOL> iter1 = self . iteritems ( multi = True ) <EOL> iter2 = other . iteritems ( multi = True ) <EOL> try : <EOL> for k1 , v1 in iter1 : <EOL> k2 , v2 = iter2 . next ( ) <EOL> if k1 != k2 or v1 != v2 : <EOL> return False <EOL> except StopIteration : <EOL> return False <EOL> try : <EOL> iter2 . next ( ) <EOL> except StopIteration : <EOL> return True <EOL> return False <EOL> if len ( self ) != len ( other ) : <EOL> return False <EOL> for key , values in self . iterlists ( ) : <EOL> if other . getlist ( key ) != values : <EOL> return False <EOL> return True <EOL> def __ne__ ( self , other ) : <EOL> return not self . __eq__ ( other ) <EOL> def __reduce_ex__ ( self , protocol ) : <EOL> return type ( self ) , ( self . items ( multi = True ) , ) <EOL> def __getstate__ ( self ) : <EOL> return self . items ( multi = True ) <EOL> def __setstate__ ( self , values ) : <EOL> dict . clear ( self ) <EOL> for key , value in values : <EOL> self . add ( key , value ) <EOL> def __getitem__ ( self , key ) : <EOL> if key in self : <EOL> return dict . __getitem__ ( self , key ) [ <NUM_LIT:0> ] . value <EOL> raise self . KeyError ( key ) <EOL> def __setitem__ ( self , key , value ) : <EOL> self . poplist ( key ) <EOL> self . add ( key , value ) <EOL> def __delitem__ ( self , key ) : <EOL> self . pop ( key ) <EOL> def iterkeys ( self ) : <EOL> return ( key for key , value in self . iteritems ( ) ) <EOL> def itervalues ( self ) : <EOL> return ( value for key , value in self . iteritems ( ) ) <EOL> def iteritems ( self , multi = False ) : <EOL> ptr = self . _first_bucket <EOL> if multi : <EOL> while ptr is not None : <EOL> yield ptr . key , ptr . value <EOL> ptr = ptr . next <EOL> else : <EOL> returned_keys = set ( ) <EOL> while ptr is not None : <EOL> if ptr . key not in returned_keys : <EOL> returned_keys . add ( ptr . key ) <EOL> yield ptr . key , ptr . value <EOL> ptr = ptr . next <EOL> def iterlists ( self ) : <EOL> returned_keys = set ( ) <EOL> ptr = self . _first_bucket <EOL> while ptr is not None : <EOL> if ptr . key not in returned_keys : <EOL> yield ptr . key , self . getlist ( ptr . key ) <EOL> returned_keys . add ( ptr . key ) <EOL> ptr = ptr . next <EOL> def iterlistvalues ( self ) : <EOL> for key , values in self . iterlists ( ) : <EOL> yield values <EOL> def add ( self , key , value ) : <EOL> dict . setdefault ( self , key , [ ] ) . append ( _omd_bucket ( self , key , value ) ) <EOL> def getlist ( self , key , type = None ) : <EOL> try : <EOL> rv = dict . __getitem__ ( self , key ) <EOL> except KeyError : <EOL> return [ ] <EOL> if type is None : <EOL> return [ x . value for x in rv ] <EOL> result = [ ] <EOL> for item in rv : <EOL> try : <EOL> result . append ( type ( item . value ) ) <EOL> except ValueError : <EOL> pass <EOL> return result <EOL> def setlist ( self , key , new_list ) : <EOL> self . poplist ( key ) <EOL> for value in new_list : <EOL> self . add ( key , value ) <EOL> def setlistdefault ( self , key , default_list = None ) : <EOL> raise TypeError ( '<STR_LIT>' <EOL> '<STR_LIT>' ) <EOL> def update ( self , mapping ) : <EOL> for key , value in iter_multi_items ( mapping ) : <EOL> OrderedMultiDict . add ( self , key , value ) <EOL> def poplist ( self , key ) : <EOL> buckets = dict . pop ( self , key , ( ) ) <EOL> for bucket in buckets : <EOL> bucket . unlink ( self ) <EOL> return [ x . value for x in buckets ] <EOL> def pop ( self , key , default = _missing ) : <EOL> try : <EOL> buckets = dict . pop ( self , key ) <EOL> except KeyError , e : <EOL> if default is not _missing : <EOL> return default <EOL> raise self . KeyError ( str ( e ) ) <EOL> for bucket in buckets : <EOL> bucket . unlink ( self ) <EOL> return buckets [ <NUM_LIT:0> ] . value <EOL> def popitem ( self ) : <EOL> try : <EOL> key , buckets = dict . popitem ( self ) <EOL> except KeyError , e : <EOL> raise self . KeyError ( str ( e ) ) <EOL> for bucket in buckets : <EOL> bucket . unlink ( self ) <EOL> return key , buckets [ <NUM_LIT:0> ] . value <EOL> def popitemlist ( self ) : <EOL> try : <EOL> key , buckets = dict . popitem ( self ) <EOL> except KeyError , e : <EOL> raise self . KeyError ( str ( e ) ) <EOL> for bucket in buckets : <EOL> bucket . unlink ( self ) <EOL> return key , [ x . value for x in buckets ] <EOL> def _options_header_vkw ( value , kw ) : <EOL> if not kw : <EOL> return value <EOL> return dump_options_header ( value , dict ( ( k . replace ( '<STR_LIT:_>' , '<STR_LIT:->' ) , v ) <EOL> for k , v in kw . items ( ) ) ) <EOL> class Headers ( object ) : <EOL> """<STR_LIT>""" <EOL> KeyError = None <EOL> def __init__ ( self , defaults = None , _list = None ) : <EOL> if _list is None : <EOL> _list = [ ] <EOL> self . _list = _list <EOL> if defaults is not None : <EOL> if isinstance ( defaults , ( list , Headers ) ) : <EOL> self . _list . extend ( defaults ) <EOL> else : <EOL> self . extend ( defaults ) <EOL> @ classmethod <EOL> def linked ( cls , headerlist ) : <EOL> """<STR_LIT>""" <EOL> return cls ( _list = headerlist ) <EOL> def __getitem__ ( self , key , _index_operation = True ) : <EOL> if _index_operation : <EOL> if isinstance ( key , ( int , long ) ) : <EOL> return self . _list [ key ] <EOL> elif isinstance ( key , slice ) : <EOL> return self . __class__ ( self . _list [ key ] ) <EOL> ikey = key . lower ( ) <EOL> for k , v in self . _list : <EOL> if k . lower ( ) == ikey : <EOL> return v <EOL> raise self . KeyError ( key ) <EOL> def __eq__ ( self , other ) : <EOL> return other . __class__ is self . __class__ and set ( other . _list ) == set ( self . _list ) <EOL> def __ne__ ( self , other ) : <EOL> return not self . __eq__ ( other ) <EOL> def get ( self , key , default = None , type = None ) : <EOL> """<STR_LIT>""" <EOL> try : <EOL> rv = self . __getitem__ ( key , _index_operation = False ) <EOL> except KeyError : <EOL> return default <EOL> if type is None : <EOL> return rv <EOL> try : <EOL> return type ( rv ) <EOL> except ValueError : <EOL> return default <EOL> def getlist ( self , key , type = None ) : <EOL> """<STR_LIT>""" <EOL> ikey = key . lower ( ) <EOL> result = [ ] <EOL> for k , v in self : <EOL> if k . lower ( ) == ikey : <EOL> if type is not None : <EOL> try : <EOL> v = type ( v ) <EOL> except ValueError : <EOL> continue <EOL> result . append ( v ) <EOL> return result <EOL> def get_all ( self , name ) : <EOL> """<STR_LIT>""" <EOL> return self . getlist ( name ) <EOL> def iteritems ( self , lower = False ) : <EOL> for key , value in self : <EOL> if lower : <EOL> key = key . lower ( ) <EOL> yield key , value <EOL> def iterkeys ( self , lower = False ) : <EOL> for key , _ in self . iteritems ( lower ) : <EOL> yield key <EOL> def itervalues ( self ) : <EOL> for _ , value in self . iteritems ( ) : <EOL> yield value <EOL> def keys ( self , lower = False ) : <EOL> return list ( self . iterkeys ( lower ) ) <EOL> def values ( self ) : <EOL> return list ( self . itervalues ( ) ) <EOL> def items ( self , lower = False ) : <EOL> return list ( self . iteritems ( lower ) ) <EOL> def extend ( self , iterable ) : <EOL> """<STR_LIT>""" <EOL> if isinstance ( iterable , dict ) : <EOL> for key , value in iterable . iteritems ( ) : <EOL> if isinstance ( value , ( tuple , list ) ) : <EOL> for v in value : <EOL> self . add ( key , v ) <EOL> else : <EOL> self . add ( key , value ) <EOL> else : <EOL> for key , value in iterable : <EOL> self . add ( key , value ) <EOL> def __delitem__ ( self , key , _index_operation = True ) : <EOL> if _index_operation and isinstance ( key , ( int , long , slice ) ) : <EOL> del self . _list [ key ] <EOL> return <EOL> key = key . lower ( ) <EOL> new = [ ] <EOL> for k , v in self . _list : <EOL> if k . lower ( ) != key : <EOL> new . append ( ( k , v ) ) <EOL> self . _list [ : ] = new <EOL> def remove ( self , key ) : <EOL> """<STR_LIT>""" <EOL> return self . __delitem__ ( key , _index_operation = False ) <EOL> def pop ( self , key = None , default = _missing ) : <EOL> """<STR_LIT>""" <EOL> if key is None : <EOL> return self . _list . pop ( ) <EOL> if isinstance ( key , ( int , long ) ) : <EOL> return self . _list . pop ( key ) <EOL> try : <EOL> rv = self [ key ] <EOL> self . remove ( key ) <EOL> except KeyError : <EOL> if default is not _missing : <EOL> return default <EOL> raise <EOL> return rv <EOL> def popitem ( self ) : <EOL> """<STR_LIT>""" <EOL> return self . pop ( ) <EOL> def __contains__ ( self , key ) : <EOL> """<STR_LIT>""" <EOL> try : <EOL> self . __getitem__ ( key , _index_operation = False ) <EOL> except KeyError : <EOL> return False <EOL> return True <EOL> has_key = __contains__ <EOL> def __iter__ ( self ) : <EOL> """<STR_LIT>""" <EOL> return iter ( self . _list ) <EOL> def __len__ ( self ) : <EOL> return len ( self . _list ) <EOL> def add ( self , _key , _value , ** kw ) : <EOL> """<STR_LIT>""" <EOL> self . _list . append ( ( _key , _options_header_vkw ( _value , kw ) ) ) <EOL> def add_header ( self , _key , _value , ** _kw ) : <EOL> """<STR_LIT>""" <EOL> self . add ( _key , _value , ** _kw ) <EOL> def clear ( self ) : <EOL> """<STR_LIT>""" <EOL> del self . _list [ : ] <EOL> def set ( self , _key , _value , ** kw ) : <EOL> """<STR_LIT>""" <EOL> lc_key = _key . lower ( ) <EOL> _value = _options_header_vkw ( _value , kw ) <EOL> for idx , ( old_key , old_value ) in enumerate ( self . _list ) : <EOL> if old_key . lower ( ) == lc_key : <EOL> self . _list [ idx ] = ( _key , _value ) <EOL> break <EOL> else : <EOL> return self . add ( _key , _value ) <EOL> self . _list [ idx + <NUM_LIT:1> : ] = [ ( k , v ) for k , v in self . _list [ idx + <NUM_LIT:1> : ] <EOL> if k . lower ( ) != lc_key ] <EOL> def setdefault ( self , key , value ) : <EOL> """<STR_LIT>""" <EOL> if key in self : <EOL> return self [ key ] <EOL> self . set ( key , value ) <EOL> return value <EOL> def __setitem__ ( self , key , value ) : <EOL> """<STR_LIT>""" <EOL> if isinstance ( key , ( slice , int , long ) ) : <EOL> self . _list [ key ] = value <EOL> else : <EOL> self . set ( key , value ) <EOL> def to_list ( self , charset = '<STR_LIT:utf-8>' ) : <EOL> """<STR_LIT>""" <EOL> result = [ ] <EOL> for k , v in self : <EOL> if isinstance ( v , unicode ) : <EOL> v = v . encode ( charset ) <EOL> else : <EOL> v = str ( v ) <EOL> result . append ( ( k , v ) ) <EOL> return result <EOL> def copy ( self ) : <EOL> return self . __class__ ( self . _list ) <EOL> def __copy__ ( self ) : <EOL> return self . copy ( ) <EOL> def __str__ ( self , charset = '<STR_LIT:utf-8>' ) : <EOL> """<STR_LIT>""" <EOL> strs = [ ] <EOL> for key , value in self . to_list ( charset ) : <EOL> strs . append ( '<STR_LIT>' % ( key , value ) ) <EOL> strs . append ( '<STR_LIT:\r\n>' ) <EOL> return '<STR_LIT:\r\n>' . join ( strs ) <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % ( <EOL> self . __class__ . __name__ , <EOL> list ( self ) <EOL> ) <EOL> class ImmutableHeadersMixin ( object ) : <EOL> """<STR_LIT>""" <EOL> def __delitem__ ( self , key ) : <EOL> is_immutable ( self ) <EOL> def __setitem__ ( self , key , value ) : <EOL> is_immutable ( self ) <EOL> set = __setitem__ <EOL> def add ( self , item ) : <EOL> is_immutable ( self ) <EOL> remove = add_header = add <EOL> def extend ( self , iterable ) : <EOL> is_immutable ( self ) <EOL> def insert ( self , pos , value ) : <EOL> is_immutable ( self ) <EOL> def pop ( self , index = - <NUM_LIT:1> ) : <EOL> is_immutable ( self ) <EOL> def popitem ( self ) : <EOL> is_immutable ( self ) <EOL> def setdefault ( self , key , default ) : <EOL> is_immutable ( self ) <EOL> class EnvironHeaders ( ImmutableHeadersMixin , Headers ) : <EOL> """<STR_LIT>""" <EOL> def __init__ ( self , environ ) : <EOL> self . environ = environ <EOL> @ classmethod <EOL> def linked ( cls , environ ) : <EOL> raise TypeError ( '<STR_LIT>' <EOL> '<STR_LIT>' % cls . __name__ ) <EOL> def __eq__ ( self , other ) : <EOL> return self . environ is other . environ <EOL> def __getitem__ ( self , key , _index_operation = False ) : <EOL> key = key . upper ( ) . replace ( '<STR_LIT:->' , '<STR_LIT:_>' ) <EOL> if key in ( '<STR_LIT>' , '<STR_LIT>' ) : <EOL> return self . environ [ key ] <EOL> return self . environ [ '<STR_LIT>' + key ] <EOL> def __len__ ( self ) : <EOL> return len ( list ( iter ( self ) ) ) <EOL> def __iter__ ( self ) : <EOL> for key , value in self . environ . iteritems ( ) : <EOL> if key . startswith ( '<STR_LIT>' ) and key not in ( '<STR_LIT>' , '<STR_LIT>' ) : <EOL> yield key [ <NUM_LIT:5> : ] . replace ( '<STR_LIT:_>' , '<STR_LIT:->' ) . title ( ) , value <EOL> elif key in ( '<STR_LIT>' , '<STR_LIT>' ) : <EOL> yield key . replace ( '<STR_LIT:_>' , '<STR_LIT:->' ) . title ( ) , value <EOL> def copy ( self ) : <EOL> raise TypeError ( '<STR_LIT>' % self . __class__ . __name__ ) <EOL> class CombinedMultiDict ( ImmutableMultiDictMixin , MultiDict ) : <EOL> """<STR_LIT>""" <EOL> def __reduce_ex__ ( self , protocol ) : <EOL> return type ( self ) , ( self . dicts , ) <EOL> def __init__ ( self , dicts = None ) : <EOL> self . dicts = dicts or [ ] <EOL> @ classmethod <EOL> def fromkeys ( cls ) : <EOL> raise TypeError ( '<STR_LIT>' % <EOL> cls . __name__ ) <EOL> def __getitem__ ( self , key ) : <EOL> for d in self . dicts : <EOL> if key in d : <EOL> return d [ key ] <EOL> raise self . KeyError ( key ) <EOL> def get ( self , key , default = None , type = None ) : <EOL> for d in self . dicts : <EOL> if key in d : <EOL> if type is not None : <EOL> try : <EOL> return type ( d [ key ] ) <EOL> except ValueError : <EOL> continue <EOL> return d [ key ] <EOL> return default <EOL> def getlist ( self , key , type = None ) : <EOL> rv = [ ] <EOL> for d in self . dicts : <EOL> rv . extend ( d . getlist ( key , type ) ) <EOL> return rv <EOL> def keys ( self ) : <EOL> rv = set ( ) <EOL> for d in self . dicts : <EOL> rv . update ( d . keys ( ) ) <EOL> return list ( rv ) <EOL> def iteritems ( self , multi = False ) : <EOL> found = set ( ) <EOL> for d in self . dicts : <EOL> for key , value in d . iteritems ( multi ) : <EOL> if multi : <EOL> yield key , value <EOL> elif key not in found : <EOL> found . add ( key ) <EOL> yield key , value <EOL> def itervalues ( self ) : <EOL> for key , value in self . iteritems ( ) : <EOL> yield value <EOL> def values ( self ) : <EOL> return list ( self . itervalues ( ) ) <EOL> def items ( self , multi = False ) : <EOL> return list ( self . iteritems ( multi ) ) <EOL> def iterlists ( self ) : <EOL> rv = { } <EOL> for d in self . dicts : <EOL> for key , values in d . iterlists ( ) : <EOL> rv . setdefault ( key , [ ] ) . extend ( values ) <EOL> return rv . iteritems ( ) <EOL> def lists ( self ) : <EOL> return list ( self . iterlists ( ) ) <EOL> def iterlistvalues ( self ) : <EOL> return ( x [ <NUM_LIT:0> ] for x in self . lists ( ) ) <EOL> def listvalues ( self ) : <EOL> return list ( self . iterlistvalues ( ) ) <EOL> def iterkeys ( self ) : <EOL> return iter ( self . keys ( ) ) <EOL> __iter__ = iterkeys <EOL> def copy ( self ) : <EOL> """<STR_LIT>""" <EOL> return self . __class__ ( self . dicts [ : ] ) <EOL> def to_dict ( self , flat = True ) : <EOL> """<STR_LIT>""" <EOL> rv = { } <EOL> for d in reversed ( self . dicts ) : <EOL> rv . update ( d . to_dict ( flat ) ) <EOL> return rv <EOL> def __len__ ( self ) : <EOL> return len ( self . keys ( ) ) <EOL> def __contains__ ( self , key ) : <EOL> for d in self . dicts : <EOL> if key in d : <EOL> return True <EOL> return False <EOL> has_key = __contains__ <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % ( self . __class__ . __name__ , self . dicts ) <EOL> class FileMultiDict ( MultiDict ) : <EOL> """<STR_LIT>""" <EOL> def add_file ( self , name , file , filename = None , content_type = None ) : <EOL> """<STR_LIT>""" <EOL> if isinstance ( file , FileStorage ) : <EOL> self [ name ] = file <EOL> return <EOL> if isinstance ( file , basestring ) : <EOL> if filename is None : <EOL> filename = file <EOL> file = open ( file , '<STR_LIT:rb>' ) <EOL> if filename and content_type is None : <EOL> content_type = mimetypes . guess_type ( filename ) [ <NUM_LIT:0> ] or '<STR_LIT>' <EOL> self [ name ] = FileStorage ( file , filename , name , content_type ) <EOL> class ImmutableDict ( ImmutableDictMixin , dict ) : <EOL> """<STR_LIT>""" <EOL> __repr__ = _proxy_repr ( dict ) <EOL> def copy ( self ) : <EOL> """<STR_LIT>""" <EOL> return dict ( self ) <EOL> def __copy__ ( self ) : <EOL> return self <EOL> class ImmutableMultiDict ( ImmutableMultiDictMixin , MultiDict ) : <EOL> """<STR_LIT>""" <EOL> def copy ( self ) : <EOL> """<STR_LIT>""" <EOL> return MultiDict ( self ) <EOL> def __copy__ ( self ) : <EOL> return self <EOL> class ImmutableOrderedMultiDict ( ImmutableMultiDictMixin , OrderedMultiDict ) : <EOL> """<STR_LIT>""" <EOL> def copy ( self ) : <EOL> """<STR_LIT>""" <EOL> return OrderedMultiDict ( self ) <EOL> def __copy__ ( self ) : <EOL> return self <EOL> class Accept ( ImmutableList ) : <EOL> """<STR_LIT>""" <EOL> def __init__ ( self , values = ( ) ) : <EOL> if values is None : <EOL> list . __init__ ( self ) <EOL> self . provided = False <EOL> elif isinstance ( values , Accept ) : <EOL> self . provided = values . provided <EOL> list . __init__ ( self , values ) <EOL> else : <EOL> self . provided = True <EOL> values = [ ( a , b ) for b , a in values ] <EOL> values . sort ( ) <EOL> values . reverse ( ) <EOL> list . __init__ ( self , [ ( a , b ) for b , a in values ] ) <EOL> def _value_matches ( self , value , item ) : <EOL> """<STR_LIT>""" <EOL> return item == '<STR_LIT:*>' or item . lower ( ) == value . lower ( ) <EOL> def __getitem__ ( self , key ) : <EOL> """<STR_LIT>""" <EOL> if isinstance ( key , basestring ) : <EOL> return self . quality ( key ) <EOL> return list . __getitem__ ( self , key ) <EOL> def quality ( self , key ) : <EOL> """<STR_LIT>""" <EOL> for item , quality in self : <EOL> if self . _value_matches ( key , item ) : <EOL> return quality <EOL> return <NUM_LIT:0> <EOL> def __contains__ ( self , value ) : <EOL> for item , quality in self : <EOL> if self . _value_matches ( value , item ) : <EOL> return True <EOL> return False <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % ( <EOL> self . __class__ . __name__ , <EOL> '<STR_LIT:U+002CU+0020>' . join ( '<STR_LIT>' % ( x , y ) for x , y in self ) <EOL> ) <EOL> def index ( self , key ) : <EOL> """<STR_LIT>""" <EOL> if isinstance ( key , basestring ) : <EOL> for idx , ( item , quality ) in enumerate ( self ) : <EOL> if self . _value_matches ( key , item ) : <EOL> return idx <EOL> raise ValueError ( key ) <EOL> return list . index ( self , key ) <EOL> def find ( self , key ) : <EOL> """<STR_LIT>""" <EOL> try : <EOL> return self . index ( key ) <EOL> except ValueError : <EOL> return - <NUM_LIT:1> <EOL> def values ( self ) : <EOL> """<STR_LIT>""" <EOL> return list ( self . itervalues ( ) ) <EOL> def itervalues ( self ) : <EOL> """<STR_LIT>""" <EOL> for item in self : <EOL> yield item [ <NUM_LIT:0> ] <EOL> def to_header ( self ) : <EOL> """<STR_LIT>""" <EOL> result = [ ] <EOL> for value , quality in self : <EOL> if quality != <NUM_LIT:1> : <EOL> value = '<STR_LIT>' % ( value , quality ) <EOL> result . append ( value ) <EOL> return '<STR_LIT:U+002C>' . join ( result ) <EOL> def __str__ ( self ) : <EOL> return self . to_header ( ) <EOL> def best_match ( self , matches , default = None ) : <EOL> """<STR_LIT>""" <EOL> best_quality = - <NUM_LIT:1> <EOL> result = default <EOL> for server_item in matches : <EOL> for client_item , quality in self : <EOL> if quality <= best_quality : <EOL> break <EOL> if self . _value_matches ( client_item , server_item ) : <EOL> best_quality = quality <EOL> result = server_item <EOL> return result <EOL> @ property <EOL> def best ( self ) : <EOL> """<STR_LIT>""" <EOL> if self : <EOL> return self [ <NUM_LIT:0> ] [ <NUM_LIT:0> ] <EOL> class MIMEAccept ( Accept ) : <EOL> """<STR_LIT>""" <EOL> def _value_matches ( self , value , item ) : <EOL> def _normalize ( x ) : <EOL> x = x . lower ( ) <EOL> return x == '<STR_LIT:*>' and ( '<STR_LIT:*>' , '<STR_LIT:*>' ) or x . split ( '<STR_LIT:/>' , <NUM_LIT:1> ) <EOL> if '<STR_LIT:/>' not in value : <EOL> raise ValueError ( '<STR_LIT>' % value ) <EOL> value_type , value_subtype = _normalize ( value ) <EOL> if value_type == '<STR_LIT:*>' and value_subtype != '<STR_LIT:*>' : <EOL> raise ValueError ( '<STR_LIT>' % value ) <EOL> if '<STR_LIT:/>' not in item : <EOL> return False <EOL> item_type , item_subtype = _normalize ( item ) <EOL> if item_type == '<STR_LIT:*>' and item_subtype != '<STR_LIT:*>' : <EOL> return False <EOL> return ( <EOL> ( item_type == item_subtype == '<STR_LIT:*>' or <EOL> value_type == value_subtype == '<STR_LIT:*>' ) or <EOL> ( item_type == value_type and ( item_subtype == '<STR_LIT:*>' or <EOL> value_subtype == '<STR_LIT:*>' or <EOL> item_subtype == value_subtype ) ) <EOL> ) <EOL> @ property <EOL> def accept_html ( self ) : <EOL> """<STR_LIT>""" <EOL> return ( <EOL> '<STR_LIT>' in self or <EOL> '<STR_LIT>' in self or <EOL> self . accept_xhtml <EOL> ) <EOL> @ property <EOL> def accept_xhtml ( self ) : <EOL> """<STR_LIT>""" <EOL> return ( <EOL> '<STR_LIT>' in self or <EOL> '<STR_LIT>' in self <EOL> ) <EOL> class LanguageAccept ( Accept ) : <EOL> """<STR_LIT>""" <EOL> def _value_matches ( self , value , item ) : <EOL> def _normalize ( language ) : <EOL> return _locale_delim_re . split ( language . lower ( ) ) <EOL> return item == '<STR_LIT:*>' or _normalize ( value ) == _normalize ( item ) <EOL> class CharsetAccept ( Accept ) : <EOL> """<STR_LIT>""" <EOL> def _value_matches ( self , value , item ) : <EOL> def _normalize ( name ) : <EOL> try : <EOL> return codecs . lookup ( name ) . name <EOL> except LookupError : <EOL> return name . lower ( ) <EOL> return item == '<STR_LIT:*>' or _normalize ( value ) == _normalize ( item ) <EOL> def cache_property ( key , empty , type ) : <EOL> """<STR_LIT>""" <EOL> return property ( lambda x : x . _get_cache_value ( key , empty , type ) , <EOL> lambda x , v : x . _set_cache_value ( key , v , type ) , <EOL> lambda x : x . _del_cache_value ( key ) , <EOL> '<STR_LIT>' % key ) <EOL> class _CacheControl ( UpdateDictMixin , dict ) : <EOL> """<STR_LIT>""" <EOL> no_cache = cache_property ( '<STR_LIT>' , '<STR_LIT:*>' , None ) <EOL> no_store = cache_property ( '<STR_LIT>' , None , bool ) <EOL> max_age = cache_property ( '<STR_LIT>' , - <NUM_LIT:1> , int ) <EOL> no_transform = cache_property ( '<STR_LIT>' , None , None ) <EOL> def __init__ ( self , values = ( ) , on_update = None ) : <EOL> dict . __init__ ( self , values or ( ) ) <EOL> self . on_update = on_update <EOL> self . provided = values is not None <EOL> def _get_cache_value ( self , key , empty , type ) : <EOL> """<STR_LIT>""" <EOL> if type is bool : <EOL> return key in self <EOL> if key in self : <EOL> value = self [ key ] <EOL> if value is None : <EOL> return empty <EOL> elif type is not None : <EOL> try : <EOL> value = type ( value ) <EOL> except ValueError : <EOL> pass <EOL> return value <EOL> def _set_cache_value ( self , key , value , type ) : <EOL> """<STR_LIT>""" <EOL> if type is bool : <EOL> if value : <EOL> self [ key ] = None <EOL> else : <EOL> self . pop ( key , None ) <EOL> else : <EOL> if value is None : <EOL> self . pop ( key ) <EOL> elif value is True : <EOL> self [ key ] = None <EOL> else : <EOL> self [ key ] = value <EOL> def _del_cache_value ( self , key ) : <EOL> """<STR_LIT>""" <EOL> if key in self : <EOL> del self [ key ] <EOL> def to_header ( self ) : <EOL> """<STR_LIT>""" <EOL> return dump_header ( self ) <EOL> def __str__ ( self ) : <EOL> return self . to_header ( ) <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % ( <EOL> self . __class__ . __name__ , <EOL> self . to_header ( ) <EOL> ) <EOL> class RequestCacheControl ( ImmutableDictMixin , _CacheControl ) : <EOL> """<STR_LIT>""" <EOL> max_stale = cache_property ( '<STR_LIT>' , '<STR_LIT:*>' , int ) <EOL> min_fresh = cache_property ( '<STR_LIT>' , '<STR_LIT:*>' , int ) <EOL> no_transform = cache_property ( '<STR_LIT>' , None , None ) <EOL> only_if_cached = cache_property ( '<STR_LIT>' , None , bool ) <EOL> class ResponseCacheControl ( _CacheControl ) : <EOL> """<STR_LIT>""" <EOL> public = cache_property ( '<STR_LIT>' , None , bool ) <EOL> private = cache_property ( '<STR_LIT>' , '<STR_LIT:*>' , None ) <EOL> must_revalidate = cache_property ( '<STR_LIT>' , None , bool ) <EOL> proxy_revalidate = cache_property ( '<STR_LIT>' , None , bool ) <EOL> s_maxage = cache_property ( '<STR_LIT>' , None , None ) <EOL> _CacheControl . cache_property = staticmethod ( cache_property ) <EOL> class CallbackDict ( UpdateDictMixin , dict ) : <EOL> """<STR_LIT>""" <EOL> def __init__ ( self , initial = None , on_update = None ) : <EOL> dict . __init__ ( self , initial or ( ) ) <EOL> self . on_update = on_update <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % ( <EOL> self . __class__ . __name__ , <EOL> dict . __repr__ ( self ) <EOL> ) <EOL> class HeaderSet ( object ) : <EOL> """<STR_LIT>""" <EOL> def __init__ ( self , headers = None , on_update = None ) : <EOL> self . _headers = list ( headers or ( ) ) <EOL> self . _set = set ( [ x . lower ( ) for x in self . _headers ] ) <EOL> self . on_update = on_update <EOL> def add ( self , header ) : <EOL> """<STR_LIT>""" <EOL> self . update ( ( header , ) ) <EOL> def remove ( self , header ) : <EOL> """<STR_LIT>""" <EOL> key = header . lower ( ) <EOL> if key not in self . _set : <EOL> raise KeyError ( header ) <EOL> self . _set . remove ( key ) <EOL> for idx , key in enumerate ( self . _headers ) : <EOL> if key . lower ( ) == header : <EOL> del self . _headers [ idx ] <EOL> break <EOL> if self . on_update is not None : <EOL> self . on_update ( self ) <EOL> def update ( self , iterable ) : <EOL> """<STR_LIT>""" <EOL> inserted_any = False <EOL> for header in iterable : <EOL> key = header . lower ( ) <EOL> if key not in self . _set : <EOL> self . _headers . append ( header ) <EOL> self . _set . add ( key ) <EOL> inserted_any = True <EOL> if inserted_any and self . on_update is not None : <EOL> self . on_update ( self ) <EOL> def discard ( self , header ) : <EOL> """<STR_LIT>""" <EOL> try : <EOL> return self . remove ( header ) <EOL> except KeyError : <EOL> pass <EOL> def find ( self , header ) : <EOL> """<STR_LIT>""" <EOL> header = header . lower ( ) <EOL> for idx , item in enumerate ( self . _headers ) : <EOL> if item . lower ( ) == header : <EOL> return idx <EOL> return - <NUM_LIT:1> <EOL> def index ( self , header ) : <EOL> """<STR_LIT>""" <EOL> rv = self . find ( header ) <EOL> if rv < <NUM_LIT:0> : <EOL> raise IndexError ( header ) <EOL> return rv <EOL> def clear ( self ) : <EOL> """<STR_LIT>""" <EOL> self . _set . clear ( ) <EOL> del self . _headers [ : ] <EOL> if self . on_update is not None : <EOL> self . on_update ( self ) <EOL> def as_set ( self , preserve_casing = False ) : <EOL> """<STR_LIT>""" <EOL> if preserve_casing : <EOL> return set ( self . _headers ) <EOL> return set ( self . _set ) <EOL> def to_header ( self ) : <EOL> """<STR_LIT>""" <EOL> return '<STR_LIT:U+002CU+0020>' . join ( map ( quote_header_value , self . _headers ) ) <EOL> def __getitem__ ( self , idx ) : <EOL> return self . _headers [ idx ] <EOL> def __delitem__ ( self , idx ) : <EOL> rv = self . _headers . pop ( idx ) <EOL> self . _set . remove ( rv . lower ( ) ) <EOL> if self . on_update is not None : <EOL> self . on_update ( self ) <EOL> def __setitem__ ( self , idx , value ) : <EOL> old = self . _headers [ idx ] <EOL> self . _set . remove ( old . lower ( ) ) <EOL> self . _headers [ idx ] = value <EOL> self . _set . add ( value . lower ( ) ) <EOL> if self . on_update is not None : <EOL> self . on_update ( self ) <EOL> def __contains__ ( self , header ) : <EOL> return header . lower ( ) in self . _set <EOL> def __len__ ( self ) : <EOL> return len ( self . _set ) <EOL> def __iter__ ( self ) : <EOL> return iter ( self . _headers ) <EOL> def __nonzero__ ( self ) : <EOL> return bool ( self . _set ) <EOL> def __str__ ( self ) : <EOL> return self . to_header ( ) <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % ( <EOL> self . __class__ . __name__ , <EOL> self . _headers <EOL> ) <EOL> class ETags ( object ) : <EOL> """<STR_LIT>""" <EOL> def __init__ ( self , strong_etags = None , weak_etags = None , star_tag = False ) : <EOL> self . _strong = frozenset ( not star_tag and strong_etags or ( ) ) <EOL> self . _weak = frozenset ( weak_etags or ( ) ) <EOL> self . star_tag = star_tag <EOL> def as_set ( self , include_weak = False ) : <EOL> """<STR_LIT>""" <EOL> rv = set ( self . _strong ) <EOL> if include_weak : <EOL> rv . update ( self . _weak ) <EOL> return rv <EOL> def is_weak ( self , etag ) : <EOL> """<STR_LIT>""" <EOL> return etag in self . _weak <EOL> def contains_weak ( self , etag ) : <EOL> """<STR_LIT>""" <EOL> return self . is_weak ( etag ) or self . contains ( etag ) <EOL> def contains ( self , etag ) : <EOL> """<STR_LIT>""" <EOL> if self . star_tag : <EOL> return True <EOL> return etag in self . _strong <EOL> def contains_raw ( self , etag ) : <EOL> """<STR_LIT>""" <EOL> etag , weak = unquote_etag ( etag ) <EOL> if weak : <EOL> return self . contains_weak ( etag ) <EOL> return self . contains ( etag ) <EOL> def to_header ( self ) : <EOL> """<STR_LIT>""" <EOL> if self . star_tag : <EOL> return '<STR_LIT:*>' <EOL> return '<STR_LIT:U+002CU+0020>' . join ( <EOL> [ '<STR_LIT>' % x for x in self . _strong ] + <EOL> [ '<STR_LIT>' % x for x in self . _weak ] <EOL> ) <EOL> def __call__ ( self , etag = None , data = None , include_weak = False ) : <EOL> if [ etag , data ] . count ( None ) != <NUM_LIT:1> : <EOL> raise TypeError ( '<STR_LIT>' ) <EOL> if etag is None : <EOL> etag = generate_etag ( data ) <EOL> if include_weak : <EOL> if etag in self . _weak : <EOL> return True <EOL> return etag in self . _strong <EOL> def __nonzero__ ( self ) : <EOL> return bool ( self . star_tag or self . _strong ) <EOL> def __str__ ( self ) : <EOL> return self . to_header ( ) <EOL> def __iter__ ( self ) : <EOL> return iter ( self . _strong ) <EOL> def __contains__ ( self , etag ) : <EOL> return self . contains ( etag ) <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % ( self . __class__ . __name__ , str ( self ) ) <EOL> class Authorization ( ImmutableDictMixin , dict ) : <EOL> """<STR_LIT>""" <EOL> def __init__ ( self , auth_type , data = None ) : <EOL> dict . __init__ ( self , data or { } ) <EOL> self . type = auth_type <EOL> username = property ( lambda x : x . get ( '<STR_LIT:username>' ) , doc = '''<STR_LIT>''' ) <EOL> password = property ( lambda x : x . get ( '<STR_LIT:password>' ) , doc = '''<STR_LIT>''' ) <EOL> realm = property ( lambda x : x . get ( '<STR_LIT>' ) , doc = '''<STR_LIT>''' ) <EOL> nonce = property ( lambda x : x . get ( '<STR_LIT>' ) , doc = '''<STR_LIT>''' ) <EOL> uri = property ( lambda x : x . get ( '<STR_LIT>' ) , doc = '''<STR_LIT>''' ) <EOL> nc = property ( lambda x : x . get ( '<STR_LIT>' ) , doc = '''<STR_LIT>''' ) <EOL> cnonce = property ( lambda x : x . get ( '<STR_LIT>' ) , doc = '''<STR_LIT>''' ) <EOL> response = property ( lambda x : x . get ( '<STR_LIT>' ) , doc = '''<STR_LIT>''' ) <EOL> opaque = property ( lambda x : x . get ( '<STR_LIT>' ) , doc = '''<STR_LIT>''' ) <EOL> @ property <EOL> def qop ( self ) : <EOL> """<STR_LIT>""" <EOL> def on_update ( header_set ) : <EOL> if not header_set and '<STR_LIT>' in self : <EOL> del self [ '<STR_LIT>' ] <EOL> elif header_set : <EOL> self [ '<STR_LIT>' ] = header_set . to_header ( ) <EOL> return parse_set_header ( self . get ( '<STR_LIT>' ) , on_update ) <EOL> class WWWAuthenticate ( UpdateDictMixin , dict ) : <EOL> """<STR_LIT>""" <EOL> _require_quoting = frozenset ( [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> def __init__ ( self , auth_type = None , values = None , on_update = None ) : <EOL> dict . __init__ ( self , values or ( ) ) <EOL> if auth_type : <EOL> self [ '<STR_LIT>' ] = auth_type <EOL> self . on_update = on_update <EOL> def set_basic ( self , realm = '<STR_LIT>' ) : <EOL> """<STR_LIT>""" <EOL> dict . clear ( self ) <EOL> dict . update ( self , { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : realm } ) <EOL> if self . on_update : <EOL> self . on_update ( self ) <EOL> def set_digest ( self , realm , nonce , qop = ( '<STR_LIT>' , ) , opaque = None , <EOL> algorithm = None , stale = False ) : <EOL> """<STR_LIT>""" <EOL> d = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : realm , <EOL> '<STR_LIT>' : nonce , <EOL> '<STR_LIT>' : dump_header ( qop ) <EOL> } <EOL> if stale : <EOL> d [ '<STR_LIT>' ] = '<STR_LIT>' <EOL> if opaque is not None : <EOL> d [ '<STR_LIT>' ] = opaque <EOL> if algorithm is not None : <EOL> d [ '<STR_LIT>' ] = algorithm <EOL> dict . clear ( self ) <EOL> dict . update ( self , d ) <EOL> if self . on_update : <EOL> self . on_update ( self ) <EOL> def to_header ( self ) : <EOL> """<STR_LIT>""" <EOL> d = dict ( self ) <EOL> auth_type = d . pop ( '<STR_LIT>' , None ) or '<STR_LIT>' <EOL> return '<STR_LIT>' % ( auth_type . title ( ) , '<STR_LIT:U+002CU+0020>' . join ( [ <EOL> '<STR_LIT>' % ( key , quote_header_value ( value , <EOL> allow_token = key not in self . _require_quoting ) ) <EOL> for key , value in d . iteritems ( ) <EOL> ] ) ) <EOL> def __str__ ( self ) : <EOL> return self . to_header ( ) <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % ( <EOL> self . __class__ . __name__ , <EOL> self . to_header ( ) <EOL> ) <EOL> def auth_property ( name , doc = None ) : <EOL> """<STR_LIT>""" <EOL> def _set_value ( self , value ) : <EOL> if value is None : <EOL> self . pop ( name , None ) <EOL> else : <EOL> self [ name ] = str ( value ) <EOL> return property ( lambda x : x . get ( name ) , _set_value , doc = doc ) <EOL> def _set_property ( name , doc = None ) : <EOL> def fget ( self ) : <EOL> def on_update ( header_set ) : <EOL> if not header_set and name in self : <EOL> del self [ name ] <EOL> elif header_set : <EOL> self [ name ] = header_set . to_header ( ) <EOL> return parse_set_header ( self . get ( name ) , on_update ) <EOL> return property ( fget , doc = doc ) <EOL> type = auth_property ( '<STR_LIT>' , doc = '''<STR_LIT>''' ) <EOL> realm = auth_property ( '<STR_LIT>' , doc = '''<STR_LIT>''' ) <EOL> domain = _set_property ( '<STR_LIT>' , doc = '''<STR_LIT>''' ) <EOL> nonce = auth_property ( '<STR_LIT>' , doc = '''<STR_LIT>''' ) <EOL> opaque = auth_property ( '<STR_LIT>' , doc = '''<STR_LIT>''' ) <EOL> algorithm = auth_property ( '<STR_LIT>' , doc = '''<STR_LIT>''' ) <EOL> qop = _set_property ( '<STR_LIT>' , doc = '''<STR_LIT>''' ) <EOL> def _get_stale ( self ) : <EOL> val = self . get ( '<STR_LIT>' ) <EOL> if val is not None : <EOL> return val . lower ( ) == '<STR_LIT:true>' <EOL> def _set_stale ( self , value ) : <EOL> if value is None : <EOL> self . pop ( '<STR_LIT>' , None ) <EOL> else : <EOL> self [ '<STR_LIT>' ] = value and '<STR_LIT>' or '<STR_LIT>' <EOL> stale = property ( _get_stale , _set_stale , doc = '''<STR_LIT>''' ) <EOL> del _get_stale , _set_stale <EOL> auth_property = staticmethod ( auth_property ) <EOL> del _set_property <EOL> class FileStorage ( object ) : <EOL> """<STR_LIT>""" <EOL> def __init__ ( self , stream = None , filename = None , name = None , <EOL> content_type = '<STR_LIT>' , content_length = - <NUM_LIT:1> , <EOL> headers = None ) : <EOL> self . name = name <EOL> self . stream = stream or _empty_stream <EOL> self . filename = filename or getattr ( stream , '<STR_LIT:name>' , None ) <EOL> self . content_type = content_type <EOL> self . content_length = content_length <EOL> if headers is None : <EOL> headers = Headers ( ) <EOL> self . headers = headers <EOL> def save ( self , dst , buffer_size = <NUM_LIT> ) : <EOL> """<STR_LIT>""" <EOL> from shutil import copyfileobj <EOL> close_dst = False <EOL> if isinstance ( dst , basestring ) : <EOL> dst = file ( dst , '<STR_LIT:wb>' ) <EOL> close_dst = True <EOL> try : <EOL> copyfileobj ( self . stream , dst , buffer_size ) <EOL> finally : <EOL> if close_dst : <EOL> dst . close ( ) <EOL> def close ( self ) : <EOL> """<STR_LIT>""" <EOL> try : <EOL> self . stream . close ( ) <EOL> except : <EOL> pass <EOL> def __nonzero__ ( self ) : <EOL> return bool ( self . filename ) <EOL> def __getattr__ ( self , name ) : <EOL> return getattr ( self . stream , name ) <EOL> def __iter__ ( self ) : <EOL> return iter ( self . readline , '<STR_LIT>' ) <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % ( <EOL> self . __class__ . __name__ , <EOL> self . filename , <EOL> self . content_type <EOL> ) <EOL> from werkzeug . http import dump_options_header , dump_header , generate_etag , quote_header_value , parse_set_header , unquote_etag <EOL> from werkzeug . exceptions import BadRequest <EOL> for _cls in MultiDict , OrderedMultiDict , CombinedMultiDict , Headers , EnvironHeaders : <EOL> _cls . KeyError = BadRequest . wrap ( KeyError , _cls . __name__ + '<STR_LIT>' ) <EOL> del _cls </s>
<s> """<STR_LIT>""" <EOL> import sys <EOL> import os <EOL> from werkzeug . utils import import_string <EOL> from kay . management . shell import ( <EOL> rshell , shell , clear_datastore , create_user , <EOL> ) <EOL> from kay . management . runserver import runserver_passthru_argv <EOL> from kay . management . startapp import startapp <EOL> from kay . management . startapp import startproject <EOL> from kay . management . appcfg import do_appcfg_passthru_argv <EOL> from kay . management . bulkloader import ( <EOL> do_bulkloader_passthru_argv , dump_all , restore_all , <EOL> ) <EOL> from kay . management . test import do_runtest <EOL> from kay . management . preparse import do_preparse_bundle <EOL> from kay . management . preparse import do_preparse_apps <EOL> from kay . management . extract_messages import do_extract_messages <EOL> from kay . management . add_translations import do_add_translations <EOL> from kay . management . update_translations import do_update_translations <EOL> from kay . management . compile_translations import do_compile_translations <EOL> from kay . management . wxadmin import do_wxadmin <EOL> from kay . management . compile_media import do_compile_media <EOL> from kay . conf import settings <EOL> action_dump_all = dump_all <EOL> action_restore_all = restore_all <EOL> action_shell = shell <EOL> action_rshell = rshell <EOL> action_startapp = startapp <EOL> action_startproject = startproject <EOL> action_test = do_runtest <EOL> action_preparse_bundle = do_preparse_bundle <EOL> action_preparse_apps = do_preparse_apps <EOL> action_extract_messages = do_extract_messages <EOL> action_add_translations = do_add_translations <EOL> action_update_translations = do_update_translations <EOL> action_compile_translations = do_compile_translations <EOL> action_appcfg = do_appcfg_passthru_argv <EOL> action_runserver = runserver_passthru_argv <EOL> action_bulkloader = do_bulkloader_passthru_argv <EOL> action_clear_datastore = clear_datastore <EOL> action_create_user = create_user <EOL> action_wxadmin = do_wxadmin <EOL> action_compile_media = do_compile_media <EOL> additional_actions = [ ] <EOL> for app in settings . INSTALLED_APPS : <EOL> try : <EOL> appmod = import_string ( app ) <EOL> if not os . path . exists ( os . path . join ( os . path . dirname ( appmod . __file__ ) , <EOL> '<STR_LIT>' ) ) : <EOL> continue <EOL> management_mod = import_string ( "<STR_LIT>" % app ) <EOL> for name , val in vars ( management_mod ) . iteritems ( ) : <EOL> if name . startswith ( "<STR_LIT>" ) : <EOL> locals ( ) [ name ] = getattr ( management_mod , name ) <EOL> additional_actions . append ( name ) <EOL> except Exception , e : <EOL> import traceback <EOL> sys . stderr . write ( '<STR_LIT:\n>' . join ( traceback . format_exception ( * ( sys . exc_info ( ) ) ) ) ) <EOL> pass <EOL> __all__ = [ <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> ] + additional_actions <EOL> def print_status ( msg ) : <EOL> print ( msg ) <EOL> sys . stdout . flush ( ) </s>
<s> """<STR_LIT>""" <EOL> from kay . routing import ( <EOL> ViewGroup , Rule <EOL> ) <EOL> view_groups = [ <EOL> ViewGroup ( <EOL> Rule ( '<STR_LIT>' , endpoint = '<STR_LIT>' , <EOL> view = ( '<STR_LIT>' , ( ) , { } ) ) , <EOL> Rule ( '<STR_LIT>' , endpoint = '<STR_LIT>' , <EOL> view = ( '<STR_LIT>' , ( ) , { } ) ) , <EOL> Rule ( '<STR_LIT>' , endpoint = '<STR_LIT>' , <EOL> view = '<STR_LIT>' ) , <EOL> ) <EOL> ] </s>
<s> """<STR_LIT>""" <EOL> from google . appengine . ext import db <EOL> from kay . utils . forms import ValidationError <EOL> from kay . utils . forms . modelform import ModelForm <EOL> class MaxLengthValidator ( object ) : <EOL> def __init__ ( self , length ) : <EOL> self . length = length <EOL> def __call__ ( self , val ) : <EOL> if len ( val ) > self . length : <EOL> raise ValidationError ( "<STR_LIT>" ) <EOL> return True <EOL> class TestModel ( db . Model ) : <EOL> number = db . IntegerProperty ( required = True ) <EOL> data_field = db . StringProperty ( required = True , <EOL> validator = MaxLengthValidator ( <NUM_LIT:20> ) ) <EOL> is_active = db . BooleanProperty ( required = True ) <EOL> string_list_field = db . StringListProperty ( required = True ) <EOL> class TestModel2 ( db . Model ) : <EOL> number = db . IntegerProperty ( required = True ) <EOL> data_field = db . StringProperty ( required = True , <EOL> validator = MaxLengthValidator ( <NUM_LIT:20> ) ) <EOL> is_active = db . BooleanProperty ( required = True ) <EOL> string_list_field = db . StringListProperty ( required = True ) <EOL> class TestModelForm ( ModelForm ) : <EOL> csrf_protected = False <EOL> class Meta ( ) : <EOL> model = TestModel <EOL> def __init__ ( self , instance = None , initial = None ) : <EOL> super ( TestModelForm , self ) . __init__ ( instance , initial ) <EOL> self . string_list_field . min_size = <NUM_LIT:1> <EOL> class JsonTestModel ( db . Model ) : <EOL> s = db . StringProperty ( ) <EOL> i = db . IntegerProperty ( ) <EOL> b = db . BooleanProperty ( ) <EOL> l = db . StringListProperty ( ) <EOL> r = db . ReferenceProperty ( ) <EOL> class ModelFormTestModel ( db . Model ) : <EOL> s_name = db . StringProperty ( ) <EOL> zip_code = db . StringProperty ( ) <EOL> addr = db . StringProperty ( ) <EOL> class ModelFormTestForm ( ModelForm ) : <EOL> csrf_protected = False <EOL> class Meta : <EOL> model = ModelFormTestModel <EOL> fields = ( '<STR_LIT>' ) <EOL> class ValidationTestModel ( db . Model ) : <EOL> slist = db . StringListProperty ( ) <EOL> class ValidationTestForm ( ModelForm ) : <EOL> csrf_protected = False <EOL> class Meta : <EOL> model = ValidationTestModel <EOL> def context_validate ( self , data ) : <EOL> raise ValidationError ( "<STR_LIT>" ) </s>
<s> """<STR_LIT>""" <EOL> import re <EOL> import sys <EOL> from os import path , listdir , mkdir <EOL> def compile_file ( env , src_path , dst_path , encoding = '<STR_LIT:utf-8>' , base_dir = '<STR_LIT>' ) : <EOL> """<STR_LIT>""" <EOL> src_file = file ( src_path , '<STR_LIT:r>' ) <EOL> try : <EOL> source = src_file . read ( ) . decode ( encoding ) <EOL> except Exception , e : <EOL> sys . stderr . write ( "<STR_LIT>" <EOL> "<STR_LIT>" % src_path ) <EOL> raise <EOL> src_file . close ( ) <EOL> name = src_path . replace ( base_dir , '<STR_LIT>' ) <EOL> raw = env . compile ( source , name = name , filename = name , raw = True ) <EOL> dst_file = open ( dst_path , '<STR_LIT:wb>' ) <EOL> dst_file . write ( raw ) <EOL> dst_file . close ( ) <EOL> def compile_dir ( env , src_path , dst_path , pattern = r'<STR_LIT>' , <EOL> encoding = '<STR_LIT:utf-8>' , base_dir = None , <EOL> negative_pattern = r'<STR_LIT>' ) : <EOL> """<STR_LIT>""" <EOL> if base_dir is None : <EOL> base_dir = src_path <EOL> for filename in listdir ( src_path ) : <EOL> if filename . startswith ( "<STR_LIT:.>" ) : <EOL> continue <EOL> src_name = path . join ( src_path , filename ) <EOL> dst_name = path . join ( dst_path , filename ) <EOL> if path . isdir ( src_name ) : <EOL> if not path . isdir ( dst_name ) : <EOL> mkdir ( dst_name ) <EOL> compile_dir ( env , src_name , dst_name , encoding = encoding , <EOL> base_dir = base_dir ) <EOL> elif path . isfile ( src_name ) and re . match ( pattern , filename ) and not re . match ( negative_pattern , filename ) : <EOL> compile_file ( env , src_name , dst_name , encoding = encoding , <EOL> base_dir = base_dir ) </s>
<s> """<STR_LIT>""" <EOL> import api <EOL> import random <EOL> import imp <EOL> import shutil <EOL> import os <EOL> from os import path <EOL> from functools import partial <EOL> from bson import json_util <EOL> from api . common import InternalException , SevereInternalException <EOL> log = api . logger . use ( __name__ ) <EOL> modifiable_problem_fields = [ "<STR_LIT:description>" ] <EOL> seed = "<STR_LIT>" <EOL> def is_autogen_problem ( pid ) : <EOL> """<STR_LIT>""" <EOL> return api . problem . get_problem ( pid = pid ) . get ( "<STR_LIT>" , False ) <EOL> def get_metadata_path ( pid , n ) : <EOL> """<STR_LIT>""" <EOL> return path . join ( get_instance_path ( pid , n = n , public = False ) , "<STR_LIT>" ) <EOL> def write_metadata ( pid , n , data ) : <EOL> """<STR_LIT>""" <EOL> metadata_path = get_metadata_path ( pid , n ) <EOL> with open ( metadata_path , "<STR_LIT:w>" ) as f : <EOL> f . write ( json_util . dumps ( data ) ) <EOL> @ api . cache . memoize ( timeout = <NUM_LIT> , fast = True ) <EOL> def read_metadata ( pid , n ) : <EOL> """<STR_LIT>""" <EOL> metadata_path = get_metadata_path ( pid , n ) <EOL> with open ( metadata_path , "<STR_LIT:r>" ) as f : <EOL> return json_util . loads ( f . read ( ) ) <EOL> def build_problem_instances ( pid , instances ) : <EOL> """<STR_LIT>""" <EOL> problem = api . problem . get_problem ( pid = pid ) <EOL> if not is_autogen_problem ( pid ) : <EOL> raise InternalException ( "<STR_LIT>" . format ( problem [ "<STR_LIT:name>" ] ) ) <EOL> previous_state = seed_generator ( "<STR_LIT>" , pid ) <EOL> instance_path , static_instance_path = get_instance_path ( pid ) , get_static_instance_path ( pid ) <EOL> for autogen_path in [ instance_path , static_instance_path ] : <EOL> log . debug ( "<STR_LIT>" , autogen_path ) <EOL> if not path . isdir ( autogen_path ) : <EOL> log . debug ( "<STR_LIT>" ) <EOL> os . makedirs ( autogen_path ) <EOL> for n in range ( instances ) : <EOL> log . debug ( "<STR_LIT>" , problem [ "<STR_LIT:name>" ] , str ( n ) ) <EOL> build = get_generator ( pid ) . generate ( random , pid , api . autogen_tools , n ) <EOL> autogen_instance_path = get_instance_path ( pid , n = n ) <EOL> file_type_paths = { <EOL> "<STR_LIT>" : { <EOL> "<STR_LIT>" : get_instance_path ( pid , n = n , public = True ) , <EOL> "<STR_LIT>" : get_instance_path ( pid , n = n , public = False ) <EOL> } , <EOL> "<STR_LIT>" : { <EOL> "<STR_LIT>" : get_static_instance_path ( pid , public = True ) , <EOL> "<STR_LIT>" : get_static_instance_path ( pid , public = False ) <EOL> } <EOL> } <EOL> for _ , file_types in file_type_paths . items ( ) : <EOL> for _ , autogen_path in file_types . items ( ) : <EOL> if not path . isdir ( autogen_path ) : <EOL> os . makedirs ( autogen_path ) <EOL> problem_updates = build . get ( "<STR_LIT>" , None ) <EOL> if problem_updates is None : <EOL> raise InternalException ( "<STR_LIT>" . format ( problem [ "<STR_LIT>" ] ) ) <EOL> write_metadata ( pid , n , problem_updates ) <EOL> for file_type , listings in build . items ( ) : <EOL> destination_type = file_type_paths . get ( file_type , None ) <EOL> if destination_type is not None : <EOL> for listing in listings : <EOL> destination = destination_type . get ( listing , None ) <EOL> if destination is not None : <EOL> files = listings [ listing ] <EOL> for f , name in files : <EOL> if path . isfile ( f ) : <EOL> shutil . copyfile ( f , path . join ( destination , name ) ) <EOL> elif path . isdir ( f ) : <EOL> shutil . copytree ( f , autogen_instance_path ) <EOL> api . autogen_tools . clear_build_directories ( ) <EOL> log . debug ( "<STR_LIT>" ) <EOL> random . setstate ( previous_state ) <EOL> def get_generator_path ( pid ) : <EOL> """<STR_LIT>""" <EOL> problem = api . problem . get_problem ( pid = pid ) <EOL> if not is_autogen_problem ( pid ) : <EOL> raise InternalException ( "<STR_LIT>" ) <EOL> if not problem . get ( "<STR_LIT>" , False ) : <EOL> raise InternalException ( "<STR_LIT>" . format ( problem [ "<STR_LIT:name>" ] ) ) <EOL> return path . join ( api . problem . grader_base_path , problem [ "<STR_LIT>" ] ) <EOL> def get_generator ( pid ) : <EOL> """<STR_LIT>""" <EOL> generator_path = get_generator_path ( pid ) <EOL> if not path . isfile ( generator_path ) : <EOL> raise InternalException ( "<STR_LIT>" . format ( generator_path ) ) <EOL> return imp . load_source ( generator_path [ : - <NUM_LIT:3> ] , generator_path ) <EOL> def get_seed ( pid , tid ) : <EOL> """<STR_LIT>""" <EOL> return seed + tid + pid <EOL> def seed_generator ( pid , tid ) : <EOL> """<STR_LIT>""" <EOL> previous_state = random . getstate ( ) <EOL> random . seed ( get_seed ( pid , tid ) ) <EOL> return previous_state <EOL> @ api . cache . memoize ( timeout = <NUM_LIT> , fast = True ) <EOL> def get_instance_number ( pid , tid ) : <EOL> """<STR_LIT>""" <EOL> previous_state = seed_generator ( tid , pid ) <EOL> total_instances = get_number_of_instances ( pid ) <EOL> if total_instances == <NUM_LIT:0> : <EOL> raise InternalException ( "<STR_LIT>" . format ( pid ) ) <EOL> instance_number = random . randint ( <NUM_LIT:0> , total_instances - <NUM_LIT:1> ) <EOL> random . setstate ( previous_state ) <EOL> return instance_number <EOL> @ api . cache . memoize ( timeout = <NUM_LIT> , fast = True ) <EOL> def get_number_of_instances ( pid ) : <EOL> """<STR_LIT>""" <EOL> try : <EOL> return [ dirname . isdigit ( ) for dirname in os . listdir ( get_instance_path ( pid , public = False ) ) ] . count ( True ) <EOL> except FileNotFoundError : <EOL> raise InternalException ( "<STR_LIT>" ) <EOL> def get_static_instance_path ( pid , public = True ) : <EOL> """<STR_LIT>""" <EOL> return path . abspath ( path . join ( get_instance_path ( pid , public = public ) , "<STR_LIT>" ) ) <EOL> def get_instance_path ( pid , n = "<STR_LIT>" , public = True ) : <EOL> """<STR_LIT>""" <EOL> generator_path = get_generator_path ( pid ) <EOL> name = api . problem . get_problem ( pid ) [ "<STR_LIT:name>" ] <EOL> instance_path = path . join ( path . dirname ( generator_path ) , "<STR_LIT>" , name , str ( n ) ) <EOL> if public : <EOL> instance_path = path . join ( instance_path , "<STR_LIT>" ) <EOL> return path . abspath ( instance_path ) <EOL> @ api . cache . memoize ( timeout = <NUM_LIT> , fast = True ) <EOL> def get_problem_instance ( pid , tid ) : <EOL> """<STR_LIT>""" <EOL> problem = api . problem . get_problem ( pid = pid ) <EOL> n = get_instance_number ( pid , tid ) <EOL> metadata = read_metadata ( pid , n ) <EOL> if not set ( metadata ) . issubset ( modifiable_problem_fields ) : <EOL> invalid_keys = set ( metadata ) . difference ( modifiable_problem_fields ) <EOL> raise InternalException ( "<STR_LIT>" . format ( pid , invalid_keys ) ) <EOL> problem . update ( metadata ) <EOL> return problem <EOL> def grade_problem_instance ( pid , tid , key ) : <EOL> """<STR_LIT>""" <EOL> if not is_autogen_problem ( pid ) : <EOL> raise InternalException ( "<STR_LIT>" . format ( pid ) ) <EOL> problem = api . problem . get_problem ( pid ) <EOL> n = get_instance_number ( pid , tid ) <EOL> grader_problem_instance = GraderProblemInstance ( pid , tid , n ) <EOL> grader = api . problem . get_grader ( pid ) <EOL> try : <EOL> correct , message = grader . grade ( grader_problem_instance , key ) <EOL> except Exception as e : <EOL> raise SevereInternalException ( "<STR_LIT>" . format ( pid , str ( e ) ) ) <EOL> return { <EOL> "<STR_LIT>" : correct , <EOL> "<STR_LIT>" : problem [ "<STR_LIT>" ] , <EOL> "<STR_LIT:message>" : message <EOL> } <EOL> class GraderProblemInstance ( object ) : <EOL> """<STR_LIT>""" <EOL> def __init__ ( self , pid , tid , n ) : <EOL> self . instance = n <EOL> self . get_instance_path = partial ( get_instance_path , pid , n = n ) <EOL> self . seed_generator = partial ( seed_generator , pid , tid ) <EOL> self . write_metadata = partial ( write_metadata , pid , n ) <EOL> self . read_metadata = partial ( read_metadata , pid ) </s>
<s> """<STR_LIT>""" <EOL> def generate ( random , pid , tools , n ) : <EOL> """<STR_LIT>""" <EOL> f = open ( "<STR_LIT>" , "<STR_LIT:w>" ) <EOL> k = str ( random . randint ( <NUM_LIT:0> , <NUM_LIT:1000> ) ) <EOL> f . write ( k ) <EOL> f . close ( ) <EOL> return { <EOL> "<STR_LIT>" : { <EOL> "<STR_LIT>" : [ ( "<STR_LIT>" , "<STR_LIT>" ) ] , <EOL> "<STR_LIT>" : [ ( "<STR_LIT>" , "<STR_LIT>" ) ] <EOL> } , <EOL> "<STR_LIT>" : { <EOL> "<STR_LIT>" : [ ( "<STR_LIT>" , "<STR_LIT>" ) ] , <EOL> "<STR_LIT>" : [ ( "<STR_LIT>" , "<STR_LIT>" ) ] <EOL> } , <EOL> "<STR_LIT>" : { <EOL> "<STR_LIT:description>" : "<STR_LIT>" + k + "<STR_LIT>" <EOL> } <EOL> } </s>
<s> import IECore <EOL> import GafferUI <EOL> import GafferScene <EOL> import GafferSceneUI <EOL> import os <EOL> scriptNode = script <EOL> scriptWindow = GafferUI . ScriptWindow . acquire ( script ) <EOL> layout = eval ( "<STR_LIT>" ) <EOL> scriptWindow . setLayout ( layout ) <EOL> scriptWindow . _Widget__qtWidget . resize ( <NUM_LIT> , <NUM_LIT> ) <EOL> for nodeName in [ '<STR_LIT>' ] : <EOL> script . selection ( ) . add ( script . descendant ( nodeName ) ) <EOL> script . context ( ) [ "<STR_LIT>" ] = GafferScene . PathMatcherData ( GafferScene . PathMatcher ( [ '<STR_LIT:/>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) ) <EOL> script . context ( ) [ "<STR_LIT>" ] = IECore . StringVectorData ( [ "<STR_LIT>" ] ) </s>
<s> import os <EOL> import glob <EOL> import IECore <EOL> class convertAnimCache ( IECore . Op ) : <EOL> def __init__ ( self ) : <EOL> IECore . Op . __init__ ( self , "<STR_LIT>" , IECore . FileSequenceParameter ( "<STR_LIT:result>" , "<STR_LIT>" ) ) <EOL> self . parameters ( ) . addParameters ( <EOL> [ <EOL> IECore . FileSequenceParameter ( <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> defaultValue = "<STR_LIT>" , <EOL> allowEmptyString = False , <EOL> check = IECore . FileSequenceParameter . CheckType . MustExist , <EOL> extensions = "<STR_LIT>" , <EOL> ) , <EOL> IECore . FileSequenceParameter ( <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> defaultValue = "<STR_LIT>" , <EOL> allowEmptyString = False , <EOL> extensions = "<STR_LIT>" , <EOL> ) , <EOL> ] , <EOL> ) <EOL> def doOperation ( self , args ) : <EOL> src = self . parameters ( ) [ "<STR_LIT>" ] . getFileSequenceValue ( ) <EOL> dst = self . parameters ( ) [ "<STR_LIT>" ] . getFileSequenceValue ( ) <EOL> if isinstance ( dst . frameList , IECore . EmptyFrameList ) : <EOL> dst . frameList = src . frameList <EOL> for ( sf , df ) in zip ( src . fileNames ( ) , dst . fileNames ( ) ) : <EOL> sc = IECore . AttributeCache ( sf , IECore . IndexedIOOpenMode . Read ) <EOL> dc = IECore . AttributeCache ( df , IECore . IndexedIOOpenMode . Write ) <EOL> combinedBound = IECore . Box3f ( ) <EOL> for objectName in sc . objects ( ) : <EOL> p = b = None <EOL> with IECore . IgnoredExceptions ( Exception ) : <EOL> p = sc . read ( objectName , "<STR_LIT>" ) <EOL> b = sc . read ( objectName , "<STR_LIT>" ) <EOL> if p is not None and b is not None : <EOL> combinedBound . extendBy ( b . value ) <EOL> dc . write ( "<STR_LIT:->" + objectName , "<STR_LIT>" , p ) <EOL> dc . write ( "<STR_LIT:->" + objectName , "<STR_LIT>" , b ) <EOL> dc . write ( "<STR_LIT:->" , "<STR_LIT>" , IECore . Box3fData ( combinedBound ) ) <EOL> return args [ "<STR_LIT>" ] . value <EOL> IECore . registerRunTimeTyped ( convertAnimCache ) </s>
<s> import os <EOL> import unittest <EOL> import subprocess32 as subprocess <EOL> import IECore <EOL> import Gaffer <EOL> import GafferTest <EOL> import GafferScene <EOL> import GafferAppleseed <EOL> import GafferAppleseedTest <EOL> class AppleseedRenderTest ( GafferTest . TestCase ) : <EOL> def setUp ( self ) : <EOL> GafferTest . TestCase . setUp ( self ) <EOL> self . __scriptFileName = self . temporaryDirectory ( ) + "<STR_LIT>" <EOL> def testExecute ( self ) : <EOL> s = Gaffer . ScriptNode ( ) <EOL> s [ "<STR_LIT>" ] = GafferScene . Plane ( ) <EOL> s [ "<STR_LIT>" ] = GafferAppleseed . AppleseedRender ( ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setValue ( "<STR_LIT>" ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( s [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) <EOL> s [ "<STR_LIT>" ] = Gaffer . Expression ( ) <EOL> s [ "<STR_LIT>" ] . setExpression ( "<STR_LIT>" + self . temporaryDirectory ( ) + "<STR_LIT>" ) <EOL> s [ "<STR_LIT>" ] . setValue ( self . __scriptFileName ) <EOL> s . save ( ) <EOL> p = subprocess . Popen ( <EOL> "<STR_LIT>" + self . __scriptFileName + "<STR_LIT>" , <EOL> shell = True , <EOL> stderr = subprocess . PIPE , <EOL> ) <EOL> p . wait ( ) <EOL> self . failIf ( p . returncode ) <EOL> for i in range ( <NUM_LIT:1> , <NUM_LIT:4> ) : <EOL> self . failUnless ( os . path . exists ( self . temporaryDirectory ( ) + "<STR_LIT>" % i ) ) <EOL> def testWaitForImage ( self ) : <EOL> s = Gaffer . ScriptNode ( ) <EOL> s [ "<STR_LIT>" ] = GafferScene . Plane ( ) <EOL> s [ "<STR_LIT>" ] = GafferScene . Outputs ( ) <EOL> s [ "<STR_LIT>" ] . addOutput ( <EOL> "<STR_LIT>" , <EOL> IECore . Display ( <EOL> self . temporaryDirectory ( ) + "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> { } <EOL> ) <EOL> ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( s [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) <EOL> s [ "<STR_LIT>" ] = GafferAppleseed . AppleseedRender ( ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( s [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setValue ( "<STR_LIT>" ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setValue ( self . temporaryDirectory ( ) + "<STR_LIT>" ) <EOL> s [ "<STR_LIT>" ] . setValue ( self . __scriptFileName ) <EOL> s . save ( ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] . execute ( ) <EOL> self . failUnless ( os . path . exists ( self . temporaryDirectory ( ) + "<STR_LIT>" ) ) <EOL> def testExecuteWithStringSubstitutions ( self ) : <EOL> s = Gaffer . ScriptNode ( ) <EOL> s [ "<STR_LIT>" ] = GafferScene . Plane ( ) <EOL> s [ "<STR_LIT>" ] = GafferAppleseed . AppleseedRender ( ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setValue ( "<STR_LIT>" ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( s [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setValue ( self . temporaryDirectory ( ) + "<STR_LIT>" ) <EOL> s [ "<STR_LIT>" ] . setValue ( self . __scriptFileName ) <EOL> s . save ( ) <EOL> p = subprocess . Popen ( <EOL> "<STR_LIT>" + self . __scriptFileName + "<STR_LIT>" , <EOL> shell = True , <EOL> stderr = subprocess . PIPE , <EOL> ) <EOL> p . wait ( ) <EOL> self . failIf ( p . returncode ) <EOL> for i in range ( <NUM_LIT:1> , <NUM_LIT:4> ) : <EOL> self . failUnless ( os . path . exists ( self . temporaryDirectory ( ) + "<STR_LIT>" % i ) ) <EOL> def testImageOutput ( self ) : <EOL> s = Gaffer . ScriptNode ( ) <EOL> s [ "<STR_LIT>" ] = GafferScene . Plane ( ) <EOL> s [ "<STR_LIT>" ] = GafferScene . Outputs ( ) <EOL> s [ "<STR_LIT>" ] . addOutput ( <EOL> "<STR_LIT>" , <EOL> IECore . Display ( <EOL> self . temporaryDirectory ( ) + "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> { } <EOL> ) <EOL> ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( s [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) <EOL> s [ "<STR_LIT>" ] = GafferAppleseed . AppleseedRender ( ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( s [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setValue ( "<STR_LIT>" ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setValue ( self . temporaryDirectory ( ) + "<STR_LIT>" ) <EOL> s [ "<STR_LIT>" ] . setValue ( self . __scriptFileName ) <EOL> s . save ( ) <EOL> c = Gaffer . Context ( ) <EOL> for i in range ( <NUM_LIT:1> , <NUM_LIT:4> ) : <EOL> c . setFrame ( i ) <EOL> with c : <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] . execute ( ) <EOL> for i in range ( <NUM_LIT:1> , <NUM_LIT:4> ) : <EOL> self . failUnless ( os . path . exists ( self . temporaryDirectory ( ) + "<STR_LIT>" % i ) ) <EOL> def testTypeNamePrefixes ( self ) : <EOL> self . assertTypeNamesArePrefixed ( GafferAppleseed ) <EOL> self . assertTypeNamesArePrefixed ( GafferAppleseedTest ) <EOL> def testDefaultNames ( self ) : <EOL> self . assertDefaultNamesAreCorrect ( GafferAppleseed ) <EOL> self . assertDefaultNamesAreCorrect ( GafferAppleseedTest ) <EOL> def testNodesConstructWithDefaultValues ( self ) : <EOL> self . assertNodesConstructWithDefaultValues ( GafferAppleseed ) <EOL> self . assertNodesConstructWithDefaultValues ( GafferAppleseedTest ) <EOL> def testDirectoryCreation ( self ) : <EOL> s = Gaffer . ScriptNode ( ) <EOL> s [ "<STR_LIT>" ] . addMember ( "<STR_LIT>" , self . temporaryDirectory ( ) + "<STR_LIT>" ) <EOL> s [ "<STR_LIT>" ] . addMember ( "<STR_LIT>" , self . temporaryDirectory ( ) + "<STR_LIT>" ) <EOL> s [ "<STR_LIT>" ] = GafferScene . Plane ( ) <EOL> s [ "<STR_LIT>" ] = GafferScene . Outputs ( ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( s [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) <EOL> s [ "<STR_LIT>" ] . addOutput ( <EOL> "<STR_LIT>" , <EOL> IECore . Display ( <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> { } <EOL> ) <EOL> ) <EOL> s [ "<STR_LIT>" ] = GafferAppleseed . AppleseedRender ( ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( s [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setValue ( "<STR_LIT>" ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setValue ( "<STR_LIT>" ) <EOL> self . assertFalse ( os . path . exists ( self . temporaryDirectory ( ) + "<STR_LIT>" ) ) <EOL> self . assertFalse ( os . path . exists ( self . temporaryDirectory ( ) + "<STR_LIT>" ) ) <EOL> self . assertFalse ( os . path . exists ( self . temporaryDirectory ( ) + "<STR_LIT>" ) ) <EOL> self . assertFalse ( os . path . exists ( self . __scriptFileName ) ) <EOL> s [ "<STR_LIT>" ] . setValue ( self . __scriptFileName ) <EOL> s . save ( ) <EOL> with s . context ( ) : <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] . execute ( ) <EOL> self . assertTrue ( os . path . exists ( self . temporaryDirectory ( ) + "<STR_LIT>" ) ) <EOL> self . assertTrue ( os . path . exists ( self . temporaryDirectory ( ) + "<STR_LIT>" ) ) <EOL> self . assertTrue ( os . path . exists ( self . temporaryDirectory ( ) + "<STR_LIT>" ) ) <EOL> self . assertTrue ( os . path . exists ( self . __scriptFileName ) ) <EOL> with s . context ( ) : <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] . execute ( ) <EOL> self . assertTrue ( os . path . exists ( self . temporaryDirectory ( ) + "<STR_LIT>" ) ) <EOL> self . assertTrue ( os . path . exists ( self . temporaryDirectory ( ) + "<STR_LIT>" ) ) <EOL> self . assertTrue ( os . path . exists ( self . temporaryDirectory ( ) + "<STR_LIT>" ) ) <EOL> if __name__ == "<STR_LIT:__main__>" : <EOL> unittest . main ( ) </s>
<s> import GafferUITest <EOL> import GafferScene <EOL> import GafferSceneUI <EOL> import GafferArnold <EOL> import GafferArnoldUI <EOL> class DocumentationTest ( GafferUITest . TestCase ) : <EOL> def test ( self ) : <EOL> self . maxDiff = None <EOL> self . assertNodesAreDocumented ( <EOL> GafferArnold , <EOL> additionalTerminalPlugTypes = ( GafferScene . ScenePlug , ) <EOL> ) <EOL> if __name__ == "<STR_LIT:__main__>" : <EOL> unittest . main ( ) </s>
<s> import IECore <EOL> class parameterChangedCallback ( IECore . Parameterised ) : <EOL> def __init__ ( self ) : <EOL> IECore . Parameterised . __init__ ( self , "<STR_LIT>" ) <EOL> self . parameters ( ) . addParameters ( <EOL> [ <EOL> IECore . IntParameter ( <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> <NUM_LIT:0> <EOL> ) , <EOL> IECore . IntParameter ( <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> <NUM_LIT:0> <EOL> ) , <EOL> ] , <EOL> ) <EOL> self . changes = [ ] <EOL> def parameterChanged ( self , parameter ) : <EOL> self . changes . append ( ( parameter , str ( parameter . getValue ( ) ) ) ) <EOL> if parameter . isSame ( self . parameters ( ) [ "<STR_LIT>" ] ) : <EOL> self . parameters ( ) [ "<STR_LIT>" ] . setNumericValue ( self . parameters ( ) [ "<STR_LIT>" ] . getNumericValue ( ) * <NUM_LIT:5> ) <EOL> IECore . registerRunTimeTyped ( parameterChangedCallback ) </s>
<s> import GafferUI <EOL> import GafferCortexUI <EOL> class ToolParameterValueWidget ( GafferCortexUI . ParameterValueWidget ) : <EOL> def __init__ ( self , parameterHandler , parenting = None ) : <EOL> GafferCortexUI . ParameterValueWidget . __init__ ( <EOL> self , <EOL> GafferUI . ToolPlugValueWidget ( parameterHandler . plug ( ) ) , <EOL> parameterHandler , <EOL> parenting = parenting <EOL> ) </s>
<s> import os <EOL> import IECore <EOL> import Gaffer <EOL> import GafferDispatch <EOL> class TextWriter ( GafferDispatch . ExecutableNode ) : <EOL> def __init__ ( self , name = "<STR_LIT>" , requiresSequenceExecution = False ) : <EOL> GafferDispatch . ExecutableNode . __init__ ( self , name ) <EOL> self . __requiresSequenceExecution = requiresSequenceExecution <EOL> self . addChild ( Gaffer . StringPlug ( "<STR_LIT>" , Gaffer . Plug . Direction . In ) ) <EOL> self . addChild ( Gaffer . StringPlug ( "<STR_LIT>" , defaultValue = "<STR_LIT:w>" , direction = Gaffer . Plug . Direction . In ) ) <EOL> self . addChild ( Gaffer . StringPlug ( "<STR_LIT:text>" , Gaffer . Plug . Direction . In ) ) <EOL> def execute ( self ) : <EOL> context = Gaffer . Context . current ( ) <EOL> fileName = self [ "<STR_LIT>" ] . getValue ( ) <EOL> directory = os . path . dirname ( fileName ) <EOL> if directory : <EOL> try : <EOL> os . makedirs ( directory ) <EOL> except OSError : <EOL> if not os . path . isdir ( directory ) : <EOL> raise <EOL> text = self . __processText ( context ) <EOL> with file ( fileName , self [ "<STR_LIT>" ] . getValue ( ) ) as f : <EOL> f . write ( text ) <EOL> def executeSequence ( self , frames ) : <EOL> if not self . __requiresSequenceExecution : <EOL> GafferDispatch . ExecutableNode . executeSequence ( self , frames ) <EOL> return <EOL> context = Gaffer . Context ( Gaffer . Context . current ( ) ) <EOL> fileName = self [ "<STR_LIT>" ] . getValue ( ) <EOL> with file ( fileName , self [ "<STR_LIT>" ] . getValue ( ) ) as f : <EOL> with context : <EOL> for frame in frames : <EOL> context . setFrame ( frame ) <EOL> text = self . __processText ( context ) <EOL> f . write ( text ) <EOL> def hash ( self , context ) : <EOL> h = GafferDispatch . ExecutableNode . hash ( self , context ) <EOL> h . append ( context . getFrame ( ) ) <EOL> h . append ( context . get ( "<STR_LIT>" , IECore . StringVectorData ( ) ) ) <EOL> self [ "<STR_LIT>" ] . hash ( h ) <EOL> self [ "<STR_LIT>" ] . hash ( h ) <EOL> self [ "<STR_LIT:text>" ] . hash ( h ) <EOL> return h <EOL> def requiresSequenceExecution ( self ) : <EOL> return self . __requiresSequenceExecution <EOL> def __processText ( self , context ) : <EOL> text = self [ "<STR_LIT:text>" ] . getValue ( ) <EOL> replace = context . get ( "<STR_LIT>" , IECore . StringVectorData ( ) ) <EOL> if replace and len ( replace ) == <NUM_LIT:2> : <EOL> text = text . replace ( replace [ <NUM_LIT:0> ] , replace [ <NUM_LIT:1> ] ) <EOL> return text <EOL> IECore . registerRunTimeTyped ( TextWriter , typeName = "<STR_LIT>" ) </s>
<s> import os <EOL> import IECore <EOL> import Gaffer <EOL> import GafferImage <EOL> import GafferTest <EOL> import GafferImageTest <EOL> class CopyImageMetadataTest ( GafferImageTest . ImageTestCase ) : <EOL> checkerFile = os . path . expandvars ( "<STR_LIT>" ) <EOL> def test ( self ) : <EOL> r = GafferImage . ImageReader ( ) <EOL> r [ "<STR_LIT>" ] . setValue ( self . checkerFile ) <EOL> inMetadata = r [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) <EOL> d = GafferImage . DeleteImageMetadata ( ) <EOL> d [ "<STR_LIT>" ] . setInput ( r [ "<STR_LIT>" ] ) <EOL> d [ "<STR_LIT>" ] . setValue ( "<STR_LIT:*>" ) <EOL> m = GafferImage . CopyImageMetadata ( ) <EOL> m [ "<STR_LIT>" ] . setInput ( d [ "<STR_LIT>" ] ) <EOL> m [ "<STR_LIT>" ] . setInput ( r [ "<STR_LIT>" ] ) <EOL> m [ "<STR_LIT>" ] . setValue ( "<STR_LIT>" ) <EOL> metadata = m [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) <EOL> self . assertEqual ( m [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) , IECore . CompoundObject ( ) ) <EOL> self . assertEqual ( m [ "<STR_LIT>" ] . image ( ) , d [ "<STR_LIT>" ] . image ( ) ) <EOL> m [ "<STR_LIT>" ] . setValue ( "<STR_LIT>" ) <EOL> metadata = m [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) <EOL> expected = set ( [ "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ] ) <EOL> self . assertEqual ( set ( metadata . keys ( ) ) , expected ) <EOL> for key in metadata . keys ( ) : <EOL> self . assertEqual ( metadata [ key ] , inMetadata [ key ] ) <EOL> m [ "<STR_LIT>" ] . setValue ( True ) <EOL> metadata = m [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) <EOL> expected = set ( [ "<STR_LIT>" , "<STR_LIT>" ] ) <EOL> self . assertEqual ( set ( metadata . keys ( ) ) , expected ) <EOL> for key in metadata . keys ( ) : <EOL> self . assertEqual ( metadata [ key ] , inMetadata [ key ] ) <EOL> def testOverwrite ( self ) : <EOL> r = GafferImage . ImageReader ( ) <EOL> r [ "<STR_LIT>" ] . setValue ( self . checkerFile ) <EOL> inMetadata = r [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) <EOL> a = GafferImage . ImageMetadata ( ) <EOL> a [ "<STR_LIT>" ] . addMember ( "<STR_LIT>" , IECore . StringData ( "<STR_LIT>" ) ) <EOL> m = GafferImage . CopyImageMetadata ( ) <EOL> m [ "<STR_LIT>" ] . setInput ( r [ "<STR_LIT>" ] ) <EOL> m [ "<STR_LIT>" ] . setInput ( a [ "<STR_LIT>" ] ) <EOL> m [ "<STR_LIT>" ] . setValue ( "<STR_LIT>" ) <EOL> metadata = m [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) <EOL> self . assertEqual ( metadata [ "<STR_LIT>" ] , IECore . StringData ( "<STR_LIT>" ) ) <EOL> self . assertEqual ( m [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) , inMetadata ) <EOL> self . assertEqual ( m [ "<STR_LIT>" ] . image ( ) , r [ "<STR_LIT>" ] . image ( ) ) <EOL> m [ "<STR_LIT>" ] . setValue ( "<STR_LIT>" ) <EOL> metadata = m [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) <EOL> self . assertTrue ( "<STR_LIT>" in metadata . keys ( ) ) <EOL> self . assertEqual ( metadata [ "<STR_LIT>" ] , IECore . StringData ( "<STR_LIT>" ) ) <EOL> def testDirtyPropogation ( self ) : <EOL> c = GafferImage . Constant ( ) <EOL> r = GafferImage . ImageReader ( ) <EOL> r [ "<STR_LIT>" ] . setValue ( self . checkerFile ) <EOL> inMetadata = r [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) <EOL> m = GafferImage . CopyImageMetadata ( ) <EOL> m [ "<STR_LIT>" ] . setInput ( c [ "<STR_LIT>" ] ) <EOL> m [ "<STR_LIT>" ] . setInput ( r [ "<STR_LIT>" ] ) <EOL> cs = GafferTest . CapturingSlot ( m . plugDirtiedSignal ( ) ) <EOL> m [ "<STR_LIT>" ] . setInput ( c [ "<STR_LIT>" ] ) <EOL> self . assertTrue ( m [ "<STR_LIT>" ] [ "<STR_LIT>" ] in set ( e [ <NUM_LIT:0> ] for e in cs ) ) <EOL> del cs [ : ] <EOL> m [ "<STR_LIT>" ] . setValue ( "<STR_LIT:test>" ) <EOL> self . assertTrue ( m [ "<STR_LIT>" ] [ "<STR_LIT>" ] in set ( e [ <NUM_LIT:0> ] for e in cs ) ) <EOL> del cs [ : ] <EOL> m [ "<STR_LIT>" ] . setValue ( True ) <EOL> self . assertTrue ( m [ "<STR_LIT>" ] [ "<STR_LIT>" ] in set ( e [ <NUM_LIT:0> ] for e in cs ) ) <EOL> def testPassThrough ( self ) : <EOL> c = GafferImage . Constant ( ) <EOL> i = GafferImage . ImageReader ( ) <EOL> i [ "<STR_LIT>" ] . setValue ( self . checkerFile ) <EOL> m = GafferImage . CopyImageMetadata ( ) <EOL> m [ "<STR_LIT>" ] . setInput ( i [ "<STR_LIT>" ] ) <EOL> m [ "<STR_LIT>" ] . setValue ( "<STR_LIT:*>" ) <EOL> self . assertEqual ( i [ "<STR_LIT>" ] [ "<STR_LIT>" ] . hash ( ) , m [ "<STR_LIT>" ] [ "<STR_LIT>" ] . hash ( ) ) <EOL> self . assertEqual ( i [ "<STR_LIT>" ] [ "<STR_LIT>" ] . hash ( ) , m [ "<STR_LIT>" ] [ "<STR_LIT>" ] . hash ( ) ) <EOL> self . assertEqual ( i [ "<STR_LIT>" ] [ "<STR_LIT>" ] . hash ( ) , m [ "<STR_LIT>" ] [ "<STR_LIT>" ] . hash ( ) ) <EOL> self . assertEqual ( i [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) , m [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) ) <EOL> self . assertEqual ( i [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) , m [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) ) <EOL> self . assertEqual ( i [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) , m [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) ) <EOL> context = Gaffer . Context ( ) <EOL> context [ "<STR_LIT>" ] = IECore . V2i ( <NUM_LIT:0> ) <EOL> with context : <EOL> for c in [ "<STR_LIT>" , "<STR_LIT:B>" , "<STR_LIT:A>" ] : <EOL> context [ "<STR_LIT>" ] = c <EOL> self . assertEqual ( i [ "<STR_LIT>" ] [ "<STR_LIT>" ] . hash ( ) , m [ "<STR_LIT>" ] [ "<STR_LIT>" ] . hash ( ) ) <EOL> self . assertEqual ( i [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) , m [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) ) <EOL> if __name__ == "<STR_LIT:__main__>" : <EOL> unittest . main ( ) </s>
<s> import os <EOL> import unittest <EOL> import IECore <EOL> import Gaffer <EOL> import GafferImage <EOL> import GafferImageTest <EOL> class ObjectToImageTest ( GafferImageTest . ImageTestCase ) : <EOL> fileName = os . path . expandvars ( "<STR_LIT>" ) <EOL> negFileName = os . path . expandvars ( "<STR_LIT>" ) <EOL> def test ( self ) : <EOL> i = IECore . Reader . create ( self . fileName ) . read ( ) <EOL> n = GafferImage . ObjectToImage ( ) <EOL> n [ "<STR_LIT:object>" ] . setValue ( i ) <EOL> self . assertEqual ( n [ "<STR_LIT>" ] . image ( ) , i ) <EOL> def testImageWithANegativeDataWindow ( self ) : <EOL> i = IECore . Reader . create ( self . negFileName ) . read ( ) <EOL> n = GafferImage . ObjectToImage ( ) <EOL> n [ "<STR_LIT:object>" ] . setValue ( i ) <EOL> self . assertEqual ( n [ "<STR_LIT>" ] . image ( ) , i ) <EOL> def testHashVariesPerTileAndChannel ( self ) : <EOL> n = GafferImage . ObjectToImage ( ) <EOL> n [ "<STR_LIT:object>" ] . setValue ( IECore . Reader . create ( self . fileName ) . read ( ) ) <EOL> self . assertNotEqual ( <EOL> n [ "<STR_LIT>" ] . channelDataHash ( "<STR_LIT:R>" , IECore . V2i ( <NUM_LIT:0> ) ) , <EOL> n [ "<STR_LIT>" ] . channelDataHash ( "<STR_LIT>" , IECore . V2i ( <NUM_LIT:0> ) ) <EOL> ) <EOL> self . assertNotEqual ( <EOL> n [ "<STR_LIT>" ] . channelDataHash ( "<STR_LIT:R>" , IECore . V2i ( <NUM_LIT:0> ) ) , <EOL> n [ "<STR_LIT>" ] . channelDataHash ( "<STR_LIT:R>" , IECore . V2i ( GafferImage . ImagePlug . tileSize ( ) ) ) <EOL> ) <EOL> if __name__ == "<STR_LIT:__main__>" : <EOL> unittest . main ( ) </s>
<s> import threading <EOL> import IECore <EOL> import Gaffer <EOL> import GafferUI <EOL> import GafferImage <EOL> __all__ = [ ] <EOL> Gaffer . Metadata . registerNode ( <EOL> GafferImage . Display , <EOL> "<STR_LIT:description>" , <EOL> """<STR_LIT>""" , <EOL> plugs = { <EOL> "<STR_LIT:port>" : [ <EOL> "<STR_LIT:description>" , <EOL> """<STR_LIT>""" , <EOL> ] , <EOL> } <EOL> ) <EOL> __plugsPendingUpdate = [ ] <EOL> __plugsPendingUpdateLock = threading . Lock ( ) <EOL> def __scheduleUpdate ( plug , force = False ) : <EOL> if not force : <EOL> global __plugsPendingUpdate <EOL> global __plugsPendingUpdateLock <EOL> with __plugsPendingUpdateLock : <EOL> for p in __plugsPendingUpdate : <EOL> if plug . isSame ( p ) : <EOL> return <EOL> __plugsPendingUpdate . append ( plug ) <EOL> GafferUI . EventLoop . executeOnUIThread ( lambda : __update ( plug ) ) <EOL> def __update ( plug ) : <EOL> node = plug . node ( ) <EOL> if node : <EOL> updateCountPlug = node [ "<STR_LIT>" ] <EOL> updateCountPlug . setValue ( updateCountPlug . getValue ( ) + <NUM_LIT:1> ) <EOL> global __plugsPendingUpdate <EOL> global __plugsPendingUpdateLock <EOL> with __plugsPendingUpdateLock : <EOL> __plugsPendingUpdate = [ p for p in __plugsPendingUpdate if not p . isSame ( plug ) ] <EOL> __displayDataReceivedConnection = GafferImage . Display . dataReceivedSignal ( ) . connect ( __scheduleUpdate ) <EOL> __displayImageReceivedConnection = GafferImage . Display . imageReceivedSignal ( ) . connect ( IECore . curry ( __scheduleUpdate , force = True ) ) </s>
<s> from _GafferImageUI import * <EOL> import DisplayUI <EOL> from FormatPlugValueWidget import FormatPlugValueWidget <EOL> from ChannelMaskPlugValueWidget import ChannelMaskPlugValueWidget <EOL> import OpenImageIOReaderUI <EOL> import ImageReaderUI <EOL> import ImageViewToolbar <EOL> import ImageTransformUI <EOL> import ConstantUI <EOL> import ImageSwitchUI <EOL> import ColorSpaceUI <EOL> import ImageContextVariablesUI <EOL> import ImageStatsUI <EOL> import DeleteChannelsUI <EOL> import ObjectToImageUI <EOL> import ClampUI <EOL> import ImageWriterUI <EOL> import GradeUI <EOL> import ImageTimeWarpUI <EOL> import ImageSamplerUI <EOL> import MergeUI <EOL> import ImageNodeUI <EOL> import ChannelDataProcessorUI <EOL> import ImageProcessorUI <EOL> import ImageMetadataUI <EOL> import DeleteImageMetadataUI <EOL> import CopyImageMetadataUI <EOL> import ImageLoopUI <EOL> import ShuffleUI <EOL> import PremultiplyUI <EOL> import UnpremultiplyUI <EOL> import CropUI <EOL> import ResizeUI <EOL> import ResampleUI <EOL> import LUTUI <EOL> import CDLUI <EOL> import DisplayTransformUI <EOL> import OffsetUI <EOL> import BlurUI <EOL> import ShapeUI <EOL> import TextUI <EOL> import WarpUI <EOL> import UVWarpUI <EOL> __import__ ( "<STR_LIT>" ) . loadConfig ( "<STR_LIT>" , { } , subdirectory = "<STR_LIT>" ) </s>
<s> import os <EOL> import unittest <EOL> import IECore <EOL> import Gaffer <EOL> import GafferTest <EOL> import GafferScene <EOL> import GafferSceneTest <EOL> import GafferRenderMan <EOL> import GafferRenderManTest <EOL> class RenderManShaderTest ( GafferRenderManTest . RenderManTestCase ) : <EOL> def setUp ( self ) : <EOL> GafferRenderManTest . RenderManTestCase . setUp ( self ) <EOL> GafferRenderMan . RenderManShader . shaderLoader ( ) . clear ( ) <EOL> def test ( self ) : <EOL> n = GafferRenderMan . RenderManShader ( ) <EOL> n . loadShader ( "<STR_LIT>" ) <EOL> self . failUnless ( isinstance ( n [ "<STR_LIT>" ] [ "<STR_LIT>" ] , Gaffer . FloatPlug ) ) <EOL> self . failUnless ( isinstance ( n [ "<STR_LIT>" ] [ "<STR_LIT>" ] , Gaffer . FloatPlug ) ) <EOL> self . failUnless ( isinstance ( n [ "<STR_LIT>" ] [ "<STR_LIT>" ] , Gaffer . FloatPlug ) ) <EOL> self . failUnless ( isinstance ( n [ "<STR_LIT>" ] [ "<STR_LIT>" ] , Gaffer . FloatPlug ) ) <EOL> self . failUnless ( isinstance ( n [ "<STR_LIT>" ] [ "<STR_LIT>" ] , Gaffer . Color3fPlug ) ) <EOL> self . assertEqual ( n [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) , <NUM_LIT:0.5> ) <EOL> self . assertEqual ( n [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) , <NUM_LIT:0.5> ) <EOL> self . assertEqual ( n [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) , <NUM_LIT:1> ) <EOL> self . assertAlmostEqual ( n [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) , <NUM_LIT:0.1> ) <EOL> self . assertEqual ( n [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) , IECore . Color3f ( <NUM_LIT:1> ) ) <EOL> def testSerialisation ( self ) : <EOL> s = Gaffer . ScriptNode ( ) <EOL> s [ "<STR_LIT:n>" ] = GafferRenderMan . RenderManShader ( ) <EOL> s [ "<STR_LIT:n>" ] . loadShader ( "<STR_LIT>" ) <EOL> ss = s . serialise ( ) <EOL> s = Gaffer . ScriptNode ( ) <EOL> s . execute ( ss ) <EOL> st = s [ "<STR_LIT:n>" ] . state ( ) <EOL> self . assertEqual ( len ( st ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( st [ <NUM_LIT:0> ] . type , "<STR_LIT>" ) <EOL> self . assertEqual ( st [ <NUM_LIT:0> ] . name , "<STR_LIT>" ) <EOL> self . failUnless ( isinstance ( s [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] , Gaffer . FloatPlug ) ) <EOL> self . failUnless ( isinstance ( s [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] , Gaffer . FloatPlug ) ) <EOL> self . failUnless ( isinstance ( s [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] , Gaffer . FloatPlug ) ) <EOL> self . failUnless ( isinstance ( s [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] , Gaffer . FloatPlug ) ) <EOL> self . failUnless ( isinstance ( s [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] , Gaffer . Color3fPlug ) ) <EOL> self . assertTrue ( "<STR_LIT>" not in s [ "<STR_LIT:n>" ] ) <EOL> def testShader ( self ) : <EOL> n = GafferRenderMan . RenderManShader ( ) <EOL> n . loadShader ( "<STR_LIT>" ) <EOL> s = n . state ( ) <EOL> self . assertEqual ( len ( s ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( s [ <NUM_LIT:0> ] . type , "<STR_LIT>" ) <EOL> self . assertEqual ( s [ <NUM_LIT:0> ] . name , "<STR_LIT>" ) <EOL> self . assertEqual ( s [ <NUM_LIT:0> ] . parameters [ "<STR_LIT>" ] , IECore . FloatData ( <NUM_LIT> ) ) <EOL> self . assertEqual ( s [ <NUM_LIT:0> ] . parameters [ "<STR_LIT>" ] , IECore . FloatData ( <NUM_LIT> ) ) <EOL> self . assertEqual ( s [ <NUM_LIT:0> ] . parameters [ "<STR_LIT>" ] , IECore . FloatData ( <NUM_LIT:1> ) ) <EOL> self . assertEqual ( s [ <NUM_LIT:0> ] . parameters [ "<STR_LIT>" ] , IECore . FloatData ( <NUM_LIT> ) ) <EOL> self . assertEqual ( s [ <NUM_LIT:0> ] . parameters [ "<STR_LIT>" ] , IECore . Color3fData ( IECore . Color3f ( <NUM_LIT:1> ) ) ) <EOL> def testShaderHash ( self ) : <EOL> n = GafferRenderMan . RenderManShader ( ) <EOL> n . loadShader ( "<STR_LIT>" ) <EOL> h1 = n . stateHash ( ) <EOL> n [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setValue ( <NUM_LIT> ) <EOL> self . assertNotEqual ( n . stateHash ( ) , h1 ) <EOL> def testCoshaderHash ( self ) : <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> shaderNode = GafferRenderMan . RenderManShader ( ) <EOL> shaderNode . loadShader ( shader ) <EOL> self . assertTrue ( "<STR_LIT>" in shaderNode [ "<STR_LIT>" ] ) <EOL> self . assertEqual ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . typeId ( ) , Gaffer . Plug . staticTypeId ( ) ) <EOL> coshader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> coshaderNode = GafferRenderMan . RenderManShader ( ) <EOL> coshaderNode . loadShader ( coshader ) <EOL> shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( coshaderNode [ "<STR_LIT>" ] ) <EOL> h1 = shaderNode . stateHash ( ) <EOL> coshaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setValue ( <NUM_LIT> ) <EOL> self . assertNotEqual ( shaderNode . stateHash ( ) , h1 ) <EOL> def testParameterOrdering ( self ) : <EOL> n = GafferRenderMan . RenderManShader ( ) <EOL> n . loadShader ( "<STR_LIT>" ) <EOL> self . assertEqual ( n [ "<STR_LIT>" ] [ <NUM_LIT:0> ] . getName ( ) , "<STR_LIT>" ) <EOL> self . assertEqual ( n [ "<STR_LIT>" ] [ <NUM_LIT:1> ] . getName ( ) , "<STR_LIT>" ) <EOL> self . assertEqual ( n [ "<STR_LIT>" ] [ <NUM_LIT:2> ] . getName ( ) , "<STR_LIT>" ) <EOL> self . assertEqual ( n [ "<STR_LIT>" ] [ <NUM_LIT:3> ] . getName ( ) , "<STR_LIT>" ) <EOL> self . assertEqual ( n [ "<STR_LIT>" ] [ <NUM_LIT:4> ] . getName ( ) , "<STR_LIT>" ) <EOL> n = GafferRenderMan . RenderManShader ( ) <EOL> n . loadShader ( "<STR_LIT>" ) <EOL> self . assertEqual ( n [ "<STR_LIT>" ] [ <NUM_LIT:0> ] . getName ( ) , "<STR_LIT>" ) <EOL> self . assertEqual ( n [ "<STR_LIT>" ] [ <NUM_LIT:1> ] . getName ( ) , "<STR_LIT>" ) <EOL> def testCoshader ( self ) : <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> shaderNode = GafferRenderMan . RenderManShader ( ) <EOL> shaderNode . loadShader ( shader ) <EOL> self . assertTrue ( "<STR_LIT>" in shaderNode [ "<STR_LIT>" ] ) <EOL> self . assertEqual ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . typeId ( ) , Gaffer . Plug . staticTypeId ( ) ) <EOL> coshader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> coshaderNode = GafferRenderMan . RenderManShader ( ) <EOL> coshaderNode . loadShader ( coshader ) <EOL> shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( coshaderNode [ "<STR_LIT>" ] ) <EOL> s = shaderNode . state ( ) <EOL> self . assertEqual ( len ( s ) , <NUM_LIT:2> ) <EOL> self . assertEqual ( s [ <NUM_LIT:0> ] . name , coshader ) <EOL> self . assertEqual ( s [ <NUM_LIT:1> ] . name , shader ) <EOL> self . assertEqual ( s [ <NUM_LIT:0> ] . parameters [ "<STR_LIT>" ] , s [ <NUM_LIT:1> ] . parameters [ "<STR_LIT>" ] ) <EOL> def testInputAcceptance ( self ) : <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> shaderNode = GafferRenderMan . RenderManShader ( ) <EOL> shaderNode . loadShader ( shader ) <EOL> coshader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> coshaderNode = GafferRenderMan . RenderManShader ( ) <EOL> coshaderNode . loadShader ( coshader ) <EOL> random = Gaffer . Random ( ) <EOL> self . assertTrue ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . acceptsInput ( coshaderNode [ "<STR_LIT>" ] ) ) <EOL> self . assertFalse ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . acceptsInput ( random [ "<STR_LIT>" ] ) ) <EOL> self . assertTrue ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . acceptsInput ( random [ "<STR_LIT>" ] ) ) <EOL> self . assertFalse ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . acceptsInput ( coshaderNode [ "<STR_LIT>" ] ) ) <EOL> self . assertTrue ( coshaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . acceptsInput ( random [ "<STR_LIT>" ] ) ) <EOL> self . assertFalse ( coshaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . acceptsInput ( coshaderNode [ "<STR_LIT>" ] ) ) <EOL> def testParameterDefaultValue ( self ) : <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> shaderNode = GafferRenderMan . RenderManShader ( ) <EOL> shaderNode . loadShader ( shader ) <EOL> self . assertEqual ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . defaultValue ( ) , <NUM_LIT:1> ) <EOL> def testParameterMinMax ( self ) : <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> shaderNode = GafferRenderMan . RenderManShader ( ) <EOL> shaderNode . loadShader ( shader ) <EOL> self . assertEqual ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . minValue ( ) , - <NUM_LIT:1> ) <EOL> self . assertEqual ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . maxValue ( ) , <NUM_LIT:10> ) <EOL> def testReload ( self ) : <EOL> shader1 = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> shaderNode = GafferRenderMan . RenderManShader ( ) <EOL> shaderNode . loadShader ( shader1 ) <EOL> shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setValue ( <NUM_LIT:0.1> ) <EOL> shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setValue ( "<STR_LIT:test>" ) <EOL> shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setValue ( IECore . Color3f ( <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> ) ) <EOL> self . assertAlmostEqual ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) , <NUM_LIT:0.1> ) <EOL> self . assertEqual ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) , "<STR_LIT:test>" ) <EOL> self . assertEqual ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) , IECore . Color3f ( <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> ) ) <EOL> shader2 = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> shaderNode . loadShader ( shader2 , keepExistingValues = True ) <EOL> self . assertEqual ( shaderNode [ "<STR_LIT>" ] . keys ( ) , [ "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ] ) <EOL> self . assertAlmostEqual ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) , <NUM_LIT:0.1> ) <EOL> self . assertEqual ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) , "<STR_LIT:test>" ) <EOL> self . assertEqual ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) , IECore . Color3f ( <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> ) ) <EOL> shaderNode . loadShader ( shader1 , keepExistingValues = True ) <EOL> self . assertEqual ( shaderNode [ "<STR_LIT>" ] . keys ( ) , [ "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ] ) <EOL> self . assertAlmostEqual ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) , <NUM_LIT:0.1> ) <EOL> self . assertEqual ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) , "<STR_LIT:test>" ) <EOL> self . assertEqual ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) , IECore . Color3f ( <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> ) ) <EOL> shaderNode . loadShader ( shader1 , keepExistingValues = False ) <EOL> self . assertEqual ( shaderNode [ "<STR_LIT>" ] . keys ( ) , [ "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ] ) <EOL> self . assertEqual ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) , "<STR_LIT>" ) <EOL> self . assertEqual ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) , IECore . Color3f ( <NUM_LIT:1> , <NUM_LIT:1> , <NUM_LIT:1> ) ) <EOL> def testReloadRemovesOldParameters ( self ) : <EOL> shader2 = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> shaderNode = GafferRenderMan . RenderManShader ( ) <EOL> shaderNode . loadShader ( shader2 ) <EOL> self . assertEqual ( shaderNode [ "<STR_LIT>" ] . keys ( ) , [ "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ] ) <EOL> shader3 = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> shaderNode . loadShader ( shader3 ) <EOL> self . assertEqual ( shaderNode [ "<STR_LIT>" ] . keys ( ) , [ "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ] ) <EOL> def testAutomaticReloadOnScriptLoad ( self ) : <EOL> shader1 = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" , shaderName = "<STR_LIT>" ) <EOL> s = Gaffer . ScriptNode ( ) <EOL> s [ "<STR_LIT>" ] = GafferRenderMan . RenderManShader ( ) <EOL> s [ "<STR_LIT>" ] . loadShader ( shader1 ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setValue ( <NUM_LIT:0.1> ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setValue ( "<STR_LIT:test>" ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setValue ( IECore . Color3f ( <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> ) ) <EOL> ss = s . serialise ( ) <EOL> self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" , shaderName = "<STR_LIT>" ) <EOL> GafferRenderMan . RenderManShader . shaderLoader ( ) . clear ( ) <EOL> s = Gaffer . ScriptNode ( ) <EOL> s . execute ( ss ) <EOL> self . assertEqual ( s [ "<STR_LIT>" ] [ "<STR_LIT>" ] . keys ( ) , [ "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ] ) <EOL> self . assertAlmostEqual ( s [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) , <NUM_LIT:0.1> ) <EOL> self . assertEqual ( s [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) , "<STR_LIT:test>" ) <EOL> self . assertEqual ( s [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) , IECore . Color3f ( <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> ) ) <EOL> def testReloadPreservesConnections ( self ) : <EOL> n = GafferRenderMan . RenderManShader ( ) <EOL> n . loadShader ( "<STR_LIT>" ) <EOL> random = Gaffer . Random ( ) <EOL> n [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( random [ "<STR_LIT>" ] ) <EOL> n [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( random [ "<STR_LIT>" ] ) <EOL> n . loadShader ( "<STR_LIT>" , keepExistingValues = True ) <EOL> self . assertTrue ( n [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getInput ( ) . isSame ( random [ "<STR_LIT>" ] ) ) <EOL> self . assertTrue ( n [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getInput ( ) . isSame ( random [ "<STR_LIT>" ] ) ) <EOL> def testReloadPreservesConnectionsWhenMinMaxOrDefaultChanges ( self ) : <EOL> shader1 = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" , shaderName = "<STR_LIT>" ) <EOL> n = GafferRenderMan . RenderManShader ( ) <EOL> n . loadShader ( shader1 ) <EOL> self . assertFalse ( n [ "<STR_LIT>" ] [ "<STR_LIT>" ] . hasMinValue ( ) ) <EOL> self . assertFalse ( n [ "<STR_LIT>" ] [ "<STR_LIT>" ] . hasMaxValue ( ) ) <EOL> self . assertEqual ( n [ "<STR_LIT>" ] [ "<STR_LIT>" ] . defaultValue ( ) , "<STR_LIT>" ) <EOL> nn = Gaffer . Node ( ) <EOL> nn [ "<STR_LIT>" ] = Gaffer . FloatPlug ( direction = Gaffer . Plug . Direction . Out ) <EOL> nn [ "<STR_LIT>" ] = Gaffer . StringPlug ( direction = Gaffer . Plug . Direction . Out ) <EOL> n [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( nn [ "<STR_LIT>" ] ) <EOL> n [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( nn [ "<STR_LIT>" ] ) <EOL> shader2 = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" , shaderName = "<STR_LIT>" ) <EOL> GafferRenderMan . RenderManShader . shaderLoader ( ) . clear ( ) <EOL> n . loadShader ( shader1 , keepExistingValues = True ) <EOL> self . assertTrue ( n [ "<STR_LIT>" ] [ "<STR_LIT>" ] . hasMinValue ( ) ) <EOL> self . assertTrue ( n [ "<STR_LIT>" ] [ "<STR_LIT>" ] . hasMaxValue ( ) ) <EOL> self . assertEqual ( n [ "<STR_LIT>" ] [ "<STR_LIT>" ] . minValue ( ) , - <NUM_LIT:1> ) <EOL> self . assertEqual ( n [ "<STR_LIT>" ] [ "<STR_LIT>" ] . maxValue ( ) , <NUM_LIT:2> ) <EOL> self . assertEqual ( n [ "<STR_LIT>" ] [ "<STR_LIT>" ] . defaultValue ( ) , "<STR_LIT>" ) <EOL> self . assertTrue ( n [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getInput ( ) . isSame ( nn [ "<STR_LIT>" ] ) ) <EOL> self . assertTrue ( n [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getInput ( ) . isSame ( nn [ "<STR_LIT>" ] ) ) <EOL> def testReloadPreservesPartialConnectionsWhenMinMaxOrDefaultChanges ( self ) : <EOL> shader1 = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" , shaderName = "<STR_LIT>" ) <EOL> n = GafferRenderMan . RenderManShader ( ) <EOL> n . loadShader ( shader1 ) <EOL> nn = Gaffer . Node ( ) <EOL> nn [ "<STR_LIT>" ] = Gaffer . FloatPlug ( direction = Gaffer . Plug . Direction . Out ) <EOL> n [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:0> ] . setInput ( nn [ "<STR_LIT>" ] ) <EOL> n [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:1> ] . setInput ( nn [ "<STR_LIT>" ] ) <EOL> n [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:2> ] . setValue ( <NUM_LIT> ) <EOL> shader2 = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" , shaderName = "<STR_LIT>" ) <EOL> GafferRenderMan . RenderManShader . shaderLoader ( ) . clear ( ) <EOL> n . loadShader ( shader1 , keepExistingValues = True ) <EOL> self . assertTrue ( n [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:0> ] . getInput ( ) . isSame ( nn [ "<STR_LIT>" ] ) ) <EOL> self . assertTrue ( n [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:1> ] . getInput ( ) . isSame ( nn [ "<STR_LIT>" ] ) ) <EOL> self . assertEqual ( n [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:2> ] . getValue ( ) , <NUM_LIT> ) <EOL> def testReloadPreservesValuesWhenMinMaxOrDefaultChanges ( self ) : <EOL> shader1 = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" , shaderName = "<STR_LIT>" ) <EOL> n = GafferRenderMan . RenderManShader ( ) <EOL> n . loadShader ( shader1 ) <EOL> n [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setValue ( <NUM_LIT> ) <EOL> n [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setValue ( "<STR_LIT>" ) <EOL> n [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setValue ( IECore . Color3f ( <NUM_LIT:0.1> , <NUM_LIT> , <NUM_LIT:0.5> ) ) <EOL> shader2 = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" , shaderName = "<STR_LIT>" ) <EOL> GafferRenderMan . RenderManShader . shaderLoader ( ) . clear ( ) <EOL> n . loadShader ( shader1 , keepExistingValues = True ) <EOL> self . assertEqual ( n [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) , <NUM_LIT> ) <EOL> self . assertEqual ( n [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) , "<STR_LIT>" ) <EOL> self . assertEqual ( n [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) , IECore . Color3f ( <NUM_LIT:0.1> , <NUM_LIT> , <NUM_LIT:0.5> ) ) <EOL> def testOutputParameters ( self ) : <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> n = GafferRenderMan . RenderManShader ( ) <EOL> n . loadShader ( shader ) <EOL> self . failIf ( "<STR_LIT>" in n [ "<STR_LIT>" ] . keys ( ) ) <EOL> def testAssignmentDirtyPropagation ( self ) : <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> shaderNode = GafferRenderMan . RenderManShader ( ) <EOL> shaderNode . loadShader ( shader ) <EOL> coshader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> coshaderNode = GafferRenderMan . RenderManShader ( ) <EOL> coshaderNode . loadShader ( coshader ) <EOL> shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( coshaderNode [ "<STR_LIT>" ] ) <EOL> plane = GafferScene . Plane ( ) <EOL> assignment = GafferScene . ShaderAssignment ( ) <EOL> assignment [ "<STR_LIT>" ] . setInput ( plane [ "<STR_LIT>" ] ) <EOL> assignment [ "<STR_LIT>" ] . setInput ( shaderNode [ "<STR_LIT>" ] ) <EOL> cs = GafferTest . CapturingSlot ( assignment . plugDirtiedSignal ( ) ) <EOL> coshaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setValue ( <NUM_LIT:12> ) <EOL> dirtiedNames = [ x [ <NUM_LIT:0> ] . fullName ( ) for x in cs ] <EOL> self . assertEqual ( len ( dirtiedNames ) , <NUM_LIT:3> ) <EOL> self . assertEqual ( dirtiedNames [ <NUM_LIT:0> ] , "<STR_LIT>" ) <EOL> self . assertEqual ( dirtiedNames [ <NUM_LIT:1> ] , "<STR_LIT>" ) <EOL> self . assertEqual ( dirtiedNames [ <NUM_LIT:2> ] , "<STR_LIT>" ) <EOL> def testArrayParameters ( self ) : <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> n = GafferRenderMan . RenderManShader ( ) <EOL> n . loadShader ( shader ) <EOL> expected = { <EOL> "<STR_LIT>" : IECore . FloatVectorData ( [ ] ) , <EOL> "<STR_LIT>" : IECore . FloatVectorData ( [ <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:4> ] ) , <EOL> "<STR_LIT>" : IECore . StringVectorData ( [ "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ] ) , <EOL> "<STR_LIT>" : IECore . StringVectorData ( [ "<STR_LIT:hello>" , "<STR_LIT>" ] ) , <EOL> "<STR_LIT>" : IECore . Color3fVectorData ( [ IECore . Color3f ( <NUM_LIT:1> ) , IECore . Color3f ( <NUM_LIT:2> ) ] ) , <EOL> "<STR_LIT>" : IECore . Color3fVectorData ( [ IECore . Color3f ( <NUM_LIT:1> ) , IECore . Color3f ( <NUM_LIT:2> ) ] ) , <EOL> "<STR_LIT>" : IECore . V3fVectorData ( [ ] , IECore . GeometricData . Interpretation . Vector ) , <EOL> "<STR_LIT>" : IECore . V3fVectorData ( [ IECore . V3f ( x ) for x in range ( <NUM_LIT:1> , <NUM_LIT:6> ) ] , IECore . GeometricData . Interpretation . Vector ) , <EOL> "<STR_LIT>" : IECore . V3fVectorData ( [ ] , IECore . GeometricData . Interpretation . Point ) , <EOL> "<STR_LIT>" : IECore . V3fVectorData ( [ IECore . V3f ( x ) for x in range ( <NUM_LIT:1> , <NUM_LIT:6> ) ] , IECore . GeometricData . Interpretation . Point ) , <EOL> "<STR_LIT>" : IECore . V3fVectorData ( [ ] , IECore . GeometricData . Interpretation . Normal ) , <EOL> "<STR_LIT>" : IECore . V3fVectorData ( [ IECore . V3f ( x ) for x in range ( <NUM_LIT:1> , <NUM_LIT:6> ) ] , IECore . GeometricData . Interpretation . Normal ) , <EOL> } <EOL> self . assertEqual ( set ( n [ "<STR_LIT>" ] . keys ( ) ) , set ( expected . keys ( ) ) ) <EOL> for name , value in expected . items ( ) : <EOL> self . assertEqual ( n [ "<STR_LIT>" ] [ name ] . defaultValue ( ) , value ) <EOL> self . assertEqual ( n [ "<STR_LIT>" ] [ name ] . getValue ( ) , value ) <EOL> s = n . state ( ) [ <NUM_LIT:0> ] <EOL> for name , value in expected . items ( ) : <EOL> self . assertEqual ( s . parameters [ name ] , value ) <EOL> def testFixedCoshaderArrayParameters ( self ) : <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> n = GafferRenderMan . RenderManShader ( ) <EOL> n . loadShader ( shader ) <EOL> self . assertEqual ( n [ "<STR_LIT>" ] . keys ( ) , [ "<STR_LIT>" , "<STR_LIT>" ] ) <EOL> self . assertTrue ( isinstance ( n [ "<STR_LIT>" ] [ "<STR_LIT>" ] , Gaffer . ArrayPlug ) ) <EOL> self . assertEqual ( len ( n [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) , <NUM_LIT:4> ) <EOL> self . assertTrue ( isinstance ( n [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] , Gaffer . Plug ) ) <EOL> self . assertTrue ( isinstance ( n [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] , Gaffer . Plug ) ) <EOL> self . assertTrue ( isinstance ( n [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] , Gaffer . Plug ) ) <EOL> self . assertTrue ( isinstance ( n [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] , Gaffer . Plug ) ) <EOL> state = n . state ( ) <EOL> self . assertEqual ( state [ <NUM_LIT:0> ] . parameters [ "<STR_LIT>" ] , IECore . StringVectorData ( [ "<STR_LIT>" ] * <NUM_LIT:4> ) ) <EOL> coshader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> coshaderNode = GafferRenderMan . RenderManShader ( ) <EOL> coshaderNode . loadShader ( coshader ) <EOL> n [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( coshaderNode [ "<STR_LIT>" ] ) <EOL> state = n . state ( ) <EOL> self . assertEqual ( state [ <NUM_LIT:1> ] . parameters [ "<STR_LIT>" ] , IECore . StringVectorData ( [ state [ <NUM_LIT:0> ] . parameters [ "<STR_LIT>" ] . value , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ] ) ) <EOL> def testCoshaderType ( self ) : <EOL> coshader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> coshaderNode = GafferRenderMan . RenderManShader ( ) <EOL> coshaderNode . loadShader ( coshader ) <EOL> self . assertEqual ( coshaderNode . state ( ) [ <NUM_LIT:0> ] . type , "<STR_LIT>" ) <EOL> def testCantConnectSurfaceShaderIntoCoshaderInput ( self ) : <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> n1 = GafferRenderMan . RenderManShader ( ) <EOL> n1 . loadShader ( shader ) <EOL> n2 = GafferRenderMan . RenderManShader ( ) <EOL> n2 . loadShader ( "<STR_LIT>" ) <EOL> self . assertFalse ( n1 [ "<STR_LIT>" ] [ "<STR_LIT>" ] . acceptsInput ( n2 [ "<STR_LIT>" ] ) ) <EOL> coshader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> n3 = GafferRenderMan . RenderManShader ( ) <EOL> n3 . loadShader ( coshader ) <EOL> self . assertTrue ( n1 [ "<STR_LIT>" ] [ "<STR_LIT>" ] . acceptsInput ( n3 [ "<STR_LIT>" ] ) ) <EOL> arrayShader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> n4 = GafferRenderMan . RenderManShader ( ) <EOL> n4 . loadShader ( arrayShader ) <EOL> self . assertFalse ( n4 [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . acceptsInput ( n2 [ "<STR_LIT>" ] ) ) <EOL> self . assertTrue ( n4 [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . acceptsInput ( n3 [ "<STR_LIT>" ] ) ) <EOL> def testConnectionsBetweenParameters ( self ) : <EOL> s = GafferRenderMan . RenderManShader ( ) <EOL> s . loadShader ( "<STR_LIT>" ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setValue ( <NUM_LIT> ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( s [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) <EOL> shader = s . state ( ) [ <NUM_LIT:0> ] <EOL> self . assertEqual ( shader . parameters [ "<STR_LIT>" ] . value , <NUM_LIT> ) <EOL> self . assertEqual ( shader . parameters [ "<STR_LIT>" ] . value , <NUM_LIT> ) <EOL> def testFixedCoshaderArrayParameterHash ( self ) : <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> n = GafferRenderMan . RenderManShader ( ) <EOL> n . loadShader ( shader ) <EOL> h1 = n . stateHash ( ) <EOL> coshader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> coshaderNode = GafferRenderMan . RenderManShader ( ) <EOL> coshaderNode . loadShader ( coshader ) <EOL> n [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( coshaderNode [ "<STR_LIT>" ] ) <EOL> h2 = n . stateHash ( ) <EOL> self . assertNotEqual ( h2 , h1 ) <EOL> n [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( coshaderNode [ "<STR_LIT>" ] ) <EOL> h3 = n . stateHash ( ) <EOL> self . assertNotEqual ( h3 , h2 ) <EOL> self . assertNotEqual ( h3 , h1 ) <EOL> n [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( None ) <EOL> n [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( coshaderNode [ "<STR_LIT>" ] ) <EOL> h4 = n . stateHash ( ) <EOL> self . assertNotEqual ( h4 , h3 ) <EOL> self . assertNotEqual ( h4 , h2 ) <EOL> self . assertNotEqual ( h4 , h1 ) <EOL> def testDisabling ( self ) : <EOL> s = GafferRenderMan . RenderManShader ( ) <EOL> s . loadShader ( "<STR_LIT>" ) <EOL> stateHash = s . stateHash ( ) <EOL> state = s . state ( ) <EOL> self . assertEqual ( len ( state ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( state [ <NUM_LIT:0> ] . name , "<STR_LIT>" ) <EOL> self . assertTrue ( s [ "<STR_LIT>" ] . isSame ( s . enabledPlug ( ) ) ) <EOL> s [ "<STR_LIT>" ] . setValue ( False ) <EOL> stateHash2 = s . stateHash ( ) <EOL> self . assertNotEqual ( stateHash2 , stateHash ) <EOL> state2 = s . state ( ) <EOL> self . assertEqual ( len ( state2 ) , <NUM_LIT:0> ) <EOL> def testDisablingCoshaders ( self ) : <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> shaderNode = GafferRenderMan . RenderManShader ( ) <EOL> shaderNode . loadShader ( shader ) <EOL> coshader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> coshaderNode = GafferRenderMan . RenderManShader ( ) <EOL> coshaderNode . loadShader ( coshader ) <EOL> shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( coshaderNode [ "<STR_LIT>" ] ) <EOL> s = shaderNode . state ( ) <EOL> self . assertEqual ( len ( s ) , <NUM_LIT:2> ) <EOL> self . assertEqual ( s [ <NUM_LIT:0> ] . name , coshader ) <EOL> self . assertEqual ( s [ <NUM_LIT:1> ] . name , shader ) <EOL> h = shaderNode . stateHash ( ) <EOL> coshaderNode [ "<STR_LIT>" ] . setValue ( False ) <EOL> s2 = shaderNode . state ( ) <EOL> self . assertEqual ( len ( s2 ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( s2 [ <NUM_LIT:0> ] . name , shader ) <EOL> self . assertTrue ( "<STR_LIT>" not in s2 [ <NUM_LIT:0> ] . parameters ) <EOL> self . assertNotEqual ( shaderNode . stateHash ( ) , h ) <EOL> def testDisablingCoshaderArrayInputs ( self ) : <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> n = GafferRenderMan . RenderManShader ( ) <EOL> n . loadShader ( shader ) <EOL> coshader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> coshaderNode1 = GafferRenderMan . RenderManShader ( ) <EOL> coshaderNode1 . loadShader ( coshader ) <EOL> coshaderNode2 = GafferRenderMan . RenderManShader ( ) <EOL> coshaderNode2 . loadShader ( coshader ) <EOL> n [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:0> ] . setInput ( coshaderNode1 [ "<STR_LIT>" ] ) <EOL> n [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:2> ] . setInput ( coshaderNode2 [ "<STR_LIT>" ] ) <EOL> state = n . state ( ) <EOL> h1 = n . stateHash ( ) <EOL> self . assertEqual ( <EOL> state [ <NUM_LIT:2> ] . parameters [ "<STR_LIT>" ] , <EOL> IECore . StringVectorData ( [ <EOL> state [ <NUM_LIT:0> ] . parameters [ "<STR_LIT>" ] . value , <EOL> "<STR_LIT>" , <EOL> state [ <NUM_LIT:1> ] . parameters [ "<STR_LIT>" ] . value , <EOL> "<STR_LIT>" <EOL> ] ) <EOL> ) <EOL> coshaderNode1 [ "<STR_LIT>" ] . setValue ( False ) <EOL> state = n . state ( ) <EOL> self . assertEqual ( <EOL> state [ <NUM_LIT:1> ] . parameters [ "<STR_LIT>" ] , <EOL> IECore . StringVectorData ( [ <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> state [ <NUM_LIT:0> ] . parameters [ "<STR_LIT>" ] . value , <EOL> "<STR_LIT>" <EOL> ] ) <EOL> ) <EOL> h2 = n . stateHash ( ) <EOL> self . assertNotEqual ( h2 , h1 ) <EOL> coshaderNode2 [ "<STR_LIT>" ] . setValue ( False ) <EOL> state = n . state ( ) <EOL> self . assertEqual ( <EOL> state [ <NUM_LIT:0> ] . parameters [ "<STR_LIT>" ] , <EOL> IECore . StringVectorData ( [ <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" <EOL> ] ) <EOL> ) <EOL> self . assertNotEqual ( n . stateHash ( ) , h1 ) <EOL> self . assertNotEqual ( n . stateHash ( ) , h2 ) <EOL> def testCorrespondingInput ( self ) : <EOL> coshader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> coshaderNode = GafferRenderMan . RenderManShader ( ) <EOL> coshaderNode . loadShader ( coshader ) <EOL> self . assertEqual ( coshaderNode . correspondingInput ( coshaderNode [ "<STR_LIT>" ] ) , None ) <EOL> coshader2 = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> coshaderNode2 = GafferRenderMan . RenderManShader ( ) <EOL> coshaderNode2 . loadShader ( coshader2 ) <EOL> self . assertTrue ( coshaderNode2 . correspondingInput ( coshaderNode2 [ "<STR_LIT>" ] ) . isSame ( coshaderNode2 [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) ) <EOL> def testCoshaderPassThrough ( self ) : <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> shaderNode = GafferRenderMan . RenderManShader ( ) <EOL> shaderNode . loadShader ( shader ) <EOL> passThroughCoshader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> passThroughCoshaderNode = GafferRenderMan . RenderManShader ( ) <EOL> passThroughCoshaderNode . loadShader ( passThroughCoshader ) <EOL> coshader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> coshaderNode = GafferRenderMan . RenderManShader ( ) <EOL> coshaderNode . loadShader ( coshader ) <EOL> shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( passThroughCoshaderNode [ "<STR_LIT>" ] ) <EOL> passThroughCoshaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( coshaderNode [ "<STR_LIT>" ] ) <EOL> h = shaderNode . stateHash ( ) <EOL> s = shaderNode . state ( ) <EOL> self . assertEqual ( len ( s ) , <NUM_LIT:3> ) <EOL> self . assertEqual ( s [ <NUM_LIT:2> ] . parameters [ "<STR_LIT>" ] , s [ <NUM_LIT:1> ] . parameters [ "<STR_LIT>" ] ) <EOL> self . assertEqual ( s [ <NUM_LIT:1> ] . name , passThroughCoshader ) <EOL> self . assertEqual ( s [ <NUM_LIT:1> ] . parameters [ "<STR_LIT>" ] , s [ <NUM_LIT:0> ] . parameters [ "<STR_LIT>" ] ) <EOL> self . assertEqual ( s [ <NUM_LIT:0> ] . name , coshader ) <EOL> passThroughCoshaderNode [ "<STR_LIT>" ] . setValue ( False ) <EOL> s = shaderNode . state ( ) <EOL> self . assertEqual ( len ( s ) , <NUM_LIT:2> ) <EOL> self . assertEqual ( s [ <NUM_LIT:1> ] . parameters [ "<STR_LIT>" ] , s [ <NUM_LIT:0> ] . parameters [ "<STR_LIT>" ] ) <EOL> self . assertEqual ( s [ <NUM_LIT:0> ] . name , coshader ) <EOL> def testSplineParameters ( self ) : <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> n = GafferRenderMan . RenderManShader ( ) <EOL> n . loadShader ( shader ) <EOL> self . assertEqual ( n [ "<STR_LIT>" ] . keys ( ) , [ "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ] ) <EOL> self . assertTrue ( isinstance ( n [ "<STR_LIT>" ] [ "<STR_LIT>" ] , Gaffer . SplineffPlug ) ) <EOL> self . assertTrue ( isinstance ( n [ "<STR_LIT>" ] [ "<STR_LIT>" ] , Gaffer . SplinefColor3fPlug ) ) <EOL> self . assertEqual ( <EOL> n [ "<STR_LIT>" ] [ "<STR_LIT>" ] . defaultValue ( ) , <EOL> IECore . Splineff ( <EOL> IECore . CubicBasisf . catmullRom ( ) , <EOL> [ <EOL> ( <NUM_LIT:0> , <NUM_LIT:0> ) , <EOL> ( <NUM_LIT:0> , <NUM_LIT:0> ) , <EOL> ( <NUM_LIT:1> , <NUM_LIT:1> ) , <EOL> ( <NUM_LIT:1> , <NUM_LIT:1> ) , <EOL> ] <EOL> ) <EOL> ) <EOL> self . assertEqual ( <EOL> n [ "<STR_LIT>" ] [ "<STR_LIT>" ] . defaultValue ( ) , <EOL> IECore . SplinefColor3f ( <EOL> IECore . CubicBasisf . catmullRom ( ) , <EOL> [ <EOL> ( <NUM_LIT:0> , IECore . Color3f ( <NUM_LIT:0> ) ) , <EOL> ( <NUM_LIT:0> , IECore . Color3f ( <NUM_LIT:0> ) ) , <EOL> ( <NUM_LIT:1> , IECore . Color3f ( <NUM_LIT:1> ) ) , <EOL> ( <NUM_LIT:1> , IECore . Color3f ( <NUM_LIT:1> ) ) , <EOL> ] <EOL> ) <EOL> ) <EOL> floatValue = IECore . Splineff ( <EOL> IECore . CubicBasisf . catmullRom ( ) , <EOL> [ <EOL> ( <NUM_LIT:0> , <NUM_LIT:0> ) , <EOL> ( <NUM_LIT:0> , <NUM_LIT:0> ) , <EOL> ( <NUM_LIT:1> , <NUM_LIT:2> ) , <EOL> ( <NUM_LIT:1> , <NUM_LIT:2> ) , <EOL> ] <EOL> ) <EOL> colorValue = IECore . SplinefColor3f ( <EOL> IECore . CubicBasisf . catmullRom ( ) , <EOL> [ <EOL> ( <NUM_LIT:0> , IECore . Color3f ( <NUM_LIT:0> ) ) , <EOL> ( <NUM_LIT:0> , IECore . Color3f ( <NUM_LIT:0> ) ) , <EOL> ( <NUM_LIT:1> , IECore . Color3f ( <NUM_LIT> ) ) , <EOL> ( <NUM_LIT:1> , IECore . Color3f ( <NUM_LIT> ) ) , <EOL> ] <EOL> ) <EOL> n [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setValue ( floatValue ) <EOL> n [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setValue ( colorValue ) <EOL> s = n . state ( ) [ <NUM_LIT:0> ] <EOL> self . assertEqual ( s . parameters [ "<STR_LIT>" ] . value , floatValue ) <EOL> self . assertEqual ( s . parameters [ "<STR_LIT>" ] . value , colorValue ) <EOL> def testSplineParameterSerialisationKeepsExistingValues ( self ) : <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> s = Gaffer . ScriptNode ( ) <EOL> s [ "<STR_LIT:n>" ] = GafferRenderMan . RenderManShader ( ) <EOL> s [ "<STR_LIT:n>" ] . loadShader ( shader ) <EOL> s [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setValue ( <EOL> IECore . Splineff ( <EOL> IECore . CubicBasisf . catmullRom ( ) , <EOL> [ <EOL> ( <NUM_LIT:0> , <NUM_LIT:0> ) , <EOL> ( <NUM_LIT:0> , <NUM_LIT:0> ) , <EOL> ( <NUM_LIT:1> , <NUM_LIT:2> ) , <EOL> ( <NUM_LIT:1> , <NUM_LIT:2> ) , <EOL> ] <EOL> ) <EOL> ) <EOL> self . assertEqual ( <EOL> s [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) , <EOL> IECore . Splineff ( <EOL> IECore . CubicBasisf . catmullRom ( ) , <EOL> [ <EOL> ( <NUM_LIT:0> , <NUM_LIT:0> ) , <EOL> ( <NUM_LIT:0> , <NUM_LIT:0> ) , <EOL> ( <NUM_LIT:1> , <NUM_LIT:2> ) , <EOL> ( <NUM_LIT:1> , <NUM_LIT:2> ) , <EOL> ] <EOL> ) , <EOL> ) <EOL> ss = s . serialise ( ) <EOL> s2 = Gaffer . ScriptNode ( ) <EOL> s2 . execute ( ss ) <EOL> self . assertEqual ( <EOL> s2 [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) , <EOL> IECore . Splineff ( <EOL> IECore . CubicBasisf . catmullRom ( ) , <EOL> [ <EOL> ( <NUM_LIT:0> , <NUM_LIT:0> ) , <EOL> ( <NUM_LIT:0> , <NUM_LIT:0> ) , <EOL> ( <NUM_LIT:1> , <NUM_LIT:2> ) , <EOL> ( <NUM_LIT:1> , <NUM_LIT:2> ) , <EOL> ] <EOL> ) , <EOL> ) <EOL> def testSplineParameterDefaultValueAnnotation ( self ) : <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> n = GafferRenderMan . RenderManShader ( ) <EOL> n . loadShader ( shader ) <EOL> self . assertEqual ( <EOL> n [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) , <EOL> IECore . SplinefColor3f ( <EOL> IECore . CubicBasisf . catmullRom ( ) , <EOL> [ <EOL> ( <NUM_LIT:0> , IECore . Color3f ( <NUM_LIT:1> ) ) , <EOL> ( <NUM_LIT:0> , IECore . Color3f ( <NUM_LIT:1> ) ) , <EOL> ( <NUM_LIT:0.5> , IECore . Color3f ( <NUM_LIT:1> , <NUM_LIT:0.5> , <NUM_LIT> ) ) , <EOL> ( <NUM_LIT:1> , IECore . Color3f ( <NUM_LIT:0> ) ) , <EOL> ( <NUM_LIT:1> , IECore . Color3f ( <NUM_LIT:0> ) ) , <EOL> ] <EOL> ) , <EOL> ) <EOL> def testCoshadersInBox ( self ) : <EOL> s = Gaffer . ScriptNode ( ) <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> s [ "<STR_LIT>" ] = GafferRenderMan . RenderManShader ( ) <EOL> s [ "<STR_LIT>" ] . loadShader ( shader ) <EOL> coshader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> s [ "<STR_LIT>" ] = GafferRenderMan . RenderManShader ( ) <EOL> s [ "<STR_LIT>" ] . loadShader ( coshader ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( s [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) <EOL> b = Gaffer . Box . create ( s , Gaffer . StandardSet ( [ s [ "<STR_LIT>" ] ] ) ) <EOL> self . assertTrue ( s [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getInput ( ) . parent ( ) . isSame ( b ) ) <EOL> s = s [ "<STR_LIT>" ] . state ( ) <EOL> self . assertEqual ( len ( s ) , <NUM_LIT:2> ) <EOL> self . assertEqual ( s [ <NUM_LIT:1> ] . parameters [ "<STR_LIT>" ] , s [ <NUM_LIT:0> ] . parameters [ "<STR_LIT>" ] ) <EOL> self . assertEqual ( s [ <NUM_LIT:0> ] . name , coshader ) <EOL> def testShaderInBoxWithExternalCoshader ( self ) : <EOL> s = Gaffer . ScriptNode ( ) <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> s [ "<STR_LIT>" ] = GafferRenderMan . RenderManShader ( ) <EOL> s [ "<STR_LIT>" ] . loadShader ( shader ) <EOL> coshader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> s [ "<STR_LIT>" ] = GafferRenderMan . RenderManShader ( ) <EOL> s [ "<STR_LIT>" ] . loadShader ( coshader ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( s [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) <EOL> b = Gaffer . Box . create ( s , Gaffer . StandardSet ( [ s [ "<STR_LIT>" ] ] ) ) <EOL> self . assertTrue ( b [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getInput ( ) . parent ( ) . isSame ( b ) ) <EOL> s = b [ "<STR_LIT>" ] . state ( ) <EOL> self . assertEqual ( len ( s ) , <NUM_LIT:2> ) <EOL> self . assertEqual ( s [ <NUM_LIT:1> ] . parameters [ "<STR_LIT>" ] , s [ <NUM_LIT:0> ] . parameters [ "<STR_LIT>" ] ) <EOL> self . assertEqual ( s [ <NUM_LIT:0> ] . name , coshader ) <EOL> def testNumericTypeAnnotations ( self ) : <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> shaderNode = GafferRenderMan . RenderManShader ( ) <EOL> shaderNode . loadShader ( shader ) <EOL> self . assertTrue ( isinstance ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] , Gaffer . FloatPlug ) ) <EOL> self . assertTrue ( isinstance ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] , Gaffer . FloatPlug ) ) <EOL> self . assertTrue ( isinstance ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] , Gaffer . IntPlug ) ) <EOL> self . assertTrue ( isinstance ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] , Gaffer . BoolPlug ) ) <EOL> self . assertEqual ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . defaultValue ( ) , <NUM_LIT> ) <EOL> self . assertEqual ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . defaultValue ( ) , <NUM_LIT> ) <EOL> self . assertEqual ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . defaultValue ( ) , <NUM_LIT:10> ) <EOL> self . assertEqual ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . defaultValue ( ) , True ) <EOL> self . assertEqual ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) , <NUM_LIT> ) <EOL> self . assertEqual ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) , <NUM_LIT> ) <EOL> self . assertEqual ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) , <NUM_LIT:10> ) <EOL> self . assertEqual ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) , True ) <EOL> def testCoshaderTypeAnnotations ( self ) : <EOL> coshader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> coshaderNode = GafferRenderMan . RenderManShader ( ) <EOL> coshaderNode . loadShader ( coshader ) <EOL> coshaderType1 = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> coshaderType1Node = GafferRenderMan . RenderManShader ( ) <EOL> coshaderType1Node . loadShader ( coshaderType1 ) <EOL> coshaderType2 = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> coshaderType2Node = GafferRenderMan . RenderManShader ( ) <EOL> coshaderType2Node . loadShader ( coshaderType2 ) <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> shaderNode = GafferRenderMan . RenderManShader ( ) <EOL> shaderNode . loadShader ( shader ) <EOL> self . assertTrue ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . acceptsInput ( coshaderNode [ "<STR_LIT>" ] ) ) <EOL> self . assertTrue ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . acceptsInput ( coshaderType1Node [ "<STR_LIT>" ] ) ) <EOL> self . assertTrue ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . acceptsInput ( coshaderType2Node [ "<STR_LIT>" ] ) ) <EOL> self . assertFalse ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . acceptsInput ( coshaderNode [ "<STR_LIT>" ] ) ) <EOL> self . assertTrue ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . acceptsInput ( coshaderType1Node [ "<STR_LIT>" ] ) ) <EOL> self . assertFalse ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . acceptsInput ( coshaderType2Node [ "<STR_LIT>" ] ) ) <EOL> self . assertFalse ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . acceptsInput ( coshaderNode [ "<STR_LIT>" ] ) ) <EOL> self . assertFalse ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . acceptsInput ( coshaderType1Node [ "<STR_LIT>" ] ) ) <EOL> self . assertTrue ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . acceptsInput ( coshaderType2Node [ "<STR_LIT>" ] ) ) <EOL> self . assertTrue ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . acceptsInput ( coshaderNode [ "<STR_LIT>" ] ) ) <EOL> self . assertTrue ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . acceptsInput ( coshaderType1Node [ "<STR_LIT>" ] ) ) <EOL> self . assertTrue ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . acceptsInput ( coshaderType2Node [ "<STR_LIT>" ] ) ) <EOL> self . assertFalse ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . acceptsInput ( coshaderNode [ "<STR_LIT>" ] ) ) <EOL> self . assertTrue ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . acceptsInput ( coshaderType1Node [ "<STR_LIT>" ] ) ) <EOL> self . assertFalse ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . acceptsInput ( coshaderType2Node [ "<STR_LIT>" ] ) ) <EOL> self . assertFalse ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:0> ] . acceptsInput ( coshaderNode [ "<STR_LIT>" ] ) ) <EOL> self . assertFalse ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:0> ] . acceptsInput ( coshaderType1Node [ "<STR_LIT>" ] ) ) <EOL> self . assertTrue ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:0> ] . acceptsInput ( coshaderType2Node [ "<STR_LIT>" ] ) ) <EOL> def testMultipleCoshaderTypeAnnotations ( self ) : <EOL> coshaderType1And2 = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> coshaderType1And2Node = GafferRenderMan . RenderManShader ( ) <EOL> coshaderType1And2Node . loadShader ( coshaderType1And2 ) <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> shaderNode = GafferRenderMan . RenderManShader ( ) <EOL> shaderNode . loadShader ( shader ) <EOL> self . assertTrue ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . acceptsInput ( coshaderType1And2Node [ "<STR_LIT>" ] ) ) <EOL> self . assertTrue ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . acceptsInput ( coshaderType1And2Node [ "<STR_LIT>" ] ) ) <EOL> self . assertTrue ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . acceptsInput ( coshaderType1And2Node [ "<STR_LIT>" ] ) ) <EOL> self . assertFalse ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . acceptsInput ( coshaderType1And2Node [ "<STR_LIT>" ] ) ) <EOL> def testSplitCoshaderPassThrough ( self ) : <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> S = GafferRenderMan . RenderManShader ( ) <EOL> S . loadShader ( shader ) <EOL> passThroughCoshader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> D = GafferRenderMan . RenderManShader ( ) <EOL> D . loadShader ( passThroughCoshader ) <EOL> coshader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> C = GafferRenderMan . RenderManShader ( ) <EOL> C . loadShader ( coshader ) <EOL> S [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:0> ] . setInput ( C [ "<STR_LIT>" ] ) <EOL> S [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:1> ] . setInput ( D [ "<STR_LIT>" ] ) <EOL> D [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( C [ "<STR_LIT>" ] ) <EOL> h = S . stateHash ( ) <EOL> s = S . state ( ) <EOL> self . assertEqual ( len ( s ) , <NUM_LIT:3> ) <EOL> self . assertEqual ( s [ <NUM_LIT:2> ] . parameters [ "<STR_LIT>" ] , IECore . StringVectorData ( [ s [ <NUM_LIT:0> ] . parameters [ "<STR_LIT>" ] . value , s [ <NUM_LIT:1> ] . parameters [ "<STR_LIT>" ] . value , "<STR_LIT>" , "<STR_LIT>" ] ) ) <EOL> self . assertEqual ( s [ <NUM_LIT:0> ] . name , coshader ) <EOL> self . assertEqual ( s [ <NUM_LIT:1> ] . parameters [ "<STR_LIT>" ] , s [ <NUM_LIT:0> ] . parameters [ "<STR_LIT>" ] ) <EOL> self . assertEqual ( s [ <NUM_LIT:1> ] . name , passThroughCoshader ) <EOL> D [ "<STR_LIT>" ] . setValue ( False ) <EOL> self . assertNotEqual ( S . stateHash ( ) , h ) <EOL> s = S . state ( ) <EOL> self . assertEqual ( len ( s ) , <NUM_LIT:2> ) <EOL> self . assertEqual ( s [ <NUM_LIT:1> ] . parameters [ "<STR_LIT>" ] , IECore . StringVectorData ( [ s [ <NUM_LIT:0> ] . parameters [ "<STR_LIT>" ] . value , s [ <NUM_LIT:0> ] . parameters [ "<STR_LIT>" ] . value , "<STR_LIT>" , "<STR_LIT>" ] ) ) <EOL> self . assertEqual ( s [ <NUM_LIT:0> ] . name , coshader ) <EOL> def testSerialDisabledShaders ( self ) : <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> S = GafferRenderMan . RenderManShader ( ) <EOL> S . loadShader ( shader ) <EOL> passThroughCoshader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> D1 = GafferRenderMan . RenderManShader ( ) <EOL> D1 . loadShader ( passThroughCoshader ) <EOL> D2 = GafferRenderMan . RenderManShader ( ) <EOL> D2 . loadShader ( passThroughCoshader ) <EOL> coshader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> C = GafferRenderMan . RenderManShader ( ) <EOL> C . loadShader ( coshader ) <EOL> S [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( D2 [ "<STR_LIT>" ] ) <EOL> D2 [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( D1 [ "<STR_LIT>" ] ) <EOL> D1 [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( C [ "<STR_LIT>" ] ) <EOL> h1 = S . stateHash ( ) <EOL> s = S . state ( ) <EOL> self . assertEqual ( len ( s ) , <NUM_LIT:4> ) <EOL> self . assertEqual ( s [ <NUM_LIT:0> ] . name , coshader ) <EOL> self . assertEqual ( s [ <NUM_LIT:1> ] . name , passThroughCoshader ) <EOL> self . assertEqual ( s [ <NUM_LIT:2> ] . name , passThroughCoshader ) <EOL> self . assertEqual ( s [ <NUM_LIT:3> ] . name , shader ) <EOL> self . assertEqual ( s [ <NUM_LIT:3> ] . parameters [ "<STR_LIT>" ] , s [ <NUM_LIT:2> ] . parameters [ "<STR_LIT>" ] ) <EOL> self . assertEqual ( s [ <NUM_LIT:2> ] . parameters [ "<STR_LIT>" ] , s [ <NUM_LIT:1> ] . parameters [ "<STR_LIT>" ] ) <EOL> self . assertEqual ( s [ <NUM_LIT:1> ] . parameters [ "<STR_LIT>" ] , s [ <NUM_LIT:0> ] . parameters [ "<STR_LIT>" ] ) <EOL> D2 [ "<STR_LIT>" ] . setValue ( False ) <EOL> h2 = S . stateHash ( ) <EOL> self . assertNotEqual ( h1 , h2 ) <EOL> s = S . state ( ) <EOL> self . assertEqual ( len ( s ) , <NUM_LIT:3> ) <EOL> self . assertEqual ( s [ <NUM_LIT:0> ] . name , coshader ) <EOL> self . assertEqual ( s [ <NUM_LIT:1> ] . name , passThroughCoshader ) <EOL> self . assertEqual ( s [ <NUM_LIT:2> ] . name , shader ) <EOL> self . assertEqual ( s [ <NUM_LIT:2> ] . parameters [ "<STR_LIT>" ] , s [ <NUM_LIT:1> ] . parameters [ "<STR_LIT>" ] ) <EOL> self . assertEqual ( s [ <NUM_LIT:1> ] . parameters [ "<STR_LIT>" ] , s [ <NUM_LIT:0> ] . parameters [ "<STR_LIT>" ] ) <EOL> D1 [ "<STR_LIT>" ] . setValue ( False ) <EOL> h3 = S . stateHash ( ) <EOL> self . assertNotEqual ( h3 , h2 ) <EOL> self . assertNotEqual ( h3 , h1 ) <EOL> s = S . state ( ) <EOL> self . assertEqual ( len ( s ) , <NUM_LIT:2> ) <EOL> self . assertEqual ( s [ <NUM_LIT:0> ] . name , coshader ) <EOL> self . assertEqual ( s [ <NUM_LIT:1> ] . name , shader ) <EOL> self . assertEqual ( s [ <NUM_LIT:1> ] . parameters [ "<STR_LIT>" ] , s [ <NUM_LIT:0> ] . parameters [ "<STR_LIT>" ] ) <EOL> def testDynamicCoshaderArrayParameters ( self ) : <EOL> coshader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> coshaderNode = GafferRenderMan . RenderManShader ( ) <EOL> coshaderNode . loadShader ( coshader ) <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> shaderNode = GafferRenderMan . RenderManShader ( ) <EOL> shaderNode . loadShader ( shader ) <EOL> self . assertEqual ( len ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) , <NUM_LIT:1> ) <EOL> self . assertTrue ( isinstance ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:0> ] , Gaffer . Plug ) ) <EOL> self . assertTrue ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:0> ] . getInput ( ) is None ) <EOL> shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:0> ] . setInput ( coshaderNode [ "<STR_LIT>" ] ) <EOL> self . assertEqual ( len ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) , <NUM_LIT:2> ) <EOL> self . assertTrue ( isinstance ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:0> ] , Gaffer . Plug ) ) <EOL> self . assertTrue ( isinstance ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:1> ] , Gaffer . Plug ) ) <EOL> self . assertTrue ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:0> ] . getInput ( ) . isSame ( coshaderNode [ "<STR_LIT>" ] ) ) <EOL> self . assertTrue ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:1> ] . getInput ( ) is None ) <EOL> shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:0> ] . setInput ( None ) <EOL> self . assertEqual ( len ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) , <NUM_LIT:1> ) <EOL> self . assertTrue ( isinstance ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:0> ] , Gaffer . Plug ) ) <EOL> self . assertTrue ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:0> ] . getInput ( ) is None ) <EOL> def testSerialiseDynamicCoshaderArrayParameters ( self ) : <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> coshader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> s = Gaffer . ScriptNode ( ) <EOL> s [ "<STR_LIT:n>" ] = GafferRenderMan . RenderManShader ( ) <EOL> s [ "<STR_LIT:n>" ] . loadShader ( shader ) <EOL> s [ "<STR_LIT:c>" ] = GafferRenderMan . RenderManShader ( ) <EOL> s [ "<STR_LIT:c>" ] . loadShader ( coshader ) <EOL> s [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:0> ] . setInput ( s [ "<STR_LIT:c>" ] [ "<STR_LIT>" ] ) <EOL> s [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:1> ] . setInput ( s [ "<STR_LIT:c>" ] [ "<STR_LIT>" ] ) <EOL> s [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:2> ] . setInput ( s [ "<STR_LIT:c>" ] [ "<STR_LIT>" ] ) <EOL> s [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:1> ] . setInput ( None ) <EOL> self . assertEqual ( len ( s [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) , <NUM_LIT:4> ) <EOL> s2 = Gaffer . ScriptNode ( ) <EOL> s2 . execute ( s . serialise ( ) ) <EOL> self . assertEqual ( len ( s2 [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) , <NUM_LIT:4> ) <EOL> self . assertTrue ( s2 [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:0> ] . getInput ( ) . isSame ( s2 [ "<STR_LIT:c>" ] [ "<STR_LIT>" ] ) ) <EOL> self . assertTrue ( s2 [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:1> ] . getInput ( ) is None ) <EOL> self . assertTrue ( s2 [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:2> ] . getInput ( ) . isSame ( s2 [ "<STR_LIT:c>" ] [ "<STR_LIT>" ] ) ) <EOL> self . assertTrue ( s2 [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:3> ] . getInput ( ) is None ) <EOL> s2 [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:3> ] . setInput ( s2 [ "<STR_LIT:c>" ] [ "<STR_LIT>" ] ) <EOL> self . assertEqual ( len ( s2 [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) , <NUM_LIT:5> ) <EOL> self . assertTrue ( s2 [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:0> ] . getInput ( ) . isSame ( s2 [ "<STR_LIT:c>" ] [ "<STR_LIT>" ] ) ) <EOL> self . assertTrue ( s2 [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:1> ] . getInput ( ) is None ) <EOL> self . assertTrue ( s2 [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:2> ] . getInput ( ) . isSame ( s2 [ "<STR_LIT:c>" ] [ "<STR_LIT>" ] ) ) <EOL> self . assertTrue ( s2 [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:3> ] . getInput ( ) . isSame ( s2 [ "<STR_LIT:c>" ] [ "<STR_LIT>" ] ) ) <EOL> self . assertTrue ( s2 [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:4> ] . getInput ( ) is None ) <EOL> def testConvertFixedCoshaderArrayToDynamic ( self ) : <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> shaderV2 = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> coshader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> s = Gaffer . ScriptNode ( ) <EOL> s [ "<STR_LIT:n>" ] = GafferRenderMan . RenderManShader ( ) <EOL> s [ "<STR_LIT:n>" ] . loadShader ( shader ) <EOL> s [ "<STR_LIT:c>" ] = GafferRenderMan . RenderManShader ( ) <EOL> s [ "<STR_LIT:c>" ] . loadShader ( coshader ) <EOL> s [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:0> ] . setInput ( s [ "<STR_LIT:c>" ] [ "<STR_LIT>" ] ) <EOL> self . assertTrue ( len ( s [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) , <NUM_LIT:4> ) <EOL> s [ "<STR_LIT:n>" ] . loadShader ( shaderV2 , keepExistingValues = True ) <EOL> self . assertTrue ( s [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:0> ] . getInput ( ) . isSame ( s [ "<STR_LIT:c>" ] [ "<STR_LIT>" ] ) ) <EOL> self . assertTrue ( s [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:1> ] . getInput ( ) is None ) <EOL> s [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:0> ] . setInput ( None ) <EOL> self . assertEqual ( len ( s [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) , <NUM_LIT:1> ) <EOL> self . assertTrue ( s [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:0> ] . getInput ( ) is None ) <EOL> def testConvertFixedCoshaderArrayToDynamicWithFirstPlugUnconnected ( self ) : <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> shaderV2 = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> coshader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> s = Gaffer . ScriptNode ( ) <EOL> s [ "<STR_LIT:n>" ] = GafferRenderMan . RenderManShader ( ) <EOL> s [ "<STR_LIT:n>" ] . loadShader ( shader ) <EOL> s [ "<STR_LIT:c>" ] = GafferRenderMan . RenderManShader ( ) <EOL> s [ "<STR_LIT:c>" ] . loadShader ( coshader ) <EOL> s [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:1> ] . setInput ( s [ "<STR_LIT:c>" ] [ "<STR_LIT>" ] ) <EOL> self . assertTrue ( len ( s [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) , <NUM_LIT:4> ) <EOL> s [ "<STR_LIT:n>" ] . loadShader ( shaderV2 , keepExistingValues = True ) <EOL> self . assertTrue ( s [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:1> ] . getInput ( ) . isSame ( s [ "<STR_LIT:c>" ] [ "<STR_LIT>" ] ) ) <EOL> self . assertTrue ( s [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:0> ] . getInput ( ) is None ) <EOL> s [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:1> ] . setInput ( None ) <EOL> self . assertEqual ( len ( s [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) , <NUM_LIT:1> ) <EOL> self . assertTrue ( s [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:0> ] . getInput ( ) is None ) <EOL> def testConvertFixedCoshaderArrayToDynamicDuringLoading ( self ) : <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> coshader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> s = Gaffer . ScriptNode ( ) <EOL> s [ "<STR_LIT:n>" ] = GafferRenderMan . RenderManShader ( ) <EOL> s [ "<STR_LIT:n>" ] . loadShader ( shader ) <EOL> s [ "<STR_LIT:c>" ] = GafferRenderMan . RenderManShader ( ) <EOL> s [ "<STR_LIT:c>" ] . loadShader ( coshader ) <EOL> s [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:1> ] . setInput ( s [ "<STR_LIT:c>" ] [ "<STR_LIT>" ] ) <EOL> self . assertTrue ( len ( s [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) , <NUM_LIT:4> ) <EOL> GafferRenderMan . RenderManShader . shaderLoader ( ) . clear ( ) <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" , shaderName = "<STR_LIT>" ) <EOL> s2 = Gaffer . ScriptNode ( ) <EOL> s2 . execute ( s . serialise ( ) ) <EOL> self . assertTrue ( s2 [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:1> ] . getInput ( ) . isSame ( s2 [ "<STR_LIT:c>" ] [ "<STR_LIT>" ] ) ) <EOL> self . assertTrue ( s2 [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:0> ] . getInput ( ) is None ) <EOL> s2 [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:1> ] . setInput ( None ) <EOL> self . assertEqual ( len ( s2 [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) , <NUM_LIT:1> ) <EOL> self . assertTrue ( s2 [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:0> ] . getInput ( ) is None ) <EOL> def testHashThroughBox ( self ) : <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> shaderNode = GafferRenderMan . RenderManShader ( ) <EOL> shaderNode . loadShader ( shader ) <EOL> b = Gaffer . Box ( ) <EOL> b . addChild ( Gaffer . Plug ( "<STR_LIT>" ) ) <EOL> b . addChild ( Gaffer . Plug ( "<STR_LIT>" , direction = Gaffer . Plug . Direction . Out ) ) <EOL> intermediateCoshader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> intermediateCoshaderNode = GafferRenderMan . RenderManShader ( ) <EOL> intermediateCoshaderNode . loadShader ( intermediateCoshader ) <EOL> coshader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> coshaderNode = GafferRenderMan . RenderManShader ( ) <EOL> coshaderNode . loadShader ( coshader ) <EOL> b [ "<STR_LIT>" ] . setInput ( coshaderNode [ "<STR_LIT>" ] ) <EOL> intermediateCoshaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( b [ "<STR_LIT>" ] ) <EOL> b [ "<STR_LIT>" ] . setInput ( intermediateCoshaderNode [ "<STR_LIT>" ] ) <EOL> shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( b [ "<STR_LIT>" ] ) <EOL> h1 = shaderNode . stateHash ( ) <EOL> coshaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setValue ( <NUM_LIT> ) <EOL> self . assertNotEqual ( shaderNode . stateHash ( ) , h1 ) <EOL> def testDanglingBoxConnection ( self ) : <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> shaderNode1 = GafferRenderMan . RenderManShader ( ) <EOL> shaderNode1 . loadShader ( shader ) <EOL> shaderNode2 = GafferRenderMan . RenderManShader ( ) <EOL> shaderNode2 . loadShader ( shader ) <EOL> b = Gaffer . Box ( ) <EOL> b . addChild ( Gaffer . Plug ( "<STR_LIT>" ) ) <EOL> b . addChild ( Gaffer . Plug ( "<STR_LIT>" , direction = Gaffer . Plug . Direction . Out ) ) <EOL> b [ "<STR_LIT>" ] = shaderNode1 <EOL> shaderNode1 [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( b [ "<STR_LIT>" ] ) <EOL> shaderNode2 [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( b [ "<STR_LIT>" ] ) <EOL> def testUnconnectedCustomBoxInput ( self ) : <EOL> class CustomBox ( Gaffer . Box ) : <EOL> def __init__ ( self , name = "<STR_LIT>" ) : <EOL> Gaffer . Box . __init__ ( self , name ) <EOL> IECore . registerRunTimeTyped ( CustomBox ) <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> b = CustomBox ( ) <EOL> b [ "<STR_LIT:s>" ] = GafferRenderMan . RenderManShader ( ) <EOL> b [ "<STR_LIT:s>" ] . loadShader ( shader ) <EOL> b [ "<STR_LIT>" ] = b [ "<STR_LIT:s>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . createCounterpart ( "<STR_LIT>" , Gaffer . Plug . Direction . In ) <EOL> b [ "<STR_LIT:s>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( b [ "<STR_LIT>" ] ) <EOL> s = b [ "<STR_LIT:s>" ] . state ( ) <EOL> self . assertEqual ( len ( s ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( s [ <NUM_LIT:0> ] . name , shader ) <EOL> self . assertTrue ( b [ "<STR_LIT:s>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getInput ( ) . isSame ( b [ "<STR_LIT>" ] ) ) <EOL> coshader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> c = GafferRenderMan . RenderManShader ( ) <EOL> c . loadShader ( coshader ) <EOL> self . assertTrue ( b [ "<STR_LIT>" ] . acceptsInput ( c [ "<STR_LIT>" ] ) ) <EOL> b [ "<STR_LIT>" ] . setInput ( c [ "<STR_LIT>" ] ) <EOL> s = b [ "<STR_LIT:s>" ] . state ( ) <EOL> self . assertEqual ( len ( s ) , <NUM_LIT:2> ) <EOL> self . assertEqual ( s [ <NUM_LIT:1> ] . parameters [ "<STR_LIT>" ] , s [ <NUM_LIT:0> ] . parameters [ "<STR_LIT>" ] ) <EOL> n = Gaffer . Node ( ) <EOL> n [ "<STR_LIT>" ] = b [ "<STR_LIT>" ] . createCounterpart ( "<STR_LIT>" , Gaffer . Plug . Direction . Out ) <EOL> self . assertFalse ( b [ "<STR_LIT>" ] . acceptsInput ( n [ "<STR_LIT>" ] ) ) <EOL> self . assertRaises ( RuntimeError , b [ "<STR_LIT>" ] . setInput , n [ "<STR_LIT>" ] ) <EOL> b [ "<STR_LIT:s>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( None ) <EOL> self . assertTrue ( b [ "<STR_LIT>" ] . acceptsInput ( n [ "<STR_LIT>" ] ) ) <EOL> b [ "<STR_LIT>" ] . setInput ( n [ "<STR_LIT>" ] ) <EOL> self . assertTrue ( b [ "<STR_LIT>" ] . getInput ( ) . isSame ( n [ "<STR_LIT>" ] ) ) <EOL> self . assertFalse ( b [ "<STR_LIT:s>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . acceptsInput ( b [ "<STR_LIT>" ] ) ) <EOL> self . assertRaises ( RuntimeError , b [ "<STR_LIT:s>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput , b [ "<STR_LIT>" ] ) <EOL> def testCoshaderSwitching ( self ) : <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> coshader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> coshaderNode0 = GafferRenderMan . RenderManShader ( ) <EOL> coshaderNode0 . loadShader ( coshader ) <EOL> coshaderNode1 = GafferRenderMan . RenderManShader ( ) <EOL> coshaderNode1 . loadShader ( coshader ) <EOL> coshaderNode0 [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setValue ( <NUM_LIT:0> ) <EOL> coshaderNode1 [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setValue ( <NUM_LIT:1> ) <EOL> shaderNode = GafferRenderMan . RenderManShader ( ) <EOL> shaderNode . loadShader ( shader ) <EOL> switch = GafferScene . ShaderSwitch ( ) <EOL> switch [ "<STR_LIT>" ] . setInput ( coshaderNode0 [ "<STR_LIT>" ] ) <EOL> switch [ "<STR_LIT>" ] . setInput ( coshaderNode1 [ "<STR_LIT>" ] ) <EOL> shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( switch [ "<STR_LIT>" ] ) <EOL> self . assertEqual ( shaderNode . state ( ) [ <NUM_LIT:0> ] . parameters [ "<STR_LIT>" ] . value , <NUM_LIT:0> ) <EOL> switch [ "<STR_LIT:index>" ] . setValue ( <NUM_LIT:1> ) <EOL> self . assertEqual ( shaderNode . state ( ) [ <NUM_LIT:0> ] . parameters [ "<STR_LIT>" ] . value , <NUM_LIT:1> ) <EOL> switch [ "<STR_LIT>" ] . setValue ( False ) <EOL> self . assertEqual ( shaderNode . state ( ) [ <NUM_LIT:0> ] . parameters [ "<STR_LIT>" ] . value , <NUM_LIT:0> ) <EOL> def testCoshaderTypingPreventsNewInvalidSwitchInputs ( self ) : <EOL> coshaderType1 = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> coshaderType1Node = GafferRenderMan . RenderManShader ( ) <EOL> coshaderType1Node . loadShader ( coshaderType1 ) <EOL> coshaderType2 = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> coshaderType2Node = GafferRenderMan . RenderManShader ( ) <EOL> coshaderType2Node . loadShader ( coshaderType2 ) <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> shaderNode = GafferRenderMan . RenderManShader ( ) <EOL> shaderNode . loadShader ( shader ) <EOL> switch = GafferScene . ShaderSwitch ( ) <EOL> switch [ "<STR_LIT>" ] . setInput ( coshaderType1Node [ "<STR_LIT>" ] ) <EOL> shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( switch [ "<STR_LIT>" ] ) <EOL> self . assertFalse ( switch [ "<STR_LIT>" ] . acceptsInput ( coshaderType2Node [ "<STR_LIT>" ] ) ) <EOL> self . assertTrue ( switch [ "<STR_LIT>" ] . acceptsInput ( coshaderType1Node [ "<STR_LIT>" ] ) ) <EOL> def testAcceptInputFromEmptySwitch ( self ) : <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> shaderNode = GafferRenderMan . RenderManShader ( ) <EOL> shaderNode . loadShader ( shader ) <EOL> switch = GafferScene . ShaderSwitch ( ) <EOL> self . assertTrue ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . acceptsInput ( switch [ "<STR_LIT>" ] ) ) <EOL> def testCoshaderSwitchingInBox ( self ) : <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> coshader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> script = Gaffer . ScriptNode ( ) <EOL> script [ "<STR_LIT>" ] = GafferRenderMan . RenderManShader ( ) <EOL> script [ "<STR_LIT>" ] . loadShader ( coshader ) <EOL> script [ "<STR_LIT>" ] = GafferRenderMan . RenderManShader ( ) <EOL> script [ "<STR_LIT>" ] . loadShader ( coshader ) <EOL> script [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setValue ( <NUM_LIT:0> ) <EOL> script [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setValue ( <NUM_LIT:1> ) <EOL> script [ "<STR_LIT>" ] = GafferRenderMan . RenderManShader ( ) <EOL> script [ "<STR_LIT>" ] . loadShader ( shader ) <EOL> script [ "<STR_LIT>" ] = GafferScene . ShaderSwitch ( ) <EOL> script [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( script [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) <EOL> script [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( script [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) <EOL> script [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( script [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) <EOL> self . assertEqual ( script [ "<STR_LIT>" ] . state ( ) [ <NUM_LIT:0> ] . parameters [ "<STR_LIT>" ] . value , <NUM_LIT:0> ) <EOL> box = Gaffer . Box . create ( script , Gaffer . StandardSet ( script . children ( Gaffer . Node ) ) ) <EOL> self . assertEqual ( box [ "<STR_LIT>" ] . state ( ) [ <NUM_LIT:0> ] . parameters [ "<STR_LIT>" ] . value , <NUM_LIT:0> ) <EOL> promotedIndex = box . promotePlug ( box [ "<STR_LIT>" ] [ "<STR_LIT:index>" ] ) <EOL> self . assertEqual ( box [ "<STR_LIT>" ] . state ( ) [ <NUM_LIT:0> ] . parameters [ "<STR_LIT>" ] . value , <NUM_LIT:0> ) <EOL> promotedIndex . setValue ( <NUM_LIT:1> ) <EOL> self . assertEqual ( box [ "<STR_LIT>" ] . state ( ) [ <NUM_LIT:0> ] . parameters [ "<STR_LIT>" ] . value , <NUM_LIT:1> ) <EOL> def testRepeatability ( self ) : <EOL> s1 = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> s2 = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> sn1 = GafferRenderMan . RenderManShader ( ) <EOL> sn2 = GafferRenderMan . RenderManShader ( ) <EOL> sn1 . loadShader ( s1 ) <EOL> sn2 . loadShader ( s2 ) <EOL> sn2 [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( sn1 [ "<STR_LIT>" ] ) <EOL> self . assertEqual ( sn2 . stateHash ( ) , sn2 . stateHash ( ) ) <EOL> self . assertEqual ( sn2 . state ( ) , sn2 . state ( ) ) <EOL> def testHandlesAreHumanReadable ( self ) : <EOL> s1 = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> s2 = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> sn1 = GafferRenderMan . RenderManShader ( "<STR_LIT>" ) <EOL> sn2 = GafferRenderMan . RenderManShader ( "<STR_LIT>" ) <EOL> sn1 . loadShader ( s1 ) <EOL> sn2 . loadShader ( s2 ) <EOL> sn2 [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( sn1 [ "<STR_LIT>" ] ) <EOL> state = sn2 . state ( ) <EOL> self . assertTrue ( "<STR_LIT>" in state [ <NUM_LIT:0> ] . parameters [ "<STR_LIT>" ] . value ) <EOL> def testHandlesAreUniqueEvenIfNodeNamesArent ( self ) : <EOL> s1 = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> s2 = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> script = Gaffer . ScriptNode ( ) <EOL> script [ "<STR_LIT>" ] = GafferRenderMan . RenderManShader ( ) <EOL> script [ "<STR_LIT>" ] . loadShader ( s1 ) <EOL> script [ "<STR_LIT>" ] = GafferRenderMan . RenderManShader ( ) <EOL> script [ "<STR_LIT>" ] . loadShader ( s1 ) <EOL> script [ "<STR_LIT>" ] = GafferRenderMan . RenderManShader ( ) <EOL> script [ "<STR_LIT>" ] . loadShader ( s2 ) <EOL> script [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:0> ] . setInput ( script [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) <EOL> script [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:1> ] . setInput ( script [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) <EOL> box = Gaffer . Box . create ( script , Gaffer . StandardSet ( [ script [ "<STR_LIT>" ] ] ) ) <EOL> box [ "<STR_LIT>" ] . setName ( "<STR_LIT>" ) <EOL> script [ "<STR_LIT>" ] . setName ( "<STR_LIT>" ) <EOL> state = script [ "<STR_LIT>" ] . state ( ) <EOL> self . assertNotEqual ( state [ <NUM_LIT:0> ] . parameters [ "<STR_LIT>" ] , state [ <NUM_LIT:1> ] . parameters [ "<STR_LIT>" ] ) <EOL> def testShaderTypesInState ( self ) : <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> shaderNode = GafferRenderMan . RenderManShader ( ) <EOL> shaderNode . loadShader ( shader ) <EOL> coshader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> coshaderNode = GafferRenderMan . RenderManShader ( ) <EOL> coshaderNode . loadShader ( coshader ) <EOL> shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( coshaderNode [ "<STR_LIT>" ] ) <EOL> state = shaderNode . state ( ) <EOL> self . assertEqual ( state [ <NUM_LIT:0> ] . type , "<STR_LIT>" ) <EOL> self . assertEqual ( state [ <NUM_LIT:1> ] . type , "<STR_LIT>" ) <EOL> def testAssignmentAttributeName ( self ) : <EOL> p = GafferScene . Plane ( ) <EOL> s = GafferRenderMan . RenderManShader ( ) <EOL> s . loadShader ( "<STR_LIT>" ) <EOL> a = GafferScene . ShaderAssignment ( ) <EOL> a [ "<STR_LIT>" ] . setInput ( p [ "<STR_LIT>" ] ) <EOL> a [ "<STR_LIT>" ] . setInput ( s [ "<STR_LIT>" ] ) <EOL> self . assertEqual ( a [ "<STR_LIT>" ] . attributes ( "<STR_LIT>" ) . keys ( ) , [ "<STR_LIT>" ] ) <EOL> def testVolumeShader ( self ) : <EOL> s = GafferRenderMan . RenderManShader ( ) <EOL> s . loadShader ( "<STR_LIT>" ) <EOL> self . assertEqual ( s [ "<STR_LIT:type>" ] . getValue ( ) , "<STR_LIT>" ) <EOL> s [ "<STR_LIT:type>" ] . setValue ( "<STR_LIT>" ) <EOL> s . loadShader ( "<STR_LIT>" , keepExistingValues = True ) <EOL> self . assertEqual ( s [ "<STR_LIT:type>" ] . getValue ( ) , "<STR_LIT>" ) <EOL> s . loadShader ( "<STR_LIT>" , keepExistingValues = False ) <EOL> self . assertEqual ( s [ "<STR_LIT:type>" ] . getValue ( ) , "<STR_LIT>" ) <EOL> def testInputAcceptanceFromDots ( self ) : <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> shaderNode = GafferRenderMan . RenderManShader ( ) <EOL> shaderNode . loadShader ( shader ) <EOL> coshader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> coshaderNode = GafferRenderMan . RenderManShader ( ) <EOL> coshaderNode . loadShader ( coshader ) <EOL> dot = Gaffer . Dot ( ) <EOL> dot . setup ( coshaderNode [ "<STR_LIT>" ] ) <EOL> self . assertTrue ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . acceptsInput ( dot [ "<STR_LIT>" ] ) ) <EOL> def testShaderTypeOverride ( self ) : <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> shaderNode = GafferRenderMan . RenderManShader ( ) <EOL> shaderNode . loadShader ( shader ) <EOL> self . assertEqual ( shaderNode [ '<STR_LIT:type>' ] . getValue ( ) , "<STR_LIT>" ) <EOL> def testReferencePromotedCoshader ( self ) : <EOL> s = Gaffer . ScriptNode ( ) <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> coshader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> s [ "<STR_LIT:b>" ] = Gaffer . Box ( ) <EOL> s [ "<STR_LIT:b>" ] [ "<STR_LIT:s>" ] = GafferRenderMan . RenderManShader ( ) <EOL> s [ "<STR_LIT:b>" ] [ "<STR_LIT:s>" ] . loadShader ( shader ) <EOL> p = s [ "<STR_LIT:b>" ] . promotePlug ( s [ "<STR_LIT:b>" ] [ "<STR_LIT:s>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) <EOL> p . setName ( "<STR_LIT:p>" ) <EOL> s [ "<STR_LIT:c>" ] = GafferRenderMan . RenderManShader ( ) <EOL> s [ "<STR_LIT:c>" ] . loadShader ( coshader ) <EOL> self . assertTrue ( s [ "<STR_LIT:b>" ] [ "<STR_LIT:p>" ] . acceptsInput ( s [ "<STR_LIT:c>" ] [ "<STR_LIT>" ] ) ) <EOL> s [ "<STR_LIT:b>" ] . exportForReference ( self . temporaryDirectory ( ) + "<STR_LIT>" ) <EOL> s [ "<STR_LIT:r>" ] = Gaffer . Reference ( ) <EOL> s [ "<STR_LIT:r>" ] . load ( self . temporaryDirectory ( ) + "<STR_LIT>" ) <EOL> self . assertTrue ( s [ "<STR_LIT:r>" ] [ "<STR_LIT:p>" ] . acceptsInput ( s [ "<STR_LIT:c>" ] [ "<STR_LIT>" ] ) ) <EOL> def testLoadAndGIL ( self ) : <EOL> script = Gaffer . ScriptNode ( ) <EOL> script [ "<STR_LIT>" ] = GafferScene . Plane ( ) <EOL> script [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setValue ( IECore . V2i ( <NUM_LIT:20> ) ) <EOL> script [ "<STR_LIT>" ] = GafferScene . Sphere ( ) <EOL> script [ "<STR_LIT>" ] = Gaffer . Expression ( ) <EOL> script [ "<STR_LIT>" ] . setExpression ( "<STR_LIT>" ) <EOL> script [ "<STR_LIT>" ] = GafferScene . Instancer ( ) <EOL> script [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( script [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) <EOL> script [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( script [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) <EOL> script [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setValue ( "<STR_LIT>" ) <EOL> script [ "<STR_LIT>" ] = GafferRenderMan . RenderManShader ( ) <EOL> script [ "<STR_LIT>" ] = GafferScene . ShaderAssignment ( ) <EOL> script [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( script [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) <EOL> script [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( script [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) <EOL> traverseConnection = Gaffer . ScopedConnection ( GafferSceneTest . connectTraverseSceneToPlugDirtiedSignal ( script [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) ) <EOL> script [ "<STR_LIT>" ] . loadShader ( "<STR_LIT>" ) <EOL> if __name__ == "<STR_LIT:__main__>" : <EOL> unittest . main ( ) </s>
<s> import os <EOL> import unittest <EOL> import IECore <EOL> import Gaffer <EOL> import GafferImage <EOL> import GafferScene <EOL> import GafferSceneTest <EOL> @ unittest . skipIf ( "<STR_LIT>" in os . environ , "<STR_LIT>" ) <EOL> class OpenGLRenderTest ( GafferSceneTest . SceneTestCase ) : <EOL> def test ( self ) : <EOL> self . assertFalse ( os . path . exists ( self . temporaryDirectory ( ) + "<STR_LIT>" ) ) <EOL> s = Gaffer . ScriptNode ( ) <EOL> s [ "<STR_LIT>" ] = GafferScene . Plane ( ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setValue ( IECore . V3f ( <NUM_LIT:0> , <NUM_LIT:0> , - <NUM_LIT:5> ) ) <EOL> s [ "<STR_LIT:image>" ] = GafferImage . ImageReader ( ) <EOL> s [ "<STR_LIT:image>" ] [ "<STR_LIT>" ] . setValue ( os . path . expandvars ( "<STR_LIT>" ) ) <EOL> s [ "<STR_LIT>" ] = GafferScene . OpenGLShader ( ) <EOL> s [ "<STR_LIT>" ] . loadShader ( "<STR_LIT>" ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( s [ "<STR_LIT:image>" ] [ "<STR_LIT>" ] ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setValue ( <NUM_LIT:1> ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setValue ( IECore . Color4f ( <NUM_LIT:1> ) ) <EOL> s [ "<STR_LIT>" ] = GafferScene . ShaderAssignment ( ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( s [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( s [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) <EOL> s [ "<STR_LIT>" ] = GafferScene . Outputs ( ) <EOL> s [ "<STR_LIT>" ] . addOutput ( <EOL> "<STR_LIT>" , <EOL> IECore . Display ( <EOL> self . temporaryDirectory ( ) + "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> { } <EOL> ) <EOL> ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( s [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) <EOL> s [ "<STR_LIT>" ] = GafferScene . OpenGLRender ( ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( s [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) <EOL> s [ "<STR_LIT>" ] . setValue ( self . temporaryDirectory ( ) + "<STR_LIT>" ) <EOL> s . save ( ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] . execute ( ) <EOL> self . assertTrue ( os . path . exists ( self . temporaryDirectory ( ) + "<STR_LIT>" ) ) <EOL> i = IECore . EXRImageReader ( self . temporaryDirectory ( ) + "<STR_LIT>" ) . read ( ) <EOL> e = IECore . ImagePrimitiveEvaluator ( i ) <EOL> r = e . createResult ( ) <EOL> e . pointAtUV ( IECore . V2f ( <NUM_LIT:0.5> ) , r ) <EOL> self . assertAlmostEqual ( r . floatPrimVar ( e . R ( ) ) , <NUM_LIT> , <NUM_LIT:5> ) <EOL> self . assertAlmostEqual ( r . floatPrimVar ( e . G ( ) ) , <NUM_LIT> , <NUM_LIT:5> ) <EOL> self . assertEqual ( r . floatPrimVar ( e . B ( ) ) , <NUM_LIT:0> ) <EOL> def testOutputDirectoryCreation ( self ) : <EOL> s = Gaffer . ScriptNode ( ) <EOL> s [ "<STR_LIT>" ] . addMember ( "<STR_LIT>" , self . temporaryDirectory ( ) + "<STR_LIT>" ) <EOL> s [ "<STR_LIT>" ] = GafferScene . Plane ( ) <EOL> s [ "<STR_LIT>" ] = GafferScene . Outputs ( ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( s [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) <EOL> s [ "<STR_LIT>" ] . addOutput ( <EOL> "<STR_LIT>" , <EOL> IECore . Display ( <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> { } <EOL> ) <EOL> ) <EOL> s [ "<STR_LIT>" ] = GafferScene . OpenGLRender ( ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( s [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) <EOL> self . assertFalse ( os . path . exists ( self . temporaryDirectory ( ) + "<STR_LIT>" ) ) <EOL> self . assertFalse ( os . path . exists ( self . temporaryDirectory ( ) + "<STR_LIT>" ) ) <EOL> s [ "<STR_LIT>" ] . setValue ( "<STR_LIT>" ) <EOL> with s . context ( ) : <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] . execute ( ) <EOL> self . assertTrue ( os . path . exists ( self . temporaryDirectory ( ) + "<STR_LIT>" ) ) <EOL> self . assertTrue ( os . path . exists ( self . temporaryDirectory ( ) + "<STR_LIT>" ) ) <EOL> def testHash ( self ) : <EOL> c = Gaffer . Context ( ) <EOL> c . setFrame ( <NUM_LIT:1> ) <EOL> c2 = Gaffer . Context ( ) <EOL> c2 . setFrame ( <NUM_LIT:2> ) <EOL> s = Gaffer . ScriptNode ( ) <EOL> s [ "<STR_LIT>" ] = GafferScene . Plane ( ) <EOL> s [ "<STR_LIT>" ] = GafferScene . Outputs ( ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( s [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) <EOL> s [ "<STR_LIT>" ] . addOutput ( "<STR_LIT>" , IECore . Display ( "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , { } ) ) <EOL> s [ "<STR_LIT>" ] = GafferScene . OpenGLRender ( ) <EOL> self . assertEqual ( s [ "<STR_LIT>" ] . hash ( c ) , IECore . MurmurHash ( ) ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( s [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) <EOL> self . assertNotEqual ( s [ "<STR_LIT>" ] . hash ( c ) , IECore . MurmurHash ( ) ) <EOL> self . assertNotEqual ( s [ "<STR_LIT>" ] . hash ( c ) , s [ "<STR_LIT>" ] . hash ( c2 ) ) <EOL> current = s [ "<STR_LIT>" ] . hash ( c ) <EOL> c [ "<STR_LIT>" ] = self . temporaryDirectory ( ) + "<STR_LIT>" <EOL> self . assertNotEqual ( s [ "<STR_LIT>" ] . hash ( c ) , current ) <EOL> current = s [ "<STR_LIT>" ] . hash ( c ) <EOL> c [ "<STR_LIT>" ] = self . temporaryDirectory ( ) + "<STR_LIT>" <EOL> self . assertNotEqual ( s [ "<STR_LIT>" ] . hash ( c ) , current ) <EOL> current = s [ "<STR_LIT>" ] . hash ( c ) <EOL> c [ "<STR_LIT>" ] = "<STR_LIT>" <EOL> self . assertEqual ( s [ "<STR_LIT>" ] . hash ( c ) , current ) <EOL> current = s [ "<STR_LIT>" ] . hash ( c ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( s [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) <EOL> self . assertNotEqual ( s [ "<STR_LIT>" ] . hash ( c ) , current ) <EOL> if __name__ == "<STR_LIT:__main__>" : <EOL> unittest . main ( ) </s>
<s> import unittest <EOL> import IECore <EOL> import Gaffer <EOL> import GafferTest <EOL> import GafferScene <EOL> import GafferSceneTest <EOL> class SceneTimeWarpTest ( GafferSceneTest . SceneTestCase ) : <EOL> def testConstruct ( self ) : <EOL> s = Gaffer . ScriptNode ( ) <EOL> s [ "<STR_LIT:n>" ] = GafferScene . SceneTimeWarp ( ) <EOL> self . assertEqual ( s [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] . getValue ( ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( s [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] . getValue ( ) , <NUM_LIT:0> ) <EOL> def testRunTimeTyped ( self ) : <EOL> n = GafferScene . SceneTimeWarp ( ) <EOL> self . failUnless ( n . isInstanceOf ( GafferScene . SceneTimeWarp . staticTypeId ( ) ) ) <EOL> self . failUnless ( n . isInstanceOf ( GafferScene . SceneContextProcessor . staticTypeId ( ) ) ) <EOL> self . failUnless ( n . isInstanceOf ( GafferScene . SceneProcessor . staticTypeId ( ) ) ) <EOL> self . failUnless ( n . isInstanceOf ( GafferScene . SceneNode . staticTypeId ( ) ) ) <EOL> self . failUnless ( n . isInstanceOf ( Gaffer . Node . staticTypeId ( ) ) ) <EOL> baseTypeIds = IECore . RunTimeTyped . baseTypeIds ( n . typeId ( ) ) <EOL> self . failUnless ( GafferScene . SceneContextProcessor . staticTypeId ( ) in baseTypeIds ) <EOL> self . failUnless ( GafferScene . SceneProcessor . staticTypeId ( ) in baseTypeIds ) <EOL> self . failUnless ( GafferScene . SceneNode . staticTypeId ( ) in baseTypeIds ) <EOL> self . failUnless ( Gaffer . Node . staticTypeId ( ) in baseTypeIds ) <EOL> def testAffects ( self ) : <EOL> n = GafferScene . SceneTimeWarp ( ) <EOL> c = GafferTest . CapturingSlot ( n . plugDirtiedSignal ( ) ) <EOL> n [ "<STR_LIT>" ] . setValue ( <NUM_LIT:2> ) <EOL> found = False <EOL> for cc in c : <EOL> if cc [ <NUM_LIT:0> ] . isSame ( n [ "<STR_LIT>" ] ) : <EOL> found = True <EOL> self . failUnless ( found ) <EOL> del c [ : ] <EOL> n [ "<STR_LIT>" ] . setValue ( <NUM_LIT:2> ) <EOL> found = False <EOL> for cc in c : <EOL> if cc [ <NUM_LIT:0> ] . isSame ( n [ "<STR_LIT>" ] ) : <EOL> found = True <EOL> self . failUnless ( found ) <EOL> def testNoExtraInputs ( self ) : <EOL> p = GafferScene . Plane ( ) <EOL> n = GafferScene . SceneTimeWarp ( ) <EOL> n [ "<STR_LIT>" ] . setInput ( p [ "<STR_LIT>" ] ) <EOL> self . assertTrue ( "<STR_LIT>" not in n ) <EOL> if __name__ == "<STR_LIT:__main__>" : <EOL> unittest . main ( ) </s>
<s> import Gaffer <EOL> import GafferScene <EOL> Gaffer . Metadata . registerNode ( <EOL> GafferScene . Cube , <EOL> "<STR_LIT:description>" , <EOL> """<STR_LIT>""" , <EOL> plugs = { <EOL> "<STR_LIT>" : [ <EOL> "<STR_LIT:description>" , <EOL> """<STR_LIT>""" , <EOL> ] , <EOL> } <EOL> ) </s>
<s> import Gaffer <EOL> import GafferScene <EOL> import GafferUI <EOL> Gaffer . Metadata . registerNode ( <EOL> GafferScene . ObjectSource , <EOL> "<STR_LIT:description>" , <EOL> """<STR_LIT>""" , <EOL> plugs = { <EOL> "<STR_LIT:name>" : [ <EOL> "<STR_LIT:description>" , <EOL> """<STR_LIT>""" , <EOL> ] , <EOL> "<STR_LIT>" : [ <EOL> "<STR_LIT:description>" , <EOL> """<STR_LIT>""" , <EOL> "<STR_LIT>" , "<STR_LIT>" , <EOL> ] , <EOL> "<STR_LIT>" : [ <EOL> "<STR_LIT:description>" , <EOL> """<STR_LIT>""" , <EOL> ] , <EOL> } <EOL> ) </s>
<s> import functools <EOL> import IECore <EOL> import Gaffer <EOL> import GafferUI <EOL> import GafferScene <EOL> import GafferSceneUI <EOL> Gaffer . Metadata . registerNode ( <EOL> GafferSceneUI . SceneView , <EOL> plugs = { <EOL> "<STR_LIT>" : [ <EOL> "<STR_LIT>" , <NUM_LIT:2> , <EOL> "<STR_LIT>" , True , <EOL> "<STR_LIT>" , "<STR_LIT>" , <EOL> ] , <EOL> "<STR_LIT>" : [ <EOL> "<STR_LIT>" , "<STR_LIT>" , <EOL> "<STR_LIT>" , True , <EOL> ] , <EOL> "<STR_LIT>" : [ <EOL> "<STR_LIT>" , "<STR_LIT>" , <EOL> "<STR_LIT>" , True , <EOL> "<STR_LIT>" , "<STR_LIT>" , <EOL> ] , <EOL> "<STR_LIT>" : [ <EOL> "<STR_LIT:description>" , <EOL> """<STR_LIT>""" , <EOL> ] , <EOL> "<STR_LIT>" : [ <EOL> "<STR_LIT:description>" , <EOL> """<STR_LIT>""" , <EOL> ] , <EOL> "<STR_LIT>" : [ <EOL> "<STR_LIT>" , "<STR_LIT>" , <EOL> ] , <EOL> "<STR_LIT>" : [ <EOL> "<STR_LIT>" , "<STR_LIT>" , <EOL> ] , <EOL> } <EOL> ) <EOL> class _ShadingModePlugValueWidget ( GafferUI . PlugValueWidget ) : <EOL> def __init__ ( self , plug , parenting = None ) : <EOL> menuButton = GafferUI . MenuButton ( <EOL> image = "<STR_LIT>" , <EOL> menu = GafferUI . Menu ( Gaffer . WeakMethod ( self . __menuDefinition ) ) , <EOL> hasFrame = False , <EOL> ) <EOL> GafferUI . PlugValueWidget . __init__ ( self , menuButton , plug , parenting = parenting ) <EOL> def hasLabel ( self ) : <EOL> return True <EOL> def _updateFromPlug ( self ) : <EOL> pass <EOL> def __menuDefinition ( self ) : <EOL> m = IECore . MenuDefinition ( ) <EOL> currentName = self . getPlug ( ) . getValue ( ) <EOL> for name in [ "<STR_LIT>" ] + GafferSceneUI . SceneView . registeredShadingModes ( ) : <EOL> m . append ( <EOL> "<STR_LIT:/>" + name if name else "<STR_LIT>" , <EOL> { <EOL> "<STR_LIT>" : name == currentName , <EOL> "<STR_LIT>" : functools . partial ( Gaffer . WeakMethod ( self . __setValue ) , name if name != currentName else "<STR_LIT>" ) , <EOL> } <EOL> ) <EOL> if not name : <EOL> m . append ( "<STR_LIT>" , { "<STR_LIT>" : True } ) <EOL> return m <EOL> def __setValue ( self , value , * unused ) : <EOL> self . getPlug ( ) . setValue ( value ) <EOL> class _ExpansionPlugValueWidget ( GafferUI . PlugValueWidget ) : <EOL> def __init__ ( self , plug , parenting = None ) : <EOL> menu = GafferUI . Menu ( Gaffer . WeakMethod ( self . __menuDefinition ) ) <EOL> menuButton = GafferUI . MenuButton ( menu = menu , image = "<STR_LIT>" , hasFrame = False ) <EOL> GafferUI . PlugValueWidget . __init__ ( self , menuButton , plug , parenting = parenting ) <EOL> def hasLabel ( self ) : <EOL> return True <EOL> def _updateFromPlug ( self ) : <EOL> pass <EOL> def __menuDefinition ( self ) : <EOL> expandAll = bool ( self . getPlug ( ) . getValue ( ) ) <EOL> m = IECore . MenuDefinition ( ) <EOL> m . append ( "<STR_LIT>" , { "<STR_LIT>" : self . getPlug ( ) . node ( ) . expandSelection , "<STR_LIT>" : not expandAll , "<STR_LIT>" : "<STR_LIT>" } ) <EOL> m . append ( "<STR_LIT>" , { "<STR_LIT>" : IECore . curry ( self . getPlug ( ) . node ( ) . expandSelection , depth = <NUM_LIT> ) , "<STR_LIT>" : not expandAll , "<STR_LIT>" : "<STR_LIT>" } ) <EOL> m . append ( "<STR_LIT>" , { "<STR_LIT>" : self . getPlug ( ) . node ( ) . collapseSelection , "<STR_LIT>" : not expandAll , "<STR_LIT>" : "<STR_LIT>" } ) <EOL> m . append ( "<STR_LIT>" , { "<STR_LIT>" : True } ) <EOL> m . append ( "<STR_LIT>" , { "<STR_LIT>" : expandAll , "<STR_LIT>" : Gaffer . WeakMethod ( self . __toggleMinimumExpansionDepth ) } ) <EOL> return m <EOL> def __toggleMinimumExpansionDepth ( self , * unused ) : <EOL> self . getPlug ( ) . setValue ( <NUM_LIT:0> if self . getPlug ( ) . getValue ( ) else <NUM_LIT> ) <EOL> class _LookThroughPlugValueWidget ( GafferUI . PlugValueWidget ) : <EOL> def __init__ ( self , plug , parenting = None ) : <EOL> row = GafferUI . ListContainer ( GafferUI . ListContainer . Orientation . Horizontal ) <EOL> GafferUI . PlugValueWidget . __init__ ( self , row , plug , parenting = parenting ) <EOL> with row : <EOL> self . __enabledWidget = GafferUI . BoolPlugValueWidget ( plug [ "<STR_LIT>" ] , displayMode = GafferUI . BoolWidget . DisplayMode . Switch ) <EOL> self . __cameraWidget = GafferSceneUI . ScenePathPlugValueWidget ( <EOL> plug [ "<STR_LIT>" ] , <EOL> path = GafferScene . ScenePath ( <EOL> plug . node ( ) [ "<STR_LIT>" ] , <EOL> plug . node ( ) . getContext ( ) , <EOL> "<STR_LIT:/>" , <EOL> filter = GafferScene . ScenePath . createStandardFilter ( [ "<STR_LIT>" ] , "<STR_LIT>" ) <EOL> ) , <EOL> ) <EOL> self . __cameraWidget . pathWidget ( ) . setFixedCharacterWidth ( <NUM_LIT> ) <EOL> if hasattr ( self . __cameraWidget . pathWidget ( ) . _qtWidget ( ) , "<STR_LIT>" ) : <EOL> self . __cameraWidget . pathWidget ( ) . _qtWidget ( ) . setPlaceholderText ( "<STR_LIT>" ) <EOL> self . _updateFromPlug ( ) <EOL> def _updateFromPlug ( self ) : <EOL> with self . getContext ( ) : <EOL> self . __cameraWidget . setEnabled ( self . getPlug ( ) [ "<STR_LIT>" ] . getValue ( ) ) <EOL> class _GridPlugValueWidget ( GafferUI . PlugValueWidget ) : <EOL> def __init__ ( self , plug , parenting = None ) : <EOL> menu = GafferUI . Menu ( Gaffer . WeakMethod ( self . __menuDefinition ) ) <EOL> menuButton = GafferUI . MenuButton ( menu = menu , image = "<STR_LIT>" , hasFrame = False ) <EOL> GafferUI . PlugValueWidget . __init__ ( self , menuButton , plug , parenting = parenting ) <EOL> def hasLabel ( self ) : <EOL> return True <EOL> def _updateFromPlug ( self ) : <EOL> pass <EOL> def __menuDefinition ( self ) : <EOL> m = IECore . MenuDefinition ( ) <EOL> m . append ( <EOL> "<STR_LIT>" , <EOL> { <EOL> "<STR_LIT>" : self . getPlug ( ) [ "<STR_LIT>" ] . getValue ( ) , <EOL> "<STR_LIT>" : self . getPlug ( ) [ "<STR_LIT>" ] . setValue , <EOL> } <EOL> ) <EOL> m . append ( <EOL> "<STR_LIT>" , <EOL> { <EOL> "<STR_LIT>" : self . getPlug ( ) . node ( ) [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) , <EOL> "<STR_LIT>" : self . getPlug ( ) . node ( ) [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setValue , <EOL> } <EOL> ) <EOL> return m </s>
<s> import IECore <EOL> import Gaffer <EOL> class AddNode ( Gaffer . ComputeNode ) : <EOL> def __init__ ( self , name = "<STR_LIT>" ) : <EOL> Gaffer . ComputeNode . __init__ ( self , name ) <EOL> p1 = Gaffer . IntPlug ( "<STR_LIT>" , Gaffer . Plug . Direction . In ) <EOL> p2 = Gaffer . IntPlug ( "<STR_LIT>" , Gaffer . Plug . Direction . In ) <EOL> self . addChild ( Gaffer . BoolPlug ( "<STR_LIT>" , defaultValue = True ) ) <EOL> self . addChild ( p1 ) <EOL> self . addChild ( p2 ) <EOL> p3 = Gaffer . IntPlug ( "<STR_LIT>" , Gaffer . Plug . Direction . Out ) <EOL> self . addChild ( p3 ) <EOL> self . numHashCalls = <NUM_LIT:0> <EOL> self . numComputeCalls = <NUM_LIT:0> <EOL> def enabledPlug ( self ) : <EOL> return self [ "<STR_LIT>" ] <EOL> def correspondingInput ( self , output ) : <EOL> if output . isSame ( self [ "<STR_LIT>" ] ) : <EOL> return self [ "<STR_LIT>" ] <EOL> return Gaffer . ComputeNode . correspondingInput ( self , output ) <EOL> def affects ( self , input ) : <EOL> outputs = Gaffer . ComputeNode . affects ( self , input ) <EOL> if input . getName ( ) in ( "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ) : <EOL> outputs . append ( self . getChild ( "<STR_LIT>" ) ) <EOL> return outputs <EOL> def hash ( self , output , context , h ) : <EOL> assert ( output . isSame ( self . getChild ( "<STR_LIT>" ) ) or plug . getFlags ( ) & plug . Flags . Dynamic ) <EOL> self . getChild ( "<STR_LIT>" ) . hash ( h ) <EOL> self . getChild ( "<STR_LIT>" ) . hash ( h ) <EOL> self . getChild ( "<STR_LIT>" ) . hash ( h ) <EOL> self . numHashCalls += <NUM_LIT:1> <EOL> def compute ( self , plug , context ) : <EOL> assert ( plug . isSame ( self . getChild ( "<STR_LIT>" ) ) or plug . getFlags ( ) & plug . Flags . Dynamic ) <EOL> assert ( isinstance ( context , Gaffer . Context ) ) <EOL> assert ( plug . settable ( ) ) <EOL> assert ( not self [ "<STR_LIT>" ] . settable ( ) ) <EOL> assert ( not self [ "<STR_LIT>" ] . settable ( ) ) <EOL> if self [ "<STR_LIT>" ] . getValue ( ) : <EOL> plug . setValue ( self . getChild ( "<STR_LIT>" ) . getValue ( ) + self . getChild ( "<STR_LIT>" ) . getValue ( ) ) <EOL> else : <EOL> plug . setValue ( self . getChild ( "<STR_LIT>" ) . getValue ( ) ) <EOL> self . numComputeCalls += <NUM_LIT:1> <EOL> IECore . registerRunTimeTyped ( AddNode , typeName = "<STR_LIT>" ) </s>
<s> from __future__ import with_statement <EOL> import unittest <EOL> import time <EOL> import datetime <EOL> import pwd <EOL> import grp <EOL> import os <EOL> import IECore <EOL> import Gaffer <EOL> import GafferTest <EOL> class FileSystemPathTest ( GafferTest . TestCase ) : <EOL> def test ( self ) : <EOL> p = Gaffer . FileSystemPath ( __file__ ) <EOL> self . assert_ ( p . isValid ( ) ) <EOL> self . assert_ ( p . isLeaf ( ) ) <EOL> while len ( p ) : <EOL> del p [ - <NUM_LIT:1> ] <EOL> self . assert_ ( p . isValid ( ) ) <EOL> self . assert_ ( not p . isLeaf ( ) ) <EOL> def testIsLeaf ( self ) : <EOL> path = Gaffer . FileSystemPath ( "<STR_LIT>" ) <EOL> self . assert_ ( not path . isLeaf ( ) ) <EOL> def testConstructWithFilter ( self ) : <EOL> p = Gaffer . FileSystemPath ( __file__ ) <EOL> self . failUnless ( p . getFilter ( ) is None ) <EOL> f = Gaffer . FileNamePathFilter ( [ "<STR_LIT>" ] ) <EOL> p = Gaffer . FileSystemPath ( __file__ , filter = f ) <EOL> self . failUnless ( p . getFilter ( ) . isSame ( f ) ) <EOL> def testBrokenSymbolicLinks ( self ) : <EOL> os . symlink ( self . temporaryDirectory ( ) + "<STR_LIT>" , self . temporaryDirectory ( ) + "<STR_LIT>" ) <EOL> d = Gaffer . FileSystemPath ( self . temporaryDirectory ( ) ) <EOL> c = d . children ( ) <EOL> self . assertEqual ( len ( c ) , <NUM_LIT:1> ) <EOL> l = c [ <NUM_LIT:0> ] <EOL> self . assertEqual ( str ( l ) , self . temporaryDirectory ( ) + "<STR_LIT>" ) <EOL> self . assertEqual ( l . isValid ( ) , True ) <EOL> info = l . info ( ) <EOL> self . failUnless ( info is not None ) <EOL> def testSymLinkInfo ( self ) : <EOL> with open ( self . temporaryDirectory ( ) + "<STR_LIT>" , "<STR_LIT:w>" ) as f : <EOL> f . write ( "<STR_LIT>" ) <EOL> os . symlink ( self . temporaryDirectory ( ) + "<STR_LIT>" , self . temporaryDirectory ( ) + "<STR_LIT>" ) <EOL> a = Gaffer . FileSystemPath ( self . temporaryDirectory ( ) + "<STR_LIT>" ) <EOL> l = Gaffer . FileSystemPath ( self . temporaryDirectory ( ) + "<STR_LIT>" ) <EOL> aInfo = a . info ( ) <EOL> self . assertEqual ( aInfo [ "<STR_LIT>" ] , l . info ( ) [ "<STR_LIT>" ] ) <EOL> os . remove ( str ( a ) ) <EOL> self . assertNotEqual ( aInfo [ "<STR_LIT>" ] , l . info ( ) [ "<STR_LIT>" ] ) <EOL> def testCopy ( self ) : <EOL> p = Gaffer . FileSystemPath ( self . temporaryDirectory ( ) ) <EOL> p2 = p . copy ( ) <EOL> self . assertEqual ( p , p2 ) <EOL> self . assertEqual ( str ( p ) , str ( p2 ) ) <EOL> def testEmptyPath ( self ) : <EOL> p = Gaffer . FileSystemPath ( ) <EOL> self . assertEqual ( str ( p ) , "<STR_LIT>" ) <EOL> self . assertTrue ( p . isEmpty ( ) ) <EOL> self . assertFalse ( p . isValid ( ) ) <EOL> def testRelativePath ( self ) : <EOL> os . chdir ( self . temporaryDirectory ( ) ) <EOL> with open ( self . temporaryDirectory ( ) + "<STR_LIT>" , "<STR_LIT:w>" ) as f : <EOL> f . write ( "<STR_LIT>" ) <EOL> p = Gaffer . FileSystemPath ( "<STR_LIT:a>" ) <EOL> self . assertEqual ( str ( p ) , "<STR_LIT:a>" ) <EOL> self . assertFalse ( p . isEmpty ( ) ) <EOL> self . assertTrue ( p . isValid ( ) ) <EOL> p2 = Gaffer . FileSystemPath ( "<STR_LIT>" ) <EOL> self . assertEqual ( str ( p2 ) , "<STR_LIT>" ) <EOL> self . assertFalse ( p2 . isEmpty ( ) ) <EOL> self . assertFalse ( p2 . isValid ( ) ) <EOL> def testRelativePathChildren ( self ) : <EOL> os . chdir ( self . temporaryDirectory ( ) ) <EOL> os . mkdir ( "<STR_LIT>" ) <EOL> with open ( self . temporaryDirectory ( ) + "<STR_LIT>" , "<STR_LIT:w>" ) as f : <EOL> f . write ( "<STR_LIT>" ) <EOL> p = Gaffer . FileSystemPath ( "<STR_LIT>" ) <EOL> c = p . children ( ) <EOL> self . assertEqual ( len ( c ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( str ( c [ <NUM_LIT:0> ] ) , "<STR_LIT>" ) <EOL> self . assertTrue ( c [ <NUM_LIT:0> ] . isValid ( ) ) <EOL> def testChildrenOfFile ( self ) : <EOL> p = Gaffer . FileSystemPath ( __file__ ) <EOL> self . assertEqual ( p . children ( ) , [ ] ) <EOL> def testModificationTimes ( self ) : <EOL> p = Gaffer . FileSystemPath ( self . temporaryDirectory ( ) ) <EOL> p . append ( "<STR_LIT:t>" ) <EOL> with open ( str ( p ) , "<STR_LIT:w>" ) as f : <EOL> f . write ( "<STR_LIT>" ) <EOL> mt = p . property ( "<STR_LIT>" ) <EOL> self . assertTrue ( isinstance ( mt , datetime . datetime ) ) <EOL> self . assertLess ( ( datetime . datetime . utcnow ( ) - mt ) . total_seconds ( ) , <NUM_LIT:2> ) <EOL> time . sleep ( <NUM_LIT:1> ) <EOL> with open ( str ( p ) , "<STR_LIT:w>" ) as f : <EOL> f . write ( "<STR_LIT>" ) <EOL> mt = p . property ( "<STR_LIT>" ) <EOL> self . assertTrue ( isinstance ( mt , datetime . datetime ) ) <EOL> self . assertLess ( ( datetime . datetime . utcnow ( ) - mt ) . total_seconds ( ) , <NUM_LIT:2> ) <EOL> def testOwner ( self ) : <EOL> p = Gaffer . FileSystemPath ( self . temporaryDirectory ( ) ) <EOL> p . append ( "<STR_LIT:t>" ) <EOL> with open ( str ( p ) , "<STR_LIT:w>" ) as f : <EOL> f . write ( "<STR_LIT>" ) <EOL> o = p . property ( "<STR_LIT>" ) <EOL> self . assertTrue ( isinstance ( o , str ) ) <EOL> self . assertEqual ( o , pwd . getpwuid ( os . stat ( str ( p ) ) . st_uid ) . pw_name ) <EOL> def testGroup ( self ) : <EOL> p = Gaffer . FileSystemPath ( self . temporaryDirectory ( ) ) <EOL> p . append ( "<STR_LIT:t>" ) <EOL> with open ( str ( p ) , "<STR_LIT:w>" ) as f : <EOL> f . write ( "<STR_LIT>" ) <EOL> g = p . property ( "<STR_LIT>" ) <EOL> self . assertTrue ( isinstance ( g , str ) ) <EOL> self . assertEqual ( g , grp . getgrgid ( os . stat ( str ( p ) ) . st_gid ) . gr_name ) <EOL> def testPropertyNames ( self ) : <EOL> p = Gaffer . FileSystemPath ( self . temporaryDirectory ( ) ) <EOL> a = p . propertyNames ( ) <EOL> self . assertTrue ( isinstance ( a , list ) ) <EOL> self . assertTrue ( "<STR_LIT>" in a ) <EOL> self . assertTrue ( "<STR_LIT>" in a ) <EOL> self . assertTrue ( "<STR_LIT>" in a ) <EOL> self . assertTrue ( "<STR_LIT>" in a ) <EOL> self . assertTrue ( "<STR_LIT>" not in a ) <EOL> p = Gaffer . FileSystemPath ( self . temporaryDirectory ( ) , includeSequences = True ) <EOL> self . assertTrue ( "<STR_LIT>" in p . propertyNames ( ) ) <EOL> def testSequences ( self ) : <EOL> os . mkdir ( self . temporaryDirectory ( ) + "<STR_LIT>" ) <EOL> for n in [ "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ] : <EOL> with open ( self . temporaryDirectory ( ) + "<STR_LIT:/>" + n , "<STR_LIT:w>" ) as f : <EOL> f . write ( "<STR_LIT>" ) <EOL> p = Gaffer . FileSystemPath ( self . temporaryDirectory ( ) , includeSequences = True ) <EOL> self . assertTrue ( p . getIncludeSequences ( ) ) <EOL> c = p . children ( ) <EOL> self . assertEqual ( len ( c ) , <NUM_LIT:8> ) <EOL> s = sorted ( c , key = str ) <EOL> self . assertEqual ( str ( s [ <NUM_LIT:0> ] ) , self . temporaryDirectory ( ) + "<STR_LIT>" ) <EOL> self . assertEqual ( str ( s [ <NUM_LIT:1> ] ) , self . temporaryDirectory ( ) + "<STR_LIT>" ) <EOL> self . assertEqual ( str ( s [ <NUM_LIT:2> ] ) , self . temporaryDirectory ( ) + "<STR_LIT>" ) <EOL> self . assertEqual ( str ( s [ <NUM_LIT:3> ] ) , self . temporaryDirectory ( ) + "<STR_LIT>" ) <EOL> self . assertEqual ( str ( s [ <NUM_LIT:4> ] ) , self . temporaryDirectory ( ) + "<STR_LIT>" ) <EOL> self . assertEqual ( str ( s [ <NUM_LIT:5> ] ) , self . temporaryDirectory ( ) + "<STR_LIT>" ) <EOL> self . assertEqual ( str ( s [ <NUM_LIT:6> ] ) , self . temporaryDirectory ( ) + "<STR_LIT>" ) <EOL> self . assertEqual ( str ( s [ <NUM_LIT:7> ] ) , self . temporaryDirectory ( ) + "<STR_LIT>" ) <EOL> for x in s : <EOL> self . assertTrue ( x . isValid ( ) ) <EOL> if not os . path . isdir ( str ( x ) ) : <EOL> self . assertTrue ( x . isLeaf ( ) ) <EOL> self . assertEqual ( x . property ( "<STR_LIT>" ) , pwd . getpwuid ( os . stat ( str ( p ) ) . st_uid ) . pw_name ) <EOL> self . assertEqual ( x . property ( "<STR_LIT>" ) , grp . getgrgid ( os . stat ( str ( p ) ) . st_gid ) . gr_name ) <EOL> self . assertLess ( ( datetime . datetime . utcnow ( ) - x . property ( "<STR_LIT>" ) ) . total_seconds ( ) , <NUM_LIT:2> ) <EOL> if "<STR_LIT>" not in str ( x ) : <EOL> self . assertFalse ( x . isFileSequence ( ) ) <EOL> self . assertEqual ( x . fileSequence ( ) , None ) <EOL> self . assertEqual ( x . property ( "<STR_LIT>" ) , "<STR_LIT>" ) <EOL> if os . path . isdir ( str ( x ) ) : <EOL> self . assertEqual ( x . property ( "<STR_LIT>" ) , <NUM_LIT:0> ) <EOL> else : <EOL> self . assertEqual ( x . property ( "<STR_LIT>" ) , <NUM_LIT:4> ) <EOL> self . assertEqual ( s [ <NUM_LIT:0> ] . property ( "<STR_LIT>" ) , "<STR_LIT>" ) <EOL> self . assertTrue ( s [ <NUM_LIT:0> ] . isFileSequence ( ) ) <EOL> self . assertTrue ( isinstance ( s [ <NUM_LIT:0> ] . fileSequence ( ) , IECore . FileSequence ) ) <EOL> self . assertEqual ( s [ <NUM_LIT:0> ] . fileSequence ( ) , IECore . FileSequence ( str ( s [ <NUM_LIT:0> ] ) , IECore . frameListFromList ( [ <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:4> ] ) ) ) <EOL> self . assertEqual ( s [ <NUM_LIT:0> ] . property ( "<STR_LIT>" ) , <NUM_LIT:4> * <NUM_LIT:3> ) <EOL> self . assertEqual ( s [ <NUM_LIT:4> ] . property ( "<STR_LIT>" ) , "<STR_LIT:3>" ) <EOL> self . assertTrue ( s [ <NUM_LIT:4> ] . isFileSequence ( ) ) <EOL> self . assertTrue ( isinstance ( s [ <NUM_LIT:4> ] . fileSequence ( ) , IECore . FileSequence ) ) <EOL> self . assertEqual ( s [ <NUM_LIT:4> ] . fileSequence ( ) , IECore . FileSequence ( str ( s [ <NUM_LIT:4> ] ) , IECore . frameListFromList ( [ <NUM_LIT:3> ] ) ) ) <EOL> self . assertEqual ( s [ <NUM_LIT:4> ] . property ( "<STR_LIT>" ) , <NUM_LIT:4> ) <EOL> p2 = p . copy ( ) <EOL> self . assertTrue ( p2 . getIncludeSequences ( ) ) <EOL> self . assertEqual ( len ( p2 . children ( ) ) , <NUM_LIT:8> ) <EOL> p = Gaffer . FileSystemPath ( self . temporaryDirectory ( ) , includeSequences = False ) <EOL> self . assertFalse ( p . getIncludeSequences ( ) ) <EOL> c = p . children ( ) <EOL> self . assertEqual ( len ( c ) , <NUM_LIT:6> ) <EOL> s = sorted ( c , key = str ) <EOL> self . assertEqual ( str ( s [ <NUM_LIT:0> ] ) , self . temporaryDirectory ( ) + "<STR_LIT>" ) <EOL> self . assertEqual ( str ( s [ <NUM_LIT:1> ] ) , self . temporaryDirectory ( ) + "<STR_LIT>" ) <EOL> self . assertEqual ( str ( s [ <NUM_LIT:2> ] ) , self . temporaryDirectory ( ) + "<STR_LIT>" ) <EOL> self . assertEqual ( str ( s [ <NUM_LIT:3> ] ) , self . temporaryDirectory ( ) + "<STR_LIT>" ) <EOL> self . assertEqual ( str ( s [ <NUM_LIT:4> ] ) , self . temporaryDirectory ( ) + "<STR_LIT>" ) <EOL> self . assertEqual ( str ( s [ <NUM_LIT:5> ] ) , self . temporaryDirectory ( ) + "<STR_LIT>" ) <EOL> p . setIncludeSequences ( True ) <EOL> self . assertTrue ( p . getIncludeSequences ( ) ) <EOL> c = p . children ( ) <EOL> self . assertEqual ( len ( c ) , <NUM_LIT:8> ) <EOL> def setUp ( self ) : <EOL> GafferTest . TestCase . setUp ( self ) <EOL> self . __originalCWD = os . getcwd ( ) <EOL> def tearDown ( self ) : <EOL> GafferTest . TestCase . tearDown ( self ) <EOL> os . chdir ( self . __originalCWD ) <EOL> if __name__ == "<STR_LIT:__main__>" : <EOL> unittest . main ( ) </s>
<s> import unittest <EOL> import IECore <EOL> import Gaffer <EOL> import GafferTest <EOL> class SequencePathTest ( GafferTest . TestCase ) : <EOL> def __dictPath ( self ) : <EOL> dict = { } <EOL> dict [ "<STR_LIT>" ] = { } <EOL> for f in IECore . FileSequence ( "<STR_LIT>" ) . fileNames ( ) : <EOL> dict [ "<STR_LIT>" ] [ f ] = <NUM_LIT:1> <EOL> for f in IECore . FileSequence ( "<STR_LIT>" ) . fileNames ( ) : <EOL> dict [ "<STR_LIT>" ] [ f ] = <NUM_LIT:1> <EOL> return Gaffer . DictPath ( dict , "<STR_LIT:/>" ) <EOL> def test ( self ) : <EOL> path = Gaffer . SequencePath ( self . __dictPath ( ) ) <EOL> self . failUnless ( path . isValid ( ) ) <EOL> self . failUnless ( not path . isLeaf ( ) ) <EOL> path . append ( "<STR_LIT>" ) <EOL> self . failUnless ( path . isValid ( ) ) <EOL> self . failUnless ( not path . isLeaf ( ) ) <EOL> path [ <NUM_LIT:0> ] = "<STR_LIT>" <EOL> self . failIf ( path . isValid ( ) ) <EOL> self . failIf ( path . isLeaf ( ) ) <EOL> path [ : ] = [ "<STR_LIT>" ] <EOL> children = path . children ( ) <EOL> for child in children : <EOL> self . failUnless ( isinstance ( child , Gaffer . SequencePath ) ) <EOL> self . assertEqual ( len ( children ) , <NUM_LIT:2> ) <EOL> childrenStrings = [ str ( c ) for c in children ] <EOL> self . failUnless ( "<STR_LIT>" in childrenStrings ) <EOL> self . failUnless ( "<STR_LIT>" in childrenStrings ) <EOL> def testNonLeafChildren ( self ) : <EOL> path = Gaffer . SequencePath ( self . __dictPath ( ) ) <EOL> children = path . children ( ) <EOL> for child in children : <EOL> self . failUnless ( isinstance ( child , Gaffer . SequencePath ) ) <EOL> self . assertEqual ( len ( children ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( str ( children [ <NUM_LIT:0> ] ) , "<STR_LIT>" ) <EOL> def testCopy ( self ) : <EOL> path = Gaffer . SequencePath ( self . __dictPath ( ) ) <EOL> path . append ( "<STR_LIT>" ) <EOL> path2 = path . copy ( ) <EOL> self . failUnless ( isinstance ( path2 , Gaffer . SequencePath ) ) <EOL> self . assertEqual ( path [ : ] , path2 [ : ] ) <EOL> self . failUnless ( path . getFilter ( ) is path2 . getFilter ( ) ) <EOL> c = [ str ( p ) for p in path . children ( ) ] <EOL> c2 = [ str ( p ) for p in path2 . children ( ) ] <EOL> self . assertEqual ( c , c2 ) <EOL> def testInfo ( self ) : <EOL> dictPath = self . __dictPath ( ) <EOL> path = Gaffer . SequencePath ( dictPath ) <EOL> self . assertEqual ( dictPath . info ( ) , path . info ( ) ) <EOL> def testInfoOfInvalidPath ( self ) : <EOL> fp = Gaffer . FileSystemPath ( "<STR_LIT>" ) <EOL> self . assertEqual ( fp . isValid ( ) , False ) <EOL> self . assertEqual ( fp . info ( ) , None ) <EOL> sp = Gaffer . SequencePath ( fp ) <EOL> self . assertEqual ( sp . isValid ( ) , False ) <EOL> self . assertEqual ( sp . info ( ) , None ) <EOL> def testFilter ( self ) : <EOL> dictPath = self . __dictPath ( ) <EOL> path = Gaffer . SequencePath ( dictPath ) <EOL> def testIsEmpty ( self ) : <EOL> dictPath = self . __dictPath ( ) <EOL> path = Gaffer . SequencePath ( dictPath ) <EOL> path . setFromString ( "<STR_LIT>" ) <EOL> self . assertTrue ( path . isEmpty ( ) ) <EOL> path2 = path . copy ( ) <EOL> self . assertTrue ( path2 . isEmpty ( ) ) <EOL> def testProperties ( self ) : <EOL> dictPath = self . __dictPath ( ) <EOL> path = Gaffer . SequencePath ( dictPath ) <EOL> self . assertEqual ( dictPath . propertyNames ( ) , path . propertyNames ( ) ) <EOL> self . assertEqual ( dictPath . property ( "<STR_LIT>" ) , path . property ( "<STR_LIT>" ) ) <EOL> if __name__ == "<STR_LIT:__main__>" : <EOL> unittest . main ( ) </s>
<s> assert ( __name__ == "<STR_LIT:__main__>" ) </s>
<s> from __future__ import with_statement <EOL> import IECore <EOL> import Gaffer <EOL> import GafferUI <EOL> class CompoundDataPlugValueWidget ( GafferUI . PlugValueWidget ) : <EOL> def __init__ ( self , plug , parenting = None ) : <EOL> self . __column = GafferUI . ListContainer ( spacing = <NUM_LIT:6> ) <EOL> GafferUI . PlugValueWidget . __init__ ( self , self . __column , plug , parenting = parenting ) <EOL> with self . __column : <EOL> self . __layout = GafferUI . PlugLayout ( plug ) <EOL> with GafferUI . ListContainer ( GafferUI . ListContainer . Orientation . Horizontal ) as self . __editRow : <EOL> GafferUI . Spacer ( IECore . V2i ( GafferUI . PlugWidget . labelWidth ( ) , <NUM_LIT:1> ) ) <EOL> GafferUI . MenuButton ( <EOL> image = "<STR_LIT>" , <EOL> hasFrame = False , <EOL> menu = GafferUI . Menu ( Gaffer . WeakMethod ( self . __addMenuDefinition ) ) <EOL> ) <EOL> GafferUI . Spacer ( IECore . V2i ( <NUM_LIT:1> ) , IECore . V2i ( <NUM_LIT> , <NUM_LIT:1> ) , parenting = { "<STR_LIT>" : True } ) <EOL> self . _updateFromPlug ( ) <EOL> def hasLabel ( self ) : <EOL> return True <EOL> def setPlug ( self , plug ) : <EOL> GafferUI . PlugValueWidget . setPlug ( self , plug ) <EOL> self . __layout = GafferUI . PlugLayout ( plug ) <EOL> self . __column [ <NUM_LIT:0> ] = self . __layout <EOL> def setReadOnly ( self , readOnly ) : <EOL> if readOnly == self . getReadOnly ( ) : <EOL> return <EOL> GafferUI . PlugValueWidget . setReadOnly ( self , readOnly ) <EOL> self . __layout . setReadOnly ( readOnly ) <EOL> def childPlugValueWidget ( self , childPlug , lazy = True ) : <EOL> return self . __layout . plugValueWidget ( childPlug , lazy ) <EOL> def _updateFromPlug ( self ) : <EOL> editable = True <EOL> if self . getPlug ( ) is not None : <EOL> editable = Gaffer . Metadata . plugValue ( self . getPlug ( ) , "<STR_LIT>" ) <EOL> editable = editable if editable is not None else True <EOL> self . __editRow . setVisible ( editable ) <EOL> def __addMenuDefinition ( self ) : <EOL> result = IECore . MenuDefinition ( ) <EOL> result . append ( "<STR_LIT>" , { "<STR_LIT>" : IECore . curry ( Gaffer . WeakMethod ( self . __addItem ) , "<STR_LIT>" , IECore . BoolData ( False ) ) } ) <EOL> result . append ( "<STR_LIT>" , { "<STR_LIT>" : IECore . curry ( Gaffer . WeakMethod ( self . __addItem ) , "<STR_LIT>" , IECore . FloatData ( <NUM_LIT:0> ) ) } ) <EOL> result . append ( "<STR_LIT>" , { "<STR_LIT>" : IECore . curry ( Gaffer . WeakMethod ( self . __addItem ) , "<STR_LIT>" , IECore . IntData ( <NUM_LIT:0> ) ) } ) <EOL> result . append ( "<STR_LIT>" , { "<STR_LIT>" : True } ) <EOL> result . append ( "<STR_LIT>" , { "<STR_LIT>" : IECore . curry ( Gaffer . WeakMethod ( self . __addItem ) , "<STR_LIT>" , IECore . StringData ( "<STR_LIT>" ) ) } ) <EOL> result . append ( "<STR_LIT>" , { "<STR_LIT>" : True } ) <EOL> result . append ( "<STR_LIT>" , { "<STR_LIT>" : IECore . curry ( Gaffer . WeakMethod ( self . __addItem ) , "<STR_LIT>" , IECore . V2iData ( IECore . V2i ( <NUM_LIT:0> ) ) ) } ) <EOL> result . append ( "<STR_LIT>" , { "<STR_LIT>" : IECore . curry ( Gaffer . WeakMethod ( self . __addItem ) , "<STR_LIT>" , IECore . V3iData ( IECore . V3i ( <NUM_LIT:0> ) ) ) } ) <EOL> result . append ( "<STR_LIT>" , { "<STR_LIT>" : IECore . curry ( Gaffer . WeakMethod ( self . __addItem ) , "<STR_LIT>" , IECore . V2fData ( IECore . V2f ( <NUM_LIT:0> ) ) ) } ) <EOL> result . append ( "<STR_LIT>" , { "<STR_LIT>" : IECore . curry ( Gaffer . WeakMethod ( self . __addItem ) , "<STR_LIT>" , IECore . V3fData ( IECore . V3f ( <NUM_LIT:0> ) ) ) } ) <EOL> result . append ( "<STR_LIT>" , { "<STR_LIT>" : True } ) <EOL> result . append ( "<STR_LIT>" , { "<STR_LIT>" : IECore . curry ( Gaffer . WeakMethod ( self . __addItem ) , "<STR_LIT>" , IECore . Color3fData ( IECore . Color3f ( <NUM_LIT:0> ) ) ) } ) <EOL> result . append ( "<STR_LIT>" , { "<STR_LIT>" : IECore . curry ( Gaffer . WeakMethod ( self . __addItem ) , "<STR_LIT>" , IECore . Color4fData ( IECore . Color4f ( <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:1> ) ) ) } ) <EOL> return result <EOL> def __addItem ( self , name , value ) : <EOL> with Gaffer . UndoContext ( self . getPlug ( ) . ancestor ( Gaffer . ScriptNode . staticTypeId ( ) ) ) : <EOL> self . getPlug ( ) . addOptionalMember ( name , value , enabled = True ) <EOL> class _MemberPlugValueWidget ( GafferUI . PlugValueWidget ) : <EOL> def __init__ ( self , childPlug ) : <EOL> self . __row = GafferUI . ListContainer ( GafferUI . ListContainer . Orientation . Horizontal , spacing = <NUM_LIT:4> ) <EOL> GafferUI . PlugValueWidget . __init__ ( self , self . __row , childPlug ) <EOL> if not childPlug . getFlags ( Gaffer . Plug . Flags . Dynamic ) : <EOL> nameWidget = GafferUI . LabelPlugValueWidget ( <EOL> childPlug , <EOL> horizontalAlignment = GafferUI . Label . HorizontalAlignment . Right , <EOL> verticalAlignment = GafferUI . Label . VerticalAlignment . Center , <EOL> ) <EOL> nameWidget . label ( ) . _qtWidget ( ) . setFixedWidth ( GafferUI . PlugWidget . labelWidth ( ) ) <EOL> nameWidget . label ( ) . _qtWidget ( ) . setFixedHeight ( <NUM_LIT:20> ) <EOL> else : <EOL> nameWidget = GafferUI . StringPlugValueWidget ( childPlug [ "<STR_LIT:name>" ] ) <EOL> nameWidget . textWidget ( ) . _qtWidget ( ) . setFixedWidth ( GafferUI . PlugWidget . labelWidth ( ) ) <EOL> self . __row . append ( nameWidget , <EOL> verticalAlignment = GafferUI . Label . VerticalAlignment . Top <EOL> ) <EOL> if "<STR_LIT>" in childPlug : <EOL> self . __row . append ( <EOL> GafferUI . BoolPlugValueWidget ( <EOL> childPlug [ "<STR_LIT>" ] , <EOL> displayMode = GafferUI . BoolWidget . DisplayMode . Switch <EOL> ) , <EOL> verticalAlignment = GafferUI . Label . VerticalAlignment . Top , <EOL> ) <EOL> self . __row . append ( GafferUI . PlugValueWidget . create ( childPlug [ "<STR_LIT:value>" ] ) , expand = True ) <EOL> self . _updateFromPlug ( ) <EOL> def setPlug ( self , plug ) : <EOL> GafferUI . PlugValueWidget . setPlug ( self , plug ) <EOL> if isinstance ( self . __row [ <NUM_LIT:0> ] , GafferUI . LabelPlugValueWidget ) : <EOL> self . __row [ <NUM_LIT:0> ] . setPlug ( plug ) <EOL> else : <EOL> self . __row [ <NUM_LIT:0> ] . setPlug ( plug [ "<STR_LIT:name>" ] ) <EOL> if "<STR_LIT>" in plug : <EOL> self . __row [ <NUM_LIT:1> ] . setPlug ( plug [ "<STR_LIT>" ] ) <EOL> self . __row [ - <NUM_LIT:1> ] . setPlug ( plug [ "<STR_LIT:value>" ] ) <EOL> def hasLabel ( self ) : <EOL> return True <EOL> def childPlugValueWidget ( self , childPlug , lazy = True ) : <EOL> for w in self . __row : <EOL> if w . getPlug ( ) . isSame ( childPlug ) : <EOL> return w <EOL> return None <EOL> def setReadOnly ( self , readOnly ) : <EOL> if readOnly == self . getReadOnly ( ) : <EOL> return <EOL> GafferUI . PlugValueWidget . setReadOnly ( self , readOnly ) <EOL> for w in self . __row : <EOL> w . setReadOnly ( readOnly ) <EOL> def _updateFromPlug ( self ) : <EOL> if "<STR_LIT>" in self . getPlug ( ) : <EOL> with self . getContext ( ) : <EOL> enabled = self . getPlug ( ) [ "<STR_LIT>" ] . getValue ( ) <EOL> if isinstance ( self . __row [ <NUM_LIT:0> ] , GafferUI . StringPlugValueWidget ) : <EOL> self . __row [ <NUM_LIT:0> ] . setEnabled ( enabled ) <EOL> self . __row [ - <NUM_LIT:1> ] . setEnabled ( enabled ) <EOL> GafferUI . PlugValueWidget . registerType ( Gaffer . CompoundDataPlug , CompoundDataPlugValueWidget ) <EOL> GafferUI . PlugValueWidget . registerType ( Gaffer . CompoundDataPlug . MemberPlug , _MemberPlugValueWidget ) <EOL> def __deletePlug ( plug ) : <EOL> with Gaffer . UndoContext ( plug . ancestor ( Gaffer . ScriptNode ) ) : <EOL> plug . parent ( ) . removeChild ( plug ) <EOL> def __plugPopupMenu ( menuDefinition , plugValueWidget ) : <EOL> plug = plugValueWidget . getPlug ( ) <EOL> memberPlug = plug if isinstance ( plug , Gaffer . CompoundDataPlug . MemberPlug ) else None <EOL> memberPlug = memberPlug if memberPlug is not None else plug . ancestor ( Gaffer . CompoundDataPlug . MemberPlug ) <EOL> if memberPlug is None : <EOL> return <EOL> if not memberPlug . getFlags ( Gaffer . Plug . Flags . Dynamic ) : <EOL> return <EOL> menuDefinition . append ( "<STR_LIT>" , { "<STR_LIT>" : True } ) <EOL> menuDefinition . append ( "<STR_LIT>" , { "<STR_LIT>" : IECore . curry ( __deletePlug , memberPlug ) , "<STR_LIT>" : not plugValueWidget . getReadOnly ( ) } ) <EOL> __plugPopupMenuConnection = GafferUI . PlugValueWidget . popupMenuSignal ( ) . connect ( __plugPopupMenu ) </s>
<s> import Gaffer <EOL> import GafferUI <EOL> class FileSystemPathPlugValueWidget ( GafferUI . PathPlugValueWidget ) : <EOL> def __init__ ( self , plug , path = None , parenting = None ) : <EOL> GafferUI . PathPlugValueWidget . __init__ ( <EOL> self , <EOL> plug , <EOL> path , <EOL> parenting = parenting <EOL> ) <EOL> self . _updateFromPlug ( ) <EOL> self . __plugMetadataChangedConnection = Gaffer . Metadata . plugValueChangedSignal ( ) . connect ( Gaffer . WeakMethod ( self . __plugMetadataChanged ) ) <EOL> def getToolTip ( self ) : <EOL> result = GafferUI . PathPlugValueWidget . getToolTip ( self ) <EOL> extensions = self . __extensions ( ) <EOL> if extensions : <EOL> result += "<STR_LIT>" + "<STR_LIT:U+002CU+0020>" . join ( extensions ) <EOL> return result <EOL> def _pathChooserDialogue ( self ) : <EOL> dialogue = GafferUI . PathPlugValueWidget . _pathChooserDialogue ( self ) <EOL> if Gaffer . Metadata . plugValue ( self . getPlug ( ) , "<STR_LIT>" ) : <EOL> columns = dialogue . pathChooserWidget ( ) . pathListingWidget ( ) . getColumns ( ) <EOL> columns . append ( GafferUI . PathListingWidget . StandardColumn ( "<STR_LIT>" , "<STR_LIT>" ) ) <EOL> dialogue . pathChooserWidget ( ) . pathListingWidget ( ) . setColumns ( columns ) <EOL> return dialogue <EOL> def _updateFromPlug ( self ) : <EOL> GafferUI . PathPlugValueWidget . _updateFromPlug ( self ) <EOL> includeSequences = Gaffer . Metadata . plugValue ( self . getPlug ( ) , "<STR_LIT>" ) or False <EOL> self . path ( ) . setFilter ( <EOL> Gaffer . FileSystemPath . createStandardFilter ( <EOL> self . __extensions ( ) , <EOL> Gaffer . Metadata . plugValue ( self . getPlug ( ) , "<STR_LIT>" ) or "<STR_LIT>" , <EOL> includeSequenceFilter = includeSequences , <EOL> ) <EOL> ) <EOL> self . path ( ) . setIncludeSequences ( includeSequences ) <EOL> def _setPlugFromPath ( self , path ) : <EOL> if Gaffer . Metadata . plugValue ( self . getPlug ( ) , "<STR_LIT>" ) : <EOL> sequence = path . fileSequence ( ) <EOL> if sequence : <EOL> self . getPlug ( ) . setValue ( str ( sequence ) ) <EOL> return <EOL> GafferUI . PathPlugValueWidget . _setPlugFromPath ( self , path ) <EOL> def __plugMetadataChanged ( self , nodeTypeId , plugPath , key , plug ) : <EOL> if self . getPlug ( ) is None : <EOL> return <EOL> if plug is not None and not plug . isSame ( self . getPlug ( ) ) : <EOL> return <EOL> if not self . getPlug ( ) . node ( ) . isInstanceOf ( nodeTypeId ) : <EOL> return <EOL> if key . startswith ( "<STR_LIT>" ) : <EOL> self . _updateFromPlug ( ) <EOL> def __extensions ( self ) : <EOL> if self . getPlug ( ) is None : <EOL> return [ ] <EOL> extensions = Gaffer . Metadata . plugValue ( self . getPlug ( ) , "<STR_LIT>" ) or [ ] <EOL> if isinstance ( extensions , str ) : <EOL> extensions = extensions . split ( ) <EOL> else : <EOL> extensions = list ( extensions ) <EOL> return extensions </s>
<s> import IECore <EOL> import Gaffer <EOL> import GafferUI <EOL> class NameLabel ( GafferUI . Label ) : <EOL> def __init__ ( self , graphComponent , horizontalAlignment = GafferUI . Label . HorizontalAlignment . Left , verticalAlignment = GafferUI . Label . VerticalAlignment . Center , numComponents = <NUM_LIT:1> , formatter = None , parenting = None ) : <EOL> GafferUI . Label . __init__ ( self , "<STR_LIT>" , horizontalAlignment , verticalAlignment , parenting = parenting ) <EOL> self . __formatter = formatter if formatter is not None else self . defaultFormatter <EOL> self . __numComponents = numComponents <EOL> self . __connections = [ ] <EOL> self . __graphComponent = False <EOL> self . setGraphComponent ( graphComponent ) <EOL> self . __buttonPressConnection = self . buttonPressSignal ( ) . connect ( Gaffer . WeakMethod ( self . __buttonPress ) ) <EOL> self . __dragBeginConnection = self . dragBeginSignal ( ) . connect ( Gaffer . WeakMethod ( self . __dragBegin ) ) <EOL> self . __dragEndConnection = self . dragEndSignal ( ) . connect ( Gaffer . WeakMethod ( self . __dragEnd ) ) <EOL> def setText ( self , text ) : <EOL> GafferUI . Label . setText ( self , text ) <EOL> self . __connections = [ ] <EOL> def setGraphComponent ( self , graphComponent ) : <EOL> if graphComponent is not None and self . __graphComponent is not False : <EOL> if graphComponent . isSame ( self . __graphComponent ) : <EOL> return <EOL> elif self . __graphComponent is None : <EOL> return <EOL> self . __graphComponent = graphComponent <EOL> self . __setupConnections ( ) <EOL> self . __setText ( ) <EOL> def getGraphComponent ( self ) : <EOL> return self . __graphComponent <EOL> def setNumComponents ( self , numComponents ) : <EOL> assert ( numComponents > <NUM_LIT:0> ) <EOL> if numComponents == self . __numComponents : <EOL> return <EOL> self . __numComponents = numComponents <EOL> self . __setupConnections ( ) <EOL> self . __setText ( ) <EOL> def getNumComponents ( self ) : <EOL> return self . __numComponents <EOL> def setFormatter ( self , formatter ) : <EOL> self . __formatter = formatter <EOL> self . __setText ( ) <EOL> def getFormatter ( self ) : <EOL> return self . __formatter <EOL> @ staticmethod <EOL> def defaultFormatter ( graphComponents ) : <EOL> return "<STR_LIT:.>" . join ( IECore . CamelCase . toSpaced ( g . getName ( ) ) for g in graphComponents ) <EOL> def __setupConnections ( self , reuseUntil = None ) : <EOL> if self . __graphComponent is None : <EOL> self . __connections = [ ] <EOL> return <EOL> updatedConnections = [ ] <EOL> n = <NUM_LIT:0> <EOL> g = self . __graphComponent <EOL> reuse = reuseUntil is not None <EOL> while g is not None and n < self . __numComponents : <EOL> if reuse : <EOL> updatedConnections . extend ( self . __connections [ n * <NUM_LIT:2> : n * <NUM_LIT:2> + <NUM_LIT:2> ] ) <EOL> else : <EOL> updatedConnections . append ( g . nameChangedSignal ( ) . connect ( Gaffer . WeakMethod ( self . __setText ) ) ) <EOL> if n < self . __numComponents - <NUM_LIT:1> : <EOL> updatedConnections . append ( g . parentChangedSignal ( ) . connect ( Gaffer . WeakMethod ( self . __parentChanged ) ) ) <EOL> if g . isSame ( reuseUntil ) : <EOL> reuse = False <EOL> g = g . parent ( ) <EOL> n += <NUM_LIT:1> <EOL> self . __connections = updatedConnections <EOL> def __parentChanged ( self , child , oldParent ) : <EOL> self . __setText ( ) <EOL> self . __setupConnections ( reuseUntil = child ) <EOL> def __setText ( self , * unwantedArgs ) : <EOL> graphComponents = [ ] <EOL> n = <NUM_LIT:0> <EOL> g = self . __graphComponent <EOL> while g is not None and n < self . __numComponents : <EOL> graphComponents . append ( g ) <EOL> g = g . parent ( ) <EOL> n += <NUM_LIT:1> <EOL> graphComponents . reverse ( ) <EOL> GafferUI . Label . setText ( self , self . __formatter ( graphComponents ) ) <EOL> def __buttonPress ( self , widget , event ) : <EOL> return self . getGraphComponent ( ) is not None and event . buttons & ( event . Buttons . Left | event . Buttons . Middle ) <EOL> def __dragBegin ( self , widget , event ) : <EOL> if event . buttons & ( event . Buttons . Left | event . Buttons . Middle ) : <EOL> GafferUI . Pointer . setCurrent ( "<STR_LIT>" ) <EOL> return self . getGraphComponent ( ) <EOL> return None <EOL> def __dragEnd ( self , widget , event ) : <EOL> GafferUI . Pointer . setCurrent ( None ) </s>
<s> import functools <EOL> import IECore <EOL> import Gaffer <EOL> import GafferUI <EOL> class PresetsPlugValueWidget ( GafferUI . PlugValueWidget ) : <EOL> def __init__ ( self , plug , parenting = None ) : <EOL> self . __menuButton = GafferUI . MenuButton ( "<STR_LIT>" , menu = GafferUI . Menu ( Gaffer . WeakMethod ( self . __menuDefinition ) ) ) <EOL> GafferUI . PlugValueWidget . __init__ ( self , self . __menuButton , plug , parenting = parenting ) <EOL> self . __plugMetadataChangedConnection = Gaffer . Metadata . plugValueChangedSignal ( ) . connect ( Gaffer . WeakMethod ( self . __plugMetadataChanged ) ) <EOL> self . _addPopupMenu ( self . __menuButton ) <EOL> self . _updateFromPlug ( ) <EOL> def _updateFromPlug ( self ) : <EOL> self . __menuButton . setEnabled ( self . _editable ( ) ) <EOL> text = "<STR_LIT>" <EOL> if self . getPlug ( ) is not None : <EOL> with self . getContext ( ) : <EOL> text = Gaffer . NodeAlgo . currentPreset ( self . getPlug ( ) ) or "<STR_LIT>" <EOL> self . __menuButton . setText ( text ) <EOL> def __menuDefinition ( self ) : <EOL> result = IECore . MenuDefinition ( ) <EOL> if self . getPlug ( ) is None : <EOL> return result <EOL> currentPreset = Gaffer . NodeAlgo . currentPreset ( self . getPlug ( ) ) <EOL> for n in Gaffer . NodeAlgo . presets ( self . getPlug ( ) ) : <EOL> result . append ( <EOL> "<STR_LIT:/>" + n , <EOL> { <EOL> "<STR_LIT>" : functools . partial ( Gaffer . WeakMethod ( self . __applyPreset ) , preset = n ) , <EOL> "<STR_LIT>" : n == currentPreset , <EOL> } <EOL> ) <EOL> return result <EOL> def __applyPreset ( self , unused , preset ) : <EOL> with Gaffer . UndoContext ( self . getPlug ( ) . ancestor ( Gaffer . ScriptNode ) ) : <EOL> Gaffer . NodeAlgo . applyPreset ( self . getPlug ( ) , preset ) <EOL> def __plugMetadataChanged ( self , nodeTypeId , plugPath , key , plug ) : <EOL> if self . getPlug ( ) is None : <EOL> return <EOL> if plug is not None and not plug . isSame ( self . getPlug ( ) ) : <EOL> return <EOL> if not self . getPlug ( ) . node ( ) . isInstanceOf ( nodeTypeId ) : <EOL> return <EOL> if key . startswith ( "<STR_LIT>" ) : <EOL> self . _updateFromPlug ( ) </s>
<s> import weakref <EOL> import functools <EOL> import types <EOL> import re <EOL> import collections <EOL> import IECore <EOL> import Gaffer <EOL> import GafferUI <EOL> class UIEditor ( GafferUI . NodeSetEditor ) : <EOL> def __init__ ( self , scriptNode , parenting = None ) : <EOL> self . __frame = GafferUI . Frame ( borderWidth = <NUM_LIT:4> , borderStyle = GafferUI . Frame . BorderStyle . None ) <EOL> GafferUI . NodeSetEditor . __init__ ( self , self . __frame , scriptNode , parenting = parenting ) <EOL> self . __nodeMetadataWidgets = [ ] <EOL> self . __plugMetadataWidgets = [ ] <EOL> with self . __frame : <EOL> self . __tabbedContainer = GafferUI . TabbedContainer ( ) <EOL> with self . __tabbedContainer : <EOL> with GafferUI . ListContainer ( spacing = <NUM_LIT:4> , borderWidth = <NUM_LIT:8> , parenting = { "<STR_LIT:label>" : "<STR_LIT>" } ) as self . __nodeTab : <EOL> with _Row ( ) : <EOL> _Label ( "<STR_LIT:Name>" ) <EOL> self . __nodeNameWidget = GafferUI . NameWidget ( None ) <EOL> with _Row ( ) : <EOL> _Label ( "<STR_LIT>" , parenting = { "<STR_LIT>" : GafferUI . ListContainer . VerticalAlignment . Top } ) <EOL> self . __nodeMetadataWidgets . append ( <EOL> _MultiLineStringMetadataWidget ( key = "<STR_LIT:description>" ) <EOL> ) <EOL> with _Row ( ) : <EOL> _Label ( "<STR_LIT>" ) <EOL> self . __nodeMetadataWidgets . append ( <EOL> _ColorSwatchMetadataWidget ( key = "<STR_LIT>" ) <EOL> ) <EOL> with GafferUI . SplitContainer ( orientation = GafferUI . SplitContainer . Orientation . Horizontal , borderWidth = <NUM_LIT:8> , parenting = { "<STR_LIT:label>" : "<STR_LIT>" } ) as self . __plugTab : <EOL> self . __plugListing = _PlugListing ( ) <EOL> self . __plugListingSelectionChangedConnection = self . __plugListing . selectionChangedSignal ( ) . connect ( Gaffer . WeakMethod ( self . __plugListingSelectionChanged ) ) <EOL> with GafferUI . TabbedContainer ( ) as self . __plugAndSectionEditorsContainer : <EOL> self . __plugEditor = _PlugEditor ( ) <EOL> self . __sectionEditor = _SectionEditor ( ) <EOL> self . __sectionEditorNameChangedConnection = self . __sectionEditor . nameChangedSignal ( ) . connect ( Gaffer . WeakMethod ( self . __sectionEditorNameChanged ) ) <EOL> self . __plugAndSectionEditorsContainer . setTabsVisible ( False ) <EOL> self . __plugTab . setSizes ( [ <NUM_LIT> , <NUM_LIT> ] ) <EOL> self . __node = None <EOL> self . __selectedPlug = None <EOL> self . __updateFromSetInternal ( lazy = False ) <EOL> def setSelection ( self , selection ) : <EOL> self . __plugListing . setSelection ( selection ) <EOL> def getSelection ( self ) : <EOL> return self . __plugListing . getSelection ( ) <EOL> def nodeEditor ( self ) : <EOL> return self . __nodeTab <EOL> def plugEditor ( self ) : <EOL> return self . __plugTab <EOL> @ classmethod <EOL> def appendNodeContextMenuDefinitions ( cls , nodeGraph , node , menuDefinition ) : <EOL> menuDefinition . append ( "<STR_LIT>" , { "<STR_LIT>" : True } ) <EOL> menuDefinition . append ( "<STR_LIT>" , { "<STR_LIT>" : functools . partial ( cls . __setColor , node = node ) } ) <EOL> @ classmethod <EOL> def appendNodeEditorToolMenuDefinitions ( cls , nodeEditor , node , menuDefinition ) : <EOL> menuDefinition . append ( <EOL> "<STR_LIT>" , <EOL> { <EOL> "<STR_LIT>" : functools . partial ( GafferUI . UIEditor . acquire , node ) , <EOL> "<STR_LIT>" : isinstance ( node , Gaffer . Box ) or nodeEditor . nodeUI ( ) . plugValueWidget ( node [ "<STR_LIT:user>" ] ) is not None <EOL> } <EOL> ) <EOL> def _updateFromSet ( self ) : <EOL> GafferUI . NodeSetEditor . _updateFromSet ( self ) <EOL> self . __updateFromSetInternal ( ) <EOL> def __updateFromSetInternal ( self , lazy = True ) : <EOL> node = self . _lastAddedNode ( ) <EOL> if lazy and node == self . __node : <EOL> return <EOL> self . __node = node <EOL> self . __nodeNameWidget . setGraphComponent ( self . __node ) <EOL> self . __nodeTab . setEnabled ( self . __node is not None ) <EOL> if self . __node is None : <EOL> self . __plugListing . setPlugParent ( None ) <EOL> self . __sectionEditor . setPlugParent ( None ) <EOL> else : <EOL> plugParent = self . __node [ "<STR_LIT:user>" ] <EOL> if isinstance ( self . __node , Gaffer . Box ) : <EOL> plugParent = self . __node <EOL> self . __plugListing . setPlugParent ( plugParent ) <EOL> self . __sectionEditor . setPlugParent ( plugParent ) <EOL> for widget in self . __nodeMetadataWidgets : <EOL> widget . setTarget ( self . __node ) <EOL> self . setSelection ( None ) <EOL> def __plugListingSelectionChanged ( self , listing ) : <EOL> selection = listing . getSelection ( ) <EOL> if selection is None or isinstance ( selection , Gaffer . Plug ) : <EOL> self . __plugEditor . setPlug ( selection ) <EOL> self . __plugAndSectionEditorsContainer . setCurrent ( self . __plugEditor ) <EOL> elif isinstance ( selection , basestring ) : <EOL> self . __plugEditor . setPlug ( None ) <EOL> self . __sectionEditor . setSection ( selection ) <EOL> self . __plugAndSectionEditorsContainer . setCurrent ( self . __sectionEditor ) <EOL> def __sectionEditorNameChanged ( self , sectionEditor , oldName , newName ) : <EOL> self . __plugListing . setSelection ( newName ) <EOL> def __repr__ ( self ) : <EOL> return "<STR_LIT>" <EOL> @ classmethod <EOL> def __setColor ( cls , menu , node ) : <EOL> color = Gaffer . Metadata . nodeValue ( node , "<STR_LIT>" ) or IECore . Color3f ( <NUM_LIT:1> ) <EOL> dialogue = GafferUI . ColorChooserDialogue ( color = color , useDisplayTransform = False ) <EOL> color = dialogue . waitForColor ( parentWindow = menu . ancestor ( GafferUI . Window ) ) <EOL> if color is not None : <EOL> with Gaffer . UndoContext ( node . ancestor ( Gaffer . ScriptNode ) ) : <EOL> Gaffer . Metadata . registerNodeValue ( node , "<STR_LIT>" , color ) <EOL> GafferUI . EditorWidget . registerType ( "<STR_LIT>" , UIEditor ) <EOL> def __editPlugUI ( node , plug ) : <EOL> editor = GafferUI . UIEditor . acquire ( node ) <EOL> editor . setSelection ( plug ) <EOL> editor . plugEditor ( ) . reveal ( ) <EOL> def __plugPopupMenu ( menuDefinition , plugValueWidget ) : <EOL> plug = plugValueWidget . getPlug ( ) <EOL> node = plug . node ( ) <EOL> if node is None : <EOL> return <EOL> if isinstance ( node , Gaffer . Box ) : <EOL> if not plug . parent ( ) . isSame ( node ) : <EOL> return <EOL> else : <EOL> if not plug . parent ( ) . isSame ( node [ "<STR_LIT:user>" ] ) : <EOL> return <EOL> menuDefinition . append ( "<STR_LIT>" , { "<STR_LIT>" : True } ) <EOL> menuDefinition . append ( "<STR_LIT>" , { "<STR_LIT>" : IECore . curry ( __editPlugUI , node , plug ) , "<STR_LIT>" : not plugValueWidget . getReadOnly ( ) } ) <EOL> __plugPopupMenuConnection = GafferUI . PlugValueWidget . popupMenuSignal ( ) . connect ( __plugPopupMenu ) <EOL> class _Label ( GafferUI . Label ) : <EOL> def __init__ ( self , * args , ** kw ) : <EOL> GafferUI . Label . __init__ ( <EOL> self , <EOL> horizontalAlignment = GafferUI . Label . HorizontalAlignment . Right , <EOL> * args , ** kw <EOL> ) <EOL> self . _qtWidget ( ) . setFixedWidth ( <NUM_LIT> ) <EOL> class _Row ( GafferUI . ListContainer ) : <EOL> def __init__ ( self , * args , ** kw ) : <EOL> GafferUI . ListContainer . __init__ ( self , GafferUI . ListContainer . Orientation . Horizontal , spacing = <NUM_LIT:4> , * args , ** kw ) <EOL> class _MetadataWidget ( GafferUI . Widget ) : <EOL> def __init__ ( self , topLevelWidget , key , target = None , parenting = None ) : <EOL> GafferUI . Widget . __init__ ( self , topLevelWidget , parenting = parenting ) <EOL> self . __key = key <EOL> self . __target = None <EOL> self . setTarget ( target ) <EOL> def setTarget ( self , target ) : <EOL> assert ( isinstance ( target , ( Gaffer . Node , Gaffer . Plug , type ( None ) ) ) ) <EOL> self . __target = target <EOL> self . setEnabled ( self . __target is not None ) <EOL> if isinstance ( self . __target , Gaffer . Node ) : <EOL> self . __metadataChangedConnection = Gaffer . Metadata . nodeValueChangedSignal ( ) . connect ( <EOL> Gaffer . WeakMethod ( self . __nodeMetadataChanged ) <EOL> ) <EOL> elif isinstance ( self . __target , Gaffer . Plug ) : <EOL> self . __metadataChangedConnection = Gaffer . Metadata . plugValueChangedSignal ( ) . connect ( <EOL> Gaffer . WeakMethod ( self . __plugMetadataChanged ) <EOL> ) <EOL> else : <EOL> self . __metadataChangedConnection = None <EOL> self . __update ( ) <EOL> def getTarget ( self ) : <EOL> return self . __target <EOL> def setKey ( self , key ) : <EOL> if key == self . __key : <EOL> return <EOL> self . __key = key <EOL> self . __update ( ) <EOL> def getKey ( self , key ) : <EOL> return self . __key <EOL> def _updateFromValue ( self , value ) : <EOL> raise NotImplementedError <EOL> def _updateFromWidget ( self , value ) : <EOL> if self . __target is None : <EOL> return <EOL> with Gaffer . UndoContext ( self . __target . ancestor ( Gaffer . ScriptNode ) ) : <EOL> _registerMetadata ( self . __target , self . __key , value ) <EOL> def _deregisterValue ( self ) : <EOL> if self . __target is None : <EOL> return <EOL> with Gaffer . UndoContext ( self . __target . ancestor ( Gaffer . ScriptNode ) ) : <EOL> _deregisterMetadata ( self . __target , self . __key ) <EOL> def __update ( self ) : <EOL> if isinstance ( self . __target , Gaffer . Node ) : <EOL> self . _updateFromValue ( Gaffer . Metadata . nodeValue ( self . __target , self . __key ) ) <EOL> elif isinstance ( self . __target , Gaffer . Plug ) : <EOL> self . _updateFromValue ( Gaffer . Metadata . plugValue ( self . __target , self . __key ) ) <EOL> else : <EOL> self . _updateFromValue ( None ) <EOL> def __nodeMetadataChanged ( self , nodeTypeId , key , node ) : <EOL> if self . __key != key : <EOL> return <EOL> if node is not None and not node . isSame ( self . __target ) : <EOL> return <EOL> if not self . __target . isInstanceOf ( nodeTypeId ) : <EOL> return <EOL> self . __update ( ) <EOL> def __plugMetadataChanged ( self , nodeTypeId , plugPath , key , plug ) : <EOL> if self . __key != key : <EOL> return <EOL> if plug is not None and not plug . isSame ( self . __target ) : <EOL> return <EOL> if not self . __target . node ( ) . isInstanceOf ( nodeTypeId ) : <EOL> return <EOL> if not Gaffer . match ( self . __target . relativeName ( self . __target . node ( ) ) , plugPath ) : <EOL> return <EOL> self . __update ( ) <EOL> class _BoolMetadataWidget ( _MetadataWidget ) : <EOL> def __init__ ( self , key , target = None , parenting = None ) : <EOL> self . __boolWidget = GafferUI . BoolWidget ( ) <EOL> _MetadataWidget . __init__ ( self , self . __boolWidget , key , target , parenting = parenting ) <EOL> self . __stateChangedConnection = self . __boolWidget . stateChangedSignal ( ) . connect ( <EOL> Gaffer . WeakMethod ( self . __stateChanged ) <EOL> ) <EOL> def _updateFromValue ( self , value ) : <EOL> self . __boolWidget . setState ( value if value is not None else False ) <EOL> def __stateChanged ( self , * unused ) : <EOL> self . _updateFromWidget ( self . __boolWidget . getState ( ) ) <EOL> class _StringMetadataWidget ( _MetadataWidget ) : <EOL> def __init__ ( self , key , target = None , acceptEmptyString = True , parenting = None ) : <EOL> self . __textWidget = GafferUI . TextWidget ( ) <EOL> _MetadataWidget . __init__ ( self , self . __textWidget , key , target , parenting = None ) <EOL> self . __acceptEmptyString = acceptEmptyString <EOL> self . __editingFinishedConnection = self . __textWidget . editingFinishedSignal ( ) . connect ( <EOL> Gaffer . WeakMethod ( self . __editingFinished ) <EOL> ) <EOL> def textWidget ( self ) : <EOL> return self . __textWidget <EOL> def _updateFromValue ( self , value ) : <EOL> self . __textWidget . setText ( value if value is not None else "<STR_LIT>" ) <EOL> def __editingFinished ( self , * unused ) : <EOL> text = self . __textWidget . getText ( ) <EOL> if text or self . __acceptEmptyString : <EOL> self . _updateFromWidget ( text ) <EOL> else : <EOL> self . _deregisterValue ( ) <EOL> class _MultiLineStringMetadataWidget ( _MetadataWidget ) : <EOL> def __init__ ( self , key , target = None , parenting = None ) : <EOL> self . __textWidget = GafferUI . MultiLineTextWidget ( ) <EOL> _MetadataWidget . __init__ ( self , self . __textWidget , key , target , parenting = None ) <EOL> self . __editingFinishedConnection = self . __textWidget . editingFinishedSignal ( ) . connect ( <EOL> Gaffer . WeakMethod ( self . __editingFinished ) <EOL> ) <EOL> def textWidget ( self ) : <EOL> return self . __textWidget <EOL> def _updateFromValue ( self , value ) : <EOL> self . __textWidget . setText ( value if value is not None else "<STR_LIT>" ) <EOL> def __editingFinished ( self , * unused ) : <EOL> self . _updateFromWidget ( self . __textWidget . getText ( ) ) <EOL> class _ColorSwatchMetadataWidget ( _MetadataWidget ) : <EOL> def __init__ ( self , key , target = None , parenting = None ) : <EOL> self . __swatch = GafferUI . ColorSwatch ( useDisplayTransform = False ) <EOL> _MetadataWidget . __init__ ( self , self . __swatch , key , target , parenting = parenting ) <EOL> self . __swatch . _qtWidget ( ) . setFixedHeight ( <NUM_LIT> ) <EOL> self . __swatch . _qtWidget ( ) . setMaximumWidth ( <NUM_LIT> ) <EOL> self . __value = None <EOL> self . __buttonReleaseConnection = self . __swatch . buttonReleaseSignal ( ) . connect ( Gaffer . WeakMethod ( self . __buttonRelease ) ) <EOL> def _updateFromValue ( self , value ) : <EOL> if value is not None : <EOL> self . __swatch . setColor ( value ) <EOL> else : <EOL> self . __swatch . setColor ( IECore . Color4f ( <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> ) ) <EOL> self . __value = value <EOL> def __buttonRelease ( self , swatch , event ) : <EOL> if event . button != event . Buttons . Left : <EOL> return False <EOL> color = self . __value if self . __value is not None else IECore . Color3f ( <NUM_LIT:1> ) <EOL> dialogue = GafferUI . ColorChooserDialogue ( color = color , useDisplayTransform = False ) <EOL> color = dialogue . waitForColor ( parentWindow = self . ancestor ( GafferUI . Window ) ) <EOL> if color is not None : <EOL> self . _updateFromWidget ( color ) <EOL> class _MenuMetadataWidget ( _MetadataWidget ) : <EOL> def __init__ ( self , key , labelsAndValues , target = None , parenting = None ) : <EOL> self . __menuButton = GafferUI . MenuButton ( <EOL> menu = GafferUI . Menu ( Gaffer . WeakMethod ( self . __menuDefinition ) ) <EOL> ) <EOL> self . __labelsAndValues = labelsAndValues <EOL> self . __currentValue = None <EOL> _MetadataWidget . __init__ ( self , self . __menuButton , key , target , parenting = parenting ) <EOL> def _updateFromValue ( self , value ) : <EOL> self . __currentValue = value <EOL> buttonText = str ( value ) <EOL> for label , value in self . __labelsAndValues : <EOL> if value == self . __currentValue : <EOL> buttonText = label <EOL> break <EOL> self . __menuButton . setText ( buttonText ) <EOL> def __menuDefinition ( self ) : <EOL> result = IECore . MenuDefinition ( ) <EOL> for label , value in self . __labelsAndValues : <EOL> result . append ( <EOL> "<STR_LIT:/>" + label , <EOL> { <EOL> "<STR_LIT>" : functools . partial ( Gaffer . WeakMethod ( self . __setValue ) , value = value ) , <EOL> "<STR_LIT>" : value == self . __currentValue <EOL> } <EOL> ) <EOL> return result <EOL> def __setValue ( self , unused , value ) : <EOL> self . _updateFromWidget ( value ) <EOL> class _LayoutItem ( object ) : <EOL> def __init__ ( self ) : <EOL> self . __parent = None <EOL> self . __children = [ ] <EOL> def parent ( self ) : <EOL> if self . __parent is None : <EOL> return None <EOL> else : <EOL> return self . __parent ( ) <EOL> def child ( self , name ) : <EOL> for c in self . __children : <EOL> if c . name ( ) == name : <EOL> return c <EOL> return None <EOL> def isAncestorOf ( self , item ) : <EOL> while item is not None : <EOL> parent = item . parent ( ) <EOL> if parent is self : <EOL> return True <EOL> item = parent <EOL> return False <EOL> def append ( self , child ) : <EOL> self . insert ( len ( self ) , child ) <EOL> def insert ( self , index , child ) : <EOL> assert ( child . parent ( ) is None ) <EOL> self . __children . insert ( index , child ) <EOL> child . __parent = weakref . ref ( self ) <EOL> def remove ( self , child ) : <EOL> assert ( child . parent ( ) is self ) <EOL> self . __children . remove ( child ) <EOL> child . __parent = None <EOL> def index ( self , child ) : <EOL> return self . __children . index ( child ) <EOL> def name ( self ) : <EOL> raise NotImplementedError <EOL> def fullName ( self ) : <EOL> result = "<STR_LIT>" <EOL> item = self <EOL> while item . parent ( ) is not None : <EOL> if result : <EOL> result = item . name ( ) + "<STR_LIT:.>" + result <EOL> else : <EOL> result = item . name ( ) <EOL> item = item . parent ( ) <EOL> return result <EOL> def __len__ ( self ) : <EOL> return len ( self . __children ) <EOL> def __getitem__ ( self , index ) : <EOL> return self . __children [ index ] <EOL> class _SectionLayoutItem ( _LayoutItem ) : <EOL> def __init__ ( self , sectionName ) : <EOL> _LayoutItem . __init__ ( self ) <EOL> self . __sectionName = sectionName <EOL> def name ( self ) : <EOL> return self . __sectionName <EOL> class _PlugLayoutItem ( _LayoutItem ) : <EOL> def __init__ ( self , plug ) : <EOL> _LayoutItem . __init__ ( self ) <EOL> self . plug = plug <EOL> self . __name = plug . getName ( ) <EOL> def name ( self ) : <EOL> return self . __name <EOL> class _PlugListing ( GafferUI . Widget ) : <EOL> class __LayoutPath ( Gaffer . Path ) : <EOL> def __init__ ( self , rootItem , path , root = "<STR_LIT:/>" , filter = None ) : <EOL> Gaffer . Path . __init__ ( self , path , root , filter ) <EOL> self . __rootItem = rootItem <EOL> def rootItem ( self ) : <EOL> return self . __rootItem <EOL> def item ( self ) : <EOL> result = self . __rootItem <EOL> for name in self : <EOL> result = result . child ( name ) <EOL> if result is None : <EOL> return None <EOL> return result <EOL> def copy ( self ) : <EOL> return self . __class__ ( self . __rootItem , self [ : ] , self . root ( ) , self . getFilter ( ) ) <EOL> def isLeaf ( self ) : <EOL> return not isinstance ( self . item ( ) , _SectionLayoutItem ) <EOL> def isValid ( self ) : <EOL> return self . item ( ) is not None <EOL> def _children ( self ) : <EOL> item = self . item ( ) <EOL> if item is None : <EOL> return [ ] <EOL> result = [ <EOL> self . __class__ ( self . __rootItem , self [ : ] + [ c . name ( ) ] , self . root ( ) , self . getFilter ( ) ) <EOL> for c in item <EOL> ] <EOL> if len ( result ) == <NUM_LIT:0> and isinstance ( item , _SectionLayoutItem ) : <EOL> result . append ( self . __class__ ( self . __rootItem , self [ : ] + [ "<STR_LIT:U+0020>" ] , self . root ( ) , self . getFilter ( ) ) ) <EOL> return result <EOL> def __init__ ( self , parenting = None ) : <EOL> column = GafferUI . ListContainer ( spacing = <NUM_LIT:4> ) <EOL> GafferUI . Widget . __init__ ( self , column , parenting = parenting ) <EOL> with column : <EOL> self . __pathListing = GafferUI . PathListingWidget ( <EOL> self . __LayoutPath ( _SectionLayoutItem ( "<STR_LIT>" ) , "<STR_LIT:/>" ) , <EOL> columns = ( GafferUI . PathListingWidget . defaultNameColumn , ) , <EOL> displayMode = GafferUI . PathListingWidget . DisplayMode . Tree , <EOL> ) <EOL> self . __pathListing . setDragPointer ( "<STR_LIT>" ) <EOL> self . __pathListing . setSortable ( False ) <EOL> self . __pathListing . setHeaderVisible ( False ) <EOL> with GafferUI . ListContainer ( GafferUI . ListContainer . Orientation . Horizontal , spacing = <NUM_LIT:4> ) : <EOL> GafferUI . MenuButton ( <EOL> image = "<STR_LIT>" , <EOL> hasFrame = False , <EOL> menu = GafferUI . Menu ( <EOL> definition = Gaffer . WeakMethod ( self . __addMenuDefinition ) <EOL> ) <EOL> ) <EOL> self . __deleteButton = GafferUI . Button ( image = "<STR_LIT>" , hasFrame = False ) <EOL> self . __deleteButtonClickedConnection = self . __deleteButton . clickedSignal ( ) . connect ( Gaffer . WeakMethod ( self . __deleteButtonClicked ) ) <EOL> self . __parent = None <EOL> self . __dragItem = None <EOL> self . __selectionChangedSignal = Gaffer . Signal1 ( ) <EOL> self . __dragEnterConnection = self . __pathListing . dragEnterSignal ( ) . connect ( Gaffer . WeakMethod ( self . __dragEnter ) ) <EOL> self . __dragMoveConnection = self . __pathListing . dragMoveSignal ( ) . connect ( Gaffer . WeakMethod ( self . __dragMove ) ) <EOL> self . __dragEndConnection = self . __pathListing . dragEndSignal ( ) . connect ( Gaffer . WeakMethod ( self . __dragEnd ) ) <EOL> self . __selectionChangedConnection = self . __pathListing . selectionChangedSignal ( ) . connect ( Gaffer . WeakMethod ( self . __selectionChanged ) ) <EOL> self . __keyPressConnection = self . keyPressSignal ( ) . connect ( Gaffer . WeakMethod ( self . __keyPress ) ) <EOL> self . __nodeMetadataChangedConnection = Gaffer . Metadata . nodeValueChangedSignal ( ) . connect ( Gaffer . WeakMethod ( self . __nodeMetadataChanged ) ) <EOL> self . __plugMetadataChangedConnection = Gaffer . Metadata . plugValueChangedSignal ( ) . connect ( Gaffer . WeakMethod ( self . __plugMetadataChanged ) ) <EOL> def setPlugParent ( self , parent ) : <EOL> assert ( isinstance ( parent , ( Gaffer . Plug , Gaffer . Node , types . NoneType ) ) ) <EOL> self . __parent = parent <EOL> self . __childAddedConnection = None <EOL> self . __childRemovedConnection = None <EOL> self . __childNameChangedConnections = { } <EOL> if self . __parent is not None : <EOL> self . __childAddedConnection = self . __parent . childAddedSignal ( ) . connect ( Gaffer . WeakMethod ( self . __childAddedOrRemoved ) ) <EOL> self . __childRemovedConnection = self . __parent . childRemovedSignal ( ) . connect ( Gaffer . WeakMethod ( self . __childAddedOrRemoved ) ) <EOL> for child in self . __parent . children ( ) : <EOL> self . __updateChildNameChangedConnection ( child ) <EOL> self . __updatePath ( ) <EOL> def getPlugParent ( self ) : <EOL> return self . __parent <EOL> def setSelection ( self , selection ) : <EOL> self . __updatePathLazily . flush ( self ) <EOL> def findPlugPath ( path , plug ) : <EOL> item = path . item ( ) <EOL> if isinstance ( item , _PlugLayoutItem ) and item . plug . isSame ( plug ) : <EOL> return path <EOL> else : <EOL> for child in path . children ( ) : <EOL> r = findPlugPath ( child , plug ) <EOL> if r is not None : <EOL> return r <EOL> return None <EOL> if isinstance ( selection , Gaffer . Plug ) : <EOL> path = findPlugPath ( self . __pathListing . getPath ( ) , selection ) <EOL> if path is None : <EOL> self . __pathListing . setSelectedPaths ( [ ] ) <EOL> else : <EOL> self . __pathListing . setSelectedPaths ( [ path ] ) <EOL> elif isinstance ( selection , basestring ) : <EOL> path = self . __pathListing . getPath ( ) . copy ( ) <EOL> path [ : ] = selection . split ( "<STR_LIT:.>" ) <EOL> self . __pathListing . setSelectedPaths ( [ path ] ) <EOL> else : <EOL> assert ( selection is None ) <EOL> self . __pathListing . setSelectedPaths ( [ ] ) <EOL> def getSelection ( self ) : <EOL> item = self . __selectedItem ( ) <EOL> if item is None : <EOL> return None <EOL> elif isinstance ( item , _PlugLayoutItem ) : <EOL> return item . plug <EOL> elif isinstance ( item , _SectionLayoutItem ) : <EOL> return item . fullName ( ) <EOL> else : <EOL> return None <EOL> def selectionChangedSignal ( self ) : <EOL> return self . __selectionChangedSignal <EOL> def __updatePath ( self ) : <EOL> if self . __parent is None : <EOL> self . __pathListing . setPath ( self . __LayoutPath ( _SectionLayoutItem ( "<STR_LIT>" ) , "<STR_LIT:/>" ) ) <EOL> return <EOL> def section ( rootLayoutItem , sectionPath ) : <EOL> sectionItem = rootLayoutItem <EOL> if sectionPath != "<STR_LIT>" : <EOL> for sectionName in sectionPath . split ( "<STR_LIT:.>" ) : <EOL> childSectionItem = sectionItem . child ( sectionName ) <EOL> if childSectionItem is None : <EOL> childSectionItem = _SectionLayoutItem ( sectionName ) <EOL> sectionItem . append ( childSectionItem ) <EOL> sectionItem = childSectionItem <EOL> return sectionItem <EOL> layout = _SectionLayoutItem ( "<STR_LIT>" ) <EOL> for sectionPath in GafferUI . PlugLayout . layoutSections ( self . __parent ) : <EOL> if sectionPath == "<STR_LIT>" and isinstance ( self . __parent , Gaffer . Node ) : <EOL> continue <EOL> sectionItem = section ( layout , sectionPath ) <EOL> for plug in GafferUI . PlugLayout . layoutOrder ( self . __parent , section = sectionPath ) : <EOL> sectionItem . append ( _PlugLayoutItem ( plug ) ) <EOL> emptySections = _metadata ( self . getPlugParent ( ) , "<STR_LIT>" ) <EOL> emptySectionIndices = _metadata ( self . getPlugParent ( ) , "<STR_LIT>" ) <EOL> if emptySections and emptySectionIndices : <EOL> for sectionPath , sectionIndex in zip ( emptySections , emptySectionIndices ) : <EOL> parentPath , unused , sectionName = sectionPath . rpartition ( "<STR_LIT:.>" ) <EOL> parentSection = section ( layout , parentPath ) <EOL> if parentSection . child ( sectionName ) is None : <EOL> parentSection . insert ( sectionIndex , _SectionLayoutItem ( sectionName ) ) <EOL> if len ( layout ) == <NUM_LIT:0> and isinstance ( self . __parent , Gaffer . Node ) : <EOL> layout . append ( _SectionLayoutItem ( "<STR_LIT>" ) ) <EOL> expandedPaths = self . __pathListing . getExpandedPaths ( ) <EOL> self . __pathListing . setPath ( self . __LayoutPath ( layout , "<STR_LIT:/>" ) ) <EOL> self . __pathListing . setExpandedPaths ( expandedPaths ) <EOL> @ GafferUI . LazyMethod ( ) <EOL> def __updatePathLazily ( self ) : <EOL> self . __updatePath ( ) <EOL> def __updateMetadata ( self ) : <EOL> emptySections = IECore . StringVectorData ( ) <EOL> emptySectionIndices = IECore . IntVectorData ( ) <EOL> def walk ( layoutItem , path = "<STR_LIT>" , index = <NUM_LIT:0> ) : <EOL> for childItem in layoutItem : <EOL> if isinstance ( childItem , _PlugLayoutItem ) : <EOL> Gaffer . Metadata . registerPlugValue ( childItem . plug , "<STR_LIT>" , path ) <EOL> Gaffer . Metadata . registerPlugValue ( childItem . plug , "<STR_LIT>" , index ) <EOL> index += <NUM_LIT:1> <EOL> elif isinstance ( childItem , _SectionLayoutItem ) : <EOL> childPath = path + "<STR_LIT:.>" + childItem . name ( ) if path else childItem . name ( ) <EOL> if len ( childItem ) : <EOL> index = walk ( childItem , childPath , index ) <EOL> else : <EOL> emptySections . append ( childPath ) <EOL> emptySectionIndices . append ( layoutItem . index ( childItem ) ) <EOL> return index <EOL> with Gaffer . BlockedConnection ( self . __plugMetadataChangedConnection ) : <EOL> walk ( self . __pathListing . getPath ( ) . copy ( ) . setFromString ( "<STR_LIT:/>" ) . item ( ) ) <EOL> _registerMetadata ( self . getPlugParent ( ) , "<STR_LIT>" , emptySections ) <EOL> _registerMetadata ( self . getPlugParent ( ) , "<STR_LIT>" , emptySectionIndices ) <EOL> def __childAddedOrRemoved ( self , parent , child ) : <EOL> assert ( parent . isSame ( self . __parent ) ) <EOL> self . __updateChildNameChangedConnection ( child ) <EOL> self . __updatePathLazily ( ) <EOL> def __childNameChanged ( self , child ) : <EOL> selection = self . getSelection ( ) <EOL> self . __updatePath ( ) <EOL> if isinstance ( selection , Gaffer . Plug ) and child . isSame ( selection ) : <EOL> self . setSelection ( selection ) <EOL> def __updateChildNameChangedConnection ( self , child ) : <EOL> if self . __parent . isSame ( child . parent ( ) ) : <EOL> if child not in self . __childNameChangedConnections : <EOL> self . __childNameChangedConnections [ child ] = child . nameChangedSignal ( ) . connect ( Gaffer . WeakMethod ( self . __childNameChanged ) ) <EOL> else : <EOL> if child in self . __childNameChangedConnections : <EOL> del self . __childNameChangedConnections [ child ] <EOL> def __dragEnter ( self , listing , event ) : <EOL> if event . sourceWidget is not self . __pathListing : <EOL> return False <EOL> if not isinstance ( event . data , IECore . StringVectorData ) : <EOL> return False <EOL> dragPath = self . __pathListing . getPath ( ) . copy ( ) . setFromString ( event . data [ <NUM_LIT:0> ] ) <EOL> self . __dragItem = dragPath . item ( ) <EOL> self . __pathListing . setPathExpanded ( dragPath , False ) <EOL> return True <EOL> def __dragMove ( self , listing , event ) : <EOL> if self . __dragItem is None : <EOL> return False <EOL> targetPath = self . __pathListing . pathAt ( event . line . p0 ) <EOL> if targetPath is not None : <EOL> targetItem = targetPath . item ( ) <EOL> if targetItem is not None : <EOL> if isinstance ( targetItem , _SectionLayoutItem ) and self . __pathListing . getPathExpanded ( targetPath ) and targetItem . parent ( ) is self . __dragItem . parent ( ) : <EOL> newParent = targetItem <EOL> newIndex = <NUM_LIT:0> <EOL> else : <EOL> newParent = targetItem . parent ( ) <EOL> newIndex = newParent . index ( targetItem ) <EOL> else : <EOL> newParent = targetPath . copy ( ) . truncateUntilValid ( ) . item ( ) <EOL> newIndex = <NUM_LIT:0> <EOL> else : <EOL> newParent = self . __pathListing . getPath ( ) . rootItem ( ) <EOL> newIndex = <NUM_LIT:0> if event . line . p0 . y < <NUM_LIT:1> else len ( newParent ) <EOL> if newParent is self . __dragItem or self . __dragItem . isAncestorOf ( newParent ) : <EOL> return True <EOL> firstNonPlugIndex = next ( <EOL> ( x [ <NUM_LIT:0> ] for x in enumerate ( newParent ) if not isinstance ( x [ <NUM_LIT:1> ] , _PlugLayoutItem ) ) , <EOL> len ( newParent ) <EOL> ) <EOL> if self . __dragItem . parent ( ) is newParent and newParent . index ( self . __dragItem ) < firstNonPlugIndex : <EOL> firstNonPlugIndex -= <NUM_LIT:1> <EOL> if isinstance ( self . __dragItem , _PlugLayoutItem ) : <EOL> if newIndex > firstNonPlugIndex : <EOL> return True <EOL> else : <EOL> if newIndex < firstNonPlugIndex : <EOL> newIndex = max ( newIndex , firstNonPlugIndex ) <EOL> self . __dragItem . parent ( ) . remove ( self . __dragItem ) <EOL> newParent . insert ( newIndex , self . __dragItem ) <EOL> self . __pathListing . getPath ( ) . pathChangedSignal ( ) ( self . __pathListing . getPath ( ) ) <EOL> selection = self . __pathListing . getPath ( ) . copy ( ) <EOL> selection [ : ] = self . __dragItem . fullName ( ) . split ( "<STR_LIT:.>" ) <EOL> self . __pathListing . setSelectedPaths ( [ selection ] , scrollToFirst = False , expandNonLeaf = False ) <EOL> return True <EOL> def __dragEnd ( self , listing , event ) : <EOL> if self . __dragItem is None : <EOL> return False <EOL> with Gaffer . UndoContext ( self . __parent . ancestor ( Gaffer . ScriptNode ) ) : <EOL> self . __updateMetadata ( ) <EOL> self . __dragItem = None <EOL> return True <EOL> def __selectionChanged ( self , pathListing ) : <EOL> self . __deleteButton . setEnabled ( bool ( pathListing . getSelectedPaths ( ) ) ) <EOL> self . __selectionChangedSignal ( self ) <EOL> def __deleteButtonClicked ( self , button ) : <EOL> self . __deleteSelected ( ) <EOL> def __nodeMetadataChanged ( self , nodeTypeId , key , node ) : <EOL> if self . __parent is None : <EOL> return <EOL> if node is not None and not self . __parent . isSame ( node ) : <EOL> return <EOL> if not self . __parent . isInstanceOf ( nodeTypeId ) : <EOL> return <EOL> if key in ( "<STR_LIT>" , "<STR_LIT>" ) : <EOL> self . __updatePathLazily ( ) <EOL> def __plugMetadataChanged ( self , nodeTypeId , plugPath , key , plug ) : <EOL> if self . __parent is None : <EOL> return <EOL> if plug is not None and not self . __parent . isSame ( plug ) and not self . __parent . isSame ( plug . parent ( ) ) : <EOL> return <EOL> node = self . __parent . node ( ) if isinstance ( self . __parent , Gaffer . Plug ) else self . __parent <EOL> if not node . isInstanceOf ( nodeTypeId ) : <EOL> return <EOL> if key in ( "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ) : <EOL> self . __updatePathLazily ( ) <EOL> def __keyPress ( self , widget , event ) : <EOL> assert ( widget is self ) <EOL> if event . key == "<STR_LIT>" or event . key == "<STR_LIT>" : <EOL> self . __deleteSelected ( ) <EOL> return True <EOL> return False <EOL> def __addMenuDefinition ( self ) : <EOL> m = IECore . MenuDefinition ( ) <EOL> m . append ( "<STR_LIT>" , { "<STR_LIT>" : functools . partial ( Gaffer . WeakMethod ( self . __addPlug ) , Gaffer . BoolPlug ) } ) <EOL> m . append ( "<STR_LIT>" , { "<STR_LIT>" : functools . partial ( Gaffer . WeakMethod ( self . __addPlug ) , Gaffer . FloatPlug ) } ) <EOL> m . append ( "<STR_LIT>" , { "<STR_LIT>" : functools . partial ( Gaffer . WeakMethod ( self . __addPlug ) , Gaffer . IntPlug ) } ) <EOL> m . append ( "<STR_LIT>" , { "<STR_LIT>" : True } ) <EOL> m . append ( "<STR_LIT>" , { "<STR_LIT>" : functools . partial ( Gaffer . WeakMethod ( self . __addPlug ) , Gaffer . StringPlug ) } ) <EOL> m . append ( "<STR_LIT>" , { "<STR_LIT>" : True } ) <EOL> m . append ( "<STR_LIT>" , { "<STR_LIT>" : functools . partial ( Gaffer . WeakMethod ( self . __addPlug ) , Gaffer . V2iPlug ) } ) <EOL> m . append ( "<STR_LIT>" , { "<STR_LIT>" : functools . partial ( Gaffer . WeakMethod ( self . __addPlug ) , Gaffer . V3iPlug ) } ) <EOL> m . append ( "<STR_LIT>" , { "<STR_LIT>" : functools . partial ( Gaffer . WeakMethod ( self . __addPlug ) , Gaffer . V2fPlug ) } ) <EOL> m . append ( "<STR_LIT>" , { "<STR_LIT>" : functools . partial ( Gaffer . WeakMethod ( self . __addPlug ) , Gaffer . V3fPlug ) } ) <EOL> m . append ( "<STR_LIT>" , { "<STR_LIT>" : True } ) <EOL> m . append ( "<STR_LIT>" , { "<STR_LIT>" : functools . partial ( Gaffer . WeakMethod ( self . __addPlug ) , Gaffer . Color3fPlug ) } ) <EOL> m . append ( "<STR_LIT>" , { "<STR_LIT>" : functools . partial ( Gaffer . WeakMethod ( self . __addPlug ) , Gaffer . Color4fPlug ) } ) <EOL> m . append ( "<STR_LIT>" , { "<STR_LIT>" : True } ) <EOL> m . append ( "<STR_LIT>" , { "<STR_LIT>" : Gaffer . WeakMethod ( self . __addSection ) } ) <EOL> return m <EOL> def __addPlug ( self , plugType ) : <EOL> plug = plugType ( flags = Gaffer . Plug . Flags . Default | Gaffer . Plug . Flags . Dynamic ) <EOL> _registerMetadata ( plug , "<STR_LIT>" , "<STR_LIT>" ) <EOL> parentItem = self . __selectedItem ( ) <EOL> if parentItem is not None : <EOL> while not isinstance ( parentItem , _SectionLayoutItem ) : <EOL> parentItem = parentItem . parent ( ) <EOL> else : <EOL> parentItem = self . __pathListing . getPath ( ) . rootItem ( ) <EOL> parentItem = next ( <EOL> ( c for c in parentItem if isinstance ( c , _SectionLayoutItem ) ) , <EOL> parentItem <EOL> ) <EOL> _registerMetadata ( plug , "<STR_LIT>" , parentItem . fullName ( ) ) <EOL> with Gaffer . UndoContext ( self . __parent . ancestor ( Gaffer . ScriptNode ) ) : <EOL> self . getPlugParent ( ) . addChild ( plug ) <EOL> self . __updatePathLazily . flush ( self ) <EOL> self . setSelection ( plug ) <EOL> def __addSection ( self ) : <EOL> rootItem = self . __pathListing . getPath ( ) . rootItem ( ) <EOL> existingSectionNames = set ( c . name ( ) for c in rootItem if isinstance ( c , _SectionLayoutItem ) ) <EOL> name = "<STR_LIT>" <EOL> index = <NUM_LIT:1> <EOL> while name in existingSectionNames : <EOL> name = "<STR_LIT>" % index <EOL> index += <NUM_LIT:1> <EOL> rootItem . append ( _SectionLayoutItem ( name ) ) <EOL> self . __pathListing . getPath ( ) . pathChangedSignal ( ) ( self . __pathListing . getPath ( ) ) <EOL> with Gaffer . UndoContext ( self . __parent . ancestor ( Gaffer . ScriptNode ) ) : <EOL> self . __updateMetadata ( ) <EOL> self . __pathListing . setSelectedPaths ( <EOL> self . __pathListing . getPath ( ) . copy ( ) . setFromString ( "<STR_LIT:/>" + name ) <EOL> ) <EOL> def __selectedItem ( self ) : <EOL> selectedPaths = self . __pathListing . getSelectedPaths ( ) <EOL> if not len ( selectedPaths ) : <EOL> return None <EOL> assert ( len ( selectedPaths ) == <NUM_LIT:1> ) <EOL> return selectedPaths [ <NUM_LIT:0> ] . item ( ) <EOL> def __deleteSelected ( self ) : <EOL> selectedItem = self . __selectedItem ( ) <EOL> if selectedItem is None : <EOL> return <EOL> selectedItem . parent ( ) . remove ( selectedItem ) <EOL> def deletePlugsWalk ( item ) : <EOL> if isinstance ( item , _PlugLayoutItem ) : <EOL> item . plug . parent ( ) . removeChild ( item . plug ) <EOL> else : <EOL> for childItem in item : <EOL> deletePlugsWalk ( childItem ) <EOL> with Gaffer . UndoContext ( self . __parent . ancestor ( Gaffer . ScriptNode ) ) : <EOL> deletePlugsWalk ( selectedItem ) <EOL> self . __updateMetadata ( ) <EOL> class _PresetsEditor ( GafferUI . Widget ) : <EOL> def __init__ ( self , parenting = None ) : <EOL> row = GafferUI . ListContainer ( GafferUI . ListContainer . Orientation . Horizontal , spacing = <NUM_LIT:8> ) <EOL> GafferUI . Widget . __init__ ( self , row , parenting = parenting ) <EOL> with row : <EOL> with GafferUI . ListContainer ( spacing = <NUM_LIT:4> ) : <EOL> self . __pathListing = GafferUI . PathListingWidget ( <EOL> Gaffer . DictPath ( collections . OrderedDict ( ) , "<STR_LIT:/>" ) , <EOL> columns = ( GafferUI . PathListingWidget . defaultNameColumn , ) , <EOL> ) <EOL> self . __pathListing . setDragPointer ( "<STR_LIT>" ) <EOL> self . __pathListing . setSortable ( False ) <EOL> self . __pathListing . setHeaderVisible ( False ) <EOL> self . __pathListing . _qtWidget ( ) . setFixedWidth ( <NUM_LIT:200> ) <EOL> self . __pathListing . _qtWidget ( ) . setFixedHeight ( <NUM_LIT:200> ) <EOL> self . __pathListingSelectionChangedConnection = self . __pathListing . selectionChangedSignal ( ) . connect ( Gaffer . WeakMethod ( self . __selectionChanged ) ) <EOL> self . __dragEnterConnection = self . __pathListing . dragEnterSignal ( ) . connect ( Gaffer . WeakMethod ( self . __dragEnter ) ) <EOL> self . __dragMoveConnection = self . __pathListing . dragMoveSignal ( ) . connect ( Gaffer . WeakMethod ( self . __dragMove ) ) <EOL> self . __dragEndConnection = self . __pathListing . dragEndSignal ( ) . connect ( Gaffer . WeakMethod ( self . __dragEnd ) ) <EOL> with GafferUI . ListContainer ( GafferUI . ListContainer . Orientation . Horizontal , spacing = <NUM_LIT:4> ) : <EOL> self . __addButton = GafferUI . Button ( image = "<STR_LIT>" , hasFrame = False ) <EOL> self . __addButtonClickedConnection = self . __addButton . clickedSignal ( ) . connect ( Gaffer . WeakMethod ( self . __addButtonClicked ) ) <EOL> self . __deleteButton = GafferUI . Button ( image = "<STR_LIT>" , hasFrame = False ) <EOL> self . __deleteButtonClickedConnection = self . __deleteButton . clickedSignal ( ) . connect ( Gaffer . WeakMethod ( self . __deleteButtonClicked ) ) <EOL> with GafferUI . ListContainer ( spacing = <NUM_LIT:4> ) as self . __editingColumn : <EOL> GafferUI . Label ( "<STR_LIT:Name>" ) <EOL> self . __nameWidget = GafferUI . TextWidget ( ) <EOL> self . __nameEditingFinishedConnection = self . __nameWidget . editingFinishedSignal ( ) . connect ( Gaffer . WeakMethod ( self . __nameEditingFinished ) ) <EOL> GafferUI . Spacer ( IECore . V2i ( <NUM_LIT:4> ) , maximumSize = IECore . V2i ( <NUM_LIT:4> ) ) <EOL> GafferUI . Label ( "<STR_LIT>" ) <EOL> self . __valueNode = Gaffer . Node ( "<STR_LIT>" ) <EOL> self . __valuePlugSetConnection = self . __valueNode . plugSetSignal ( ) . connect ( Gaffer . WeakMethod ( self . __valuePlugSet ) ) <EOL> def setPlug ( self , plug ) : <EOL> self . __plug = plug <EOL> self . __plugMetadataChangedConnection = None <EOL> del self . __editingColumn [ <NUM_LIT:4> : ] <EOL> plugValueWidget = None <EOL> if self . __plug is not None : <EOL> self . __plugMetadataChangedConnection = Gaffer . Metadata . plugValueChangedSignal ( ) . connect ( Gaffer . WeakMethod ( self . __plugMetadataChanged ) ) <EOL> self . __valueNode [ "<STR_LIT>" ] = plug . createCounterpart ( "<STR_LIT>" , plug . Direction . In ) <EOL> if hasattr ( self . __plug , "<STR_LIT>" ) : <EOL> plugValueWidget = GafferUI . PlugValueWidget . create ( self . __valueNode [ "<STR_LIT>" ] , useTypeOnly = True ) <EOL> self . __editingColumn . append ( plugValueWidget if plugValueWidget is not None else GafferUI . TextWidget ( ) ) <EOL> self . __editingColumn . append ( GafferUI . Spacer ( IECore . V2i ( <NUM_LIT:0> ) , parenting = { "<STR_LIT>" : True } ) ) <EOL> self . __updatePath ( ) <EOL> self . __addButton . setEnabled ( hasattr ( self . __plug , "<STR_LIT>" ) ) <EOL> def getPlug ( self ) : <EOL> return self . __plug <EOL> def __updatePath ( self ) : <EOL> d = self . __pathListing . getPath ( ) . dict ( ) <EOL> d . clear ( ) <EOL> if self . __plug is not None : <EOL> for name in _registeredMetadata ( self . __plug , instanceOnly = True , persistentOnly = True ) : <EOL> if name . startswith ( "<STR_LIT>" ) : <EOL> d [ name [ <NUM_LIT:7> : ] ] = _metadata ( self . __plug , name ) <EOL> self . __pathListing . getPath ( ) . pathChangedSignal ( ) ( self . __pathListing . getPath ( ) ) <EOL> def __plugMetadataChanged ( self , nodeTypeId , plugPath , key , plug ) : <EOL> if plug is None or not plug . isSame ( self . __plug ) : <EOL> return <EOL> if key . startswith ( "<STR_LIT>" ) : <EOL> self . __updatePath ( ) <EOL> def __selectionChanged ( self , listing ) : <EOL> selectedPaths = listing . getSelectedPaths ( ) <EOL> self . __nameWidget . setText ( selectedPaths [ <NUM_LIT:0> ] [ <NUM_LIT:0> ] if selectedPaths else "<STR_LIT>" ) <EOL> if selectedPaths : <EOL> with Gaffer . BlockedConnection ( self . __valuePlugSetConnection ) : <EOL> self . __valueNode [ "<STR_LIT>" ] . setValue ( <EOL> Gaffer . Metadata . plugValue ( self . getPlug ( ) , "<STR_LIT>" + selectedPaths [ <NUM_LIT:0> ] [ <NUM_LIT:0> ] ) <EOL> ) <EOL> self . __editingColumn . setEnabled ( bool ( selectedPaths ) ) <EOL> self . __deleteButton . setEnabled ( bool ( selectedPaths ) ) <EOL> def __dragEnter ( self , listing , event ) : <EOL> if event . sourceWidget is not self . __pathListing : <EOL> return False <EOL> if not isinstance ( event . data , IECore . StringVectorData ) : <EOL> return False <EOL> return True <EOL> def __dragMove ( self , listing , event ) : <EOL> d = self . __pathListing . getPath ( ) . dict ( ) <EOL> srcPath = self . __pathListing . getPath ( ) . copy ( ) . setFromString ( event . data [ <NUM_LIT:0> ] ) <EOL> srcIndex = d . keys ( ) . index ( srcPath [ <NUM_LIT:0> ] ) <EOL> targetPath = self . __pathListing . pathAt ( event . line . p0 ) <EOL> if targetPath is not None : <EOL> targetIndex = d . keys ( ) . index ( targetPath [ <NUM_LIT:0> ] ) <EOL> else : <EOL> targetIndex = <NUM_LIT:0> if event . line . p0 . y < <NUM_LIT:1> else len ( d ) <EOL> if srcIndex == targetIndex : <EOL> return True <EOL> items = d . items ( ) <EOL> item = items [ srcIndex ] <EOL> del items [ srcIndex ] <EOL> items . insert ( targetIndex , item ) <EOL> d . clear ( ) <EOL> d . update ( items ) <EOL> self . __pathListing . getPath ( ) . pathChangedSignal ( ) ( self . __pathListing . getPath ( ) ) <EOL> return True <EOL> def __dragEnd ( self , listing , event ) : <EOL> d = self . __pathListing . getPath ( ) . dict ( ) <EOL> with Gaffer . BlockedConnection ( self . __plugMetadataChangedConnection ) : <EOL> with Gaffer . UndoContext ( self . getPlug ( ) . ancestor ( Gaffer . ScriptNode ) ) : <EOL> for item in d . items ( ) : <EOL> Gaffer . Metadata . deregisterPlugValue ( self . getPlug ( ) , "<STR_LIT>" + item [ <NUM_LIT:0> ] ) <EOL> for item in d . items ( ) : <EOL> Gaffer . Metadata . registerPlugValue ( self . getPlug ( ) , "<STR_LIT>" + item [ <NUM_LIT:0> ] , item [ <NUM_LIT:1> ] ) <EOL> self . __updatePath ( ) <EOL> return True <EOL> def __addButtonClicked ( self , button ) : <EOL> existingNames = [ p [ <NUM_LIT:0> ] for p in self . __pathListing . getPath ( ) . children ( ) ] <EOL> name = "<STR_LIT>" <EOL> index = <NUM_LIT:1> <EOL> while name in existingNames : <EOL> name = "<STR_LIT>" % index <EOL> index += <NUM_LIT:1> <EOL> with Gaffer . UndoContext ( self . __plug . ancestor ( Gaffer . ScriptNode ) ) : <EOL> Gaffer . Metadata . registerPlugValue ( self . __plug , "<STR_LIT>" + name , self . __plug . getValue ( ) ) <EOL> self . __pathListing . setSelectedPaths ( <EOL> self . __pathListing . getPath ( ) . copy ( ) . setFromString ( "<STR_LIT:/>" + name ) <EOL> ) <EOL> self . __nameWidget . grabFocus ( ) <EOL> self . __nameWidget . setSelection ( <NUM_LIT:0> , len ( name ) ) <EOL> return True <EOL> def __deleteButtonClicked ( self , button ) : <EOL> paths = self . __pathListing . getPath ( ) . children ( ) <EOL> selectedPreset = self . __pathListing . getSelectedPaths ( ) [ <NUM_LIT:0> ] [ <NUM_LIT:0> ] <EOL> selectedIndex = [ p [ <NUM_LIT:0> ] for p in paths ] . index ( selectedPreset ) <EOL> with Gaffer . UndoContext ( self . __plug . ancestor ( Gaffer . ScriptNode ) ) : <EOL> Gaffer . Metadata . deregisterPlugValue ( self . __plug , "<STR_LIT>" + selectedPreset ) <EOL> del paths [ selectedIndex ] <EOL> if len ( paths ) : <EOL> self . __pathListing . setSelectedPaths ( [ paths [ min ( selectedIndex , len ( paths ) - <NUM_LIT:1> ) ] ] ) <EOL> return True <EOL> def __nameEditingFinished ( self , nameWidget ) : <EOL> selectedPaths = self . __pathListing . getSelectedPaths ( ) <EOL> if not len ( selectedPaths ) : <EOL> return True <EOL> oldName = selectedPaths [ <NUM_LIT:0> ] [ <NUM_LIT:0> ] <EOL> newName = nameWidget . getText ( ) <EOL> items = self . __pathListing . getPath ( ) . dict ( ) . items ( ) <EOL> with Gaffer . BlockedConnection ( self . __plugMetadataChangedConnection ) : <EOL> with Gaffer . UndoContext ( self . getPlug ( ) . ancestor ( Gaffer . ScriptNode ) ) : <EOL> for item in items : <EOL> Gaffer . Metadata . deregisterPlugValue ( self . getPlug ( ) , "<STR_LIT>" + item [ <NUM_LIT:0> ] ) <EOL> for item in items : <EOL> Gaffer . Metadata . registerPlugValue ( self . getPlug ( ) , "<STR_LIT>" + ( item [ <NUM_LIT:0> ] if item [ <NUM_LIT:0> ] != oldName else newName ) , item [ <NUM_LIT:1> ] ) <EOL> self . __updatePath ( ) <EOL> self . __pathListing . setSelectedPaths ( [ self . __pathListing . getPath ( ) . copy ( ) . setFromString ( "<STR_LIT:/>" + newName ) ] ) <EOL> return True <EOL> def __valuePlugSet ( self , plug ) : <EOL> if not plug . isSame ( self . __valueNode [ "<STR_LIT>" ] ) : <EOL> return <EOL> selectedPaths = self . __pathListing . getSelectedPaths ( ) <EOL> preset = selectedPaths [ <NUM_LIT:0> ] [ <NUM_LIT:0> ] <EOL> with Gaffer . UndoContext ( self . getPlug ( ) . ancestor ( Gaffer . ScriptNode ) ) : <EOL> Gaffer . Metadata . registerPlugValue ( self . getPlug ( ) , "<STR_LIT>" + preset , plug . getValue ( ) ) <EOL> class _PlugEditor ( GafferUI . Widget ) : <EOL> def __init__ ( self , parenting = None ) : <EOL> scrolledContainer = GafferUI . ScrolledContainer ( horizontalMode = GafferUI . ScrolledContainer . ScrollMode . Never , borderWidth = <NUM_LIT:8> ) <EOL> GafferUI . Widget . __init__ ( self , scrolledContainer , parenting = parenting ) <EOL> self . __metadataWidgets = { } <EOL> scrolledContainer . setChild ( GafferUI . ListContainer ( spacing = <NUM_LIT:4> ) ) <EOL> with scrolledContainer . getChild ( ) : <EOL> with _Row ( ) : <EOL> _Label ( "<STR_LIT:Name>" ) <EOL> self . __nameWidget = GafferUI . NameWidget ( None ) <EOL> with _Row ( ) : <EOL> _Label ( "<STR_LIT>" ) <EOL> self . __metadataWidgets [ "<STR_LIT:label>" ] = _StringMetadataWidget ( key = "<STR_LIT:label>" , acceptEmptyString = False ) <EOL> with _Row ( ) : <EOL> _Label ( "<STR_LIT>" , parenting = { "<STR_LIT>" : GafferUI . ListContainer . VerticalAlignment . Top } ) <EOL> self . __metadataWidgets [ "<STR_LIT:description>" ] = _MultiLineStringMetadataWidget ( key = "<STR_LIT:description>" ) <EOL> self . __metadataWidgets [ "<STR_LIT:description>" ] . textWidget ( ) . setFixedLineHeight ( <NUM_LIT:10> ) <EOL> with _Row ( ) : <EOL> _Label ( "<STR_LIT>" ) <EOL> self . __widgetMenu = GafferUI . MenuButton ( <EOL> menu = GafferUI . Menu ( Gaffer . WeakMethod ( self . __widgetMenuDefinition ) ) <EOL> ) <EOL> with GafferUI . Collapsible ( "<STR_LIT>" , collapsed = True ) : <EOL> with _Row ( ) : <EOL> _Label ( "<STR_LIT>" ) <EOL> self . __presetsEditor = _PresetsEditor ( ) <EOL> with GafferUI . Collapsible ( "<STR_LIT>" , collapsed = True ) : <EOL> with GafferUI . ListContainer ( spacing = <NUM_LIT:4> ) : <EOL> with _Row ( ) : <EOL> _Label ( "<STR_LIT>" ) <EOL> self . __metadataWidgets [ "<STR_LIT>" ] = _BoolMetadataWidget ( key = "<STR_LIT>" ) <EOL> for m in self . __metadataDefinitions : <EOL> with _Row ( ) : <EOL> _Label ( m . label ) <EOL> self . __metadataWidgets [ m . key ] = m . metadataWidgetType ( key = m . key ) <EOL> with GafferUI . Collapsible ( "<STR_LIT>" , collapsed = True ) : <EOL> with GafferUI . ListContainer ( spacing = <NUM_LIT:4> ) as self . __nodeGraphSection : <EOL> with _Row ( ) : <EOL> _Label ( "<STR_LIT>" ) <EOL> self . __gadgetMenu = GafferUI . MenuButton ( <EOL> menu = GafferUI . Menu ( Gaffer . WeakMethod ( self . __gadgetMenuDefinition ) ) <EOL> ) <EOL> with _Row ( ) : <EOL> _Label ( "<STR_LIT>" ) <EOL> self . __metadataWidgets [ "<STR_LIT>" ] = _MenuMetadataWidget ( <EOL> key = "<STR_LIT>" , <EOL> labelsAndValues = [ <EOL> ( "<STR_LIT>" , None ) , <EOL> ( "<STR_LIT>" , "<STR_LIT>" ) , <EOL> ( "<STR_LIT>" , "<STR_LIT>" ) , <EOL> ( "<STR_LIT>" , "<STR_LIT:left>" ) , <EOL> ( "<STR_LIT>" , "<STR_LIT:right>" ) , <EOL> ] <EOL> ) <EOL> with _Row ( ) : <EOL> _Label ( "<STR_LIT>" ) <EOL> self . __metadataWidgets [ "<STR_LIT>" ] = _ColorSwatchMetadataWidget ( key = "<STR_LIT>" ) <EOL> with _Row ( ) : <EOL> _Label ( "<STR_LIT>" ) <EOL> self . __metadataWidgets [ "<STR_LIT>" ] = _ColorSwatchMetadataWidget ( key = "<STR_LIT>" ) <EOL> GafferUI . Spacer ( IECore . V2i ( <NUM_LIT:0> ) , parenting = { "<STR_LIT>" : True } ) <EOL> self . __plugMetadataChangedConnection = Gaffer . Metadata . plugValueChangedSignal ( ) . connect ( Gaffer . WeakMethod ( self . __plugMetadataChanged ) ) <EOL> self . __plug = None <EOL> def setPlug ( self , plug ) : <EOL> self . __plug = plug <EOL> self . __nameWidget . setGraphComponent ( self . __plug ) <EOL> for widget in self . __metadataWidgets . values ( ) : <EOL> widget . setTarget ( self . __plug ) <EOL> self . __updateWidgetMenuText ( ) <EOL> self . __updateWidgetSettings ( ) <EOL> self . __updateGadgetMenuText ( ) <EOL> self . __presetsEditor . setPlug ( plug ) <EOL> self . __nodeGraphSection . setEnabled ( self . __plug is not None and self . __plug . parent ( ) . isSame ( self . __plug . node ( ) ) ) <EOL> self . setEnabled ( self . __plug is not None ) <EOL> def getPlug ( self ) : <EOL> return self . __plug <EOL> def __plugMetadataChanged ( self , nodeTypeId , plugPath , key , plug ) : <EOL> if self . getPlug ( ) is None : <EOL> return <EOL> if plug is not None and not plug . isSame ( self . getPlug ( ) ) : <EOL> return <EOL> if not self . getPlug ( ) . node ( ) . isInstanceOf ( nodeTypeId ) : <EOL> return <EOL> if key == "<STR_LIT>" : <EOL> self . __updateWidgetMenuText ( ) <EOL> self . __updateWidgetSettings ( ) <EOL> elif key == "<STR_LIT>" : <EOL> self . __updateGadgetMenuText ( ) <EOL> def __updateWidgetMenuText ( self ) : <EOL> if self . getPlug ( ) is None : <EOL> self . __widgetMenu . setText ( "<STR_LIT>" ) <EOL> return <EOL> metadata = Gaffer . Metadata . plugValue ( self . getPlug ( ) , "<STR_LIT>" ) <EOL> for w in self . __widgetDefinitions : <EOL> if w . metadata == metadata : <EOL> self . __widgetMenu . setText ( w . label ) <EOL> return <EOL> self . __widgetMenu . setText ( metadata ) <EOL> def __updateWidgetSettings ( self ) : <EOL> widgetType = None <EOL> if self . getPlug ( ) is not None : <EOL> widgetType = Gaffer . Metadata . plugValue ( self . getPlug ( ) , "<STR_LIT>" ) <EOL> for m in self . __metadataDefinitions : <EOL> widget = self . __metadataWidgets [ m . key ] <EOL> widget . parent ( ) . setEnabled ( m . plugValueWidgetType == widgetType ) <EOL> self . __metadataWidgets [ "<STR_LIT>" ] . parent ( ) . setEnabled ( <EOL> self . getPlug ( ) is not None and self . getPlug ( ) . direction ( ) == Gaffer . Plug . Direction . In <EOL> ) <EOL> def __widgetMenuDefinition ( self ) : <EOL> result = IECore . MenuDefinition ( ) <EOL> if self . getPlug ( ) is None : <EOL> return result <EOL> metadata = Gaffer . Metadata . plugValue ( self . getPlug ( ) , "<STR_LIT>" ) <EOL> for w in self . __widgetDefinitions : <EOL> if not isinstance ( self . getPlug ( ) , w . plugType ) : <EOL> continue <EOL> result . append ( <EOL> "<STR_LIT:/>" + w . label , <EOL> { <EOL> "<STR_LIT>" : functools . partial ( Gaffer . WeakMethod ( self . __registerOrDeregisterMetadata ) , key = "<STR_LIT>" , value = w . metadata ) , <EOL> "<STR_LIT>" : metadata == w . metadata , <EOL> } <EOL> ) <EOL> return result <EOL> def __updateGadgetMenuText ( self ) : <EOL> if self . getPlug ( ) is None : <EOL> self . __gadgetMenu . setText ( "<STR_LIT>" ) <EOL> return <EOL> metadata = Gaffer . Metadata . plugValue ( self . getPlug ( ) , "<STR_LIT>" ) <EOL> metadata = None if metadata == "<STR_LIT>" else metadata <EOL> for g in self . __gadgetDefinitions : <EOL> if g . metadata == metadata : <EOL> self . __gadgetMenu . setText ( g . label ) <EOL> return <EOL> self . __gadgetMenu . setText ( metadata ) <EOL> def __gadgetMenuDefinition ( self ) : <EOL> result = IECore . MenuDefinition ( ) <EOL> if self . getPlug ( ) is None : <EOL> return result <EOL> metadata = Gaffer . Metadata . plugValue ( self . getPlug ( ) , "<STR_LIT>" ) <EOL> for g in self . __gadgetDefinitions : <EOL> if not isinstance ( self . getPlug ( ) , g . plugType ) : <EOL> continue <EOL> result . append ( <EOL> "<STR_LIT:/>" + g . label , <EOL> { <EOL> "<STR_LIT>" : functools . partial ( Gaffer . WeakMethod ( self . __registerOrDeregisterMetadata ) , key = "<STR_LIT>" , value = g . metadata ) , <EOL> "<STR_LIT>" : metadata == g . metadata , <EOL> } <EOL> ) <EOL> return result <EOL> def __registerOrDeregisterMetadata ( self , unused , key , value ) : <EOL> with Gaffer . UndoContext ( self . getPlug ( ) . ancestor ( Gaffer . ScriptNode ) ) : <EOL> if value is not None : <EOL> Gaffer . Metadata . registerPlugValue ( self . getPlug ( ) , key , value ) <EOL> else : <EOL> Gaffer . Metadata . deregisterPlugValue ( self . getPlug ( ) , key ) <EOL> __WidgetDefinition = collections . namedtuple ( "<STR_LIT>" , ( "<STR_LIT:label>" , "<STR_LIT>" , "<STR_LIT>" ) ) <EOL> __widgetDefinitions = ( <EOL> __WidgetDefinition ( "<STR_LIT>" , Gaffer . Plug , None ) , <EOL> __WidgetDefinition ( "<STR_LIT>" , Gaffer . IntPlug , "<STR_LIT>" ) , <EOL> __WidgetDefinition ( "<STR_LIT>" , Gaffer . StringPlug , "<STR_LIT>" ) , <EOL> __WidgetDefinition ( "<STR_LIT>" , Gaffer . StringPlug , "<STR_LIT>" ) , <EOL> __WidgetDefinition ( "<STR_LIT>" , Gaffer . ValuePlug , "<STR_LIT>" ) , <EOL> __WidgetDefinition ( "<STR_LIT>" , Gaffer . Plug , "<STR_LIT>" ) , <EOL> __WidgetDefinition ( "<STR_LIT:None>" , Gaffer . Plug , "<STR_LIT>" ) , <EOL> ) <EOL> __MetadataDefinition = collections . namedtuple ( "<STR_LIT>" , ( "<STR_LIT:key>" , "<STR_LIT:label>" , "<STR_LIT>" , "<STR_LIT>" ) ) <EOL> __metadataDefinitions = ( <EOL> __MetadataDefinition ( "<STR_LIT>" , "<STR_LIT>" , _StringMetadataWidget , "<STR_LIT>" ) , <EOL> __MetadataDefinition ( "<STR_LIT>" , "<STR_LIT>" , _StringMetadataWidget , "<STR_LIT>" ) , <EOL> __MetadataDefinition ( "<STR_LIT>" , "<STR_LIT>" , _BoolMetadataWidget , "<STR_LIT>" ) , <EOL> __MetadataDefinition ( "<STR_LIT>" , "<STR_LIT>" , _BoolMetadataWidget , "<STR_LIT>" ) , <EOL> __MetadataDefinition ( "<STR_LIT>" , "<STR_LIT>" , _BoolMetadataWidget , "<STR_LIT>" ) , <EOL> __MetadataDefinition ( "<STR_LIT>" , "<STR_LIT>" , _BoolMetadataWidget , "<STR_LIT>" ) , <EOL> ) <EOL> __GadgetDefinition = collections . namedtuple ( "<STR_LIT>" , ( "<STR_LIT:label>" , "<STR_LIT>" , "<STR_LIT>" ) ) <EOL> __gadgetDefinitions = ( <EOL> __GadgetDefinition ( "<STR_LIT>" , Gaffer . Plug , None ) , <EOL> __GadgetDefinition ( "<STR_LIT>" , Gaffer . ArrayPlug , "<STR_LIT>" ) , <EOL> __GadgetDefinition ( "<STR_LIT:None>" , Gaffer . Plug , "<STR_LIT>" ) , <EOL> ) <EOL> class _SectionEditor ( GafferUI . Widget ) : <EOL> def __init__ ( self , parenting = None ) : <EOL> column = GafferUI . ListContainer ( spacing = <NUM_LIT:4> , borderWidth = <NUM_LIT:8> ) <EOL> GafferUI . Widget . __init__ ( self , column , parenting = parenting ) <EOL> with column : <EOL> with _Row ( ) : <EOL> _Label ( "<STR_LIT:Name>" ) <EOL> self . __nameWidget = GafferUI . TextWidget ( ) <EOL> self . __nameWidgetEditingFinishedConnection = self . __nameWidget . editingFinishedSignal ( ) . connect ( Gaffer . WeakMethod ( self . __nameWidgetEditingFinished ) ) <EOL> with _Row ( ) : <EOL> _Label ( "<STR_LIT>" , parenting = { "<STR_LIT>" : GafferUI . ListContainer . VerticalAlignment . Top } ) <EOL> self . __summaryMetadataWidget = _MultiLineStringMetadataWidget ( key = "<STR_LIT>" ) <EOL> self . __section = "<STR_LIT>" <EOL> self . __plugParent = None <EOL> self . __nameChangedSignal = Gaffer . Signal3 ( ) <EOL> def setPlugParent ( self , plugParent ) : <EOL> self . __plugParent = plugParent <EOL> self . __summaryMetadataWidget . setTarget ( self . __plugParent ) <EOL> def getPlugParent ( self ) : <EOL> return self . __plugParent <EOL> def setSection ( self , section ) : <EOL> assert ( isinstance ( section , basestring ) ) <EOL> self . __section = section <EOL> self . __nameWidget . setText ( section . rpartition ( "<STR_LIT:.>" ) [ - <NUM_LIT:1> ] ) <EOL> self . __summaryMetadataWidget . setKey ( "<STR_LIT>" + self . __section + "<STR_LIT>" ) <EOL> def getSection ( self ) : <EOL> return self . __section <EOL> def nameChangedSignal ( self ) : <EOL> return self . __nameChangedSignal <EOL> def __nameWidgetEditingFinished ( self , nameWidget ) : <EOL> if nameWidget . getText ( ) == "<STR_LIT>" : <EOL> self . setSection ( self . __section ) <EOL> return <EOL> oldSectionPath = self . __section . split ( "<STR_LIT:.>" ) <EOL> newSectionPath = oldSectionPath [ : ] <EOL> newSectionPath [ - <NUM_LIT:1> ] = nameWidget . getText ( ) . replace ( "<STR_LIT:.>" , "<STR_LIT>" ) <EOL> if oldSectionPath == newSectionPath : <EOL> return <EOL> def newSection ( oldSection ) : <EOL> s = oldSection . split ( "<STR_LIT:.>" ) <EOL> if s [ : len ( oldSectionPath ) ] == oldSectionPath : <EOL> s [ : len ( oldSectionPath ) ] = newSectionPath <EOL> return "<STR_LIT:.>" . join ( s ) <EOL> else : <EOL> return oldSection <EOL> with Gaffer . UndoContext ( self . __plugParent . ancestor ( Gaffer . ScriptNode ) ) : <EOL> for plug in self . __plugParent . children ( Gaffer . Plug ) : <EOL> s = _metadata ( plug , "<STR_LIT>" ) <EOL> if s is not None : <EOL> _registerMetadata ( plug , "<STR_LIT>" , newSection ( s ) ) <EOL> emptySections = _metadata ( self . getPlugParent ( ) , "<STR_LIT>" ) <EOL> if emptySections : <EOL> for i in range ( <NUM_LIT:0> , len ( emptySections ) ) : <EOL> emptySections [ i ] = newSection ( emptySections [ i ] ) <EOL> _registerMetadata ( self . getPlugParent ( ) , "<STR_LIT>" , emptySections ) <EOL> for name in _registeredMetadata ( self . getPlugParent ( ) , instanceOnly = True , persistentOnly = True ) : <EOL> m = re . match ( "<STR_LIT>" , name ) <EOL> if m : <EOL> if newSection ( m . group ( <NUM_LIT:2> ) ) != m . group ( <NUM_LIT:2> ) : <EOL> _registerMetadata ( <EOL> self . getPlugParent ( ) , <EOL> m . group ( <NUM_LIT:1> ) + newSection ( m . group ( <NUM_LIT:2> ) ) + m . group ( <NUM_LIT:3> ) , <EOL> _metadata ( self . getPlugParent ( ) , name ) <EOL> ) <EOL> _deregisterMetadata ( self . getPlugParent ( ) , name ) <EOL> self . setSection ( "<STR_LIT:.>" . join ( newSectionPath ) ) <EOL> self . nameChangedSignal ( ) ( self , "<STR_LIT:.>" . join ( oldSectionPath ) , "<STR_LIT:.>" . join ( newSectionPath ) ) <EOL> def _registerMetadata ( target , name , value ) : <EOL> if isinstance ( target , Gaffer . Node ) : <EOL> Gaffer . Metadata . registerNodeValue ( target , name , value ) <EOL> else : <EOL> Gaffer . Metadata . registerPlugValue ( target , name , value ) <EOL> def _registeredMetadata ( target , inherit = True , instanceOnly = False , persistentOnly = False ) : <EOL> if isinstance ( target , Gaffer . Node ) : <EOL> return Gaffer . Metadata . registeredNodeValues ( target , inherit , instanceOnly , persistentOnly ) <EOL> else : <EOL> return Gaffer . Metadata . registeredPlugValues ( target , inherit , instanceOnly , persistentOnly ) <EOL> def _metadata ( target , name ) : <EOL> if isinstance ( target , Gaffer . Node ) : <EOL> return Gaffer . Metadata . nodeValue ( target , name ) <EOL> else : <EOL> return Gaffer . Metadata . plugValue ( target , name ) <EOL> def _deregisterMetadata ( target , name ) : <EOL> if isinstance ( target , Gaffer . Node ) : <EOL> return Gaffer . Metadata . deregisterNodeValue ( target , name ) <EOL> else : <EOL> return Gaffer . Metadata . deregisterPlugValue ( target , name ) </s>
<s> import unittest <EOL> import GafferTest <EOL> import GafferUI <EOL> class NumericSliderTest ( unittest . TestCase ) : <EOL> def testConstruction ( self ) : <EOL> s = GafferUI . NumericSlider ( value = <NUM_LIT:0> , min = <NUM_LIT:0> , max = <NUM_LIT:1> ) <EOL> self . assertEqual ( s . getPosition ( ) , <NUM_LIT:0> ) <EOL> self . assertEqual ( s . getValue ( ) , <NUM_LIT:0> ) <EOL> self . assertEqual ( s . getRange ( ) , ( <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:0> , <NUM_LIT:1> ) ) <EOL> def testSetValue ( self ) : <EOL> s = GafferUI . NumericSlider ( value = <NUM_LIT:0> , min = <NUM_LIT:0> , max = <NUM_LIT:2> ) <EOL> self . assertEqual ( s . getPosition ( ) , <NUM_LIT:0> ) <EOL> self . assertEqual ( s . getValue ( ) , <NUM_LIT:0> ) <EOL> s . setValue ( <NUM_LIT:0.5> ) <EOL> self . assertEqual ( s . getPosition ( ) , <NUM_LIT> ) <EOL> self . assertEqual ( s . getValue ( ) , <NUM_LIT:0.5> ) <EOL> def testSetRange ( self ) : <EOL> s = GafferUI . NumericSlider ( value = <NUM_LIT:1> , min = <NUM_LIT:0> , max = <NUM_LIT:2> ) <EOL> self . assertEqual ( s . getPosition ( ) , <NUM_LIT:0.5> ) <EOL> self . assertEqual ( s . getValue ( ) , <NUM_LIT:1> ) <EOL> s . setRange ( <NUM_LIT:0> , <NUM_LIT:1> ) <EOL> self . assertEqual ( s . getPosition ( ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( s . getValue ( ) , <NUM_LIT:1> ) <EOL> def testSetZeroRange ( self ) : <EOL> s = GafferUI . NumericSlider ( value = <NUM_LIT:1> , min = <NUM_LIT:1> , max = <NUM_LIT:2> ) <EOL> self . assertEqual ( s . getPosition ( ) , <NUM_LIT:0> ) <EOL> self . assertEqual ( s . getValue ( ) , <NUM_LIT:1> ) <EOL> s . setRange ( <NUM_LIT:1> , <NUM_LIT:1> ) <EOL> self . assertEqual ( s . getValue ( ) , <NUM_LIT:1> ) <EOL> def testSetPosition ( self ) : <EOL> s = GafferUI . NumericSlider ( value = <NUM_LIT:0> , min = <NUM_LIT:0> , max = <NUM_LIT:2> ) <EOL> self . assertEqual ( s . getPosition ( ) , <NUM_LIT:0> ) <EOL> self . assertEqual ( s . getValue ( ) , <NUM_LIT:0> ) <EOL> s . setPosition ( <NUM_LIT:0.5> ) <EOL> self . assertEqual ( s . getPosition ( ) , <NUM_LIT:0.5> ) <EOL> self . assertEqual ( s . getValue ( ) , <NUM_LIT:1> ) <EOL> def testValuesOutsideRangeAreClamped ( self ) : <EOL> s = GafferUI . NumericSlider ( value = <NUM_LIT:0.1> , min = <NUM_LIT:0> , max = <NUM_LIT:2> ) <EOL> cs = GafferTest . CapturingSlot ( s . valueChangedSignal ( ) , s . positionChangedSignal ( ) ) <EOL> s . setValue ( <NUM_LIT:3> ) <EOL> self . assertEqual ( s . getValue ( ) , <NUM_LIT:2> ) <EOL> self . assertEqual ( s . getPosition ( ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( len ( cs ) , <NUM_LIT:2> ) <EOL> s . setValue ( <NUM_LIT:3> ) <EOL> self . assertEqual ( s . getValue ( ) , <NUM_LIT:2> ) <EOL> self . assertEqual ( s . getPosition ( ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( len ( cs ) , <NUM_LIT:2> ) <EOL> def testPositionsOutsideRangeAreClamped ( self ) : <EOL> s = GafferUI . NumericSlider ( value = <NUM_LIT:0.1> , min = <NUM_LIT:0> , max = <NUM_LIT:2> ) <EOL> cs = GafferTest . CapturingSlot ( s . valueChangedSignal ( ) , s . positionChangedSignal ( ) ) <EOL> s . setPosition ( <NUM_LIT:2> ) <EOL> self . assertEqual ( s . getValue ( ) , <NUM_LIT:2> ) <EOL> self . assertEqual ( s . getPosition ( ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( len ( cs ) , <NUM_LIT:2> ) <EOL> s . setPosition ( <NUM_LIT:2> ) <EOL> self . assertEqual ( s . getValue ( ) , <NUM_LIT:2> ) <EOL> self . assertEqual ( s . getPosition ( ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( len ( cs ) , <NUM_LIT:2> ) <EOL> def testHardRange ( self ) : <EOL> s = GafferUI . NumericSlider ( value = <NUM_LIT:0.1> , min = <NUM_LIT:0> , max = <NUM_LIT:2> , hardMin = - <NUM_LIT:1> , hardMax = <NUM_LIT:3> ) <EOL> self . assertEqual ( s . getRange ( ) , ( <NUM_LIT:0> , <NUM_LIT:2> , - <NUM_LIT:1> , <NUM_LIT:3> ) ) <EOL> cs = GafferTest . CapturingSlot ( s . valueChangedSignal ( ) , s . positionChangedSignal ( ) ) <EOL> s . setValue ( <NUM_LIT:3> ) <EOL> self . assertEqual ( s . getValue ( ) , <NUM_LIT:3> ) <EOL> self . assertEqual ( s . getPosition ( ) , <NUM_LIT> ) <EOL> self . assertEqual ( len ( cs ) , <NUM_LIT:2> ) <EOL> s . setValue ( <NUM_LIT> ) <EOL> self . assertEqual ( s . getValue ( ) , <NUM_LIT:3> ) <EOL> self . assertEqual ( s . getPosition ( ) , <NUM_LIT> ) <EOL> self . assertEqual ( len ( cs ) , <NUM_LIT:2> ) <EOL> s . setValue ( - <NUM_LIT:1> ) <EOL> self . assertEqual ( s . getValue ( ) , - <NUM_LIT:1> ) <EOL> self . assertEqual ( s . getPosition ( ) , - <NUM_LIT:0.5> ) <EOL> self . assertEqual ( len ( cs ) , <NUM_LIT:4> ) <EOL> s . setValue ( - <NUM_LIT:2> ) <EOL> self . assertEqual ( s . getValue ( ) , - <NUM_LIT:1> ) <EOL> self . assertEqual ( s . getPosition ( ) , - <NUM_LIT:0.5> ) <EOL> self . assertEqual ( len ( cs ) , <NUM_LIT:4> ) <EOL> def testSetRangeClampsValue ( self ) : <EOL> s = GafferUI . NumericSlider ( value = <NUM_LIT:0.5> , min = <NUM_LIT:0> , max = <NUM_LIT:2> ) <EOL> self . assertEqual ( s . getPosition ( ) , <NUM_LIT> ) <EOL> self . assertEqual ( s . getValue ( ) , <NUM_LIT:0.5> ) <EOL> s . setRange ( <NUM_LIT:1> , <NUM_LIT:2> ) <EOL> self . assertEqual ( s . getPosition ( ) , <NUM_LIT:0> ) <EOL> self . assertEqual ( s . getValue ( ) , <NUM_LIT:1> ) <EOL> def testMultipleValues ( self ) : <EOL> self . assertRaises ( Exception , GafferUI . NumericSlider , value = <NUM_LIT:0> , values = [ <NUM_LIT:1> , <NUM_LIT:2> ] ) <EOL> s = GafferUI . NumericSlider ( values = [ <NUM_LIT:1> , <NUM_LIT> ] , min = <NUM_LIT:0> , max = <NUM_LIT:2> ) <EOL> self . assertEqual ( s . getValues ( ) , [ <NUM_LIT:1> , <NUM_LIT> ] ) <EOL> self . assertEqual ( s . getPositions ( ) , [ <NUM_LIT:0.5> , <NUM_LIT> ] ) <EOL> self . assertRaises ( ValueError , s . getValue ) <EOL> if __name__ == "<STR_LIT:__main__>" : <EOL> unittest . main ( ) </s>
<s> import unittest <EOL> import weakref <EOL> import sys <EOL> import IECore <EOL> import Gaffer <EOL> import GafferTest <EOL> import GafferUI <EOL> import GafferUITest <EOL> QtCore = GafferUI . _qtImport ( "<STR_LIT>" ) <EOL> QtGui = GafferUI . _qtImport ( "<STR_LIT>" ) <EOL> class TestWidget ( GafferUI . Widget ) : <EOL> def __init__ ( self , ** kw ) : <EOL> GafferUI . Widget . __init__ ( self , QtGui . QLabel ( "<STR_LIT:hello>" ) , ** kw ) <EOL> class TestWidget2 ( GafferUI . Widget ) : <EOL> def __init__ ( self ) : <EOL> self . topLevelGafferWidget = TestWidget ( ) <EOL> GafferUI . Widget . __init__ ( self , self . topLevelGafferWidget ) <EOL> class WidgetTest ( GafferUITest . TestCase ) : <EOL> def testOwner ( self ) : <EOL> w = TestWidget ( ) <EOL> self . assert_ ( GafferUI . Widget . _owner ( w . _qtWidget ( ) ) is w ) <EOL> def testParent ( self ) : <EOL> w = TestWidget ( ) <EOL> self . assert_ ( w . parent ( ) is None ) <EOL> def testCanDie ( self ) : <EOL> w = TestWidget ( ) <EOL> wr1 = weakref . ref ( w ) <EOL> wr2 = weakref . ref ( w . _qtWidget ( ) ) <EOL> del w <EOL> self . assert_ ( wr1 ( ) is None ) <EOL> self . assert_ ( wr2 ( ) is None ) <EOL> def testAncestor ( self ) : <EOL> w = GafferUI . Window ( "<STR_LIT:test>" ) <EOL> l = GafferUI . ListContainer ( GafferUI . ListContainer . Orientation . Vertical ) <EOL> p = GafferUI . SplitContainer ( ) <EOL> l . append ( p ) <EOL> w . setChild ( l ) <EOL> self . assert_ ( p . ancestor ( GafferUI . ListContainer ) is l ) <EOL> self . assert_ ( p . ancestor ( GafferUI . Window ) is w ) <EOL> self . assert_ ( p . ancestor ( GafferUI . Menu ) is None ) <EOL> def testIsAncestorOf ( self ) : <EOL> with GafferUI . Window ( "<STR_LIT:test>" ) as w : <EOL> with GafferUI . SplitContainer ( ) as p : <EOL> with GafferUI . ListContainer ( ) as l1 : <EOL> b1 = GafferUI . Button ( ) <EOL> with GafferUI . ListContainer ( ) as l2 : <EOL> b2 = GafferUI . Button ( ) <EOL> self . assertTrue ( l2 . isAncestorOf ( b2 ) ) <EOL> self . assertFalse ( l1 . isAncestorOf ( b2 ) ) <EOL> self . assertTrue ( p . isAncestorOf ( b2 ) ) <EOL> self . assertTrue ( w . isAncestorOf ( b2 ) ) <EOL> self . assertFalse ( b2 . isAncestorOf ( b1 ) ) <EOL> self . assertFalse ( b2 . isAncestorOf ( l1 ) ) <EOL> self . assertFalse ( b2 . isAncestorOf ( l2 ) ) <EOL> self . assertFalse ( b2 . isAncestorOf ( p ) ) <EOL> self . assertFalse ( b2 . isAncestorOf ( w ) ) <EOL> self . assertTrue ( l1 . isAncestorOf ( b1 ) ) <EOL> self . assertFalse ( l2 . isAncestorOf ( b1 ) ) <EOL> self . assertTrue ( p . isAncestorOf ( b1 ) ) <EOL> self . assertTrue ( w . isAncestorOf ( b1 ) ) <EOL> def testGafferWidgetAsTopLevel ( self ) : <EOL> w = TestWidget2 ( ) <EOL> self . assert_ ( GafferUI . Widget . _owner ( w . _qtWidget ( ) ) is w ) <EOL> self . assert_ ( w . topLevelGafferWidget . parent ( ) is w ) <EOL> self . assert_ ( GafferUI . Widget . _owner ( w . topLevelGafferWidget . _qtWidget ( ) ) is not w ) <EOL> def testToolTip ( self ) : <EOL> w = TestWidget ( ) <EOL> self . assertEqual ( w . getToolTip ( ) , "<STR_LIT>" ) <EOL> w = TestWidget ( toolTip = "<STR_LIT>" ) <EOL> self . assertEqual ( w . getToolTip ( ) , "<STR_LIT>" ) <EOL> w . setToolTip ( "<STR_LIT:a>" ) <EOL> self . assertEqual ( w . getToolTip ( ) , "<STR_LIT:a>" ) <EOL> def testEnabledState ( self ) : <EOL> w = TestWidget ( ) <EOL> self . assertEqual ( w . getEnabled ( ) , True ) <EOL> self . assertEqual ( w . enabled ( ) , True ) <EOL> w . setEnabled ( False ) <EOL> self . assertEqual ( w . getEnabled ( ) , False ) <EOL> self . assertEqual ( w . enabled ( ) , False ) <EOL> w . setEnabled ( True ) <EOL> self . assertEqual ( w . getEnabled ( ) , True ) <EOL> self . assertEqual ( w . enabled ( ) , True ) <EOL> def testDisabledWidgetsDontGetSignals ( self ) : <EOL> w = TestWidget ( ) <EOL> def f ( w , event ) : <EOL> WidgetTest . signalsEmitted += <NUM_LIT:1> <EOL> c = w . buttonPressSignal ( ) . connect ( f ) <EOL> WidgetTest . signalsEmitted = <NUM_LIT:0> <EOL> event = QtGui . QMouseEvent ( QtCore . QEvent . MouseButtonPress , QtCore . QPoint ( <NUM_LIT:0> , <NUM_LIT:0> ) , QtCore . Qt . LeftButton , QtCore . Qt . LeftButton , QtCore . Qt . NoModifier ) <EOL> QtGui . QApplication . instance ( ) . sendEvent ( w . _qtWidget ( ) , event ) <EOL> self . assertEqual ( WidgetTest . signalsEmitted , <NUM_LIT:1> ) <EOL> w . setEnabled ( False ) <EOL> QtGui . QApplication . instance ( ) . sendEvent ( w . _qtWidget ( ) , event ) <EOL> self . assertEqual ( WidgetTest . signalsEmitted , <NUM_LIT:1> ) <EOL> w . setEnabled ( True ) <EOL> QtGui . QApplication . instance ( ) . sendEvent ( w . _qtWidget ( ) , event ) <EOL> self . assertEqual ( WidgetTest . signalsEmitted , <NUM_LIT:2> ) <EOL> def testCanDieAfterUsingSignals ( self ) : <EOL> w = TestWidget ( ) <EOL> wr1 = weakref . ref ( w ) <EOL> wr2 = weakref . ref ( w . _qtWidget ( ) ) <EOL> w . buttonPressSignal ( ) <EOL> w . buttonReleaseSignal ( ) <EOL> w . mouseMoveSignal ( ) <EOL> w . wheelSignal ( ) <EOL> del w <EOL> self . assert_ ( wr1 ( ) is None ) <EOL> self . assert_ ( wr2 ( ) is None ) <EOL> def testVisibility ( self ) : <EOL> with GafferUI . Window ( ) as w : <EOL> with GafferUI . ListContainer ( ) as l : <EOL> t = TestWidget ( ) <EOL> self . assertEqual ( w . getVisible ( ) , False ) <EOL> self . assertEqual ( l . getVisible ( ) , True ) <EOL> self . assertEqual ( t . getVisible ( ) , True ) <EOL> self . assertEqual ( w . visible ( ) , False ) <EOL> self . assertEqual ( l . visible ( ) , False ) <EOL> self . assertEqual ( t . visible ( ) , False ) <EOL> w . setVisible ( True ) <EOL> self . assertEqual ( w . getVisible ( ) , True ) <EOL> self . assertEqual ( l . getVisible ( ) , True ) <EOL> self . assertEqual ( t . getVisible ( ) , True ) <EOL> self . assertEqual ( w . visible ( ) , True ) <EOL> self . assertEqual ( l . visible ( ) , True ) <EOL> self . assertEqual ( t . visible ( ) , True ) <EOL> w . setVisible ( False ) <EOL> self . assertEqual ( w . getVisible ( ) , False ) <EOL> self . assertEqual ( l . getVisible ( ) , True ) <EOL> self . assertEqual ( t . getVisible ( ) , True ) <EOL> self . assertEqual ( w . visible ( ) , False ) <EOL> self . assertEqual ( l . visible ( ) , False ) <EOL> self . assertEqual ( t . visible ( ) , False ) <EOL> self . assertEqual ( t . visible ( relativeTo = l ) , True ) <EOL> self . assertEqual ( t . visible ( relativeTo = w ) , True ) <EOL> w . setVisible ( True ) <EOL> t . setVisible ( False ) <EOL> self . assertEqual ( t . getVisible ( ) , False ) <EOL> self . assertEqual ( t . visible ( ) , False ) <EOL> self . assertEqual ( t . visible ( relativeTo = l ) , False ) <EOL> def testGetVisibleForNewWidgets ( self ) : <EOL> w = TestWidget ( ) <EOL> self . assertEqual ( w . getVisible ( ) , True ) <EOL> def testVisibilityOfParentlessWidgets ( self ) : <EOL> w = GafferUI . Window ( ) <EOL> t = TestWidget ( ) <EOL> self . assertEqual ( w . getVisible ( ) , False ) <EOL> self . assertEqual ( w . visible ( ) , False ) <EOL> self . assertEqual ( t . getVisible ( ) , True ) <EOL> self . assertEqual ( t . visible ( ) , False ) <EOL> w . setVisible ( True ) <EOL> self . assertEqual ( w . getVisible ( ) , True ) <EOL> self . assertEqual ( w . visible ( ) , True ) <EOL> w . setChild ( t ) <EOL> self . assertEqual ( t . getVisible ( ) , True ) <EOL> self . assertEqual ( t . visible ( ) , True ) <EOL> w . removeChild ( t ) <EOL> self . assertEqual ( t . parent ( ) , None ) <EOL> self . assertEqual ( t . getVisible ( ) , True ) <EOL> self . assertEqual ( t . visible ( ) , False ) <EOL> def testVisibilityWhenTransferringWidgets ( self ) : <EOL> w1 = GafferUI . Window ( ) <EOL> w1 . setVisible ( True ) <EOL> w2 = GafferUI . Window ( ) <EOL> w2 . setVisible ( True ) <EOL> v = TestWidget ( ) <EOL> self . assertEqual ( v . getVisible ( ) , True ) <EOL> self . assertEqual ( v . visible ( ) , False ) <EOL> h = TestWidget ( ) <EOL> self . assertEqual ( h . getVisible ( ) , True ) <EOL> h . setVisible ( False ) <EOL> self . assertEqual ( h . getVisible ( ) , False ) <EOL> self . assertEqual ( h . visible ( ) , False ) <EOL> w1 . setChild ( v ) <EOL> self . assertEqual ( v . getVisible ( ) , True ) <EOL> self . assertEqual ( v . visible ( ) , True ) <EOL> self . assertEqual ( h . getVisible ( ) , False ) <EOL> self . assertEqual ( h . visible ( ) , False ) <EOL> w2 . setChild ( v ) <EOL> self . assertEqual ( v . getVisible ( ) , True ) <EOL> self . assertEqual ( v . visible ( ) , True ) <EOL> self . assertEqual ( h . getVisible ( ) , False ) <EOL> self . assertEqual ( h . visible ( ) , False ) <EOL> w1 . setChild ( h ) <EOL> self . assertEqual ( v . getVisible ( ) , True ) <EOL> self . assertEqual ( v . visible ( ) , True ) <EOL> self . assertEqual ( h . getVisible ( ) , False ) <EOL> self . assertEqual ( h . visible ( ) , False ) <EOL> w2 . setChild ( h ) <EOL> self . assertEqual ( v . getVisible ( ) , True ) <EOL> self . assertEqual ( v . visible ( ) , False ) <EOL> self . assertEqual ( h . getVisible ( ) , False ) <EOL> self . assertEqual ( h . visible ( ) , False ) <EOL> def testSignals ( self ) : <EOL> w = TestWidget ( ) <EOL> for s in [ <EOL> ( "<STR_LIT>" , GafferUI . WidgetEventSignal ) , <EOL> ( "<STR_LIT>" , GafferUI . WidgetEventSignal ) , <EOL> ( "<STR_LIT>" , GafferUI . WidgetEventSignal ) , <EOL> ( "<STR_LIT>" , GafferUI . WidgetEventSignal ) , <EOL> ( "<STR_LIT>" , GafferUI . WidgetEventSignal ) , <EOL> ( "<STR_LIT>" , GafferUI . WidgetEventSignal ) , <EOL> ( "<STR_LIT>" , GafferUI . WidgetSignal ) , <EOL> ( "<STR_LIT>" , GafferUI . WidgetSignal ) , <EOL> ( "<STR_LIT>" , GafferUI . WidgetEventSignal ) , <EOL> ( "<STR_LIT>" , GafferUI . WidgetSignal ) , <EOL> ( "<STR_LIT>" , GafferUI . WidgetSignal ) , <EOL> ( "<STR_LIT>" , GafferUI . WidgetSignal ) , <EOL> ] : <EOL> self . failUnless ( isinstance ( getattr ( w , s [ <NUM_LIT:0> ] ) ( ) , s [ <NUM_LIT:1> ] ) ) <EOL> self . failUnless ( getattr ( w , s [ <NUM_LIT:0> ] ) ( ) is getattr ( w , s [ <NUM_LIT:0> ] ) ( ) ) <EOL> def testBound ( self ) : <EOL> w = GafferUI . Window ( borderWidth = <NUM_LIT:8> ) <EOL> b = GafferUI . Button ( ) <EOL> w . setChild ( b ) <EOL> w . setVisible ( True ) <EOL> w . setPosition ( IECore . V2i ( <NUM_LIT:100> ) ) <EOL> self . waitForIdle ( <NUM_LIT:1000> ) <EOL> wb = w . bound ( ) <EOL> bb = b . bound ( ) <EOL> bbw = b . bound ( relativeTo = w ) <EOL> self . failUnless ( isinstance ( wb , IECore . Box2i ) ) <EOL> self . failUnless ( isinstance ( bb , IECore . Box2i ) ) <EOL> self . failUnless ( isinstance ( bbw , IECore . Box2i ) ) <EOL> self . assertEqual ( bb . size ( ) , bbw . size ( ) ) <EOL> self . assertEqual ( bbw . min , bb . min - wb . min ) <EOL> self . assertEqual ( b . size ( ) , bb . size ( ) ) <EOL> def testParentChangedSignal ( self ) : <EOL> w = TestWidget ( ) <EOL> window = GafferUI . Window ( ) <EOL> cs = GafferTest . CapturingSlot ( w . parentChangedSignal ( ) ) <EOL> self . assertEqual ( len ( cs ) , <NUM_LIT:0> ) <EOL> window . setChild ( w ) <EOL> self . assertEqual ( len ( cs ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( cs [ <NUM_LIT:0> ] , ( w , ) ) <EOL> window . setChild ( None ) <EOL> self . assertEqual ( len ( cs ) , <NUM_LIT:2> ) <EOL> self . assertEqual ( cs [ <NUM_LIT:1> ] , ( w , ) ) <EOL> def testHighlighting ( self ) : <EOL> w = TestWidget ( ) <EOL> self . assertEqual ( w . getHighlighted ( ) , False ) <EOL> w . setHighlighted ( True ) <EOL> self . assertEqual ( w . getHighlighted ( ) , True ) <EOL> w . setHighlighted ( False ) <EOL> self . assertEqual ( w . getHighlighted ( ) , False ) <EOL> def testWidgetAt ( self ) : <EOL> with GafferUI . Window ( ) as w1 : <EOL> t1 = GafferUI . TextWidget ( "<STR_LIT:hello>" ) <EOL> with GafferUI . Window ( ) as w2 : <EOL> t2 = GafferUI . TextWidget ( "<STR_LIT:hello>" ) <EOL> w1 . setVisible ( True ) <EOL> w2 . setVisible ( True ) <EOL> w1 . setPosition ( IECore . V2i ( <NUM_LIT:100> ) ) <EOL> w2 . setPosition ( IECore . V2i ( <NUM_LIT> ) ) <EOL> self . waitForIdle ( <NUM_LIT:1000> ) <EOL> self . assertTrue ( GafferUI . Widget . widgetAt ( w1 . bound ( ) . center ( ) ) is t1 ) <EOL> self . assertTrue ( GafferUI . Widget . widgetAt ( w2 . bound ( ) . center ( ) ) is t2 ) <EOL> self . assertTrue ( GafferUI . Widget . widgetAt ( w1 . bound ( ) . center ( ) , widgetType = GafferUI . Window ) is w1 ) <EOL> self . assertTrue ( GafferUI . Widget . widgetAt ( w2 . bound ( ) . center ( ) , widgetType = GafferUI . Window ) is w2 ) <EOL> def testMousePosition ( self ) : <EOL> w = GafferUI . Window ( borderWidth = <NUM_LIT:8> ) <EOL> b = GafferUI . Button ( ) <EOL> w . setChild ( b ) <EOL> w . setVisible ( True ) <EOL> w . setPosition ( IECore . V2i ( <NUM_LIT:100> ) ) <EOL> self . waitForIdle ( <NUM_LIT:1000> ) <EOL> mouseGlobal = GafferUI . Widget . mousePosition ( ) <EOL> mouseLocal = GafferUI . Widget . mousePosition ( relativeTo = b ) <EOL> self . assertEqual ( mouseGlobal , mouseLocal + b . bound ( ) . min ) <EOL> def testAddressAndObject ( self ) : <EOL> button = GafferUI . Button ( ) <EOL> address = GafferUI . _qtAddress ( button . _qtWidget ( ) ) <EOL> self . assertTrue ( isinstance ( address , int ) ) <EOL> widget = GafferUI . _qtObject ( address , QtGui . QPushButton ) <EOL> self . assertTrue ( isinstance ( widget , QtGui . QPushButton ) ) <EOL> def testSetVisibleWithNonBool ( self ) : <EOL> w = TestWidget ( ) <EOL> self . assertTrue ( w . getVisible ( ) is True ) <EOL> w . setVisible ( <NUM_LIT:0> ) <EOL> self . assertTrue ( w . getVisible ( ) is False ) <EOL> w . setVisible ( <NUM_LIT:1> ) <EOL> self . assertTrue ( w . getVisible ( ) is True ) <EOL> if __name__ == "<STR_LIT:__main__>" : <EOL> unittest . main ( ) </s>
<s> import GafferUI <EOL> import GafferSceneUI <EOL> def __toolMenu ( nodeEditor , node , menuDefinition ) : <EOL> GafferUI . UIEditor . appendNodeEditorToolMenuDefinitions ( nodeEditor , node , menuDefinition ) <EOL> GafferUI . BoxUI . appendNodeEditorToolMenuDefinitions ( nodeEditor , node , menuDefinition ) <EOL> GafferSceneUI . FilteredSceneProcessorUI . appendNodeEditorToolMenuDefinitions ( nodeEditor , node , menuDefinition ) <EOL> __nodeEditorToolMenuConnection = GafferUI . NodeEditor . toolMenuSignal ( ) . connect ( __toolMenu ) </s>
<s> VERSION = ( <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:0> , '<STR_LIT>' , <NUM_LIT:1> ) <EOL> __version__ = '<STR_LIT:.>' . join ( map ( str , VERSION ) ) <EOL> def get_version ( ) : <EOL> version = '<STR_LIT>' % ( VERSION [ <NUM_LIT:0> ] , VERSION [ <NUM_LIT:1> ] ) <EOL> if VERSION [ <NUM_LIT:2> ] : <EOL> version = '<STR_LIT>' % ( version , VERSION [ <NUM_LIT:2> ] ) <EOL> if VERSION [ <NUM_LIT:3> : ] == ( '<STR_LIT>' , <NUM_LIT:0> ) : <EOL> version = '<STR_LIT>' % version <EOL> else : <EOL> if VERSION [ <NUM_LIT:3> ] != '<STR_LIT>' : <EOL> version = '<STR_LIT>' % ( version , VERSION [ <NUM_LIT:3> ] , VERSION [ <NUM_LIT:4> ] ) <EOL> return version </s>
<s> import yappi <EOL> import os <EOL> from totalimpact import backend <EOL> rootdir = "<STR_LIT:.>" <EOL> logfile = '<STR_LIT>' <EOL> yappi . clear_stats ( ) <EOL> yappi . start ( ) <EOL> backend . main ( logfile ) <EOL> yappi . stop ( ) <EOL> yappi . print_stats ( sort_type = yappi . SORTTYPE_TTOT , limit = <NUM_LIT:30> , thread_stats_on = False ) </s>
<s> import os , collections , simplejson <EOL> from totalimpact import db , app <EOL> from totalimpact . providers import pmc <EOL> from test . unit_tests . providers import common <EOL> from test . unit_tests . providers . common import ProviderTestCase <EOL> from totalimpact . providers . provider import Provider , ProviderContentMalformedError , ProviderFactory <EOL> from totalimpact import provider_batch_data <EOL> from test . utils import http <EOL> from test . utils import setup_postgres_for_unittests , teardown_postgres_for_unittests <EOL> from nose . tools import assert_equals , raises , nottest , assert_items_equal <EOL> datadir = os . path . join ( os . path . split ( __file__ ) [ <NUM_LIT:0> ] , "<STR_LIT>" ) <EOL> SAMPLE_EXTRACT_METRICS_PAGE = os . path . join ( datadir , "<STR_LIT>" ) <EOL> SAMPLE_EXTRACT_METRICS_PAGE_DIFFERENT_MONTH = os . path . join ( datadir , "<STR_LIT>" ) <EOL> TEST_PMID = "<STR_LIT>" <EOL> class TestPmc ( ProviderTestCase ) : <EOL> provider_name = "<STR_LIT>" <EOL> testitem_aliases = ( "<STR_LIT>" , TEST_PMID ) <EOL> testitem_metrics = ( "<STR_LIT>" , TEST_PMID ) <EOL> def setUp ( self ) : <EOL> ProviderTestCase . setUp ( self ) <EOL> self . db = setup_postgres_for_unittests ( db , app ) <EOL> sample_data_dump = open ( SAMPLE_EXTRACT_METRICS_PAGE , "<STR_LIT:r>" ) . read ( ) <EOL> sample_data_dump_different_month = open ( SAMPLE_EXTRACT_METRICS_PAGE_DIFFERENT_MONTH , "<STR_LIT:r>" ) . read ( ) <EOL> test_monthly_data = [ <EOL> { "<STR_LIT>" : "<STR_LIT:abc>" , <EOL> "<STR_LIT:type>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : sample_data_dump , <EOL> "<STR_LIT>" : <NUM_LIT:1.0> , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : { "<STR_LIT>" : [ "<STR_LIT>" , "<STR_LIT>" ] } , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" <EOL> } , <EOL> { "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT:type>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : sample_data_dump_different_month , <EOL> "<STR_LIT>" : <NUM_LIT:1.0> , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : { "<STR_LIT>" : [ "<STR_LIT>" ] } , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" <EOL> } , <EOL> { <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : { <EOL> "<STR_LIT>" : [ <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" <EOL> ] <EOL> } , <EOL> "<STR_LIT>" : <NUM_LIT:1> , <EOL> "<STR_LIT:type>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" <EOL> } <EOL> ] <EOL> for doc in test_monthly_data : <EOL> new_object = provider_batch_data . create_objects_from_doc ( doc ) <EOL> print new_object <EOL> self . provider = pmc . Pmc ( ) <EOL> print "<STR_LIT>" <EOL> def tearDown ( self ) : <EOL> teardown_postgres_for_unittests ( self . db ) <EOL> def test_has_applicable_batch_data_true ( self ) : <EOL> response = self . provider . has_applicable_batch_data ( "<STR_LIT>" , "<STR_LIT>" ) <EOL> assert_equals ( response , True ) <EOL> def test_has_applicable_batch_data_false ( self ) : <EOL> response = self . provider . has_applicable_batch_data ( "<STR_LIT>" , "<STR_LIT>" ) <EOL> assert_equals ( response , False ) <EOL> def test_build_batch_data_dict ( self ) : <EOL> response = self . provider . build_batch_data_dict ( ) <EOL> print response . keys ( ) <EOL> expected = [ ( '<STR_LIT>' , '<STR_LIT>' ) , ( '<STR_LIT>' , '<STR_LIT>' ) , ( '<STR_LIT>' , '<STR_LIT>' ) , ( '<STR_LIT>' , '<STR_LIT>' ) , ( '<STR_LIT>' , '<STR_LIT>' ) , ( '<STR_LIT>' , '<STR_LIT>' ) , ( '<STR_LIT>' , '<STR_LIT>' ) , ( '<STR_LIT>' , '<STR_LIT>' ) , ( '<STR_LIT>' , '<STR_LIT>' ) , ( '<STR_LIT>' , '<STR_LIT>' ) , ( '<STR_LIT>' , '<STR_LIT>' ) , ( '<STR_LIT>' , '<STR_LIT>' ) , ( '<STR_LIT>' , '<STR_LIT>' ) , ( '<STR_LIT>' , '<STR_LIT>' ) , ( '<STR_LIT>' , '<STR_LIT>' ) ] <EOL> assert_items_equal ( response . keys ( ) , expected ) <EOL> def test_is_relevant_alias ( self ) : <EOL> assert_equals ( self . provider . is_relevant_alias ( self . testitem_aliases ) , True ) <EOL> def test_extract_metrics_success ( self ) : <EOL> f = open ( SAMPLE_EXTRACT_METRICS_PAGE , "<STR_LIT:r>" ) <EOL> good_page = f . read ( ) <EOL> metrics_dict = self . provider . _extract_metrics ( good_page , id = "<STR_LIT>" ) <EOL> print metrics_dict <EOL> expected = { '<STR_LIT>' : <NUM_LIT> , '<STR_LIT>' : <NUM_LIT> , '<STR_LIT>' : <NUM_LIT> , '<STR_LIT>' : <NUM_LIT:9> } <EOL> assert_equals ( metrics_dict , expected ) <EOL> def test_provider_metrics_500 ( self ) : <EOL> pass <EOL> def test_provider_metrics_400 ( self ) : <EOL> pass <EOL> def test_provider_metrics_nonsense_xml ( self ) : <EOL> pass <EOL> def test_provider_metrics_nonsense_txt ( self ) : <EOL> pass <EOL> def test_provider_metrics_empty ( self ) : <EOL> pass <EOL> @ http <EOL> def test_metrics ( self ) : <EOL> metrics_dict = self . provider . metrics ( [ ( "<STR_LIT>" , "<STR_LIT>" ) ] ) <EOL> expected = { '<STR_LIT>' : ( <NUM_LIT> , '<STR_LIT>' ) , '<STR_LIT>' : ( <NUM_LIT> , '<STR_LIT>' ) , '<STR_LIT>' : ( <NUM_LIT> , '<STR_LIT>' ) , '<STR_LIT>' : ( <NUM_LIT:9> , '<STR_LIT>' ) } <EOL> print metrics_dict <EOL> for key in expected : <EOL> assert metrics_dict [ key ] [ <NUM_LIT:0> ] >= expected [ key ] [ <NUM_LIT:0> ] , [ key , metrics_dict [ key ] , expected [ key ] ] <EOL> assert metrics_dict [ key ] [ <NUM_LIT:1> ] == expected [ key ] [ <NUM_LIT:1> ] , [ key , metrics_dict [ key ] , expected [ key ] ] <EOL> @ http <EOL> def test_metrics_multiple_months ( self ) : <EOL> metrics_dict = self . provider . metrics ( [ ( "<STR_LIT>" , "<STR_LIT>" ) ] ) <EOL> expected = { '<STR_LIT>' : ( <NUM_LIT> , '<STR_LIT>' ) , '<STR_LIT>' : ( <NUM_LIT> , '<STR_LIT>' ) , '<STR_LIT>' : ( <NUM_LIT> , '<STR_LIT>' ) , '<STR_LIT>' : ( <NUM_LIT> , '<STR_LIT>' ) , '<STR_LIT>' : ( <NUM_LIT> , '<STR_LIT>' ) } <EOL> print metrics_dict <EOL> for key in expected : <EOL> assert metrics_dict [ key ] [ <NUM_LIT:0> ] >= expected [ key ] [ <NUM_LIT:0> ] , [ key , metrics_dict [ key ] , expected [ key ] ] <EOL> assert metrics_dict [ key ] [ <NUM_LIT:1> ] == expected [ key ] [ <NUM_LIT:1> ] , [ key , metrics_dict [ key ] , expected [ key ] ] <EOL> @ http <EOL> def test_metrics_real ( self ) : <EOL> metrics_dict = self . provider . metrics ( [ ( "<STR_LIT>" , "<STR_LIT>" ) ] ) <EOL> expected = { '<STR_LIT>' : ( <NUM_LIT> , '<STR_LIT>' ) , '<STR_LIT>' : ( <NUM_LIT> , '<STR_LIT>' ) , '<STR_LIT>' : ( <NUM_LIT> , '<STR_LIT>' ) , '<STR_LIT>' : ( <NUM_LIT> , '<STR_LIT>' ) , '<STR_LIT>' : ( <NUM_LIT> , '<STR_LIT>' ) } <EOL> print metrics_dict <EOL> for key in expected : <EOL> assert metrics_dict [ key ] [ <NUM_LIT:0> ] >= expected [ key ] [ <NUM_LIT:0> ] , [ key , metrics_dict [ key ] , expected [ key ] ] <EOL> assert metrics_dict [ key ] [ <NUM_LIT:1> ] == expected [ key ] [ <NUM_LIT:1> ] , [ key , metrics_dict [ key ] , expected [ key ] ] </s>
<s> import os <EOL> import sys <EOL> import hashlib <EOL> import logging <EOL> import json <EOL> from cPickle import PicklingError <EOL> import redis <EOL> from totalimpact import REDIS_CACHE_DATABASE_NUMBER <EOL> logger = logging . getLogger ( "<STR_LIT>" ) <EOL> cache_client = redis . from_url ( os . getenv ( "<STR_LIT>" ) , REDIS_CACHE_DATABASE_NUMBER ) <EOL> MAX_PAYLOAD_SIZE_BYTES = <NUM_LIT:1000> * <NUM_LIT:1000> <EOL> MAX_CACHE_SIZE_BYTES = <NUM_LIT:100> * <NUM_LIT:1000> * <NUM_LIT:1000> <EOL> class CacheException ( Exception ) : <EOL> pass <EOL> class Cache ( object ) : <EOL> """<STR_LIT>""" <EOL> def _build_hash_key ( self , key ) : <EOL> json_key = json . dumps ( key ) <EOL> hash_key = hashlib . md5 ( json_key . encode ( "<STR_LIT:utf-8>" ) ) . hexdigest ( ) <EOL> return hash_key <EOL> def _get_client ( self ) : <EOL> return cache_client <EOL> def __init__ ( self , max_cache_age = <NUM_LIT> * <NUM_LIT> ) : <EOL> self . max_cache_age = max_cache_age <EOL> self . flush_cache ( ) <EOL> def flush_cache ( self ) : <EOL> mc = self . _get_client ( ) <EOL> def get_cache_entry ( self , key ) : <EOL> """<STR_LIT>""" <EOL> mc = self . _get_client ( ) <EOL> hash_key = self . _build_hash_key ( key ) <EOL> response = mc . get ( hash_key ) <EOL> if response : <EOL> response = json . loads ( response ) <EOL> return response <EOL> def set_cache_entry ( self , key , data ) : <EOL> """<STR_LIT>""" <EOL> if sys . getsizeof ( data [ "<STR_LIT:text>" ] ) > MAX_PAYLOAD_SIZE_BYTES : <EOL> logger . debug ( u"<STR_LIT>" ) <EOL> return None <EOL> mc = self . _get_client ( ) <EOL> if mc . info ( ) [ "<STR_LIT>" ] >= MAX_CACHE_SIZE_BYTES : <EOL> logger . debug ( u"<STR_LIT>" ) <EOL> return None <EOL> hash_key = self . _build_hash_key ( key ) <EOL> set_response = mc . set ( hash_key , json . dumps ( data ) ) <EOL> mc . expire ( hash_key , self . max_cache_age ) <EOL> if not set_response : <EOL> logger . warning ( "<STR_LIT>" ) <EOL> raise CacheException ( "<STR_LIT>" ) <EOL> return set_response </s>
<s> from totalimpact . providers import provider <EOL> from totalimpact . providers . provider import Provider , ProviderContentMalformedError <EOL> import simplejson , os , re , urllib <EOL> import logging <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> class Plosalm ( Provider ) : <EOL> example_id = ( "<STR_LIT>" , "<STR_LIT>" ) <EOL> url = "<STR_LIT>" <EOL> descr = "<STR_LIT>" <EOL> metrics_url_template = "<STR_LIT>" + os . environ [ "<STR_LIT>" ] <EOL> provenance_url_template = "<STR_LIT>" <EOL> PLOS_ICON = "<STR_LIT>" <EOL> static_meta_dict = { <EOL> "<STR_LIT>" : { <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT:description>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : PLOS_ICON , <EOL> } , <EOL> "<STR_LIT>" : { <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT:description>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : PLOS_ICON , <EOL> } <EOL> } <EOL> def __init__ ( self ) : <EOL> super ( Plosalm , self ) . __init__ ( ) <EOL> def is_relevant_alias ( self , alias ) : <EOL> ( namespace , nid ) = alias <EOL> relevant = ( ( "<STR_LIT>" == namespace ) and ( "<STR_LIT>" in nid ) ) <EOL> return ( relevant ) <EOL> def _extract_metrics ( self , page , status_code = <NUM_LIT:200> , id = None ) : <EOL> if status_code != <NUM_LIT:200> : <EOL> if status_code == <NUM_LIT> : <EOL> return { } <EOL> else : <EOL> raise ( self . _get_error ( status_code ) ) <EOL> if not "<STR_LIT>" in page : <EOL> raise ProviderContentMalformedError <EOL> json_response = provider . _load_json ( page ) <EOL> this_article = json_response [ <NUM_LIT:0> ] [ "<STR_LIT>" ] [ <NUM_LIT:0> ] [ "<STR_LIT>" ] <EOL> dict_of_keylists = { <EOL> '<STR_LIT>' : [ '<STR_LIT:html>' ] , <EOL> '<STR_LIT>' : [ '<STR_LIT>' ] <EOL> } <EOL> metrics_dict = provider . _extract_from_data_dict ( this_article , dict_of_keylists ) <EOL> return metrics_dict </s>
<s> import os <EOL> import sys <EOL> import urlparse <EOL> from kombu import Exchange , Queue <EOL> sys . path . append ( '<STR_LIT:.>' ) <EOL> redis_url = os . environ . get ( '<STR_LIT>' , "<STR_LIT>" ) <EOL> if not redis_url . endswith ( "<STR_LIT:/>" ) : <EOL> redis_url += "<STR_LIT:/>" <EOL> BROKER_URL = redis_url + "<STR_LIT:1>" <EOL> CELERY_RESULT_BACKEND = redis_url + "<STR_LIT:2>" <EOL> REDIS_CONNECT_RETRY = True <EOL> BROKER_TRANSPORT_OPTIONS = { '<STR_LIT>' : True , <EOL> '<STR_LIT>' : True , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : <NUM_LIT:100> <EOL> } <EOL> CELERY_DEFAULT_QUEUE = '<STR_LIT>' <EOL> CELERY_QUEUES = [ <EOL> Queue ( '<STR_LIT>' , routing_key = '<STR_LIT>' ) , <EOL> Queue ( '<STR_LIT>' , routing_key = '<STR_LIT>' ) <EOL> ] <EOL> BROKER_POOL_LIMIT = None <EOL> CELERY_CREATE_MISSING_QUEUES = True <EOL> CELERY_ACCEPT_CONTENT = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> CELERY_ENABLE_UTC = True <EOL> CELERY_TASK_RESULT_EXPIRES = <NUM_LIT> * <NUM_LIT> * <NUM_LIT:1> <EOL> CELERY_ACKS_LATE = True <EOL> CELERYD_FORCE_EXECV = True <EOL> CELERY_TRACK_STARTED = True <EOL> CELERYD_PREFETCH_MULTIPLIER = <NUM_LIT:1> <EOL> CELERY_IMPORTS = ( "<STR_LIT>" , ) <EOL> CELERY_ANNOTATIONS = { <EOL> '<STR_LIT>' : { '<STR_LIT>' : <NUM_LIT> * <NUM_LIT:2> } <EOL> } </s>
<s> from totalimpact . providers import provider <EOL> from totalimpact . providers . provider import Provider , ProviderFactory <EOL> from totalimpactwebapp import app , db <EOL> from nose . tools import assert_equals , nottest <EOL> from xml . dom import minidom <EOL> from test . utils import setup_postgres_for_unittests , teardown_postgres_for_unittests <EOL> import simplejson , BeautifulSoup <EOL> import os <EOL> from sqlalchemy . sql import text <EOL> sampledir = os . path . join ( os . path . split ( __file__ ) [ <NUM_LIT:0> ] , "<STR_LIT>" ) <EOL> class Test_Provider ( ) : <EOL> TEST_PROVIDER_CONFIG = [ <EOL> ( "<STR_LIT>" , { "<STR_LIT>" : <NUM_LIT:1> } ) , <EOL> ( "<STR_LIT>" , { "<STR_LIT>" : <NUM_LIT:3> } ) , <EOL> ( "<STR_LIT>" , { "<STR_LIT>" : <NUM_LIT:3> } ) , <EOL> ] <EOL> TEST_JSON = """<STR_LIT>""" <EOL> TEST_XML = open ( os . path . join ( sampledir , "<STR_LIT>" , "<STR_LIT>" ) ) . read ( ) <EOL> def setUp ( self ) : <EOL> self . db = setup_postgres_for_unittests ( db , app ) <EOL> def tearDown ( self ) : <EOL> teardown_postgres_for_unittests ( self . db ) <EOL> def test_get_provider ( self ) : <EOL> provider = ProviderFactory . get_provider ( "<STR_LIT>" ) <EOL> assert_equals ( provider . __class__ . __name__ , "<STR_LIT>" ) <EOL> def test_get_providers ( self ) : <EOL> providers = ProviderFactory . get_providers ( self . TEST_PROVIDER_CONFIG ) <EOL> provider_names = [ provider . __class__ . __name__ for provider in providers ] <EOL> assert_equals ( set ( provider_names ) , set ( [ '<STR_LIT>' , '<STR_LIT>' , "<STR_LIT>" ] ) ) <EOL> def test_get_providers_filters_by_metrics ( self ) : <EOL> providers = ProviderFactory . get_providers ( self . TEST_PROVIDER_CONFIG , "<STR_LIT>" ) <EOL> provider_names = [ provider . __class__ . __name__ for provider in providers ] <EOL> assert_equals ( set ( provider_names ) , set ( [ '<STR_LIT>' , '<STR_LIT>' , "<STR_LIT>" ] ) ) <EOL> def test_get_providers_filters_by_biblio ( self ) : <EOL> providers = ProviderFactory . get_providers ( self . TEST_PROVIDER_CONFIG , "<STR_LIT>" ) <EOL> provider_names = [ provider . __class__ . __name__ for provider in providers ] <EOL> assert_equals ( set ( provider_names ) , set ( [ '<STR_LIT>' , '<STR_LIT>' ] ) ) <EOL> def test_get_providers_filters_by_aliases ( self ) : <EOL> providers = ProviderFactory . get_providers ( self . TEST_PROVIDER_CONFIG , "<STR_LIT>" ) <EOL> provider_names = [ provider . __class__ . __name__ for provider in providers ] <EOL> assert_equals ( set ( provider_names ) , set ( [ '<STR_LIT>' , '<STR_LIT>' ] ) ) <EOL> def test_lookup_json ( self ) : <EOL> page = self . TEST_JSON <EOL> data = simplejson . loads ( page ) <EOL> response = provider . _lookup_json ( data , [ '<STR_LIT>' , '<STR_LIT:name>' ] ) <EOL> assert_equals ( response , u'<STR_LIT>' ) <EOL> def test_extract_json ( self ) : <EOL> page = self . TEST_JSON <EOL> dict_of_keylists = { <EOL> '<STR_LIT:title>' : [ '<STR_LIT>' , '<STR_LIT:name>' ] , <EOL> '<STR_LIT:description>' : [ '<STR_LIT>' , '<STR_LIT:description>' ] } <EOL> response = provider . _extract_from_json ( page , dict_of_keylists ) <EOL> assert_equals ( response , { '<STR_LIT:description>' : u'<STR_LIT>' , '<STR_LIT:title>' : u'<STR_LIT>' } ) <EOL> def test_lookup_xml_from_dom ( self ) : <EOL> page = self . TEST_XML <EOL> doc = minidom . parseString ( page . strip ( ) ) <EOL> response = provider . _lookup_xml_from_dom ( doc , [ '<STR_LIT>' ] ) <EOL> assert_equals ( response , <NUM_LIT> ) <EOL> def test_lookup_xml_from_soup ( self ) : <EOL> page = self . TEST_XML <EOL> doc = BeautifulSoup . BeautifulStoneSoup ( page ) <EOL> response = provider . _lookup_xml_from_soup ( doc , [ '<STR_LIT>' ] ) <EOL> assert_equals ( response , <NUM_LIT> ) <EOL> def test_extract_xml ( self ) : <EOL> page = self . TEST_XML <EOL> dict_of_keylists = { <EOL> '<STR_LIT:count>' : [ '<STR_LIT>' ] } <EOL> response = provider . _extract_from_xml ( page , dict_of_keylists ) <EOL> assert_equals ( response , { '<STR_LIT:count>' : <NUM_LIT> } ) <EOL> def test_doi_from_url_string ( self ) : <EOL> test_url = "<STR_LIT>" <EOL> expected = "<STR_LIT>" <EOL> response = provider . doi_from_url_string ( test_url ) <EOL> assert_equals ( response , expected ) <EOL> def test_is_issn_in_doaj_false ( self ) : <EOL> response = provider . is_issn_in_doaj ( "<STR_LIT>" ) <EOL> assert_equals ( response , False ) <EOL> def test_is_issn_in_doaj_true ( self ) : <EOL> zookeys_issn = "<STR_LIT>" <EOL> response = provider . is_issn_in_doaj ( zookeys_issn ) <EOL> assert_equals ( response , True ) <EOL> def test_import_products ( self ) : <EOL> response = provider . import_products ( "<STR_LIT>" , <EOL> { "<STR_LIT>" : [ "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ] } ) <EOL> expected = [ ( '<STR_LIT>' , '<STR_LIT>' ) , ( '<STR_LIT:url>' , '<STR_LIT>' ) , ( '<STR_LIT>' , '<STR_LIT>' ) , ( '<STR_LIT>' , '<STR_LIT>' ) ] <EOL> assert_equals ( response , expected ) <EOL> def test_import_products_bad_providername ( self ) : <EOL> response = provider . import_products ( "<STR_LIT>" , { } ) <EOL> expected = [ ] <EOL> assert_equals ( response , expected ) <EOL> class TestProviderFactory ( ) : <EOL> TEST_PROVIDER_CONFIG = [ <EOL> ( "<STR_LIT>" , { "<STR_LIT>" : <NUM_LIT:1> } ) , <EOL> ( "<STR_LIT>" , { "<STR_LIT>" : <NUM_LIT:3> } ) , <EOL> ( "<STR_LIT>" , { "<STR_LIT>" : <NUM_LIT:3> } ) , <EOL> ] <EOL> def test_get_all_static_meta ( self ) : <EOL> sm = ProviderFactory . get_all_static_meta ( self . TEST_PROVIDER_CONFIG ) <EOL> expected = '<STR_LIT>' <EOL> assert_equals ( sm [ "<STR_LIT>" ] [ "<STR_LIT:description>" ] , expected ) <EOL> def test_get_all_metric_names ( self ) : <EOL> response = ProviderFactory . get_all_metric_names ( self . TEST_PROVIDER_CONFIG ) <EOL> expected = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> assert_equals ( response , expected ) <EOL> def test_get_all_metadata ( self ) : <EOL> md = ProviderFactory . get_all_metadata ( self . TEST_PROVIDER_CONFIG ) <EOL> print md [ "<STR_LIT>" ] <EOL> assert_equals ( md [ "<STR_LIT>" ] [ '<STR_LIT:url>' ] , '<STR_LIT>' ) </s>
<s> import datetime <EOL> import copy <EOL> import unicode_helpers <EOL> import json <EOL> import logging <EOL> from util import cached_property <EOL> from util import dict_from_dir <EOL> from totalimpactwebapp import db <EOL> logger = logging . getLogger ( "<STR_LIT>" ) <EOL> def clean_id ( nid ) : <EOL> try : <EOL> nid = nid . strip ( '<STR_LIT>' ) . strip ( ) <EOL> nid = unicode_helpers . remove_nonprinting_characters ( nid ) <EOL> except ( TypeError , AttributeError ) : <EOL> pass <EOL> return ( nid ) <EOL> def normalize_alias_tuple ( ns , nid ) : <EOL> ns = clean_id ( ns ) <EOL> ns = ns . lower ( ) <EOL> if ns == "<STR_LIT>" : <EOL> return ( ns , nid ) <EOL> nid = clean_id ( nid ) <EOL> from totalimpact . providers import crossref <EOL> from totalimpact . providers import pubmed <EOL> from totalimpact . providers import arxiv <EOL> from totalimpact . providers import webpage <EOL> from totalimpact import importer <EOL> clean_nid = None <EOL> if ns == "<STR_LIT>" or importer . is_doi ( nid ) : <EOL> ns = "<STR_LIT>" <EOL> clean_nid = crossref . clean_doi ( nid ) <EOL> elif ns == "<STR_LIT>" or importer . is_pmid ( nid ) : <EOL> ns = "<STR_LIT>" <EOL> clean_nid = pubmed . clean_pmid ( nid ) <EOL> elif ns == "<STR_LIT>" or importer . is_arxiv ( nid ) : <EOL> ns = "<STR_LIT>" <EOL> clean_nid = arxiv . clean_arxiv_id ( nid ) <EOL> elif ns == "<STR_LIT:url>" or importer . is_url ( nid ) : <EOL> ns = "<STR_LIT:url>" <EOL> clean_nid = webpage . clean_url ( nid ) <EOL> elif ns not in [ "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT:url>" ] : <EOL> clean_nid = nid <EOL> if not clean_nid : <EOL> return None <EOL> return ( ns , clean_nid ) <EOL> def clean_alias_tuple_for_comparing ( ns , nid ) : <EOL> alias_tuple = normalize_alias_tuple ( ns , nid ) <EOL> if not alias_tuple : <EOL> return None <EOL> try : <EOL> ( ns , nid ) = alias_tuple <EOL> cleaned_alias = ( ns . lower ( ) , nid . lower ( ) ) <EOL> except AttributeError : <EOL> logger . debug ( u"<STR_LIT>" . format ( <EOL> ns = ns , nid = nid ) ) <EOL> cleaned_alias = ( ns , nid ) <EOL> return cleaned_alias <EOL> def alias_tuples_from_dict ( aliases_dict ) : <EOL> """<STR_LIT>""" <EOL> alias_tuples = [ ] <EOL> for ns , ids in aliases_dict . iteritems ( ) : <EOL> if isinstance ( ids , basestring ) : <EOL> alias_tuples . append ( ( ns , ids ) ) <EOL> else : <EOL> for id in ids : <EOL> alias_tuples . append ( ( ns , id ) ) <EOL> return alias_tuples <EOL> def alias_dict_from_tuples ( aliases_tuples ) : <EOL> alias_dict = { } <EOL> for ( ns , ids ) in aliases_tuples : <EOL> if ns in alias_dict : <EOL> alias_dict [ ns ] += [ ids ] <EOL> else : <EOL> alias_dict [ ns ] = [ ids ] <EOL> return alias_dict <EOL> def canonical_aliases ( orig_aliases_dict ) : <EOL> lowercase_aliases_dict = { } <EOL> for orig_namespace in orig_aliases_dict : <EOL> lowercase_namespace = clean_id ( orig_namespace . lower ( ) ) <EOL> if lowercase_namespace == "<STR_LIT>" : <EOL> lowercase_aliases_dict [ lowercase_namespace ] = [ clean_id ( doi . lower ( ) ) for doi in orig_aliases_dict [ orig_namespace ] ] <EOL> else : <EOL> lowercase_aliases_dict [ lowercase_namespace ] = [ clean_id ( nid ) for nid in orig_aliases_dict [ orig_namespace ] ] <EOL> return lowercase_aliases_dict <EOL> def merge_alias_dicts ( aliases1 , aliases2 ) : <EOL> merged_aliases = copy . deepcopy ( aliases1 ) <EOL> for ns , nid_list in aliases2 . iteritems ( ) : <EOL> for nid in nid_list : <EOL> try : <EOL> if not nid in merged_aliases [ ns ] : <EOL> merged_aliases [ ns ] . append ( nid ) <EOL> except KeyError : <EOL> merged_aliases [ ns ] = [ nid ] <EOL> return merged_aliases <EOL> def matches_alias ( product1 , product2 , exclude = [ ] ) : <EOL> alias_tuple_list1 = [ alias_row . my_alias_tuple_for_comparing for alias_row in product1 . alias_rows ] <EOL> alias_tuple_list2 = [ alias_row . my_alias_tuple_for_comparing for alias_row in product2 . alias_rows ] <EOL> has_matches = False <EOL> for alias_tuple1 in alias_tuple_list1 : <EOL> if alias_tuple1 : <EOL> ( ns , nid ) = alias_tuple1 <EOL> if alias_tuple1 in alias_tuple_list2 and ns not in exclude : <EOL> has_matches = True <EOL> return has_matches <EOL> class AliasRow ( db . Model ) : <EOL> __tablename__ = '<STR_LIT>' <EOL> tiid = db . Column ( db . Text , db . ForeignKey ( '<STR_LIT>' ) , primary_key = True ) <EOL> namespace = db . Column ( db . Text , primary_key = True ) <EOL> nid = db . Column ( db . Text , primary_key = True ) <EOL> collected_date = db . Column ( db . DateTime ( ) ) <EOL> def __init__ ( self , ** kwargs ) : <EOL> if "<STR_LIT>" not in kwargs : <EOL> self . collected_date = datetime . datetime . utcnow ( ) <EOL> super ( AliasRow , self ) . __init__ ( ** kwargs ) <EOL> @ cached_property <EOL> def alias_tuple ( self ) : <EOL> return ( self . namespace , self . nid ) <EOL> @ cached_property <EOL> def my_alias_tuple_for_comparing ( self ) : <EOL> return clean_alias_tuple_for_comparing ( self . namespace , self . nid ) <EOL> def is_equivalent_alias ( self , given_namespace , given_nid ) : <EOL> if not given_nid : <EOL> return False <EOL> given_clean_alias = clean_alias_tuple_for_comparing ( given_namespace , given_nid ) <EOL> if not given_clean_alias : <EOL> return False <EOL> return given_clean_alias == self . my_alias_tuple_for_comparing <EOL> class Aliases ( object ) : <EOL> def __init__ ( self , alias_rows ) : <EOL> ignore_namepaces = [ "<STR_LIT>" ] <EOL> self . tiid = None <EOL> for alias_row in alias_rows : <EOL> if alias_row . namespace not in ignore_namepaces : <EOL> self . tiid = alias_row . tiid <EOL> try : <EOL> getattr ( self , alias_row . namespace ) . append ( alias_row . nid ) <EOL> except AttributeError : <EOL> setattr ( self , alias_row . namespace , [ alias_row . nid ] ) <EOL> @ cached_property <EOL> def best_url ( self ) : <EOL> if self . display_doi : <EOL> return u"<STR_LIT>" + self . display_doi <EOL> if self . display_pmid : <EOL> return u"<STR_LIT>" + self . display_pmid <EOL> if self . display_pmc : <EOL> return u"<STR_LIT>" + self . display_pmc <EOL> if self . resolved_url : <EOL> return self . resolved_url <EOL> try : <EOL> return self . url [ <NUM_LIT:0> ] <EOL> except AttributeError : <EOL> return None <EOL> @ cached_property <EOL> def display_best_url ( self ) : <EOL> return self . best_url <EOL> @ cached_property <EOL> def display_pmid ( self ) : <EOL> try : <EOL> return self . pmid [ <NUM_LIT:0> ] <EOL> except AttributeError : <EOL> return None <EOL> @ cached_property <EOL> def display_pmc ( self ) : <EOL> try : <EOL> return self . pmc [ <NUM_LIT:0> ] <EOL> except AttributeError : <EOL> return None <EOL> @ cached_property <EOL> def display_doi ( self ) : <EOL> try : <EOL> return self . doi [ <NUM_LIT:0> ] <EOL> except AttributeError : <EOL> return None <EOL> @ cached_property <EOL> def display_arxiv ( self ) : <EOL> try : <EOL> return self . arxiv [ <NUM_LIT:0> ] <EOL> except AttributeError : <EOL> return None <EOL> @ cached_property <EOL> def has_formal_alias ( self ) : <EOL> if self . display_arxiv or self . display_doi or self . display_pmid or self . display_pmc : <EOL> return True <EOL> else : <EOL> return False <EOL> @ cached_property <EOL> def resolved_url ( self ) : <EOL> try : <EOL> for url in self . url : <EOL> if "<STR_LIT>" in url : <EOL> continue <EOL> elif "<STR_LIT>" in url : <EOL> continue <EOL> elif "<STR_LIT>" in url : <EOL> continue <EOL> elif "<STR_LIT>" in url : <EOL> continue <EOL> elif "<STR_LIT>" in url : <EOL> continue <EOL> else : <EOL> return url <EOL> return self . url [ <NUM_LIT:0> ] <EOL> except AttributeError : <EOL> return None <EOL> def get_genre ( self ) : <EOL> return self . _guess_genre_and_host_from_aliases ( ) [ <NUM_LIT:0> ] <EOL> def get_host ( self ) : <EOL> return self . _guess_genre_and_host_from_aliases ( ) [ <NUM_LIT:1> ] <EOL> def _guess_genre_and_host_from_aliases ( self ) : <EOL> """<STR_LIT>""" <EOL> genre = "<STR_LIT>" <EOL> host = "<STR_LIT>" <EOL> if hasattr ( self , "<STR_LIT>" ) : <EOL> joined_doi_string = "<STR_LIT>" . join ( self . doi ) . lower ( ) <EOL> if "<STR_LIT>" in joined_doi_string : <EOL> genre = "<STR_LIT>" <EOL> host = "<STR_LIT>" <EOL> elif "<STR_LIT>" in joined_doi_string : <EOL> host = "<STR_LIT>" <EOL> genre = "<STR_LIT>" <EOL> else : <EOL> genre = "<STR_LIT>" <EOL> elif hasattr ( self , "<STR_LIT>" ) : <EOL> genre = "<STR_LIT>" <EOL> elif hasattr ( self , "<STR_LIT>" ) : <EOL> genre = "<STR_LIT>" <EOL> host = "<STR_LIT>" <EOL> elif hasattr ( self , "<STR_LIT>" ) : <EOL> genre = "<STR_LIT>" <EOL> host = "<STR_LIT>" <EOL> elif hasattr ( self , "<STR_LIT>" ) : <EOL> genre = "<STR_LIT>" <EOL> host = "<STR_LIT>" <EOL> elif hasattr ( self , "<STR_LIT:url>" ) : <EOL> joined_url_string = "<STR_LIT>" . join ( self . url ) . lower ( ) <EOL> if "<STR_LIT>" in joined_url_string : <EOL> genre = "<STR_LIT>" <EOL> host = "<STR_LIT>" <EOL> elif "<STR_LIT>" in joined_url_string : <EOL> genre = "<STR_LIT>" <EOL> host = "<STR_LIT>" <EOL> elif ( "<STR_LIT>" in joined_url_string ) or ( "<STR_LIT>" in joined_url_string ) : <EOL> genre = "<STR_LIT>" <EOL> host = "<STR_LIT>" <EOL> elif "<STR_LIT>" in joined_url_string : <EOL> genre = "<STR_LIT>" <EOL> host = "<STR_LIT>" <EOL> else : <EOL> genre = "<STR_LIT>" <EOL> return genre , host <EOL> def to_dict ( self ) : <EOL> ret = dict_from_dir ( self ) <EOL> return ret </s>
<s> from totalimpactwebapp import json_sqlalchemy <EOL> from util import commit <EOL> from util import cached_property <EOL> from util import dict_from_dir <EOL> from util import as_int_or_float_if_possible <EOL> from totalimpactwebapp import db <EOL> from totalimpactwebapp . tweeter import Tweeter <EOL> from birdy . twitter import AppClient , TwitterApiError , TwitterRateLimitError , TwitterClientError <EOL> from collections import defaultdict <EOL> from sqlalchemy import case <EOL> import os <EOL> import re <EOL> import datetime <EOL> import logging <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def tweets_from_tiids ( tiids ) : <EOL> if not tiids : <EOL> return [ ] <EOL> tweets = db . session . query ( Tweet ) . filter ( Tweet . tiid . in_ ( tiids ) ) . all ( ) <EOL> return tweets <EOL> def get_product_tweets_for_profile ( profile_id ) : <EOL> tweets = db . session . query ( Tweet ) . filter ( Tweet . profile_id == profile_id ) . all ( ) <EOL> response = defaultdict ( list ) <EOL> for tweet in tweets : <EOL> if tweet . tiid and tweet . tweet_text : <EOL> response [ tweet . tiid ] . append ( tweet ) <EOL> return response <EOL> def store_tweet_payload_and_tweeter_from_twitter ( payload_dicts_from_twitter , tweets ) : <EOL> tweets_by_tweet_id = defaultdict ( list ) <EOL> for tweet in tweets : <EOL> tweets_by_tweet_id [ tweet . tweet_id ] . append ( tweet ) <EOL> for payload_dict in payload_dicts_from_twitter : <EOL> tweet_id = payload_dict [ "<STR_LIT>" ] <EOL> logger . debug ( "<STR_LIT>" . format ( <EOL> tweet_id = tweet_id ) ) <EOL> for tweet in tweets_by_tweet_id [ tweet_id ] : <EOL> if not tweet . payload : <EOL> tweet . payload = payload_dict <EOL> logger . info ( u"<STR_LIT>" . format ( <EOL> tweet_id = tweet_id , tiid = tweet . tiid ) ) <EOL> if "<STR_LIT:user>" in payload_dict : <EOL> try : <EOL> tweet . tweeter . set_attributes_from_twitter_data ( payload_dict [ "<STR_LIT:user>" ] ) <EOL> except AttributeError : <EOL> tweeter = Tweeter . query . get ( tweet . screen_name ) <EOL> if not tweeter : <EOL> tweeter = Tweeter ( screen_name = tweet . screen_name ) <EOL> db . session . add ( tweeter ) <EOL> tweeter . set_attributes_from_twitter_data ( payload_dict [ "<STR_LIT:user>" ] ) <EOL> tweet . tweeter = tweeter <EOL> commit ( db ) <EOL> if tweet . tweeter : <EOL> logger . info ( u"<STR_LIT>" . format ( <EOL> screen_name = tweet . tweeter . screen_name ) ) <EOL> def flag_deleted_tweets ( tweet_ids ) : <EOL> if not tweet_ids : <EOL> return None <EOL> for tweet in Tweet . query . filter ( Tweet . tweet_id . in_ ( tweet_ids ) ) . all ( ) : <EOL> tweet . is_deleted = True <EOL> db . session . merge ( tweet ) <EOL> def handle_all_tweets ( data , tweets ) : <EOL> store_tweet_payload_and_tweeter_from_twitter ( data , tweets ) <EOL> tweet_ids = [ tweet . tweet_id for tweet in tweets ] <EOL> tweet_ids_with_response = [ tweet [ "<STR_LIT>" ] for tweet in data ] <EOL> tweet_ids_without_response = [ tweet for tweet in tweet_ids if tweet not in tweet_ids_with_response ] <EOL> flag_deleted_tweets ( tweet_ids_without_response ) <EOL> return True <EOL> class AppDictClient ( AppClient ) : <EOL> @ staticmethod <EOL> def get_json_object_hook ( data ) : <EOL> return data <EOL> def get_and_save_tweet_text_and_tweeter_followers ( tweets ) : <EOL> client = AppDictClient ( <EOL> os . getenv ( "<STR_LIT>" ) , <EOL> os . getenv ( "<STR_LIT>" ) , <EOL> access_token = os . getenv ( "<STR_LIT>" ) <EOL> ) <EOL> logger . info ( u"<STR_LIT>" . format ( <EOL> num = len ( tweets ) ) ) <EOL> group_size = <NUM_LIT:100> <EOL> list_of_groups = [ tweets [ i : i + group_size ] for i in range ( <NUM_LIT:0> , len ( tweets ) , group_size ) ] <EOL> for tweet_subset in list_of_groups : <EOL> tweet_id_string = "<STR_LIT:U+002C>" . join ( [ tweet . tweet_id for tweet in tweet_subset ] ) <EOL> try : <EOL> response = client . api . statuses . lookup . post ( id = tweet_id_string , trim_user = False ) <EOL> handle_all_tweets ( response . data , tweet_subset ) <EOL> except TwitterApiError , e : <EOL> logger . exception ( "<STR_LIT>" ) <EOL> except TwitterClientError , e : <EOL> logger . exception ( "<STR_LIT>" ) <EOL> except TwitterRateLimitError , e : <EOL> logger . exception ( "<STR_LIT>" ) <EOL> return <EOL> def hydrate_twitter_text_and_followers ( profile_id , altmetric_twitter_posts ) : <EOL> logger . info ( u"<STR_LIT>" . format ( <EOL> profile_id = profile_id ) ) <EOL> tweets_to_hydrate_from_twitter = [ ] <EOL> tweets = Tweet . query . filter ( Tweet . profile_id == profile_id ) <EOL> tweet_dict = dict ( [ ( ( tweet . tweet_id , tweet . tiid ) , tweet ) for tweet in tweets ] ) <EOL> for tiid , post_list in altmetric_twitter_posts . iteritems ( ) : <EOL> for post in post_list : <EOL> tweet_id = post [ "<STR_LIT>" ] <EOL> screen_name = post [ "<STR_LIT>" ] [ "<STR_LIT>" ] <EOL> if ( tweet_id , tiid ) in tweet_dict . keys ( ) : <EOL> tweet = tweet_dict [ ( tweet_id , tiid ) ] <EOL> if not tweet . tweet_text and not tweet . is_deleted : <EOL> tweets_to_hydrate_from_twitter . append ( tweet ) <EOL> else : <EOL> if not Tweet . query . get ( ( tweet_id , tiid ) ) : <EOL> tweet = Tweet ( tweet_id = tweet_id , tiid = tiid ) <EOL> tweet . set_attributes_from_altmetric_post ( post ) <EOL> tweet . profile_id = profile_id <EOL> tweets_to_hydrate_from_twitter . append ( tweet ) <EOL> db . session . add ( tweet ) <EOL> if not tweet . tweeter : <EOL> tweeter = Tweeter . query . get ( screen_name ) <EOL> if not tweeter : <EOL> tweeter = Tweeter ( screen_name = screen_name ) <EOL> db . session . add ( tweeter ) <EOL> tweeter . set_attributes_from_altmetric_post ( post ) <EOL> commit ( db ) <EOL> logger . info ( u"<STR_LIT>" . format ( <EOL> profile_id = profile_id ) ) <EOL> if tweets_to_hydrate_from_twitter : <EOL> commit ( db ) <EOL> tweet_ids = [ tweet . tweet_id for tweet in tweets_to_hydrate_from_twitter ] <EOL> logger . info ( u"<STR_LIT>" . format ( <EOL> profile_id = profile_id ) ) <EOL> get_and_save_tweet_text_and_tweeter_followers ( tweets_to_hydrate_from_twitter ) <EOL> commit ( db ) <EOL> else : <EOL> logger . info ( u"<STR_LIT>" . format ( <EOL> profile_id = profile_id ) ) <EOL> return <EOL> handle_workaround_join_string = "<STR_LIT>" <EOL> class Tweet ( db . Model ) : <EOL> tweet_id = db . Column ( db . Text , primary_key = True ) <EOL> tiid = db . Column ( db . Text , primary_key = True ) <EOL> profile_id = db . Column ( db . Integer , db . ForeignKey ( '<STR_LIT>' ) ) <EOL> screen_name = db . Column ( db . Text , db . ForeignKey ( '<STR_LIT>' ) ) <EOL> tweet_timestamp = db . Column ( db . DateTime ( ) ) <EOL> payload = db . Column ( json_sqlalchemy . JSONAlchemy ( db . Text ) ) <EOL> is_deleted = db . Column ( db . Boolean ) <EOL> tweet_url = db . Column ( db . Text ) <EOL> country = db . Column ( db . Text ) <EOL> followers_at_time_of_tweet = db . Column ( db . Integer ) <EOL> tweeter = db . relationship ( <EOL> '<STR_LIT>' , <EOL> lazy = '<STR_LIT>' , <EOL> cascade = '<STR_LIT:all>' , <EOL> backref = db . backref ( "<STR_LIT>" ) , <EOL> uselist = False , <EOL> primaryjoin = handle_workaround_join_string <EOL> ) <EOL> def __init__ ( self , ** kwargs ) : <EOL> if "<STR_LIT>" in kwargs : <EOL> payload_dict = kwargs [ "<STR_LIT>" ] <EOL> kwargs [ "<STR_LIT>" ] = payload_dict [ "<STR_LIT>" ] <EOL> kwargs [ "<STR_LIT>" ] = payload_dict [ "<STR_LIT:user>" ] [ "<STR_LIT>" ] <EOL> kwargs [ "<STR_LIT>" ] = payload_dict <EOL> kwargs [ "<STR_LIT>" ] = datetime . datetime . strptime ( payload_dict [ "<STR_LIT>" ] , r"<STR_LIT>" ) <EOL> if not "<STR_LIT>" in kwargs : <EOL> try : <EOL> kwargs [ "<STR_LIT>" ] = payload_dict [ "<STR_LIT>" ] [ "<STR_LIT>" ] <EOL> except ( AttributeError , TypeError ) : <EOL> pass <EOL> super ( Tweet , self ) . __init__ ( ** kwargs ) <EOL> @ classmethod <EOL> def most_recent_tweet_id ( cls , screen_name ) : <EOL> screen_name = screen_name . replace ( "<STR_LIT:@>" , "<STR_LIT>" ) <EOL> q = db . session . query ( Tweet ) . filter ( Tweet . screen_name == screen_name ) . order_by ( Tweet . tweet_timestamp . desc ( ) ) <EOL> tweet = q . first ( ) <EOL> try : <EOL> tweet_id = tweet . tweet_id <EOL> except AttributeError : <EOL> tweet_id = None <EOL> return tweet_id <EOL> @ cached_property <EOL> def tweet_text ( self ) : <EOL> try : <EOL> return self . payload [ "<STR_LIT:text>" ] <EOL> except TypeError : <EOL> return None <EOL> @ cached_property <EOL> def tweet_text_with_links ( self ) : <EOL> if self . tweet_text is None : <EOL> return None <EOL> ret = self . tweet_text <EOL> ret = re . sub ( r"<STR_LIT>" , r"<STR_LIT>" , ret ) <EOL> for url_info in self . urls : <EOL> my_link = u"<STR_LIT>" . format ( <EOL> url = url_info [ "<STR_LIT>" ] , <EOL> display_url = url_info [ "<STR_LIT>" ] <EOL> ) <EOL> ret = re . sub ( r"<STR_LIT>" , my_link , ret , <NUM_LIT:1> ) <EOL> ret = re . sub ( r"<STR_LIT>" , r"<STR_LIT>" , ret ) <EOL> ret = re . sub ( r"<STR_LIT>" , r"<STR_LIT>" , ret ) <EOL> return ret <EOL> @ cached_property <EOL> def urls ( self ) : <EOL> try : <EOL> return self . payload [ "<STR_LIT>" ] [ "<STR_LIT>" ] <EOL> except TypeError : <EOL> return None <EOL> except KeyError : <EOL> return [ ] <EOL> @ cached_property <EOL> def has_country ( self ) : <EOL> return self . country != None <EOL> def set_attributes_from_altmetric_post ( self , post ) : <EOL> self . tweet_id = post [ "<STR_LIT>" ] <EOL> self . screen_name = post [ "<STR_LIT>" ] [ "<STR_LIT>" ] <EOL> self . tweet_timestamp = post [ "<STR_LIT>" ] <EOL> if "<STR_LIT>" in post [ "<STR_LIT>" ] : <EOL> self . country = post [ "<STR_LIT>" ] [ "<STR_LIT>" ] . get ( "<STR_LIT>" , None ) <EOL> return self <EOL> def __repr__ ( self ) : <EOL> return u'<STR_LIT>' . format ( <EOL> tweet_id = self . tweet_id , <EOL> profile_id = self . profile_id , <EOL> screen_name = self . screen_name , <EOL> timestamp = self . tweet_timestamp ) <EOL> def to_dict ( self ) : <EOL> attributes_to_ignore = [ <EOL> "<STR_LIT>" <EOL> ] <EOL> ret = dict_from_dir ( self , attributes_to_ignore ) <EOL> return ret <EOL> twitter_example_contents = """<STR_LIT>""" </s>
<s> import os <EOL> import numpy as np <EOL> def load_gender_data ( ntrain = <NUM_LIT> , ntest = <NUM_LIT> ) : <EOL> import pandas as pd <EOL> file_loc = os . path . dirname ( os . path . realpath ( __file__ ) ) <EOL> relative_path = "<STR_LIT>" <EOL> fullpath = os . path . join ( file_loc , relative_path ) <EOL> data = pd . read_csv ( fullpath , nrows = ntrain + ntest ) <EOL> X = data [ '<STR_LIT:text>' ] . values <EOL> X = [ str ( x ) for x in X ] <EOL> Y = data [ '<STR_LIT>' ] . values <EOL> trX = X [ : - ntest ] <EOL> teX = X [ - ntest : ] <EOL> trY = Y [ : - ntest ] <EOL> teY = Y [ - ntest : ] <EOL> return trX , teX , trY , teY <EOL> def load_mnist ( data_dir = None ) : <EOL> if data_dir is None : <EOL> import urllib <EOL> import gzip <EOL> url = '<STR_LIT>' <EOL> fnames = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' <EOL> ] <EOL> for fname in fnames : <EOL> if not os . path . isfile ( fname ) : <EOL> print '<STR_LIT>' , fname <EOL> urllib . urlretrieve ( url + fname , fname ) <EOL> data_dir = '<STR_LIT>' <EOL> fd = gzip . open ( os . path . join ( data_dir , '<STR_LIT>' ) ) <EOL> loaded = np . fromstring ( fd . read ( ) , dtype = np . uint8 ) <EOL> trX = loaded [ <NUM_LIT:16> : ] . reshape ( ( <NUM_LIT> , - <NUM_LIT:1> ) ) <EOL> fd = gzip . open ( os . path . join ( data_dir , '<STR_LIT>' ) ) <EOL> loaded = np . fromstring ( fd . read ( ) , dtype = np . uint8 ) <EOL> trY = loaded [ <NUM_LIT:8> : ] . reshape ( ( <NUM_LIT> ) ) <EOL> fd = gzip . open ( os . path . join ( data_dir , '<STR_LIT>' ) ) <EOL> loaded = np . fromstring ( fd . read ( ) , dtype = np . uint8 ) <EOL> teX = loaded [ <NUM_LIT:16> : ] . reshape ( ( <NUM_LIT> , - <NUM_LIT:1> ) ) <EOL> fd = gzip . open ( os . path . join ( data_dir , '<STR_LIT>' ) ) <EOL> loaded = np . fromstring ( fd . read ( ) , dtype = np . uint8 ) <EOL> teY = loaded [ <NUM_LIT:8> : ] . reshape ( ( <NUM_LIT> ) ) <EOL> trX = trX / <NUM_LIT> <EOL> teX = teX / <NUM_LIT> <EOL> trX = trX . reshape ( - <NUM_LIT:1> , <NUM_LIT> , <NUM_LIT> ) <EOL> teX = teX . reshape ( - <NUM_LIT:1> , <NUM_LIT> , <NUM_LIT> ) <EOL> return trX , teX , trY , teY </s>
<s> import unittest <EOL> import os <EOL> import commands <EOL> from utils import get_temporary_location <EOL> from utils import delete_repository <EOL> from gitpy import LocalRepository <EOL> from gitpy import find_repository <EOL> from gitpy . exceptions import GitException <EOL> class EmptyRepositoryTest ( unittest . TestCase ) : <EOL> def setUp ( self ) : <EOL> self . dirname = get_temporary_location ( ) <EOL> self . repo = LocalRepository ( self . dirname ) <EOL> self . assertFalse ( os . path . exists ( self . dirname ) ) <EOL> self . assertFalse ( self . repo . isValid ( ) ) <EOL> def tearDown ( self ) : <EOL> if os . path . exists ( self . dirname ) : <EOL> delete_repository ( self . repo ) <EOL> class BasicRepositories ( EmptyRepositoryTest ) : <EOL> def testRepositoryInit ( self ) : <EOL> self . repo . init ( ) <EOL> self . assertTrue ( self . repo . isValid ( ) ) <EOL> self . failUnless ( os . path . isdir ( self . dirname ) ) <EOL> self . failUnless ( os . path . isdir ( os . path . join ( self . dirname , "<STR_LIT>" ) ) ) <EOL> def testConfiguration ( self ) : <EOL> self . repo . init ( ) <EOL> self . repo . config . setParameter ( '<STR_LIT>' , <NUM_LIT:2> ) <EOL> self . assertEquals ( self . repo . config . getParameter ( '<STR_LIT>' ) , '<STR_LIT:2>' ) <EOL> def testRepositoryInitWhenExists ( self ) : <EOL> os . mkdir ( self . dirname ) <EOL> self . repo . init ( ) <EOL> self . failUnless ( os . path . isdir ( self . dirname ) ) <EOL> self . failUnless ( os . path . isdir ( os . path . join ( self . dirname , "<STR_LIT>" ) ) ) <EOL> class ModifiedRepositoryTest ( EmptyRepositoryTest ) : <EOL> FILENAME = "<STR_LIT>" <EOL> def setUp ( self ) : <EOL> super ( ModifiedRepositoryTest , self ) . setUp ( ) <EOL> self . repo . init ( ) <EOL> with open ( os . path . join ( self . repo . path , self . FILENAME ) , "<STR_LIT:wb>" ) as f : <EOL> print >> f , "<STR_LIT>" <EOL> self . assertFalse ( self . repo . isWorkingDirectoryClean ( ) ) <EOL> class ModifiedRepositories ( ModifiedRepositoryTest ) : <EOL> def testStatus ( self ) : <EOL> untracked = self . repo . getUntrackedFiles ( ) <EOL> self . assertEquals ( untracked , [ self . FILENAME ] ) <EOL> def testAdding ( self ) : <EOL> untracked_files = self . repo . getUntrackedFiles ( ) <EOL> for u in untracked_files : <EOL> self . repo . add ( u ) <EOL> self . assertEquals ( self . repo . getStagedFiles ( ) , untracked_files ) <EOL> self . assertFalse ( self . repo . isWorkingDirectoryClean ( ) ) <EOL> def testCommitting ( self ) : <EOL> self . repo . addAll ( ) <EOL> self . assertNotEquals ( self . repo . getStagedFiles ( ) , [ ] ) <EOL> c = self . repo . commit ( message = "<STR_LIT>" ) <EOL> self . assertTrue ( self . repo . isWorkingDirectoryClean ( ) ) <EOL> self . assertEquals ( self . repo . getStagedFiles ( ) , [ ] ) <EOL> class CleaningUntrackedFiles ( ModifiedRepositoryTest ) : <EOL> def _clean ( self ) : <EOL> self . repo . cleanUntrackedFiles ( ) <EOL> self . failIf ( self . repo . getUntrackedFiles ( ) ) <EOL> def testCleaningUpUntrackedFiles ( self ) : <EOL> with open ( os . path . join ( self . repo . path , "<STR_LIT>" ) , "<STR_LIT:wb>" ) as f : <EOL> print >> f , "<STR_LIT:data>" <EOL> self . failUnless ( self . repo . getUntrackedFiles ( ) ) <EOL> self . _clean ( ) <EOL> dirpath = os . path . join ( self . repo . path , "<STR_LIT>" ) <EOL> os . mkdir ( dirpath ) <EOL> self . _clean ( ) <EOL> self . failIf ( os . path . exists ( dirpath ) ) <EOL> class TestAPI ( ModifiedRepositoryTest ) : <EOL> def test_find_repository ( self ) : <EOL> prev_path = os . path . realpath ( "<STR_LIT:.>" ) <EOL> subpath = os . path . join ( self . repo . path , "<STR_LIT:a>" , "<STR_LIT:b>" , "<STR_LIT:c>" ) <EOL> os . makedirs ( subpath ) <EOL> os . chdir ( subpath ) <EOL> try : <EOL> repo = find_repository ( ) <EOL> finally : <EOL> os . chdir ( prev_path ) <EOL> self . failUnless ( repo . path == self . repo . path ) <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL> unittest . main ( ) </s>
<s> import logging <EOL> from okcupyd . db import model , txn , with_txn <EOL> log = logging . getLogger ( __name__ ) <EOL> class UserAdapter ( object ) : <EOL> def __init__ ( self , profile ) : <EOL> self . profile = profile <EOL> def build ( self , session ) : <EOL> found = model . User . query_no_txn ( session , model . User . handle == <EOL> self . profile . username ) <EOL> if found : <EOL> return found [ <NUM_LIT:0> ] <EOL> else : <EOL> return model . User ( okc_id = self . profile . id , <EOL> handle = self . profile . username , <EOL> age = self . profile . age , <EOL> location = self . profile . location ) <EOL> def get_no_txn ( self , session ) : <EOL> return model . User . upsert_one_no_txn ( session , self . build ( session ) , <EOL> id_key = '<STR_LIT>' ) <EOL> get = with_txn ( get_no_txn ) <EOL> class ThreadAdapter ( object ) : <EOL> def __init__ ( self , thread ) : <EOL> self . thread = thread <EOL> def _get_thread ( self , session ) : <EOL> initiator = UserAdapter ( self . thread . initiator ) . get_no_txn ( session ) <EOL> respondent = UserAdapter ( self . thread . respondent ) . get_no_txn ( session ) <EOL> message_thread = model . MessageThread ( okc_id = self . thread . id , <EOL> initiator = initiator , <EOL> respondent = respondent ) <EOL> return model . MessageThread . upsert_one_no_txn ( session , message_thread , <EOL> id_key = '<STR_LIT>' ) <EOL> def _add_messages ( self , thread_model ) : <EOL> existing_message_ids = set ( [ m . okc_id for m in thread_model . messages ] ) <EOL> new_messages = [ message for message in self . thread . messages <EOL> if message . id not in existing_message_ids ] <EOL> new_message_models = [ ] <EOL> for new_message in new_messages : <EOL> from_initiator = thread_model . initiator . handle . lower ( ) == new_message . sender . username . lower ( ) <EOL> sender , recipient = ( thread_model . initiator , <EOL> thread_model . respondent ) if from_initiator else ( thread_model . respondent , <EOL> thread_model . initiator ) <EOL> new_message_model = model . Message ( okc_id = new_message . id , <EOL> text = new_message . content , <EOL> sender = sender , <EOL> recipient = recipient , <EOL> time_sent = new_message . time_sent ) <EOL> new_message_models . append ( new_message_model ) <EOL> thread_model . messages . append ( new_message_model ) <EOL> return new_message_models <EOL> def add_messages ( self ) : <EOL> with txn ( ) as session : <EOL> thread_model = model . MessageThread . find_no_txn ( session , <EOL> self . thread . id , <EOL> id_key = '<STR_LIT>' ) <EOL> return self . _add_messages ( thread_model ) <EOL> def get_thread ( self ) : <EOL> with txn ( ) as session : <EOL> thread_model = self . _get_thread ( session ) <EOL> return thread_model , self . _add_messages ( thread_model ) </s>
<s> import logging <EOL> from invoke import task <EOL> import IPython <EOL> from okcupyd import db <EOL> from okcupyd import util <EOL> from okcupyd . db import mailbox , model <EOL> from okcupyd . user import User <EOL> log = logging . getLogger ( __name__ ) <EOL> @ task ( default = True ) <EOL> def session ( ) : <EOL> with db . txn ( ) as session : <EOL> IPython . embed ( ) <EOL> @ task <EOL> def reset ( ) : <EOL> util . enable_logger ( __name__ ) <EOL> log . info ( db . Base . metadata . bind ) <EOL> db . Base . metadata . drop_all ( ) <EOL> db . Base . metadata . create_all ( ) <EOL> @ task <EOL> def sync ( ) : <EOL> user = User ( ) <EOL> mailbox . Sync ( user ) . all ( ) <EOL> log . info ( model . Message . query ( model . User . okc_id == user . profile . id ) ) <EOL> @ task <EOL> def make ( ) : <EOL> user = User ( ) <EOL> user_model = model . User . from_profile ( user . profile ) <EOL> user_model . upsert_model ( id_key = '<STR_LIT>' ) <EOL> okcupyd_user = model . OKCupydUser ( user_id = user_model . id ) <EOL> okcupyd_user . upsert_model ( id_key = '<STR_LIT>' ) <EOL> return okcupyd_user </s>
<s> from . import util <EOL> from okcupyd import User , photo <EOL> @ util . use_cassette ( path = '<STR_LIT>' , <EOL> match_on = util . match_on_no_body ) <EOL> def test_photo_upload ( ) : <EOL> uploader = photo . PhotoUploader ( ) <EOL> upload_response_dict = uploader . upload_and_confirm ( '<STR_LIT>' ) <EOL> assert int ( upload_response_dict [ '<STR_LIT:id>' ] ) > <NUM_LIT:0> <EOL> @ util . use_cassette ( path = '<STR_LIT>' , match_on = util . match_on_no_body ) <EOL> def test_photo_delete ( ) : <EOL> user = User ( ) <EOL> response_dict = user . photo . upload_and_confirm ( user . quickmatch ( ) . photo_infos [ <NUM_LIT:0> ] ) <EOL> before_delete_photos = user . profile . photo_infos <EOL> user . photo . delete ( response_dict [ '<STR_LIT:id>' ] ) <EOL> user . profile . refresh ( ) <EOL> assert len ( before_delete_photos ) - <NUM_LIT:1> == len ( user . profile . photo_infos ) <EOL> def test_make_photo_uri_from_https_link ( ) : <EOL> photo_info = photo . Info . from_cdn_uri ( <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> ) <EOL> assert photo_info . id == <NUM_LIT> <EOL> assert photo_info . thumb_nail_top == <NUM_LIT> <EOL> @ util . use_cassette <EOL> def test_photo_info_upload ( vcr_live_sleep ) : <EOL> user = User ( ) <EOL> response = user . photo . upload_and_confirm ( user . quickmatch ( ) . photo_infos [ <NUM_LIT:0> ] ) <EOL> vcr_live_sleep ( <NUM_LIT:2> ) <EOL> assert int ( response [ '<STR_LIT:id>' ] ) in [ pi . id for pi in user . profile . photo_infos ] </s>
<s> import theano <EOL> import theano . tensor as T <EOL> from theano . sandbox . rng_mrg import MRG_RandomStreams <EOL> from theano . tensor . nnet . conv import conv2d <EOL> from theano . tensor . signal . downsample import max_pool_2d <EOL> from theano . tensor . shared_randomstreams import RandomStreams <EOL> import numpy as np <EOL> from toolbox import * <EOL> from modelbase import * <EOL> class LM_gru ( ModelLMBase ) : <EOL> def __init__ ( self , data , hp ) : <EOL> super ( LM_gru , self ) . __init__ ( self . __class__ . __name__ , data , hp ) <EOL> self . n_h = <NUM_LIT> <EOL> self . dropout = <NUM_LIT:0.5> <EOL> self . params = Parameters ( ) <EOL> self . hiddenstates = Parameters ( ) <EOL> n_tokens = self . data [ '<STR_LIT>' ] <EOL> n_h = self . n_h <EOL> scale = hp . init_scale <EOL> gates = <NUM_LIT:3> <EOL> with self . hiddenstates : <EOL> b1_h = shared_zeros ( ( self . hp . batch_size , n_h ) ) <EOL> b2_h = shared_zeros ( ( self . hp . batch_size , n_h ) ) <EOL> if hp . load_model and os . path . isfile ( self . filename ) : <EOL> self . params . load ( self . filename ) <EOL> else : <EOL> with self . params : <EOL> W_emb = shared_normal ( ( n_tokens , n_h ) , scale = scale ) <EOL> W1 = shared_normal ( ( n_h , n_h * gates ) , scale = scale * <NUM_LIT> ) <EOL> V1 = shared_normal ( ( n_h , n_h * gates ) , scale = scale * <NUM_LIT> ) <EOL> b1 = shared_zeros ( ( n_h * gates ) ) <EOL> W2 = shared_normal ( ( n_h , n_h * gates ) , scale = scale * <NUM_LIT> ) <EOL> V2 = shared_normal ( ( n_h , n_h * gates ) , scale = scale * <NUM_LIT> ) <EOL> b2 = shared_zeros ( ( n_h * gates , ) ) <EOL> def lstm ( X , h , c , W , U , b ) : <EOL> g_on = T . dot ( X , W ) + T . dot ( h , U ) + b <EOL> i_on = T . nnet . sigmoid ( g_on [ : , : n_h ] ) <EOL> f_on = T . nnet . sigmoid ( g_on [ : , n_h : <NUM_LIT:2> * n_h ] ) <EOL> o_on = T . nnet . sigmoid ( g_on [ : , <NUM_LIT:2> * n_h : <NUM_LIT:3> * n_h ] ) <EOL> c = f_on * c + i_on * T . tanh ( g_on [ : , <NUM_LIT:3> * n_h : ] ) <EOL> h = o_on * T . tanh ( c ) <EOL> return h , c <EOL> def gru ( X , h , W , U , b ) : <EOL> z_t = T . nnet . sigmoid ( T . dot ( X , W [ : , : n_h ] ) + T . dot ( h , U [ : , : n_h ] ) + b [ : n_h ] ) <EOL> r_t = T . nnet . sigmoid ( T . dot ( X , W [ : , n_h : <NUM_LIT:2> * n_h ] ) + T . dot ( h , U [ : , n_h : <NUM_LIT:2> * n_h ] ) + b [ n_h : <NUM_LIT:2> * n_h ] ) <EOL> h_t = T . tanh ( T . dot ( X , W [ : , <NUM_LIT:2> * n_h : <NUM_LIT:3> * n_h ] ) + r_t * T . dot ( h , U [ : , <NUM_LIT:2> * n_h : <NUM_LIT:3> * n_h ] ) + b [ <NUM_LIT:2> * n_h : <NUM_LIT:3> * n_h ] ) <EOL> return ( <NUM_LIT:1> - z_t ) * h + z_t * h_t <EOL> def sgru ( X , h , W , U , b ) : <EOL> z_t = T . tanh ( T . dot ( X , W [ : , : n_h ] ) + T . dot ( h , U [ : , : n_h ] ) + b [ : n_h ] ) <EOL> h_t = T . tanh ( T . dot ( X , W [ : , <NUM_LIT:1> * n_h : <NUM_LIT:2> * n_h ] ) + T . dot ( h , U [ : , <NUM_LIT:1> * n_h : <NUM_LIT:2> * n_h ] ) + b [ <NUM_LIT:1> * n_h : <NUM_LIT:2> * n_h ] ) <EOL> return z_t * h_t <EOL> def model ( x , p , p_dropout ) : <EOL> input_size = x . shape [ <NUM_LIT:1> ] <EOL> h0 = p . W_emb [ x ] <EOL> h0 = dropout ( h0 , p_dropout ) <EOL> cost , h1 , h2 = [ <NUM_LIT:0.> , b1_h , b2_h ] <EOL> for t in xrange ( <NUM_LIT:0> , self . hp . seq_size ) : <EOL> if t >= self . hp . warmup_size : <EOL> pyx = softmax ( T . dot ( dropout ( h2 , p_dropout ) , T . transpose ( p . W_emb ) ) ) <EOL> cost += T . sum ( T . nnet . categorical_crossentropy ( pyx , theano_one_hot ( x [ t ] , n_tokens ) ) ) <EOL> h1 = gru ( h0 [ t ] , h1 , p . W1 , p . V1 , p . b1 ) <EOL> h2 = gru ( dropout ( h1 , p_dropout ) , h2 , p . W2 , p . V2 , p . b2 ) <EOL> h_updates = [ ( b1_h , h1 ) , ( b2_h , h2 ) ] <EOL> return cost , h_updates <EOL> cost , h_updates = model ( self . X , self . params , self . dropout ) <EOL> te_cost , te_h_updates = model ( self . X , self . params , <NUM_LIT:0.> ) <EOL> self . compile ( cost , te_cost , h_updates , te_h_updates ) </s>
<s> """<STR_LIT>""" <EOL> import csv <EOL> import sys <EOL> def csvOutput ( queryResult , separator = '<STR_LIT:U+002C>' , quote = '<STR_LIT:">' ) : <EOL> """<STR_LIT>""" <EOL> csvWriter = csv . writer ( sys . stdout , delimiter = separator , quotechar = quote , <EOL> quoting = csv . QUOTE_MINIMAL ) <EOL> for line in queryResult : <EOL> csvWriter . writerow ( line ) </s>
<s> import sys , os , stat <EOL> import pythoncom <EOL> from win32com . shell import shell , shellcon <EOL> import commctrl <EOL> import winerror <EOL> from win32com . server . util import wrap <EOL> from pywintypes import IID <EOL> IPersist_Methods = [ "<STR_LIT>" ] <EOL> IColumnProvider_Methods = IPersist_Methods + [ "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ] <EOL> class ColumnProvider : <EOL> _reg_progid_ = "<STR_LIT>" <EOL> _reg_desc_ = "<STR_LIT>" <EOL> _reg_clsid_ = IID ( "<STR_LIT>" ) <EOL> _com_interfaces_ = [ pythoncom . IID_IPersist , <EOL> shell . IID_IColumnProvider , <EOL> ] <EOL> _public_methods_ = IColumnProvider_Methods <EOL> def GetClassID ( self ) : <EOL> return self . _reg_clsid_ <EOL> def Initialize ( self , colInit ) : <EOL> flags , reserved , name = colInit <EOL> print "<STR_LIT>" , name <EOL> def GetColumnInfo ( self , index ) : <EOL> if index in [ <NUM_LIT:0> , <NUM_LIT:1> ] : <EOL> if index == <NUM_LIT:0> : <EOL> ext = "<STR_LIT>" <EOL> else : <EOL> ext = "<STR_LIT>" <EOL> title = ext + "<STR_LIT>" <EOL> description = "<STR_LIT>" % ext <EOL> col_id = ( self . _reg_clsid_ , <EOL> index ) <EOL> col_info = ( <EOL> col_id , <EOL> pythoncom . VT_I4 , <EOL> commctrl . LVCFMT_RIGHT , <EOL> <NUM_LIT:20> , <EOL> shellcon . SHCOLSTATE_TYPE_INT | shellcon . SHCOLSTATE_SECONDARYUI , <EOL> title , <EOL> description ) <EOL> return col_info <EOL> return None <EOL> def GetItemData ( self , colid , colData ) : <EOL> fmt_id , pid = colid <EOL> fmt_id == self . _reg_clsid_ <EOL> flags , attr , reserved , ext , name = colData <EOL> if ext . lower ( ) not in [ "<STR_LIT>" , "<STR_LIT>" ] : <EOL> return None <EOL> if pid == <NUM_LIT:0> : <EOL> ext = "<STR_LIT>" <EOL> else : <EOL> ext = "<STR_LIT>" <EOL> check_file = os . path . splitext ( name ) [ <NUM_LIT:0> ] + ext <EOL> try : <EOL> st = os . stat ( check_file ) <EOL> return st [ stat . ST_SIZE ] <EOL> except OSError : <EOL> return None <EOL> def DllRegisterServer ( ) : <EOL> import _winreg <EOL> key = _winreg . CreateKey ( _winreg . HKEY_CLASSES_ROOT , <EOL> "<STR_LIT>" + str ( ColumnProvider . _reg_clsid_ ) ) <EOL> _winreg . SetValueEx ( key , None , <NUM_LIT:0> , _winreg . REG_SZ , ColumnProvider . _reg_desc_ ) <EOL> print ColumnProvider . _reg_desc_ , "<STR_LIT>" <EOL> def DllUnregisterServer ( ) : <EOL> import _winreg <EOL> try : <EOL> key = _winreg . DeleteKey ( _winreg . HKEY_CLASSES_ROOT , <EOL> "<STR_LIT>" + str ( ColumnProvider . _reg_clsid_ ) ) <EOL> except WindowsError , details : <EOL> import errno <EOL> if details . errno != errno . ENOENT : <EOL> raise <EOL> print ColumnProvider . _reg_desc_ , "<STR_LIT>" <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL> from win32com . server import register <EOL> register . UseCommandLine ( ColumnProvider , <EOL> finalize_register = DllRegisterServer , <EOL> finalize_unregister = DllUnregisterServer ) </s>
<s> def __load ( ) : <EOL> import imp , os , sys <EOL> try : <EOL> dirname = os . path . dirname ( __loader__ . archive ) <EOL> except NameError : <EOL> dirname = sys . prefix <EOL> path = os . path . join ( dirname , '<STR_LIT>' ) <EOL> mod = imp . load_dynamic ( __name__ , path ) <EOL> __load ( ) <EOL> del __load </s>
<s> import logging <EOL> class LoggerFactory ( object ) : <EOL> _isSetup = False <EOL> def __init__ ( self , level = logging . DEBUG ) : <EOL> if LoggerFactory . _isSetup is False : <EOL> logger = logging . getLogger ( "<STR_LIT>" ) <EOL> logger . setLevel ( level ) <EOL> formatter = logging . Formatter ( '<STR_LIT>' ) <EOL> ch = logging . StreamHandler ( ) <EOL> ch . setLevel ( level ) <EOL> ch . setFormatter ( formatter ) <EOL> logger . addHandler ( ch ) <EOL> LoggerFactory . _isSetup = True <EOL> def getLogger ( self , name , level = logging . DEBUG ) : <EOL> logger = logging . getLogger ( "<STR_LIT>" % name ) <EOL> logger . setLevel ( level ) <EOL> return logger </s>
<s> from . functions import * </s>
<s> from __future__ import division <EOL> import numpy as np <EOL> from pysd import functions <EOL> def time ( ) : <EOL> return _t <EOL> def flowa ( ) : <EOL> """<STR_LIT>""" <EOL> return <NUM_LIT:0.1> <EOL> def stocka ( ) : <EOL> return _state [ '<STR_LIT>' ] <EOL> def _stocka_init ( ) : <EOL> return - <NUM_LIT:5> <EOL> def _dstocka_dt ( ) : <EOL> return flowa ( ) <EOL> def test_exp ( ) : <EOL> """<STR_LIT>""" <EOL> return np . exp ( stocka ( ) ) <EOL> def final_time ( ) : <EOL> """<STR_LIT>""" <EOL> return <NUM_LIT:100> <EOL> def initial_time ( ) : <EOL> """<STR_LIT>""" <EOL> return <NUM_LIT:0> <EOL> def saveper ( ) : <EOL> """<STR_LIT>""" <EOL> return time_step ( ) <EOL> def time_step ( ) : <EOL> """<STR_LIT>""" <EOL> return <NUM_LIT:1> </s>
<s> """<STR_LIT>""" <EOL> __all__ = [ <EOL> '<STR_LIT>' <EOL> ] <EOL> __version__ = '<STR_LIT>' </s>
<s> from myapp import utils <EOL> module_name = utils . getFinalName ( __name__ ) <EOL> module = utils . getModule ( __name__ , subdomain = module_name ) <EOL> import views <EOL> import views . morepages </s>
<s> """<STR_LIT>""" <EOL> import sys <EOL> import os <EOL> import subprocess <EOL> def perform_testing ( config ) : <EOL> requirements = { <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" <EOL> } <EOL> print "<STR_LIT>" <EOL> print canwrite ( config [ '<STR_LIT>' ] [ '<STR_LIT>' ] ) , "<STR_LIT>" <EOL> print "<STR_LIT>" <EOL> print "<STR_LIT>" <EOL> for req in requirements : <EOL> print checkcommand ( requirements [ req ] ) , req <EOL> sys . exit ( <NUM_LIT:0> ) <EOL> def canwrite ( path ) : <EOL> try : <EOL> ret = booltostatus ( os . access ( path , os . W_OK | os . X_OK ) ) <EOL> except : <EOL> ret = False <EOL> finally : <EOL> return ret <EOL> def booltostatus ( inbool ) : <EOL> if inbool : <EOL> return "<STR_LIT>" <EOL> else : <EOL> return "<STR_LIT>" <EOL> def checkcommand ( com ) : <EOL> proc = subprocess . Popen ( <EOL> [ <EOL> '<STR_LIT>' , <EOL> str ( com ) <EOL> ] , <EOL> stderr = subprocess . PIPE , <EOL> stdout = subprocess . PIPE <EOL> ) <EOL> return booltostatus ( len ( proc . stdout . read ( ) ) > <NUM_LIT:0> ) </s>
<s> """<STR_LIT>""" <EOL> from collections import namedtuple <EOL> from uuid import uuid4 <EOL> from django . http import HttpResponse <EOL> from django . contrib . gis . db . models . query import GeoQuerySet <EOL> from django . contrib . gis . db . models import GeometryField <EOL> from django import forms as f <EOL> import json <EOL> from django . shortcuts import render_to_response <EOL> from ga_ows . views import common <EOL> from ga_ows . utils import MultipleValueField , BBoxField , CaseInsensitiveDict <EOL> from lxml import etree <EOL> from ga_ows . views . common import RequestForm , CommonParameters , GetCapabilitiesMixin <EOL> from osgeo import ogr <EOL> from django . conf import settings <EOL> from tempfile import gettempdir <EOL> from django . db import connections <EOL> import re <EOL> from lxml import etree <EOL> import os <EOL> class InputParameters ( RequestForm ) : <EOL> """<STR_LIT:U+0020>""" <EOL> srs_name = f . CharField ( ) <EOL> input_format = f . CharField ( ) <EOL> srs_format = f . CharField ( required = False ) <EOL> @ classmethod <EOL> def from_request ( cls , request ) : <EOL> request [ '<STR_LIT>' ] = request . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> request [ '<STR_LIT>' ] = request . get ( '<STR_LIT>' , "<STR_LIT>" ) <EOL> class PresentationParameters ( RequestForm ) : <EOL> count = f . IntegerField ( ) <EOL> start_index = f . IntegerField ( ) <EOL> max_features = f . IntegerField ( ) <EOL> output_format = f . CharField ( ) <EOL> @ classmethod <EOL> def from_request ( cls , request ) : <EOL> request [ '<STR_LIT:count>' ] = int ( request . get ( '<STR_LIT:count>' , '<STR_LIT:1>' ) ) <EOL> request [ '<STR_LIT>' ] = int ( request . get ( '<STR_LIT>' , '<STR_LIT:1>' ) ) <EOL> request [ '<STR_LIT>' ] = int ( request . get ( '<STR_LIT>' , '<STR_LIT:1>' ) ) <EOL> request [ '<STR_LIT>' ] = request . get ( '<STR_LIT>' , "<STR_LIT>" ) <EOL> class AdHocQueryParameters ( RequestForm ) : <EOL> type_names = MultipleValueField ( ) <EOL> aliases = MultipleValueField ( required = False ) <EOL> filter = f . CharField ( required = False ) <EOL> filter_language = f . CharField ( required = False ) <EOL> resource_id = f . CharField ( required = False ) <EOL> bbox = BBoxField ( ) <EOL> sort_by = f . CharField ( required = False ) <EOL> @ classmethod <EOL> def from_request ( cls , request ) : <EOL> request [ '<STR_LIT>' ] = request . getlist ( '<STR_LIT>' ) <EOL> request [ '<STR_LIT>' ] = request . getlist ( '<STR_LIT>' ) <EOL> request [ '<STR_LIT>' ] = request . get ( '<STR_LIT>' ) <EOL> request [ '<STR_LIT>' ] = request . get ( '<STR_LIT>' ) <EOL> request [ '<STR_LIT>' ] = request . get ( '<STR_LIT>' ) <EOL> request [ '<STR_LIT>' ] = request . get ( '<STR_LIT>' ) <EOL> request [ '<STR_LIT>' ] = request . get ( '<STR_LIT>' ) <EOL> class StoredQueryParameters ( RequestForm ) : <EOL> stored_query_id = f . CharField ( required = False ) <EOL> @ classmethod <EOL> def from_request ( cls , request ) : <EOL> request [ '<STR_LIT>' ] = request . get ( '<STR_LIT>' ) <EOL> class GetFeatureByIdParameters ( RequestForm ) : <EOL> feature_id = f . CharField ( ) <EOL> @ classmethod <EOL> def from_request ( cls , request ) : <EOL> request [ '<STR_LIT>' ] = request . get ( '<STR_LIT:id>' ) <EOL> class ResolveParameters ( RequestForm ) : <EOL> resolve = f . CharField ( required = False ) <EOL> resolve_depth = f . IntegerField ( ) <EOL> resolve_timeout = f . FloatField ( ) <EOL> @ classmethod <EOL> def from_request ( cls , request ) : <EOL> request [ '<STR_LIT>' ] = request . get ( '<STR_LIT>' ) <EOL> request [ '<STR_LIT>' ] = int ( request . get ( '<STR_LIT>' , '<STR_LIT:0>' ) ) <EOL> request [ '<STR_LIT>' ] = float ( request . get ( '<STR_LIT>' , '<STR_LIT:0>' ) ) <EOL> class CannotLockAllFeatures ( common . OWSException ) : <EOL> """<STR_LIT>""" <EOL> class DuplicateStoredQueryIdValue ( common . OWSException ) : <EOL> """<STR_LIT>""" <EOL> class DuplicateStoredQueryParameterName ( common . OWSException ) : <EOL> """<STR_LIT>""" <EOL> class FeaturesNotLocked ( common . OWSException ) : <EOL> """<STR_LIT>""" <EOL> class InvalidLockId ( common . OWSException ) : <EOL> """<STR_LIT>""" <EOL> class InvalidValue ( common . OWSException ) : <EOL> """<STR_LIT>""" <EOL> class LockHasExpired ( common . OWSException ) : <EOL> """<STR_LIT>""" <EOL> class OperationParsingFailed ( common . OWSException ) : <EOL> """<STR_LIT>""" <EOL> class OperationProcessingFailed ( common . OWSException ) : <EOL> """<STR_LIT>""" <EOL> class ResponseCacheExpired ( common . OWSException ) : <EOL> """<STR_LIT>""" <EOL> class OperationNotSupported ( common . OWSException ) : <EOL> """<STR_LIT>""" <EOL> FeatureDescription = namedtuple ( '<STR_LIT>' , ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT:name>' , '<STR_LIT:title>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) ) <EOL> StoredQueryParameter = namedtuple ( "<STR_LIT>" , ( '<STR_LIT:type>' , '<STR_LIT:name>' , '<STR_LIT:title>' , '<STR_LIT>' , '<STR_LIT>' ) ) <EOL> StoredQueryExpression = namedtuple ( "<STR_LIT>" , ( '<STR_LIT:text>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) ) <EOL> StoredQueryDescription = namedtuple ( "<STR_LIT>" , ( '<STR_LIT:name>' , '<STR_LIT>' , '<STR_LIT:title>' , '<STR_LIT>' ) ) <EOL> class WFSAdapter ( object ) : <EOL> """<STR_LIT>""" <EOL> def get_feature_descriptions ( self , request , * types ) : <EOL> raise OperationNotSupported . at ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> def list_stored_queries ( self , request ) : <EOL> """<STR_LIT>""" <EOL> queries = dict ( [ ( q [ <NUM_LIT:3> : ] , [ ] ) for q in filter ( lambda x : x . startswith ( "<STR_LIT>" ) , <EOL> reduce ( <EOL> list . __add__ , <EOL> [ c . __dict__ . keys ( ) for c in self . __class__ . mro ( ) ] <EOL> ) <EOL> ) ] ) <EOL> return queries <EOL> def get_features ( self , request , parms ) : <EOL> raise OperationNotSupported . at ( '<STR_LIT>' , "<STR_LIT>" ) <EOL> def supports_feature_versioning ( self ) : <EOL> return False <EOL> class GeoDjangoWFSAdapter ( WFSAdapter ) : <EOL> def __init__ ( self , models ) : <EOL> self . models = { } <EOL> self . srids = { } <EOL> self . geometries = { } <EOL> for model in models : <EOL> self . models [ model . _meta . app_label + "<STR_LIT::>" + model . _meta . object_name ] = model <EOL> for field in model . _meta . fields : <EOL> if isinstance ( field , GeometryField ) : <EOL> self . geometries [ model . _meta . app_label + "<STR_LIT::>" + model . _meta . object_name ] = field <EOL> self . srids [ model . _meta . app_label + "<STR_LIT::>" + model . _meta . object_name ] = field . srid <EOL> def list_stored_queries ( self , request ) : <EOL> sq = super ( GeoDjangoWFSAdapter , self ) . list_stored_queries ( request ) <EOL> fts = list ( self . models . keys ( ) ) <EOL> for k in sq . keys ( ) : <EOL> sq [ k ] = StoredQueryDescription ( name = k , feature_types = fts , title = k , parameters = [ ] ) <EOL> return sq <EOL> def get_feature_descriptions ( self , request , * types ) : <EOL> namespace = request . build_absolute_uri ( ) . split ( '<STR_LIT:?>' ) [ <NUM_LIT:0> ] + "<STR_LIT>" <EOL> for model in self . models . values ( ) : <EOL> if model . objects . count ( ) > <NUM_LIT:0> : <EOL> extent = model . objects . extent ( ) <EOL> else : <EOL> extent = ( <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> ) <EOL> yield FeatureDescription ( <EOL> ns = namespace , <EOL> ns_name = model . _meta . app_label , <EOL> name = model . _meta . object_name , <EOL> abstract = model . __doc__ , <EOL> title = model . _meta . verbose_name , <EOL> keywords = [ ] , <EOL> srs = self . srids [ model . _meta . app_label + "<STR_LIT::>" + model . _meta . object_name ] , <EOL> bbox = extent , <EOL> schema = namespace <EOL> ) <EOL> def get_features ( self , request , parms ) : <EOL> if parms . cleaned_data [ '<STR_LIT>' ] : <EOL> squid = "<STR_LIT>" + parms . cleaned_data [ '<STR_LIT>' ] <EOL> try : <EOL> return self . __getattribute__ ( squid ) ( request , parms ) <EOL> except AttributeError : <EOL> raise OperationNotSupported . at ( '<STR_LIT>' , '<STR_LIT>' . format ( squid = squid ) ) <EOL> else : <EOL> return self . AdHocQuery ( request , parms ) <EOL> def AdHocQuery ( self , request , parms ) : <EOL> type_names = parms . cleaned_data [ '<STR_LIT>' ] <EOL> flt = parms . cleaned_data [ '<STR_LIT>' ] <EOL> flt_lang = parms . cleaned_data [ '<STR_LIT>' ] <EOL> bbox = parms . cleaned_data [ '<STR_LIT>' ] <EOL> sort_by = parms . cleaned_data [ '<STR_LIT>' ] <EOL> count = parms . cleaned_data [ '<STR_LIT:count>' ] <EOL> if not count : <EOL> count = parms . cleaned_data [ '<STR_LIT>' ] <EOL> start_index = parms . cleaned_data [ '<STR_LIT>' ] <EOL> srs_name = parms . cleaned_data [ '<STR_LIT>' ] <EOL> srs_format = parms . cleaned_data [ '<STR_LIT>' ] <EOL> model = self . models [ type_names [ <NUM_LIT:0> ] ] <EOL> geometry_field = self . geometries [ type_names [ <NUM_LIT:0> ] ] <EOL> query_set = model . objects . all ( ) <EOL> if bbox : <EOL> mnx , mny , mxx , mxy = bbox <EOL> query_set . filter ( ** { geometry_field . name + "<STR_LIT>" : <EOL> "<STR_LIT>" . format ( <EOL> mnx = mnx , <EOL> mny = mny , <EOL> mxx = mxx , <EOL> mxy = mxy ) <EOL> } ) <EOL> if flt : <EOL> flt = json . loads ( flt ) <EOL> query_set = query_set . filter ( ** flt ) <EOL> if sort_by and '<STR_LIT:U+002C>' in sort_by : <EOL> sort_by = sort_by . split ( '<STR_LIT:U+002C>' ) <EOL> query_set = query_set . order_by ( * sort_by ) <EOL> elif sort_by : <EOL> query_set = query_set . order_by ( sort_by ) <EOL> if start_index and count : <EOL> query_set = query_set [ start_index : start_index + count ] <EOL> elif start_index : <EOL> query_set = query_set [ start_index : ] <EOL> elif count : <EOL> query_set = query_set [ : count ] <EOL> if srs_name : <EOL> if ( not srs_format or srs_format == '<STR_LIT>' ) and srs_name != geometry_field . srid : <EOL> if srs_name . lower ( ) . startswith ( '<STR_LIT>' ) : <EOL> srs_name = srs_name [ <NUM_LIT:5> : ] <EOL> query_set . transform ( int ( srs_name ) ) <EOL> return query_set <EOL> def SQ_GetFeatureById ( self , request , parms ) : <EOL> my_parms = GetFeatureByIdParameters . create ( request . REQUEST ) <EOL> typename , pk = my_parms . cleaned_data [ '<STR_LIT>' ] . split ( '<STR_LIT:.>' ) <EOL> return self . models [ typename ] . objects . filter ( pk = int ( pk ) ) <EOL> class WFSBase ( object ) : <EOL> """<STR_LIT>""" <EOL> adapter = None <EOL> class DescribeFeatureTypeMixin ( WFSBase ) : <EOL> """<STR_LIT>""" <EOL> class Parameters ( <EOL> CommonParameters <EOL> ) : <EOL> type_names = MultipleValueField ( ) <EOL> output_format = f . CharField ( ) <EOL> @ classmethod <EOL> def from_request ( cls , request ) : <EOL> request [ '<STR_LIT>' ] = request . getlist ( '<STR_LIT>' ) + request . getlist ( '<STR_LIT>' ) <EOL> request [ '<STR_LIT>' ] = request . get ( '<STR_LIT>' , "<STR_LIT>" ) <EOL> def _parse_xml_DescribeFeatureType ( self , request ) : <EOL> """<STR_LIT>""" <EOL> def add_ns ( it , ns ) : <EOL> x = it . split ( '<STR_LIT::>' ) <EOL> if len ( x ) > <NUM_LIT:1> : <EOL> return ns [ x [ <NUM_LIT:0> ] ] , x [ <NUM_LIT:1> ] <EOL> else : <EOL> return '<STR_LIT>' , x <EOL> root = etree . fromstring ( request ) <EOL> xmlns = root . get ( '<STR_LIT>' ) <EOL> output_format = root . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> if xmlns is not None : <EOL> xmlns = "<STR_LIT:{>" + xmlns + "<STR_LIT:}>" <EOL> else : <EOL> xmlns = "<STR_LIT>" <EOL> namespaces = { } <EOL> for name , value in root . attrib . items ( ) : <EOL> if name . startswith ( xmlns ) : <EOL> namespaces [ value ] = name [ len ( xmlns ) : ] <EOL> type_names = root . get ( '<STR_LIT>' ) <EOL> if type_names is not None : <EOL> type_names = [ add_ns ( n , namespaces ) for n in type_names . split ( '<STR_LIT:U+002C>' ) ] <EOL> else : <EOL> type_names = [ ] <EOL> for elt in root : <EOL> if elt . tag . endswith ( "<STR_LIT>" ) : <EOL> namespace , name = elt . text . split ( "<STR_LIT::>" ) <EOL> namespace = namespaces [ namespace ] <EOL> type_names . append ( ( namespace , name ) ) <EOL> if not len ( type_names ) : <EOL> type_names = '<STR_LIT:all>' <EOL> return DescribeFeatureTypeMixin . Parameters . create ( CaseInsensitiveDict ( { "<STR_LIT>" : type_names , "<STR_LIT>" : output_format } ) ) <EOL> def _response_xml_DescribeFeatureType ( self , response ) : <EOL> return render_to_response ( "<STR_LIT>" , { "<STR_LIT>" : list ( response ) } ) <EOL> def _response_json_DescribeFeatureType ( self , response , callback = None ) : <EOL> rsp = [ ] <EOL> for feature_type in response : <EOL> rsp . append ( { <EOL> "<STR_LIT>" : feature_type . schema , <EOL> "<STR_LIT:name>" : feature_type . name , <EOL> "<STR_LIT>" : feature_type . abstract , <EOL> "<STR_LIT:title>" : feature_type . title , <EOL> "<STR_LIT>" : feature_type . ns_name <EOL> } ) <EOL> if callback is not None : <EOL> return HttpResponse ( callback + "<STR_LIT:(>" + json . dumps ( rsp ) + "<STR_LIT:)>" , mimetype = '<STR_LIT>' ) <EOL> else : <EOL> return HttpResponse ( json . dumps ( rsp ) , mimetype = '<STR_LIT:application/json>' ) <EOL> def DescribeFeatureType ( self , request , kwargs ) : <EOL> """<STR_LIT>""" <EOL> if '<STR_LIT>' in kwargs : <EOL> parms = self . _parse_xml_DescribeFeatureType ( kwargs [ '<STR_LIT>' ] ) <EOL> else : <EOL> parms = DescribeFeatureTypeMixin . Parameters . create ( kwargs ) <EOL> response = self . adapter . get_feature_descriptions ( request , * parms . cleaned_data [ '<STR_LIT>' ] ) <EOL> if parms . cleaned_data [ '<STR_LIT>' ] . endswith ( '<STR_LIT>' ) : <EOL> if '<STR_LIT>' in kwargs : <EOL> return self . _response_json_DescribeFeatureType ( response , callback = kwargs [ '<STR_LIT>' ] ) <EOL> elif '<STR_LIT>' in kwargs : <EOL> return self . _response_json_DescribeFeatureType ( response , callback = kwargs [ '<STR_LIT>' ] ) <EOL> else : <EOL> return self . _response_json_DescribeFeatureType ( response ) <EOL> else : <EOL> return self . _response_xml_DescribeFeatureType ( response ) <EOL> class GetFeatureMixin ( WFSBase ) : <EOL> """<STR_LIT>""" <EOL> class Parameters ( <EOL> CommonParameters , <EOL> InputParameters , <EOL> PresentationParameters , <EOL> AdHocQueryParameters , <EOL> StoredQueryParameters <EOL> ) : <EOL> pass <EOL> def _parse_xml_GetFeature ( self , request ) : <EOL> """<STR_LIT:U+0020>""" <EOL> raise OperationNotSupported . at ( "<STR_LIT>" , "<STR_LIT>" ) <EOL> def GetFeature ( self , request , kwargs ) : <EOL> """<STR_LIT:U+0020>""" <EOL> mimetypes = { <EOL> '<STR_LIT>' : '<STR_LIT:application/json>' <EOL> } <EOL> if '<STR_LIT>' in kwargs : <EOL> parms = self . _parse_xml_GetFeature ( kwargs [ '<STR_LIT>' ] ) <EOL> else : <EOL> parms = GetFeatureMixin . Parameters . create ( kwargs ) <EOL> response = self . adapter . get_features ( request , parms ) <EOL> if isinstance ( response , GeoQuerySet ) : <EOL> layer = None <EOL> db_params = settings . DATABASES [ response . db ] <EOL> if db_params [ '<STR_LIT>' ] . endswith ( '<STR_LIT>' ) : <EOL> from psycopg2 . extensions import adapt <EOL> query , parameters = response . query . get_compiler ( response . db ) . as_sql ( ) <EOL> parameters = tuple ( [ adapt ( p ) for p in parameters ] ) <EOL> query = query % parameters <EOL> drv = ogr . GetDriverByName ( "<STR_LIT>" ) <EOL> connection_string = "<STR_LIT>" . format ( db = db_params [ '<STR_LIT>' ] ) <EOL> if '<STR_LIT>' in db_params and db_params [ '<STR_LIT>' ] : <EOL> connection_string += "<STR_LIT>" . format ( host = db_params [ '<STR_LIT>' ] ) <EOL> if '<STR_LIT>' in db_params and db_params [ '<STR_LIT>' ] : <EOL> connection_string += "<STR_LIT>" . format ( port = db_params [ '<STR_LIT>' ] ) <EOL> if '<STR_LIT>' in db_params and db_params [ '<STR_LIT>' ] : <EOL> connection_string += "<STR_LIT>" . format ( user = db_params [ '<STR_LIT>' ] ) <EOL> if '<STR_LIT>' in db_params and db_params [ '<STR_LIT>' ] : <EOL> connection_string += "<STR_LIT>" . format ( password = db_params [ '<STR_LIT>' ] ) <EOL> conn = drv . Open ( connection_string ) <EOL> layer = conn . ExecuteSQL ( query . encode ( '<STR_LIT:ascii>' ) ) <EOL> elif db_params [ '<STR_LIT>' ] . endswith ( '<STR_LIT>' ) : <EOL> from psycopg2 . extensions import adapt <EOL> query , parameters = response . query . get_compiler ( response . db ) . as_sql ( ) <EOL> parameters = tuple ( [ adapt ( p ) for p in parameters ] ) <EOL> query = query % parameters <EOL> drv = ogr . GetDriverByName ( "<STR_LIT>" ) <EOL> conn = drv . Open ( db_params [ '<STR_LIT>' ] ) <EOL> layer = conn . ExecuteSQL ( query ) <EOL> else : <EOL> layer = response . GetLayerByIndex ( <NUM_LIT:0> ) <EOL> drivers = dict ( [ ( ogr . GetDriver ( drv ) . GetName ( ) , ogr . GetDriver ( drv ) ) for drv in range ( ogr . GetDriverCount ( ) ) if ogr . GetDriver ( drv ) . TestCapability ( ogr . ODrCCreateDataSource ) ] ) <EOL> output_format = parms . cleaned_data [ '<STR_LIT>' ] . decode ( '<STR_LIT:ascii>' ) <EOL> if '<STR_LIT>' in output_format or '<STR_LIT>' in output_format : <EOL> tmpname = "<STR_LIT>" . format ( tmpdir = gettempdir ( ) , uuid = uuid4 ( ) , output_format = '<STR_LIT>' , sep = os . path . sep ) <EOL> drv = ogr . GetDriverByName ( "<STR_LIT>" ) <EOL> ds = drv . CreateDataSource ( tmpname ) <EOL> l2 = ds . CopyLayer ( layer , '<STR_LIT>' ) <EOL> l2 . SyncToDisk ( ) <EOL> del ds <EOL> responsef = open ( tmpname ) <EOL> rdata = responsef . read ( ) <EOL> responsef . close ( ) <EOL> os . unlink ( tmpname ) <EOL> return HttpResponse ( rdata , mimetype = output_format ) <EOL> elif output_format in drivers : <EOL> tmpname = "<STR_LIT>" . format ( tmpdir = gettempdir ( ) , uuid = uuid4 ( ) , output_format = output_format , sep = os . path . sep ) <EOL> drv = drivers [ output_format ] <EOL> ds = drv . CreateDataSource ( tmpname ) <EOL> l2 = ds . CopyLayer ( layer , '<STR_LIT>' ) <EOL> l2 . SyncToDisk ( ) <EOL> del ds <EOL> responsef = open ( tmpname ) <EOL> rdata = responsef . read ( ) <EOL> responsef . close ( ) <EOL> os . unlink ( tmpname ) <EOL> return HttpResponse ( rdata , mimetype = mimetypes . get ( output_format , '<STR_LIT>' ) ) <EOL> else : <EOL> raise OperationProcessingFailed . at ( '<STR_LIT>' , '<STR_LIT>' . format ( of = output_format , formats = drivers . keys ( ) ) ) <EOL> class ListStoredQueriesMixin ( WFSBase ) : <EOL> """<STR_LIT>""" <EOL> def ListStoredQueries ( self , request , kwargs ) : <EOL> """<STR_LIT:U+0020>""" <EOL> queries = self . adapter . list_stored_queries ( request ) <EOL> response = etree . Element ( "<STR_LIT>" ) <EOL> for query , description in queries . items ( ) : <EOL> sub = etree . SubElement ( response , "<STR_LIT>" ) <EOL> etree . SubElement ( sub , "<STR_LIT>" ) . text = query <EOL> for feature_type in description . feature_types : <EOL> etree . SubElement ( sub , '<STR_LIT>' ) . text = feature_type <EOL> return HttpResponse ( etree . tostring ( response , pretty_print = True ) , mimetype = '<STR_LIT>' ) <EOL> class DescribeStoredQueriesMixin ( WFSBase ) : <EOL> class Parameters ( CommonParameters ) : <EOL> stored_query_id = MultipleValueField ( ) <EOL> @ classmethod <EOL> def from_request ( cls , request ) : <EOL> request [ '<STR_LIT>' ] = request . getlist ( '<STR_LIT>' ) <EOL> def DescribeStoredQueries ( self , request , kwargs ) : <EOL> parms = DescribeStoredQueriesMixin . Parameters . create ( kwargs ) <EOL> inspected_queries = parms . cleaned_data [ '<STR_LIT>' ] <EOL> response = etree . Element ( '<STR_LIT>' ) <EOL> for query , description in filter ( lambda ( x , y ) : x in inspected_queries , self . adapter . list_stored_queries ( request ) . items ( ) ) : <EOL> desc = etree . SubElement ( response , "<STR_LIT>" ) <EOL> etree . SubElement ( desc , '<STR_LIT>' ) . text = query <EOL> for parameter in description . parameters : <EOL> p = etree . SubElement ( desc , "<STR_LIT>" , attrib = { "<STR_LIT:name>" : parameter . name , "<STR_LIT:type>" : parameter . type } ) <EOL> etree . SubElement ( p , '<STR_LIT>' ) . text = parameter . title <EOL> etree . SubElement ( p , '<STR_LIT>' ) . text = parameter . abstractS <EOL> if parameter . query_expression : <EOL> etree . SubElement ( p , "<STR_LIT>" , attrib = { <EOL> "<STR_LIT>" : parameter . query_expression . private == True , <EOL> "<STR_LIT>" : parameter . query_expression . language , <EOL> "<STR_LIT>" : '<STR_LIT:U+0020>' . join ( parameter . query_expression . return_feature_types ) <EOL> } ) . text = parameter . query_expression . text <EOL> return HttpResponse ( etree . tostring ( response , pretty_print = True ) , mimetype = '<STR_LIT>' ) <EOL> class CreateStoredQuery ( WFSBase ) : <EOL> def CreateStoredQuery ( self , request , kwargs ) : <EOL> raise OperationNotSupported . at ( "<STR_LIT>" ) <EOL> class DropStoredQuery ( WFSBase ) : <EOL> def DropStoredQuery ( self , request , kwargs ) : <EOL> raise OperationNotSupported . at ( "<STR_LIT>" ) <EOL> class TransactionMixin ( WFSBase ) : <EOL> def Transaction ( self , request , kwargs ) : <EOL> """<STR_LIT:U+0020>""" <EOL> raise OperationNotSupported . at ( '<STR_LIT>' ) <EOL> class GetFeatureWithLockMixin ( WFSBase ) : <EOL> def GetFeatureWithLock ( self , request , kwargs ) : <EOL> raise OperationNotSupported . at ( "<STR_LIT>" ) <EOL> class LockFeatureMixin ( WFSBase ) : <EOL> def LockFeature ( self , request , kwargs ) : <EOL> raise OperationNotSupported . at ( '<STR_LIT>' ) <EOL> class GetPropertyValueMixin ( WFSBase ) : <EOL> class Parameters ( StoredQueryParameters , AdHocQueryParameters ) : <EOL> value_reference = f . CharField ( ) <EOL> resolve_path = f . CharField ( required = False ) <EOL> def from_request ( cls , request ) : <EOL> request [ '<STR_LIT>' ] = request [ '<STR_LIT>' ] <EOL> request [ '<STR_LIT>' ] = request [ '<STR_LIT>' ] <EOL> def GetPropertyValue ( self , request , kwargs ) : <EOL> raise OperationNotSupported . at ( '<STR_LIT>' ) <EOL> class WFS ( <EOL> common . OWSView , <EOL> GetCapabilitiesMixin , <EOL> DescribeFeatureTypeMixin , <EOL> DescribeStoredQueriesMixin , <EOL> GetFeatureMixin , <EOL> ListStoredQueriesMixin , <EOL> GetPropertyValueMixin <EOL> ) : <EOL> """<STR_LIT>""" <EOL> adapter = None <EOL> models = None <EOL> title = None <EOL> keywords = [ ] <EOL> fees = None <EOL> access_constraints = None <EOL> provider_name = None <EOL> addr_street = None <EOL> addr_city = None <EOL> addr_admin_area = None <EOL> addr_postcode = None <EOL> addr_country = None <EOL> addr_email = None <EOL> def __init__ ( self , ** kwargs ) : <EOL> common . OWSView . __init__ ( self , ** kwargs ) <EOL> if self . models : <EOL> self . adapter = GeoDjangoWFSAdapter ( self . models ) <EOL> def get_capabilities_response ( self , request , params ) : <EOL> return render_to_response ( '<STR_LIT>' , { <EOL> "<STR_LIT:title>" : self . title , <EOL> "<STR_LIT>" : self . keywords , <EOL> "<STR_LIT>" : self . fees , <EOL> "<STR_LIT>" : self . access_constraints , <EOL> "<STR_LIT>" : request . build_absolute_uri ( ) . split ( '<STR_LIT:?>' ) [ <NUM_LIT:0> ] , <EOL> "<STR_LIT>" : [ ogr . GetDriver ( drv ) . GetName ( ) for drv in range ( ogr . GetDriverCount ( ) ) if ogr . GetDriver ( drv ) . TestCapability ( ogr . ODrCCreateDataSource ) ] , <EOL> "<STR_LIT>" : self . addr_street , <EOL> "<STR_LIT>" : self . addr_city , <EOL> "<STR_LIT>" : self . addr_admin_area , <EOL> "<STR_LIT>" : self . addr_postcode , <EOL> "<STR_LIT>" : self . addr_country , <EOL> "<STR_LIT>" : False , <EOL> "<STR_LIT>" : False , <EOL> '<STR_LIT>' : self . adapter . get_feature_descriptions ( request ) <EOL> } ) <EOL> class WFST ( WFS , TransactionMixin , GetFeatureWithLockMixin , LockFeatureMixin ) : <EOL> """<STR_LIT>""" <EOL> def get_capabilities_response ( self , request , params ) : <EOL> return render_to_response ( '<STR_LIT>' , { <EOL> "<STR_LIT:title>" : self . title , <EOL> "<STR_LIT>" : self . keywords , <EOL> "<STR_LIT>" : self . fees , <EOL> "<STR_LIT>" : self . access_constraints , <EOL> "<STR_LIT>" : request . build_absolute_uri ( ) . split ( '<STR_LIT:?>' ) [ <NUM_LIT:0> ] , <EOL> "<STR_LIT>" : [ ogr . GetDriver ( drv ) . GetName ( ) for drv in range ( ogr . GetDriverCount ( ) ) if ogr . GetDriver ( drv ) . TestCapability ( ogr . ODrCCreateDataSource ) ] , <EOL> "<STR_LIT>" : self . addr_street , <EOL> "<STR_LIT>" : self . addr_city , <EOL> "<STR_LIT>" : self . addr_admin_area , <EOL> "<STR_LIT>" : self . addr_postcode , <EOL> "<STR_LIT>" : self . addr_country , <EOL> "<STR_LIT>" : self . adapter . supports_feature_versioning ( ) , <EOL> "<STR_LIT>" : True , <EOL> '<STR_LIT>' : self . adapter . get_feature_descriptions ( request ) <EOL> } ) </s>
<s> from sondra . document . valuehandlers import DateTime , Geometry , Now <EOL> from shapely . geometry import Point <EOL> from datetime import datetime <EOL> import rethinkdb as r <EOL> import pytest <EOL> from sondra . tests . api import * <EOL> from sondra . auth import Auth <EOL> s = ConcreteSuite ( ) <EOL> api = SimpleApp ( s ) <EOL> auth = Auth ( s ) <EOL> AuthenticatedApp ( s ) <EOL> AuthorizedApp ( s ) <EOL> s . ensure_database_objects ( ) <EOL> @ pytest . fixture ( scope = '<STR_LIT>' ) <EOL> def simple_doc ( request ) : <EOL> simple_doc = s [ '<STR_LIT>' ] [ '<STR_LIT>' ] . create ( { <EOL> '<STR_LIT:name>' : "<STR_LIT>" , <EOL> "<STR_LIT:date>" : datetime . now ( ) , <EOL> "<STR_LIT:value>" : <NUM_LIT:0> <EOL> } ) <EOL> def teardown ( ) : <EOL> simple_doc . delete ( ) <EOL> request . addfinalizer ( teardown ) <EOL> return simple_doc <EOL> @ pytest . fixture ( scope = '<STR_LIT>' ) <EOL> def fk_doc ( request , simple_doc ) : <EOL> fk_doc = s [ '<STR_LIT>' ] [ '<STR_LIT>' ] . create ( { <EOL> '<STR_LIT:name>' : "<STR_LIT>" , <EOL> '<STR_LIT>' : simple_doc , <EOL> '<STR_LIT>' : [ simple_doc ] <EOL> } ) <EOL> def teardown ( ) : <EOL> fk_doc . delete ( ) <EOL> request . addfinalizer ( teardown ) <EOL> return fk_doc <EOL> def test_foreignkey ( fk_doc , simple_doc ) : <EOL> retr_doc = s [ '<STR_LIT>' ] [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> assert isinstance ( fk_doc . obj [ '<STR_LIT>' ] , str ) <EOL> assert fk_doc . obj [ '<STR_LIT>' ] == simple_doc . url <EOL> assert isinstance ( retr_doc . obj [ '<STR_LIT>' ] , str ) <EOL> assert retr_doc . obj [ '<STR_LIT>' ] == simple_doc . url <EOL> storage_repr = fk_doc . rql_repr ( ) <EOL> assert storage_repr [ '<STR_LIT>' ] == simple_doc . id <EOL> assert isinstance ( fk_doc [ '<STR_LIT>' ] , SimpleDocument ) </s>
<s> import os <EOL> from PySide . QtGui import * <EOL> from PySide . QtCore import * <EOL> from ui_Event import Ui_Event <EOL> '''<STR_LIT>''' <EOL> class EventWindow ( QDialog , Ui_Event ) : <EOL> def __init__ ( self , parent , eventId ) : <EOL> super ( EventWindow , self ) . __init__ ( parent ) <EOL> self . rent = parent <EOL> self . data = parent . eventData [ eventId ] <EOL> self . deckAssignment = [ ] <EOL> self . setupUi ( self ) <EOL> self . assignWidgets ( ) <EOL> self . setWindowTitle ( unicode ( "<STR_LIT>" % eventId ) ) <EOL> def savePressed ( self ) : <EOL> self . data [ "<STR_LIT>" ] = self . notesText . toPlainText ( ) <EOL> self . data [ "<STR_LIT>" ] = self . deckText . text ( ) <EOL> self . data [ "<STR_LIT>" ] = self . placeText . text ( ) <EOL> self . data [ "<STR_LIT>" ] = self . eventTypeText . text ( ) <EOL> self . data [ "<STR_LIT>" ] = self . playersText . text ( ) <EOL> self . data [ "<STR_LIT>" ] = self . formatText . text ( ) <EOL> self . data [ "<STR_LIT>" ] = self . locationText . text ( ) <EOL> self . data [ "<STR_LIT>" ] = self . dateText . text ( ) <EOL> ourCounter = <NUM_LIT:0> <EOL> for ourRound in self . deckAssignment : <EOL> self . data [ "<STR_LIT>" ] [ self . deckAssignment [ ourCounter ] [ <NUM_LIT:0> ] ] [ <NUM_LIT:2> ] = self . deckAssignment [ ourCounter ] [ <NUM_LIT:1> ] <EOL> ourCounter += <NUM_LIT:1> <EOL> self . rent . updateGUI ( ) <EOL> self . rent . messageBox ( "<STR_LIT>" ) <EOL> def closePressed ( self ) : <EOL> self . hide ( ) <EOL> def roundSelected ( self , ourRound , ourColumn ) : <EOL> ourIndex = int ( ourRound . text ( <NUM_LIT:0> ) ) - <NUM_LIT:1> <EOL> deckName , ok = QInputDialog . getText ( self , "<STR_LIT>" , <EOL> "<STR_LIT>" ) <EOL> if ok and deckName : <EOL> self . data [ "<STR_LIT>" ] [ ourIndex ] [ <NUM_LIT:3> ] . setData ( <NUM_LIT:3> , <NUM_LIT:0> , deckName ) <EOL> self . deckAssignment . append ( [ ourIndex , deckName ] ) <EOL> def assignWidgets ( self ) : <EOL> self . saveChangesButton . clicked . connect ( self . savePressed ) <EOL> self . closeButton . clicked . connect ( self . closePressed ) <EOL> self . roundTree . itemDoubleClicked . connect ( self . roundSelected ) <EOL> self . notesText . setPlainText ( self . data [ "<STR_LIT>" ] ) <EOL> self . deckText . setText ( self . data [ "<STR_LIT>" ] ) <EOL> self . placeText . setText ( self . data [ "<STR_LIT>" ] ) <EOL> self . eventTypeText . setText ( self . data [ "<STR_LIT>" ] ) <EOL> self . playersText . setText ( self . data [ "<STR_LIT>" ] ) <EOL> self . formatText . setText ( self . data [ "<STR_LIT>" ] ) <EOL> self . locationText . setText ( self . data [ "<STR_LIT>" ] ) <EOL> self . dateText . setText ( self . data [ "<STR_LIT>" ] ) <EOL> matchItem = TreeWidgetItem ( self . resultsTree ) <EOL> matchItem . setText ( <NUM_LIT:0> , unicode ( self . data [ "<STR_LIT>" ] ) ) <EOL> matchItem . setText ( <NUM_LIT:1> , unicode ( self . data [ "<STR_LIT>" ] ) ) <EOL> matchItem . setText ( <NUM_LIT:2> , unicode ( self . data [ "<STR_LIT>" ] ) ) <EOL> matchItem . setText ( <NUM_LIT:3> , unicode ( self . data [ "<STR_LIT>" ] ) ) <EOL> self . resultsTree . addTopLevelItem ( matchItem ) <EOL> for i in range ( <NUM_LIT:4> ) : <EOL> self . resultsTree . resizeColumnToContents ( i ) <EOL> roundCounter = <NUM_LIT:1> <EOL> for opponent in self . data [ "<STR_LIT>" ] : <EOL> roundItem = TreeWidgetItem ( self . roundTree ) <EOL> roundItem . setText ( <NUM_LIT:0> , unicode ( roundCounter ) ) <EOL> roundItem . setText ( <NUM_LIT:1> , unicode ( opponent [ <NUM_LIT:0> ] ) ) <EOL> roundItem . setText ( <NUM_LIT:2> , unicode ( opponent [ <NUM_LIT:1> ] ) ) <EOL> roundItem . setText ( <NUM_LIT:3> , unicode ( opponent [ <NUM_LIT:2> ] ) ) <EOL> opponent [ <NUM_LIT:3> ] = roundItem <EOL> self . roundTree . addTopLevelItem ( roundItem ) <EOL> roundCounter += <NUM_LIT:1> <EOL> for i in range ( <NUM_LIT:4> ) : <EOL> self . roundTree . resizeColumnToContents ( i ) <EOL> class TreeWidgetItem ( QTreeWidgetItem ) : <EOL> def __init__ ( self , parent = None ) : <EOL> QTreeWidgetItem . __init__ ( self , parent ) <EOL> def __lt__ ( self , otherItem ) : <EOL> column = self . treeWidget ( ) . sortColumn ( ) <EOL> try : <EOL> return float ( self . text ( column ) ) > float ( otherItem . text ( column ) ) <EOL> except ValueError : <EOL> return self . text ( column ) > otherItem . text ( column ) </s>
<s> """<STR_LIT>""" <EOL> import numpy as np <EOL> from pylatex import Document , Section , Subsection , Math , Matrix , VectorName <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL> a = np . array ( [ [ <NUM_LIT:100> , <NUM_LIT:10> , <NUM_LIT:20> ] ] ) . T <EOL> doc = Document ( ) <EOL> section = Section ( '<STR_LIT>' ) <EOL> subsection = Subsection ( '<STR_LIT>' ) <EOL> vec = Matrix ( a ) <EOL> vec_name = VectorName ( '<STR_LIT:a>' ) <EOL> math = Math ( data = [ vec_name , '<STR_LIT:=>' , vec ] ) <EOL> subsection . append ( math ) <EOL> section . append ( subsection ) <EOL> subsection = Subsection ( '<STR_LIT>' ) <EOL> M = np . matrix ( [ [ <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:4> ] , <EOL> [ <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:1> ] , <EOL> [ <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:2> ] ] ) <EOL> matrix = Matrix ( M , mtype = '<STR_LIT:b>' ) <EOL> math = Math ( data = [ '<STR_LIT>' , matrix ] ) <EOL> subsection . append ( math ) <EOL> section . append ( subsection ) <EOL> subsection = Subsection ( '<STR_LIT>' ) <EOL> math = Math ( data = [ '<STR_LIT:M>' , vec_name , '<STR_LIT:=>' , Matrix ( M * a ) ] ) <EOL> subsection . append ( math ) <EOL> section . append ( subsection ) <EOL> doc . append ( section ) <EOL> doc . generate_pdf ( '<STR_LIT>' ) </s>
<s> import quantities as pq <EOL> from pylatex . quantities import _dimensionality_to_siunitx , Quantity <EOL> def test_quantity ( ) : <EOL> v = <NUM_LIT:1> * pq . m / pq . s <EOL> q1 = Quantity ( v ) <EOL> assert q1 . dumps ( ) == r'<STR_LIT>' <EOL> q2 = Quantity ( v , format_cb = lambda x : str ( int ( x ) ) ) <EOL> assert q2 . dumps ( ) == r'<STR_LIT>' <EOL> q3 = Quantity ( v , options = { '<STR_LIT>' : '<STR_LIT:true>' } ) <EOL> ref = r'<STR_LIT>' <EOL> assert q3 . dumps ( ) == ref <EOL> def test_quantity_float ( ) : <EOL> q1 = Quantity ( <NUM_LIT> ) <EOL> assert q1 . dumps ( ) == r'<STR_LIT>' <EOL> def test_quantity_uncertain ( ) : <EOL> t = pq . UncertainQuantity ( <NUM_LIT> , pq . second , <NUM_LIT:1.> ) <EOL> q1 = Quantity ( t ) <EOL> assert q1 . dumps ( ) == r'<STR_LIT>' <EOL> def test_dimensionality_to_siunitx ( ) : <EOL> assert _dimensionality_to_siunitx ( ( pq . volt / pq . kelvin ) . dimensionality ) == r'<STR_LIT>' <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL> test_quantity ( ) <EOL> test_dimensionality_to_siunitx ( ) </s>
