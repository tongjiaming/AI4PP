<s> from django . utils . translation import ugettext_lazy as _ <EOL> from horizon import tabs <EOL> class NetworkProfileTab ( tabs . Tab ) : <EOL> name = _ ( "<STR_LIT>" ) <EOL> slug = "<STR_LIT>" <EOL> template_name = '<STR_LIT>' <EOL> def get_context_data ( self , request ) : <EOL> return None <EOL> class PolicyProfileTab ( tabs . Tab ) : <EOL> name = _ ( "<STR_LIT>" ) <EOL> slug = "<STR_LIT>" <EOL> template_name = '<STR_LIT>' <EOL> preload = False <EOL> class IndexTabs ( tabs . TabGroup ) : <EOL> slug = "<STR_LIT>" <EOL> tabs = ( NetworkProfileTab , PolicyProfileTab ) </s>
<s> """<STR_LIT>""" <EOL> import weakref <EOL> from eventlet import corolocal <EOL> class WeakLocal ( corolocal . local ) : <EOL> def __getattribute__ ( self , attr ) : <EOL> rval = corolocal . local . __getattribute__ ( self , attr ) <EOL> if rval : <EOL> rval = rval ( ) <EOL> return rval <EOL> def __setattr__ ( self , attr , value ) : <EOL> value = weakref . ref ( value ) <EOL> return corolocal . local . __setattr__ ( self , attr , value ) <EOL> store = WeakLocal ( ) <EOL> weak_store = WeakLocal ( ) <EOL> strong_store = corolocal . local </s>
<s> import eventlet <EOL> eventlet . monkey_patch ( ) <EOL> import contextlib <EOL> import sys <EOL> from oslo . config import cfg <EOL> from openstack_dashboard . openstack . common import log as logging <EOL> from openstack_dashboard . openstack . common import rpc <EOL> from openstack_dashboard . openstack . common . rpc import impl_zmq <EOL> CONF = cfg . CONF <EOL> CONF . register_opts ( rpc . rpc_opts ) <EOL> CONF . register_opts ( impl_zmq . zmq_opts ) <EOL> def main ( ) : <EOL> CONF ( sys . argv [ <NUM_LIT:1> : ] , project = '<STR_LIT>' ) <EOL> logging . setup ( "<STR_LIT>" ) <EOL> with contextlib . closing ( impl_zmq . ZmqProxy ( CONF ) ) as reactor : <EOL> reactor . consume_in_thread ( ) <EOL> reactor . wait ( ) </s>
<s> from openstack_dashboard import api <EOL> from openstack_dashboard . test import helpers as test <EOL> from neutronclient . v2_0 import client <EOL> neutronclient = client . Client <EOL> class VPNaasApiTests ( test . APITestCase ) : <EOL> @ test . create_stubs ( { neutronclient : ( '<STR_LIT>' , ) } ) <EOL> def test_vpnservice_create ( self ) : <EOL> vpnservice1 = self . api_vpnservices . first ( ) <EOL> form_data = { <EOL> '<STR_LIT:name>' : vpnservice1 [ '<STR_LIT:name>' ] , <EOL> '<STR_LIT:description>' : vpnservice1 [ '<STR_LIT:description>' ] , <EOL> '<STR_LIT>' : vpnservice1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : vpnservice1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : vpnservice1 [ '<STR_LIT>' ] <EOL> } <EOL> vpnservice = { '<STR_LIT>' : self . api_vpnservices . first ( ) } <EOL> neutronclient . create_vpnservice ( <EOL> { '<STR_LIT>' : form_data } ) . AndReturn ( vpnservice ) <EOL> self . mox . ReplayAll ( ) <EOL> ret_val = api . vpn . vpnservice_create ( self . request , ** form_data ) <EOL> self . assertIsInstance ( ret_val , api . vpn . VPNService ) <EOL> @ test . create_stubs ( { neutronclient : ( '<STR_LIT>' , ) } ) <EOL> def test_vpnservices_get ( self ) : <EOL> vpnservices = { '<STR_LIT>' : self . vpnservices . list ( ) } <EOL> vpnservices_dict = { '<STR_LIT>' : self . api_vpnservices . list ( ) } <EOL> neutronclient . list_vpnservices ( ) . AndReturn ( vpnservices_dict ) <EOL> self . mox . ReplayAll ( ) <EOL> ret_val = api . vpn . vpnservices_get ( self . request ) <EOL> for ( v , d ) in zip ( ret_val , vpnservices [ '<STR_LIT>' ] ) : <EOL> self . assertIsInstance ( v , api . vpn . VPNService ) <EOL> self . assertTrue ( v . name , d . name ) <EOL> self . assertTrue ( v . id ) <EOL> @ test . create_stubs ( { neutronclient : ( '<STR_LIT>' , ) } ) <EOL> def test_vpnservice_get ( self ) : <EOL> vpnservice1 = self . api_vpnservices . first ( ) <EOL> vpnservice = { '<STR_LIT>' : vpnservice1 } <EOL> neutronclient . show_vpnservice ( <EOL> vpnservice [ '<STR_LIT>' ] [ '<STR_LIT:id>' ] ) . AndReturn ( vpnservice ) <EOL> self . mox . ReplayAll ( ) <EOL> ret_val = api . vpn . vpnservice_get ( self . request , <EOL> vpnservice [ '<STR_LIT>' ] [ '<STR_LIT:id>' ] ) <EOL> self . assertIsInstance ( ret_val , api . vpn . VPNService ) <EOL> @ test . create_stubs ( { neutronclient : ( '<STR_LIT>' , ) } ) <EOL> def test_ikepolicy_create ( self ) : <EOL> ikepolicy1 = self . api_ikepolicies . first ( ) <EOL> form_data = { <EOL> '<STR_LIT:name>' : ikepolicy1 [ '<STR_LIT:name>' ] , <EOL> '<STR_LIT:description>' : ikepolicy1 [ '<STR_LIT:description>' ] , <EOL> '<STR_LIT>' : ikepolicy1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ikepolicy1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ikepolicy1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ikepolicy1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ikepolicy1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ikepolicy1 [ '<STR_LIT>' ] <EOL> } <EOL> ikepolicy = { '<STR_LIT>' : self . api_ikepolicies . first ( ) } <EOL> neutronclient . create_ikepolicy ( <EOL> { '<STR_LIT>' : form_data } ) . AndReturn ( ikepolicy ) <EOL> self . mox . ReplayAll ( ) <EOL> ret_val = api . vpn . ikepolicy_create ( self . request , ** form_data ) <EOL> self . assertIsInstance ( ret_val , api . vpn . IKEPolicy ) <EOL> @ test . create_stubs ( { neutronclient : ( '<STR_LIT>' , ) } ) <EOL> def test_ikepolicies_get ( self ) : <EOL> ikepolicies = { '<STR_LIT>' : self . ikepolicies . list ( ) } <EOL> ikepolicies_dict = { '<STR_LIT>' : self . api_ikepolicies . list ( ) } <EOL> neutronclient . list_ikepolicies ( ) . AndReturn ( ikepolicies_dict ) <EOL> self . mox . ReplayAll ( ) <EOL> ret_val = api . vpn . ikepolicies_get ( self . request ) <EOL> for ( v , d ) in zip ( ret_val , ikepolicies [ '<STR_LIT>' ] ) : <EOL> self . assertIsInstance ( v , api . vpn . IKEPolicy ) <EOL> self . assertTrue ( v . name , d . name ) <EOL> self . assertTrue ( v . id ) <EOL> @ test . create_stubs ( { neutronclient : ( '<STR_LIT>' , ) } ) <EOL> def test_ikepolicy_get ( self ) : <EOL> ikepolicy1 = self . api_ikepolicies . first ( ) <EOL> ikepolicy = { '<STR_LIT>' : ikepolicy1 } <EOL> neutronclient . show_ikepolicy ( <EOL> ikepolicy [ '<STR_LIT>' ] [ '<STR_LIT:id>' ] ) . AndReturn ( ikepolicy ) <EOL> self . mox . ReplayAll ( ) <EOL> ret_val = api . vpn . ikepolicy_get ( self . request , <EOL> ikepolicy [ '<STR_LIT>' ] [ '<STR_LIT:id>' ] ) <EOL> self . assertIsInstance ( ret_val , api . vpn . IKEPolicy ) <EOL> @ test . create_stubs ( { neutronclient : ( '<STR_LIT>' , ) } ) <EOL> def test_ipsecpolicy_create ( self ) : <EOL> ipsecpolicy1 = self . api_ipsecpolicies . first ( ) <EOL> form_data = { <EOL> '<STR_LIT:name>' : ipsecpolicy1 [ '<STR_LIT:name>' ] , <EOL> '<STR_LIT:description>' : ipsecpolicy1 [ '<STR_LIT:description>' ] , <EOL> '<STR_LIT>' : ipsecpolicy1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ipsecpolicy1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ipsecpolicy1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ipsecpolicy1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ipsecpolicy1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ipsecpolicy1 [ '<STR_LIT>' ] <EOL> } <EOL> ipsecpolicy = { '<STR_LIT>' : self . api_ipsecpolicies . first ( ) } <EOL> neutronclient . create_ipsecpolicy ( <EOL> { '<STR_LIT>' : form_data } ) . AndReturn ( ipsecpolicy ) <EOL> self . mox . ReplayAll ( ) <EOL> ret_val = api . vpn . ipsecpolicy_create ( self . request , ** form_data ) <EOL> self . assertIsInstance ( ret_val , api . vpn . IPSecPolicy ) <EOL> @ test . create_stubs ( { neutronclient : ( '<STR_LIT>' , ) } ) <EOL> def test_ipsecpolicies_get ( self ) : <EOL> ipsecpolicies = { '<STR_LIT>' : self . ipsecpolicies . list ( ) } <EOL> ipsecpolicies_dict = { '<STR_LIT>' : self . api_ipsecpolicies . list ( ) } <EOL> neutronclient . list_ipsecpolicies ( ) . AndReturn ( ipsecpolicies_dict ) <EOL> self . mox . ReplayAll ( ) <EOL> ret_val = api . vpn . ipsecpolicies_get ( self . request ) <EOL> for ( v , d ) in zip ( ret_val , ipsecpolicies [ '<STR_LIT>' ] ) : <EOL> self . assertIsInstance ( v , api . vpn . IPSecPolicy ) <EOL> self . assertTrue ( v . name , d . name ) <EOL> self . assertTrue ( v . id ) <EOL> @ test . create_stubs ( { neutronclient : ( '<STR_LIT>' , ) } ) <EOL> def test_ipsecpolicy_get ( self ) : <EOL> ipsecpolicy1 = self . api_ipsecpolicies . first ( ) <EOL> ipsecpolicy = { '<STR_LIT>' : ipsecpolicy1 } <EOL> neutronclient . show_ipsecpolicy ( <EOL> ipsecpolicy [ '<STR_LIT>' ] [ '<STR_LIT:id>' ] ) . AndReturn ( ipsecpolicy ) <EOL> self . mox . ReplayAll ( ) <EOL> ret_val = api . vpn . ipsecpolicy_get ( self . request , <EOL> ipsecpolicy [ '<STR_LIT>' ] [ '<STR_LIT:id>' ] ) <EOL> self . assertIsInstance ( ret_val , api . vpn . IPSecPolicy ) <EOL> @ test . create_stubs ( { neutronclient : ( '<STR_LIT>' , ) } ) <EOL> def test_ipsecsiteconnection_create ( self ) : <EOL> ipsecsiteconnection1 = self . api_ipsecsiteconnections . first ( ) <EOL> form_data = { <EOL> '<STR_LIT:name>' : ipsecsiteconnection1 [ '<STR_LIT:name>' ] , <EOL> '<STR_LIT:description>' : ipsecsiteconnection1 [ '<STR_LIT:description>' ] , <EOL> '<STR_LIT>' : ipsecsiteconnection1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ipsecsiteconnection1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ipsecsiteconnection1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ipsecsiteconnection1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ipsecsiteconnection1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ipsecsiteconnection1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ipsecsiteconnection1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ipsecsiteconnection1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ipsecsiteconnection1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ipsecsiteconnection1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ipsecsiteconnection1 [ '<STR_LIT>' ] <EOL> } <EOL> ipsecsiteconnection = { '<STR_LIT>' : <EOL> self . api_ipsecsiteconnections . first ( ) } <EOL> neutronclient . create_ipsec_site_connection ( <EOL> { '<STR_LIT>' : <EOL> form_data } ) . AndReturn ( ipsecsiteconnection ) <EOL> self . mox . ReplayAll ( ) <EOL> ret_val = api . vpn . ipsecsiteconnection_create ( <EOL> self . request , ** form_data ) <EOL> self . assertIsInstance ( ret_val , api . vpn . IPSecSiteConnection ) <EOL> @ test . create_stubs ( { neutronclient : ( '<STR_LIT>' , ) } ) <EOL> def test_ipsecsiteconnections_get ( self ) : <EOL> ipsecsiteconnections = { <EOL> '<STR_LIT>' : self . ipsecsiteconnections . list ( ) } <EOL> ipsecsiteconnections_dict = { <EOL> '<STR_LIT>' : self . api_ipsecsiteconnections . list ( ) } <EOL> neutronclient . list_ipsec_site_connections ( ) . AndReturn ( <EOL> ipsecsiteconnections_dict ) <EOL> self . mox . ReplayAll ( ) <EOL> ret_val = api . vpn . ipsecsiteconnections_get ( self . request ) <EOL> for ( v , d ) in zip ( ret_val , <EOL> ipsecsiteconnections [ '<STR_LIT>' ] ) : <EOL> self . assertIsInstance ( v , api . vpn . IPSecSiteConnection ) <EOL> self . assertTrue ( v . name , d . name ) <EOL> self . assertTrue ( v . id ) <EOL> @ test . create_stubs ( { neutronclient : ( '<STR_LIT>' , ) } ) <EOL> def test_ipsecsiteconnection_get ( self ) : <EOL> ipsecsiteconnection1 = self . api_ipsecsiteconnections . first ( ) <EOL> ipsecsiteconnection = { '<STR_LIT>' : ipsecsiteconnection1 } <EOL> neutronclient . show_ipsec_site_connection ( <EOL> ipsecsiteconnection [ '<STR_LIT>' ] [ '<STR_LIT:id>' ] ) . AndReturn ( <EOL> ipsecsiteconnection ) <EOL> self . mox . ReplayAll ( ) <EOL> ret_val = api . vpn . ipsecsiteconnection_get ( self . request , <EOL> ipsecsiteconnection [ '<STR_LIT>' ] [ '<STR_LIT:id>' ] ) <EOL> self . assertIsInstance ( ret_val , api . vpn . IPSecSiteConnection ) </s>
<s> from horizon import tables <EOL> from openstack_dashboard . usage import base <EOL> class UsageView ( tables . DataTableView ) : <EOL> usage_class = None <EOL> show_terminated = True <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( UsageView , self ) . __init__ ( * args , ** kwargs ) <EOL> if not issubclass ( self . usage_class , base . BaseUsage ) : <EOL> raise AttributeError ( "<STR_LIT>" <EOL> "<STR_LIT>" ) <EOL> def get_template_names ( self ) : <EOL> if self . request . GET . get ( '<STR_LIT>' , '<STR_LIT:html>' ) == '<STR_LIT>' : <EOL> return "<STR_LIT:.>" . join ( ( self . template_name . rsplit ( '<STR_LIT:.>' , <NUM_LIT:1> ) [ <NUM_LIT:0> ] , '<STR_LIT>' ) ) <EOL> return self . template_name <EOL> def get_content_type ( self ) : <EOL> if self . request . GET . get ( '<STR_LIT>' , '<STR_LIT:html>' ) == '<STR_LIT>' : <EOL> return "<STR_LIT>" <EOL> return "<STR_LIT>" <EOL> def get_data ( self ) : <EOL> project_id = self . kwargs . get ( '<STR_LIT>' , self . request . user . tenant_id ) <EOL> self . usage = self . usage_class ( self . request , project_id ) <EOL> self . usage . summarize ( * self . usage . get_date_range ( ) ) <EOL> self . usage . get_limits ( ) <EOL> self . kwargs [ '<STR_LIT>' ] = self . usage <EOL> return self . usage . usage_list <EOL> def get_context_data ( self , ** kwargs ) : <EOL> context = super ( UsageView , self ) . get_context_data ( ** kwargs ) <EOL> context [ '<STR_LIT>' ] . kwargs [ '<STR_LIT>' ] = self . usage <EOL> context [ '<STR_LIT>' ] = self . usage . form <EOL> context [ '<STR_LIT>' ] = self . usage <EOL> return context <EOL> def render_to_response ( self , context , ** response_kwargs ) : <EOL> if self . request . GET . get ( '<STR_LIT>' , '<STR_LIT:html>' ) == '<STR_LIT>' : <EOL> render_class = self . csv_response_class <EOL> response_kwargs . setdefault ( "<STR_LIT:filename>" , "<STR_LIT>" ) <EOL> else : <EOL> render_class = self . response_class <EOL> resp = render_class ( request = self . request , <EOL> template = self . get_template_names ( ) , <EOL> context = context , <EOL> content_type = self . get_content_type ( ) , <EOL> ** response_kwargs ) <EOL> return resp </s>
<s> from enum import IntEnum <EOL> from . component import Component <EOL> from . object import field <EOL> class ReflectionProbeUsage ( IntEnum ) : <EOL> Off = <NUM_LIT:0> <EOL> BlendProbes = <NUM_LIT:1> <EOL> BlendProbesAndSkybox = <NUM_LIT:2> <EOL> Simple = <NUM_LIT:3> <EOL> class ShadowCastingMode ( IntEnum ) : <EOL> Off = <NUM_LIT:0> <EOL> On = <NUM_LIT:1> <EOL> TwoSided = <NUM_LIT:2> <EOL> ShadowsOnly = <NUM_LIT:3> <EOL> class Renderer ( Component ) : <EOL> enabled = field ( "<STR_LIT>" , bool ) <EOL> lightmap_index = field ( "<STR_LIT>" ) <EOL> materials = field ( "<STR_LIT>" ) <EOL> probe_anchor = field ( "<STR_LIT>" ) <EOL> receive_shadows = field ( "<STR_LIT>" , bool ) <EOL> reflection_probe_usage = field ( "<STR_LIT>" , ReflectionProbeUsage ) <EOL> shadow_casting_mode = field ( "<STR_LIT>" , ShadowCastingMode ) <EOL> sorting_layer_id = field ( "<STR_LIT>" ) <EOL> sorting_order = field ( "<STR_LIT>" ) <EOL> use_light_probes = field ( "<STR_LIT>" , bool ) <EOL> lightmap_index_dynamic = field ( "<STR_LIT>" ) <EOL> lightmap_tiling_offset = field ( "<STR_LIT>" ) <EOL> lightmap_tiling_offset_dynamic = field ( "<STR_LIT>" ) <EOL> static_batch_root = field ( "<STR_LIT>" ) <EOL> subset_indices = field ( "<STR_LIT>" ) <EOL> @ property <EOL> def material ( self ) : <EOL> return self . materials [ <NUM_LIT:0> ] <EOL> class ParticleSystemRenderMode ( IntEnum ) : <EOL> Billboard = <NUM_LIT:0> <EOL> Stretch = <NUM_LIT:1> <EOL> HorizontalBillboard = <NUM_LIT:2> <EOL> VerticalBillboard = <NUM_LIT:3> <EOL> Mesh = <NUM_LIT:4> <EOL> class ParticleSystemSortMode ( IntEnum ) : <EOL> None_ = <NUM_LIT:0> <EOL> Distance = <NUM_LIT:1> <EOL> OldestInFront = <NUM_LIT:2> <EOL> YoungestInFront = <NUM_LIT:3> <EOL> class MeshRenderer ( Component ) : <EOL> pass <EOL> class ParticleRenderer ( Renderer ) : <EOL> camera_velocity_scale = field ( "<STR_LIT>" ) <EOL> length_scale = field ( "<STR_LIT>" ) <EOL> max_particle_size = field ( "<STR_LIT>" ) <EOL> velocity_scale = field ( "<STR_LIT>" ) <EOL> stretch_particles = field ( "<STR_LIT>" ) <EOL> uv_animation = field ( "<STR_LIT>" ) <EOL> class ParticleSystemRenderer ( Renderer ) : <EOL> camera_velocity_scale = field ( "<STR_LIT>" ) <EOL> length_scale = field ( "<STR_LIT>" ) <EOL> max_particle_size = field ( "<STR_LIT>" ) <EOL> mesh = field ( "<STR_LIT>" ) <EOL> mesh1 = field ( "<STR_LIT>" ) <EOL> mesh2 = field ( "<STR_LIT>" ) <EOL> mesh3 = field ( "<STR_LIT>" ) <EOL> normal_direction = field ( "<STR_LIT>" ) <EOL> render_mode = field ( "<STR_LIT>" , ParticleSystemRenderMode ) <EOL> sort_mode = field ( "<STR_LIT>" , ParticleSystemSortMode ) <EOL> sorting_fudge = field ( "<STR_LIT>" ) <EOL> velocity_scale = field ( "<STR_LIT>" ) </s>
<s> from ConfigParser import * <EOL> from StringIO import * <EOL> from Log import Log <EOL> import datetime <EOL> class Config : <EOL> @ staticmethod <EOL> def LoadConfig ( ) : <EOL> Config . parser = ConfigParser ( ) <EOL> try : <EOL> sconff = open ( CONFIG_FILE , "<STR_LIT:r>" ) <EOL> except : <EOL> Log . warn ( "<STR_LIT>" ) <EOL> return <EOL> sconf = StringIO ( ) <EOL> sconf . write ( "<STR_LIT>" ) <EOL> sconf . write ( sconff . read ( ) ) <EOL> sconf . seek ( <NUM_LIT:0> ) <EOL> Config . parser . readfp ( sconf ) <EOL> sconff . close ( ) <EOL> sconf . close ( ) <EOL> return <EOL> @ staticmethod <EOL> def GetBoardsFile ( ) : <EOL> return BOARDS_FILE <EOL> @ staticmethod <EOL> def GetInt ( name , defval ) : <EOL> if ( Config . parser . has_option ( '<STR_LIT>' , name ) ) : <EOL> return Config . parser . getint ( '<STR_LIT>' , name ) <EOL> else : <EOL> return defval <EOL> @ staticmethod <EOL> def GetString ( name , defval ) : <EOL> if ( Config . parser . has_option ( '<STR_LIT>' , name ) ) : <EOL> val = Config . parser . get ( '<STR_LIT>' , name ) <EOL> if ( val [ <NUM_LIT:0> ] == '<STR_LIT:">' and val . endswith ( '<STR_LIT:">' ) ) : <EOL> val = val [ <NUM_LIT:1> : - <NUM_LIT:1> ] <EOL> return val . decode ( '<STR_LIT>' ) <EOL> else : <EOL> return defval <EOL> BBS_ROOT = '<STR_LIT>' <EOL> BBS_XMPP_CERT_FILE = BBS_ROOT + "<STR_LIT>" <EOL> BBS_XMPP_KEY_FILE = BBS_ROOT + "<STR_LIT>" <EOL> BOARDS_FILE = BBS_ROOT + '<STR_LIT>' <EOL> STRLEN = <NUM_LIT> <EOL> ARTICLE_TITLE_LEN = <NUM_LIT> <EOL> BM_LEN = <NUM_LIT> <EOL> MAXBOARD = <NUM_LIT> <EOL> CONFIG_FILE = BBS_ROOT + '<STR_LIT>' <EOL> FILENAME_LEN = <NUM_LIT:20> <EOL> OWNER_LEN = <NUM_LIT:30> <EOL> SESSIONID_LEN = <NUM_LIT:32> <EOL> REFRESH_TOKEN_LEN = <NUM_LIT> <EOL> NAMELEN = <NUM_LIT> <EOL> IDLEN = <NUM_LIT:12> <EOL> MD5PASSLEN = <NUM_LIT:16> <EOL> OLDPASSLEN = <NUM_LIT> <EOL> MOBILE_NUMBER_LEN = <NUM_LIT> <EOL> MAXCLUB = <NUM_LIT> <EOL> MAXUSERS = <NUM_LIT> <EOL> MAX_MSG_SIZE = <NUM_LIT> <EOL> MAXFRIENDS = <NUM_LIT> <EOL> MAXMESSAGE = <NUM_LIT:5> <EOL> MAXSIGLINES = <NUM_LIT:6> <EOL> IPLEN = <NUM_LIT:16> <EOL> DEFAULTBOARD = "<STR_LIT>" <EOL> BLESS_BOARD = "<STR_LIT>" <EOL> QUOTED_LINES = <NUM_LIT:10> <EOL> MAXACTIVE = <NUM_LIT> <EOL> USHM_SIZE = MAXACTIVE + <NUM_LIT:10> <EOL> UTMP_HASHSIZE = USHM_SIZE * <NUM_LIT:4> <EOL> UCACHE_SEMLOCK = <NUM_LIT:0> <EOL> LEN_FRIEND_EXP = <NUM_LIT:15> <EOL> REFRESH_TIME = <NUM_LIT:30> <EOL> USER_TITLE_LEN = <NUM_LIT> <EOL> SESSION_TIMEOUT = datetime . timedelta ( <NUM_LIT:30> ) <EOL> SESSION_TIMEOUT_SECONDS = <NUM_LIT> * <NUM_LIT:30> <EOL> XMPP_IDLE_TIME = <NUM_LIT> <EOL> XMPP_LONG_IDLE_TIME = <NUM_LIT> <EOL> XMPP_UPDATE_TIME_INTERVAL = <NUM_LIT:10> <EOL> XMPP_PING_TIME_INTERVAL = <NUM_LIT> <EOL> PUBLIC_SHMKEY = <NUM_LIT> <EOL> MAX_ATTACHSIZE = <NUM_LIT:20> * <NUM_LIT> * <NUM_LIT> <EOL> BMDEL_DECREASE = True <EOL> SYSMAIL_BOARD = "<STR_LIT>" <EOL> ADD_EDITMARK = True <EOL> SEARCH_COUNT_LIMIT = <NUM_LIT:20> <EOL> MAIL_SIZE_LIMIT = - <NUM_LIT:1> <EOL> SEC_DELETED_OLDHOME = <NUM_LIT> * <NUM_LIT> * <NUM_LIT:3> <EOL> SELF_INTRO_MAX_LEN = <NUM_LIT> </s>
<s> import re <EOL> import os <EOL> import stat <EOL> import json <EOL> import struct <EOL> import time <EOL> import Config <EOL> import Board <EOL> import Post <EOL> import BoardManager <EOL> from Util import Util <EOL> from Log import Log <EOL> from errors import * <EOL> DEFAULT_DIGEST_LIST_COUNT = <NUM_LIT:20> <EOL> class DigestItem : <EOL> def __init__ ( self , basepath ) : <EOL> self . basepath = basepath <EOL> self . title = '<STR_LIT>' <EOL> self . host = '<STR_LIT>' <EOL> self . port = <NUM_LIT:0> <EOL> self . attachpos = <NUM_LIT:0> <EOL> self . fname = '<STR_LIT>' <EOL> self . mtitle = '<STR_LIT>' <EOL> self . items = [ ] <EOL> self . update_time = <NUM_LIT:0> <EOL> self . id = <NUM_LIT:0> <EOL> self . sysop_only = <NUM_LIT:0> <EOL> self . bms_only = <NUM_LIT:0> <EOL> self . zixia_only = <NUM_LIT:0> <EOL> def IsDir ( self ) : <EOL> try : <EOL> st = os . stat ( self . realpath ( ) ) <EOL> return stat . S_ISDIR ( st . st_mode ) <EOL> except : <EOL> return False <EOL> def IsFile ( self ) : <EOL> try : <EOL> st = os . stat ( self . realpath ( ) ) <EOL> return stat . S_ISREG ( st . st_mode ) <EOL> except : <EOL> return False <EOL> def GetModTime ( self ) : <EOL> try : <EOL> st = os . stat ( self . realpath ( ) ) <EOL> mtime = st . st_mtime <EOL> except : <EOL> mtime = time . time ( ) <EOL> return mtime <EOL> def names_path ( self ) : <EOL> return "<STR_LIT>" % self . realpath ( ) <EOL> def realpath ( self ) : <EOL> return "<STR_LIT>" % ( Config . BBS_ROOT , self . path ( ) ) <EOL> def path ( self ) : <EOL> if ( self . fname ) : <EOL> return "<STR_LIT>" % ( self . basepath , self . fname ) <EOL> else : <EOL> return self . basepath <EOL> def CheckUpdate ( self ) : <EOL> try : <EOL> stat = os . stat ( self . names_path ( ) ) <EOL> if ( stat . st_mtime > self . update_time ) : <EOL> self . LoadNames ( ) <EOL> except : <EOL> return False <EOL> return True <EOL> def LoadNames ( self ) : <EOL> try : <EOL> f = open ( self . names_path ( ) , "<STR_LIT:r>" ) <EOL> except IOError : <EOL> return <NUM_LIT:0> <EOL> stat = os . fstat ( f . fileno ( ) ) <EOL> self . update_time = stat . st_mtime <EOL> item = DigestItem ( self . path ( ) ) <EOL> hostname = '<STR_LIT>' <EOL> _id = <NUM_LIT:0> <EOL> bms_only = <NUM_LIT:0> <EOL> sysop_only = <NUM_LIT:0> <EOL> zixia_only = <NUM_LIT:0> <EOL> while ( True ) : <EOL> line = f . readline ( ) <EOL> if ( line == "<STR_LIT>" ) : break <EOL> npos = line . find ( "<STR_LIT:\n>" ) <EOL> if ( npos != - <NUM_LIT:1> ) : line = line [ : npos ] <EOL> if ( line [ : <NUM_LIT:1> ] == '<STR_LIT:#>' ) : <EOL> if ( line [ : <NUM_LIT:8> ] == "<STR_LIT>" ) : <EOL> if ( not self . mtitle ) : <EOL> self . mtitle = line [ <NUM_LIT:8> : ] <EOL> result = re . match ( '<STR_LIT>' , line ) <EOL> if ( result ) : <EOL> key = result . group ( <NUM_LIT:1> ) <EOL> value = result . group ( <NUM_LIT:2> ) <EOL> if ( key == "<STR_LIT:Name>" ) : <EOL> item . title = value <EOL> item . attachpos = <NUM_LIT:0> <EOL> elif ( key == "<STR_LIT>" ) : <EOL> if ( value [ : <NUM_LIT:2> ] == "<STR_LIT>" ) : <EOL> item . fname = value [ <NUM_LIT:2> : ] <EOL> else : <EOL> item . fname = value <EOL> if ( item . fname . find ( "<STR_LIT:..>" ) != - <NUM_LIT:1> ) : <EOL> continue <EOL> if ( item . title . find ( "<STR_LIT>" ) != - <NUM_LIT:1> ) : <EOL> bms_only += <NUM_LIT:1> <EOL> elif ( item . title . find ( "<STR_LIT>" ) != - <NUM_LIT:1> ) : <EOL> sysop_only += <NUM_LIT:1> <EOL> elif ( item . title . find ( "<STR_LIT>" ) != - <NUM_LIT:1> ) : <EOL> zixia_only += <NUM_LIT:1> <EOL> if ( item . fname . find ( "<STR_LIT>" ) != - <NUM_LIT:1> ) : <EOL> parts = re . split ( '<STR_LIT>' , item . fname ) <EOL> newparts = [ ] <EOL> for part in parts : <EOL> if ( part ) : <EOL> newparts += [ part ] <EOL> hostname = newparts [ <NUM_LIT:0> ] <EOL> item . fname = newparts [ <NUM_LIT:1> ] <EOL> try : <EOL> item . port = int ( newparts [ <NUM_LIT:2> ] ) <EOL> except : <EOL> item . port = <NUM_LIT:0> <EOL> item . id = _id <EOL> _id += <NUM_LIT:1> <EOL> item . bms_only = bms_only <EOL> item . sysop_only = sysop_only <EOL> item . zixia_only = zixia_only <EOL> item . host = hostname <EOL> self . items += [ item ] <EOL> item = DigestItem ( self . path ( ) ) <EOL> hostname = '<STR_LIT>' <EOL> elif ( key == "<STR_LIT>" ) : <EOL> hostname = value <EOL> elif ( key == "<STR_LIT>" ) : <EOL> try : <EOL> item . port = int ( value ) <EOL> except : <EOL> item . port = <NUM_LIT:0> <EOL> elif ( key == "<STR_LIT>" ) : <EOL> try : <EOL> item . attachpos = int ( value ) <EOL> except : <EOL> item . attachpos = <NUM_LIT:0> <EOL> f . close ( ) <EOL> return <NUM_LIT:1> <EOL> def GetItem ( self , user , route , has_perm = False , need_perm = False ) : <EOL> self . CheckUpdate ( ) <EOL> if ( self . mtitle . find ( "<STR_LIT>" ) != - <NUM_LIT:1> ) : <EOL> if ( Board . Board . IsBM ( user , self . mtitle [ <NUM_LIT:4> : ] , ) or user . IsSysop ( ) ) : <EOL> has_perm = True <EOL> elif ( need_perm and not has_perm ) : <EOL> return None <EOL> if ( self . mtitle . find ( "<STR_LIT>" ) != - <NUM_LIT:1> <EOL> or self . mtitle . find ( "<STR_LIT>" ) != - <NUM_LIT:1> <EOL> or self . mtitle . find ( "<STR_LIT>" ) != - <NUM_LIT:1> ) : <EOL> need_perm = True <EOL> if ( len ( route ) == <NUM_LIT:0> ) : <EOL> return self <EOL> target = route [ <NUM_LIT:0> ] - <NUM_LIT:1> <EOL> _id = target <EOL> if ( _id >= len ( self . items ) ) : <EOL> return None <EOL> while ( self . items [ _id ] . EffectiveId ( user ) < target ) : <EOL> _id += <NUM_LIT:1> <EOL> if ( _id >= len ( self . items ) ) : <EOL> return None <EOL> item = self . items [ _id ] <EOL> item . mtitle = item . title <EOL> if ( len ( route ) == <NUM_LIT:1> ) : <EOL> return item <EOL> else : <EOL> if ( item . IsDir ( ) ) : <EOL> if ( not item . CheckUpdate ( ) ) : <EOL> return None <EOL> return item . GetItem ( user , route [ <NUM_LIT:1> : ] , has_perm , need_perm ) <EOL> else : <EOL> return None <EOL> def GetRange ( self , user , route , start , end , has_perm = False , need_perm = False ) : <EOL> self . CheckUpdate ( ) <EOL> firstitem = self . GetItem ( user , route + [ start ] , has_perm , need_perm ) <EOL> if ( not firstitem ) : <EOL> return [ ] <EOL> parent = self . GetItem ( user , route , has_perm , need_perm ) <EOL> if ( not parent ) : <EOL> return [ ] <EOL> if ( not parent . IsDir ( ) ) : <EOL> return [ ] <EOL> result = [ ] <EOL> _id = start - <NUM_LIT:1> <EOL> for i in range ( start , end + <NUM_LIT:1> ) : <EOL> target = i - <NUM_LIT:1> <EOL> if ( _id >= len ( parent . items ) ) : <EOL> return [ ] <EOL> while ( parent . items [ _id ] . EffectiveId ( user ) < target ) : <EOL> _id += <NUM_LIT:1> <EOL> if ( _id >= len ( parent . items ) ) : <EOL> return result <EOL> item = parent . items [ _id ] <EOL> item . mtitle = item . title <EOL> result += [ item ] <EOL> return result <EOL> def EffectiveId ( self , user ) : <EOL> _id = self . id <EOL> if ( user . IsSysop ( ) ) : <EOL> return _id <EOL> if ( not user . IsSysop ( ) ) : <EOL> _id -= self . sysop_only <EOL> if ( not user . IsBM ( ) ) : <EOL> _id -= self . bms_only <EOL> if ( not user . IsSECANC ( ) ) : <EOL> _id -= self . zixia_only <EOL> return _id <EOL> def GetInfo ( self ) : <EOL> info = { } <EOL> info [ '<STR_LIT>' ] = Util . gbkDec ( self . mtitle ) <EOL> info [ '<STR_LIT:title>' ] = Util . gbkDec ( self . title ) <EOL> info [ '<STR_LIT>' ] = self . attachpos <EOL> if ( self . host != '<STR_LIT>' ) : <EOL> info [ '<STR_LIT:host>' ] = self . host <EOL> info [ '<STR_LIT:port>' ] = self . port <EOL> info [ '<STR_LIT:type>' ] = '<STR_LIT>' <EOL> elif ( self . IsDir ( ) ) : <EOL> info [ '<STR_LIT:type>' ] = '<STR_LIT>' <EOL> elif ( self . IsFile ( ) ) : <EOL> info [ '<STR_LIT:type>' ] = '<STR_LIT:file>' <EOL> else : <EOL> info [ '<STR_LIT:type>' ] = '<STR_LIT>' <EOL> info [ '<STR_LIT>' ] = int ( self . GetModTime ( ) ) <EOL> return info <EOL> def GetInfoForUser ( self , user ) : <EOL> info = self . GetInfo ( ) <EOL> info [ '<STR_LIT:id>' ] = self . EffectiveId ( user ) + <NUM_LIT:1> <EOL> return info <EOL> def GetAttachLink ( self , session ) : <EOL> _hash = Util . HashGen ( self . path ( ) , "<STR_LIT>" ) <EOL> filename = '<STR_LIT>' <EOL> for i in range ( <NUM_LIT:2> ) : <EOL> filename += "<STR_LIT>" % struct . unpack ( '<STR_LIT>' , _hash [ i * <NUM_LIT:4> : ( i + <NUM_LIT:1> ) * <NUM_LIT:4> ] ) <EOL> link = "<STR_LIT>" % ( session . GetMirror ( Config . Config . GetInt ( '<STR_LIT>' , <NUM_LIT> ) ) , filename ) <EOL> linkfile = "<STR_LIT>" % ( Config . BBS_ROOT , filename ) <EOL> target = "<STR_LIT>" % self . path ( ) <EOL> try : <EOL> os . symlink ( target , linkfile ) <EOL> except : <EOL> pass <EOL> return link <EOL> class Digest : <EOL> root = DigestItem ( "<STR_LIT>" ) <EOL> def __init__ ( self , board , path ) : <EOL> self . board = board <EOL> self . path = path <EOL> self . root = DigestItem ( self . path ) <EOL> @ staticmethod <EOL> def GET ( svc , session , params , action ) : <EOL> if ( session is None ) : raise Unauthorized ( '<STR_LIT>' ) <EOL> if not session . CheckScope ( '<STR_LIT>' ) : raise NoPerm ( "<STR_LIT>" ) <EOL> user = session . GetUser ( ) <EOL> boardname = svc . get_str ( params , '<STR_LIT>' , '<STR_LIT>' ) <EOL> if ( boardname ) : <EOL> board = BoardManager . BoardManager . GetBoard ( boardname ) <EOL> if ( board is None ) : raise NotFound ( '<STR_LIT>' % boardname ) <EOL> if ( not board . CheckReadPerm ( user ) ) : <EOL> raise NoPerm ( '<STR_LIT>' ) <EOL> basenode = board . digest . root <EOL> has_perm = user . IsDigestMgr ( ) or user . IsSysop ( ) or user . IsSuperBM ( ) <EOL> else : <EOL> basenode = Digest . root <EOL> has_perm = user . IsDigestMgr ( ) <EOL> if ( action == "<STR_LIT:list>" ) : <EOL> route = svc . get_str ( params , '<STR_LIT>' ) <EOL> start = svc . get_int ( params , '<STR_LIT:start>' , <NUM_LIT:1> ) <EOL> end = svc . get_int ( params , '<STR_LIT:end>' , start + DEFAULT_DIGEST_LIST_COUNT - <NUM_LIT:1> ) <EOL> Digest . List ( svc , basenode , route , start , end , session , has_perm ) <EOL> return <EOL> elif ( action == "<STR_LIT>" ) : <EOL> route = svc . get_str ( params , '<STR_LIT>' ) <EOL> start = svc . get_int ( params , '<STR_LIT:start>' , <NUM_LIT:0> ) <EOL> count = svc . get_int ( params , '<STR_LIT:count>' , <NUM_LIT:0> ) <EOL> Digest . View ( svc , basenode , route , session , has_perm , start , count ) <EOL> return <EOL> else : <EOL> raise WrongArgs ( '<STR_LIT>' % action ) <EOL> @ staticmethod <EOL> def ParseRoute ( route ) : <EOL> ret = [ ] <EOL> items = re . split ( '<STR_LIT:->' , route ) <EOL> items = items [ <NUM_LIT:1> : ] <EOL> for item in items : <EOL> try : <EOL> ret += [ int ( item ) ] <EOL> except : <EOL> raise WrongArgs ( '<STR_LIT>' % item ) <EOL> return ret <EOL> @ staticmethod <EOL> def List ( svc , basenode , route , start , end , session , has_perm ) : <EOL> route_array = Digest . ParseRoute ( route ) <EOL> parent = basenode . GetItem ( session . GetUser ( ) , route_array , has_perm ) <EOL> if ( not parent ) : <EOL> raise WrongArgs ( '<STR_LIT>' % route ) <EOL> if ( not parent . IsDir ( ) ) : <EOL> raise WrongArgs ( '<STR_LIT>' % route ) <EOL> items = basenode . GetRange ( session . GetUser ( ) , route_array , start , end , has_perm ) <EOL> result = { } <EOL> result [ '<STR_LIT>' ] = parent . GetInfoForUser ( session . GetUser ( ) ) <EOL> result [ '<STR_LIT:count>' ] = len ( items ) <EOL> result_list = [ ] <EOL> for item in items : <EOL> result_list += [ item . GetInfoForUser ( session . GetUser ( ) ) ] <EOL> result [ '<STR_LIT>' ] = result_list <EOL> svc . writedata ( json . dumps ( result ) ) <EOL> @ staticmethod <EOL> def View ( svc , basenode , route , session , has_perm , start , count ) : <EOL> route_array = Digest . ParseRoute ( route ) <EOL> item = basenode . GetItem ( session . GetUser ( ) , route_array , has_perm ) <EOL> if ( not item ) : <EOL> raise WrongArgs ( '<STR_LIT>' % route ) <EOL> if ( not item . IsFile ( ) ) : <EOL> raise WrongArgs ( '<STR_LIT>' % route ) <EOL> result = { } <EOL> result [ '<STR_LIT>' ] = item . GetInfoForUser ( session . GetUser ( ) ) <EOL> postinfo = Post . Post ( item . realpath ( ) , None ) <EOL> ( result [ '<STR_LIT:content>' ] , result [ '<STR_LIT>' ] ) = postinfo . GetContent ( start , count ) <EOL> attachlist = postinfo . GetAttachListByType ( ) <EOL> result [ '<STR_LIT>' ] = attachlist [ <NUM_LIT:0> ] <EOL> result [ '<STR_LIT>' ] = attachlist [ <NUM_LIT:1> ] <EOL> if ( attachlist [ <NUM_LIT:0> ] or attachlist [ <NUM_LIT:1> ] ) : <EOL> result [ '<STR_LIT>' ] = item . GetAttachLink ( session ) <EOL> svc . writedata ( json . dumps ( result ) ) </s>
<s> import time <EOL> import UserManager <EOL> import UserInfo <EOL> from Session import Session <EOL> from Log import Log <EOL> import UCache <EOL> import Config <EOL> import MsgBox <EOL> import xmpp <EOL> import modes <EOL> import Util <EOL> import traceback <EOL> import os <EOL> from xmpp . features import NoRoute <EOL> __disco_info_ns__ = '<STR_LIT>' <EOL> __disco_items_ns__ = '<STR_LIT>' <EOL> __vcard_ns__ = '<STR_LIT>' <EOL> STEAL_AFTER_SEEN = <NUM_LIT:3> <EOL> def elem_to_str ( elem ) : <EOL> return "<STR_LIT>" % ( elem . tag , elem . attrib , elem . text ) <EOL> class XMPPServer ( xmpp . Plugin ) : <EOL> """<STR_LIT>""" <EOL> def __init__ ( self , rosters , host ) : <EOL> self . probed = False <EOL> self . _closed = False <EOL> self . rosters = rosters <EOL> self . _session = None <EOL> self . rosters . set_resources ( self . get_resources ( ) ) <EOL> self . _fixedjid = UCache . UCache . formalize_jid ( unicode ( self . authJID ) ) <EOL> self . _userid = self . _fixedjid . partition ( '<STR_LIT:@>' ) [ <NUM_LIT:0> ] . encode ( "<STR_LIT>" ) <EOL> if ( not self . rosters . allow_login ( self . authJID . bare ) ) : <EOL> Log . warn ( "<STR_LIT>" % self . _userid ) <EOL> self . stream_error ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> return <EOL> Log . info ( "<STR_LIT>" % unicode ( self . authJID ) ) <EOL> if self . authJID . resource [ : - <NUM_LIT:8> ] != "<STR_LIT>" and len ( self . authJID . resource ) > <NUM_LIT:8> : <EOL> try : <EOL> routes = self . routes ( self . authJID . bare ) <EOL> for route in routes : <EOL> jid = route [ <NUM_LIT:0> ] <EOL> if jid . resource [ : - <NUM_LIT:8> ] == self . authJID . resource [ : - <NUM_LIT:8> ] : <EOL> if jid . resource != self . authJID . resource : <EOL> Log . info ( "<STR_LIT>" % ( jid . full , route [ <NUM_LIT:1> ] ) ) <EOL> route [ <NUM_LIT:1> ] . stream_error ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> else : <EOL> Log . info ( "<STR_LIT>" % ( jid . full , route [ <NUM_LIT:1> ] ) ) <EOL> except NoRoute : <EOL> pass <EOL> Log . debug ( "<STR_LIT>" % self . authJID . full ) <EOL> self . _user = UserManager . UserManager . LoadUser ( self . _userid ) <EOL> if ( self . _user == None ) : <EOL> raise Exception ( "<STR_LIT>" ) <EOL> self . _peer_addr = self . getpeername ( ) <EOL> self . _session = Session ( self . _user , self . _peer_addr [ <NUM_LIT:0> ] ) <EOL> self . _session . RecordLogin ( ) <EOL> self . _userinfo = self . _session . Register ( ) <EOL> self . _loginid = self . _session . utmpent <EOL> self . _hostname = host <EOL> self . bind ( xmpp . ReceivedCloseStream , self . recv_close ) <EOL> self . bind ( xmpp . StreamClosed , self . stream_closed ) <EOL> self . bind ( xmpp . SentCloseStream , self . sent_close ) <EOL> self . rosters . register_conn ( self ) <EOL> msgbox = MsgBox . MsgBox ( self . _userid ) <EOL> if self . rosters . get_xmpp_read ( self . _user . GetUID ( ) ) is None : <EOL> self . rosters . set_xmpp_read ( self . _user . GetUID ( ) , msgbox . GetMsgCount ( all = False ) - msgbox . GetUnreadCount ( ) ) <EOL> self . check_msg ( ) <EOL> def get_loginid ( self ) : <EOL> return self . _loginid <EOL> def recv_close ( self ) : <EOL> Log . debug ( "<STR_LIT>" % self . authJID . full ) <EOL> return self . close ( ) <EOL> def stream_closed ( self ) : <EOL> Log . debug ( "<STR_LIT>" % self . authJID . full ) <EOL> return self . close ( ) <EOL> def sent_close ( self ) : <EOL> Log . debug ( "<STR_LIT>" % self . authJID . full ) <EOL> return self . close ( ) <EOL> def close ( self ) : <EOL> if ( self . _closed ) : <EOL> Log . debug ( "<STR_LIT>" ) <EOL> return <EOL> self . _closed = True <EOL> Log . info ( "<STR_LIT>" % unicode ( self . authJID ) ) <EOL> if ( self . _session ) : <EOL> self . _session . Unregister ( ) <EOL> self . unbind_res ( ) <EOL> self . rosters . unregister_conn ( self ) <EOL> @ xmpp . iq ( '<STR_LIT>' ) <EOL> def ping ( self , iq ) : <EOL> """<STR_LIT>""" <EOL> self . refresh ( ) <EOL> return self . iq ( '<STR_LIT:result>' , iq ) <EOL> @ xmpp . stanza ( '<STR_LIT:message>' ) <EOL> def message ( self , elem ) : <EOL> """<STR_LIT>""" <EOL> to_jid = elem . get ( '<STR_LIT:to>' ) <EOL> from_jid = elem . get ( '<STR_LIT>' ) <EOL> if ( from_jid == None ) : <EOL> return <EOL> text_body = None <EOL> for child in elem : <EOL> if ( child . tag . endswith ( '<STR_LIT>' ) ) : <EOL> text_body = child . text <EOL> if ( text_body == None ) : <EOL> return <EOL> ret = self . rosters . send_msg ( from_jid , to_jid , text_body ) <EOL> if ( ret <= <NUM_LIT:0> ) : <EOL> Log . warn ( "<STR_LIT>" % ( to_jid , from_jid , ret ) ) <EOL> errors = { <EOL> - <NUM_LIT:1> : "<STR_LIT>" , <EOL> - <NUM_LIT:11> : "<STR_LIT>" , <EOL> - <NUM_LIT:12> : "<STR_LIT>" , <EOL> - <NUM_LIT> : "<STR_LIT>" , <EOL> - <NUM_LIT> : "<STR_LIT>" , <EOL> - <NUM_LIT:2> : "<STR_LIT>" , <EOL> - <NUM_LIT> : "<STR_LIT>" } <EOL> if ( ret in errors ) : <EOL> elem = self . E . message ( { '<STR_LIT>' : to_jid , <EOL> '<STR_LIT:to>' : from_jid , <EOL> '<STR_LIT:type>' : '<STR_LIT:error>' } , <EOL> self . E . body ( errors [ ret ] ) ) <EOL> self . recv ( from_jid , elem ) <EOL> def make_jid ( self , userid ) : <EOL> return "<STR_LIT>" % ( userid , self . _hostname ) <EOL> def refresh ( self ) : <EOL> self . _userinfo . freshtime = int ( time . time ( ) ) <EOL> self . _userinfo . save ( ) <EOL> def ping_result ( self , iq ) : <EOL> self . refresh ( ) <EOL> def ping_client ( self ) : <EOL> try : <EOL> pingelem = self . E . ping ( xmlns = '<STR_LIT>' ) <EOL> return self . iq ( '<STR_LIT>' , self . ping_result , pingelem ) <EOL> except Exception as e : <EOL> Log . debug ( "<STR_LIT>" % ( self . authJID , e ) ) <EOL> Log . debug ( traceback . format_exc ( ) ) <EOL> return False <EOL> def get_uid ( self ) : <EOL> return self . _user . GetUID ( ) <EOL> def recv_msg ( self , from_ , msgtext ) : <EOL> elem = self . E . message ( { '<STR_LIT>' : from_ , '<STR_LIT:to>' : unicode ( self . authJID ) } , <EOL> self . E . body ( msgtext ) ) <EOL> self . recv ( unicode ( self . authJID ) , elem ) <EOL> def check_msg ( self ) : <EOL> Log . debug ( "<STR_LIT>" % self . _userid ) <EOL> msgbox = MsgBox . MsgBox ( self . _userid ) <EOL> msg_count = msgbox . GetMsgCount ( all = False ) <EOL> my_pid = os . getpid ( ) <EOL> xmpp_read = self . rosters . get_xmpp_read ( self . _user . GetUID ( ) ) <EOL> if xmpp_read > msg_count : <EOL> xmpp_read = <NUM_LIT:0> <EOL> Log . debug ( "<STR_LIT>" % ( msg_count , xmpp_read ) ) <EOL> self . rosters . set_xmpp_read ( self . _user . GetUID ( ) , msg_count ) <EOL> if xmpp_read < msg_count : <EOL> return xmpp_read <EOL> else : <EOL> return - <NUM_LIT:1> <EOL> def deliver_msg ( self , start ) : <EOL> Log . debug ( "<STR_LIT>" % unicode ( self . authJID ) ) <EOL> msgbox = MsgBox . MsgBox ( self . _userid ) <EOL> msg_count = msgbox . GetMsgCount ( all = False ) <EOL> my_pid = os . getpid ( ) <EOL> for i in range ( start , msg_count ) : <EOL> msghead = msgbox . LoadMsgHead ( i , all = False ) <EOL> if msghead . topid == my_pid : <EOL> msgtext = msgbox . LoadMsgText ( msghead ) <EOL> self . recv_msg ( self . make_jid ( msghead . id ) , msgtext ) <EOL> def steal_msg ( self ) : <EOL> Log . debug ( "<STR_LIT>" % self . _userid ) <EOL> msgbox = MsgBox . MsgBox ( self . _userid ) <EOL> msg_count = msgbox . GetMsgCount ( all = False ) <EOL> msg_unread = msgbox . GetUnreadCount ( ) <EOL> read_count = msg_count - msg_unread <EOL> my_pid = os . getpid ( ) <EOL> term_read = self . rosters . get_term_read ( self . get_uid ( ) ) <EOL> term_stealed = self . rosters . get_term_stealed ( self . get_uid ( ) ) <EOL> all_xmpp = True <EOL> new_unread = { } <EOL> for i in range ( read_count - <NUM_LIT:1> , msg_count ) : <EOL> if i < <NUM_LIT:0> : <EOL> continue <EOL> msghead = msgbox . LoadMsgHead ( i , all = False ) <EOL> if i >= read_count and all_xmpp : <EOL> if msghead . topid == my_pid : <EOL> msgbox . GetUnreadMsg ( ) <EOL> else : <EOL> all_xmpp = False <EOL> if msghead . topid == my_pid : <EOL> continue <EOL> if i < read_count : <EOL> session = self . rosters . find_session ( self . authJID . bare , msghead . topid ) <EOL> if session is None or session . get_mode ( ) != modes . MSG : <EOL> continue <EOL> Log . debug ( "<STR_LIT>" % i ) <EOL> if msghead . topid not in new_unread : <EOL> Log . debug ( "<STR_LIT>" % ( msghead . topid , i ) ) <EOL> new_unread [ msghead . topid ] = i <EOL> final_unread = { } <EOL> to_steal = { } <EOL> to_steal_begin = msg_count <EOL> for pid in term_read : <EOL> if pid in new_unread : <EOL> if new_unread [ pid ] == term_read [ pid ] [ <NUM_LIT:0> ] : <EOL> final_unread [ pid ] = ( term_read [ pid ] [ <NUM_LIT:0> ] , term_read [ pid ] [ <NUM_LIT:1> ] + <NUM_LIT:1> ) <EOL> Log . debug ( "<STR_LIT>" % ( new_unread [ pid ] , pid , term_read [ pid ] [ <NUM_LIT:1> ] + <NUM_LIT:1> ) ) <EOL> if final_unread [ pid ] [ <NUM_LIT:1> ] > STEAL_AFTER_SEEN : <EOL> to_steal [ pid ] = final_unread [ pid ] <EOL> Log . debug ( "<STR_LIT>" % ( to_steal [ pid ] [ <NUM_LIT:0> ] , pid ) ) <EOL> if pid in term_stealed : <EOL> steal_begin = max ( final_unread [ pid ] [ <NUM_LIT:0> ] , term_stealed [ pid ] + <NUM_LIT:1> ) <EOL> else : <EOL> steal_begin = final_unread [ pid ] [ <NUM_LIT:0> ] <EOL> if steal_begin < to_steal_begin : <EOL> to_steal_begin = steal_begin <EOL> else : <EOL> final_unread [ pid ] = ( new_unread [ pid ] , <NUM_LIT:1> ) <EOL> Log . debug ( "<STR_LIT>" % ( term_read [ pid ] [ <NUM_LIT:0> ] , new_unread [ pid ] , pid ) ) <EOL> else : <EOL> Log . debug ( "<STR_LIT>" % pid ) <EOL> pass <EOL> for pid in new_unread : <EOL> if pid not in term_read : <EOL> Log . debug ( "<STR_LIT>" % ( new_unread [ pid ] , pid ) ) <EOL> final_unread [ pid ] = ( new_unread [ pid ] , <NUM_LIT:1> ) <EOL> if to_steal : <EOL> Log . debug ( "<STR_LIT>" % to_steal_begin ) <EOL> for i in range ( to_steal_begin , msg_count ) : <EOL> msghead = msgbox . LoadMsgHead ( i , all = False ) <EOL> if msghead . topid == my_pid : <EOL> Log . debug ( "<STR_LIT>" % ( i , msghead . topid ) ) <EOL> msgbox . GetUnreadMsg ( ) <EOL> elif msghead . topid in to_steal : <EOL> if msghead . topid not in term_stealed or i > term_stealed [ msghead . topid ] : <EOL> Log . debug ( "<STR_LIT>" % ( i , msghead . topid ) ) <EOL> msgtext = msgbox . LoadMsgText ( msghead ) <EOL> self . recv_msg ( self . make_jid ( msghead . id ) , msgtext ) <EOL> term_stealed [ msghead . topid ] = i <EOL> else : <EOL> Log . debug ( "<STR_LIT>" % ( i , msghead . topid ) ) <EOL> self . rosters . set_term_read ( self . get_uid ( ) , final_unread ) <EOL> @ xmpp . stanza ( '<STR_LIT>' ) <EOL> def presence ( self , elem ) : <EOL> """<STR_LIT>""" <EOL> Log . warn ( "<STR_LIT>" % ( self . authJID , elem_to_str ( elem ) ) ) <EOL> if self . authJID == elem . get ( '<STR_LIT>' ) : <EOL> if ( elem . get ( '<STR_LIT:to>' ) == None or ( not self . authJID . match_bare ( elem . get ( '<STR_LIT:to>' ) ) ) ) : <EOL> return self . send_presence ( elem ) <EOL> self . recv_presence ( elem ) <EOL> def send_presence ( self , elem ) : <EOL> Log . warn ( "<STR_LIT>" % ( self . authJID , elem_to_str ( elem ) ) ) <EOL> direct = elem . get ( '<STR_LIT:to>' ) <EOL> if not direct : <EOL> self . rosters . broadcast ( self , elem ) <EOL> if elem . get ( '<STR_LIT:type>' ) != '<STR_LIT>' : <EOL> self . recv_presence ( elem ) <EOL> if not self . probed : <EOL> self . probed = True <EOL> self . rosters . probe ( self ) <EOL> elif not self . rosters . send ( self , direct , elem ) : <EOL> self . send ( direct , elem ) <EOL> def recv_presence ( self , elem ) : <EOL> Log . warn ( "<STR_LIT>" % ( self . authJID , elem_to_str ( elem ) ) ) <EOL> if not self . rosters . recv ( self , elem ) : <EOL> Log . warn ( "<STR_LIT>" ) <EOL> self . write ( elem ) <EOL> @ xmpp . iq ( '<STR_LIT>' ) <EOL> def roster ( self , iq ) : <EOL> """<STR_LIT>""" <EOL> roster = self . rosters . get ( self ) <EOL> method = getattr ( self , '<STR_LIT>' % iq . get ( '<STR_LIT:type>' ) ) <EOL> return method and method ( iq , roster ) <EOL> def get_roster ( self , iq , roster ) : <EOL> query = self . E . query ( { '<STR_LIT>' : '<STR_LIT>' } ) <EOL> for item in roster . items ( ) : <EOL> query . append ( item ) <EOL> return self . iq ( '<STR_LIT:result>' , iq , query ) <EOL> def set_roster ( self , iq , roster ) : <EOL> query = self . E . query ( xmlns = '<STR_LIT>' ) <EOL> for item in iq [ <NUM_LIT:0> ] : <EOL> result = roster . set ( item ) <EOL> if result is not None : <EOL> query . append ( result ) <EOL> if len ( query ) > <NUM_LIT:0> : <EOL> self . push ( roster , query ) <EOL> return self . iq ( '<STR_LIT:result>' , iq ) <EOL> def push ( self , roster , query ) : <EOL> """<STR_LIT>""" <EOL> for jid in roster . requests ( ) : <EOL> for ( to , route ) in self . routes ( jid ) : <EOL> route . iq ( '<STR_LIT>' , self . ignore , query ) <EOL> def ignore ( self , iq ) : <EOL> """<STR_LIT>""" <EOL> @ xmpp . iq ( '<STR_LIT>' ) <EOL> def vcard ( self , iq ) : <EOL> """<STR_LIT>""" <EOL> if iq . get ( '<STR_LIT:type>' ) == '<STR_LIT>' : <EOL> if ( iq . get ( '<STR_LIT:to>' ) == None ) : <EOL> target = iq . get ( '<STR_LIT>' ) <EOL> else : <EOL> target = iq . get ( '<STR_LIT:to>' ) <EOL> form_target = UCache . UCache . formalize_jid ( target ) <EOL> name = form_target . partition ( '<STR_LIT:@>' ) [ <NUM_LIT:0> ] <EOL> user = UserManager . UserManager . LoadUser ( name ) <EOL> info = user . GetInfo ( ) <EOL> desc = '''<STR_LIT>''' % ( info [ '<STR_LIT>' ] , info [ '<STR_LIT>' ] , info [ '<STR_LIT>' ] , <EOL> info [ '<STR_LIT>' ] , info [ '<STR_LIT>' ] , info [ '<STR_LIT>' ] , info [ '<STR_LIT>' ] ) <EOL> if ( '<STR_LIT>' in info ) : <EOL> desc += "<STR_LIT>" % ( info [ '<STR_LIT>' ] . replace ( '<STR_LIT:\n>' , '<STR_LIT:\r\n>' ) ) <EOL> vcard = self . E . vCard ( { '<STR_LIT>' : '<STR_LIT>' } , <EOL> self . E ( '<STR_LIT>' , name ) , <EOL> self . E ( '<STR_LIT>' , Util . Util . RemoveTags ( info [ '<STR_LIT>' ] ) ) , <EOL> self . E ( '<STR_LIT>' , Util . Util . RemoveTags ( desc ) ) ) <EOL> if ( iq . get ( '<STR_LIT:to>' ) == None ) : <EOL> return self . iq ( '<STR_LIT:result>' , iq , vcard ) <EOL> else : <EOL> return self . iq ( '<STR_LIT:result>' , iq , vcard , { '<STR_LIT>' : iq . get ( '<STR_LIT:to>' ) } ) <EOL> @ xmpp . iq ( '<STR_LIT>' % __disco_info_ns__ ) <EOL> def disco_info ( self , iq ) : <EOL> """<STR_LIT>""" <EOL> target = iq . get ( '<STR_LIT:to>' ) <EOL> if ( target . find ( '<STR_LIT:@>' ) < <NUM_LIT:0> ) : <EOL> query = self . E . query ( { '<STR_LIT>' : __disco_info_ns__ } , <EOL> self . E . identity ( { '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:type>' : '<STR_LIT>' , <EOL> '<STR_LIT:name>' : Config . Config . GetString ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> } ) ) <EOL> features = [ __disco_info_ns__ , __disco_items_ns__ , __vcard_ns__ ] <EOL> for feature in features : <EOL> query . append ( self . E . feature ( { '<STR_LIT>' : feature } ) ) <EOL> else : <EOL> query = self . E . query ( { '<STR_LIT>' : __disco_info_ns__ } , <EOL> self . E . identity ( { '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:type>' : '<STR_LIT>' , <EOL> '<STR_LIT:name>' : Config . Config . GetString ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> } ) ) <EOL> features = [ __disco_info_ns__ , __disco_items_ns__ , __vcard_ns__ ] <EOL> for feature in features : <EOL> query . append ( self . E . feature ( { '<STR_LIT>' : feature } ) ) <EOL> return self . iq ( '<STR_LIT:result>' , iq , query , { '<STR_LIT>' : target } ) <EOL> @ xmpp . iq ( '<STR_LIT>' % __disco_items_ns__ ) <EOL> def disco_items ( self , iq ) : <EOL> """<STR_LIT>""" <EOL> target = iq . get ( '<STR_LIT:to>' ) <EOL> if ( target . find ( '<STR_LIT:@>' ) < <NUM_LIT:0> ) : <EOL> query = self . E . query ( { '<STR_LIT>' : __disco_items_ns__ } ) <EOL> else : <EOL> query = self . E . query ( { '<STR_LIT>' : __disco_items_ns__ } ) <EOL> return self . iq ( '<STR_LIT:result>' , iq , query , { '<STR_LIT>' : target } ) </s>
<s> from __future__ import print_function <EOL> from __future__ import unicode_literals <EOL> from __future__ import division <EOL> from __future__ import absolute_import <EOL> from builtins import range <EOL> from future import standard_library <EOL> standard_library . install_aliases ( ) <EOL> import sys <EOL> PYTHON_VERSION = sys . version_info [ : <NUM_LIT:3> ] <EOL> PY2 = ( PYTHON_VERSION [ <NUM_LIT:0> ] == <NUM_LIT:2> ) <EOL> if PY2 : <EOL> if PYTHON_VERSION < ( <NUM_LIT:2> , <NUM_LIT:7> , <NUM_LIT:9> ) : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> elif PYTHON_VERSION < ( <NUM_LIT:3> , <NUM_LIT:4> ) : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> import hpOneView as hpov <EOL> from pprint import pprint <EOL> import json <EOL> from hpOneView . common import uri <EOL> import hpOneView . profile as profile <EOL> def acceptEULA ( con ) : <EOL> con . get_eula_status ( ) <EOL> try : <EOL> if con . get_eula_status ( ) is True : <EOL> print ( '<STR_LIT>' ) <EOL> con . set_eula ( '<STR_LIT>' ) <EOL> except Exception as e : <EOL> print ( '<STR_LIT>' ) <EOL> print ( e ) <EOL> def login ( con , credential ) : <EOL> try : <EOL> con . login ( credential ) <EOL> except : <EOL> print ( '<STR_LIT>' ) <EOL> def get_eg_uri_from_arg ( srv , name ) : <EOL> if srv and name : <EOL> if name . startswith ( '<STR_LIT>' ) and uri [ '<STR_LIT>' ] in name : <EOL> return name <EOL> else : <EOL> egs = srv . get_enclosure_groups ( ) <EOL> for eg in egs : <EOL> if eg [ '<STR_LIT:name>' ] == name : <EOL> return eg [ '<STR_LIT>' ] <EOL> return None <EOL> def get_sht_from_arg ( srv , name ) : <EOL> if srv and name : <EOL> if name . startswith ( '<STR_LIT>' ) and uri [ '<STR_LIT>' ] in name : <EOL> return name <EOL> else : <EOL> shts = srv . get_server_hardware_types ( ) <EOL> for sht in shts : <EOL> if sht [ '<STR_LIT:name>' ] == name : <EOL> return sht <EOL> return None <EOL> def define_profile_template ( <EOL> srv , <EOL> name , <EOL> desc , <EOL> sp_desc , <EOL> server_hwt , <EOL> enc_group , <EOL> affinity , <EOL> hide_flexnics , <EOL> conn_list , <EOL> fw_settings , <EOL> boot , <EOL> bootmode ) : <EOL> if conn_list : <EOL> conn = json . loads ( open ( conn_list ) . read ( ) ) <EOL> else : <EOL> conn = [ ] <EOL> profile_template = srv . create_server_profile_template ( <EOL> name = name , <EOL> description = desc , <EOL> serverProfileDescription = sp_desc , <EOL> serverHardwareTypeUri = server_hwt , <EOL> enclosureGroupUri = enc_group , <EOL> affinity = affinity , <EOL> hideUnusedFlexNics = hide_flexnics , <EOL> profileConnectionV4 = conn , <EOL> firmwareSettingsV3 = fw_settings , <EOL> bootSettings = boot , <EOL> bootModeSetting = bootmode ) <EOL> if '<STR_LIT>' in profile_template : <EOL> print ( '<STR_LIT>' , profile_template [ '<STR_LIT:name>' ] ) <EOL> print ( '<STR_LIT>' , profile_template [ '<STR_LIT:type>' ] ) <EOL> print ( '<STR_LIT>' , profile_template [ '<STR_LIT:description>' ] ) <EOL> print ( '<STR_LIT>' , profile_template [ '<STR_LIT>' ] ) <EOL> print ( '<STR_LIT>' ) <EOL> for connection in profile_template [ '<STR_LIT>' ] : <EOL> print ( '<STR_LIT>' , connection [ '<STR_LIT:name>' ] ) <EOL> print ( '<STR_LIT>' , connection [ '<STR_LIT>' ] ) <EOL> print ( '<STR_LIT>' , connection [ '<STR_LIT>' ] ) <EOL> print ( '<STR_LIT>' ) <EOL> print ( '<STR_LIT>' , profile_template [ '<STR_LIT>' ] [ '<STR_LIT>' ] ) <EOL> print ( '<STR_LIT>' , profile_template [ '<STR_LIT>' ] [ '<STR_LIT>' ] ) <EOL> print ( '<STR_LIT>' , profile_template [ '<STR_LIT>' ] [ '<STR_LIT>' ] ) <EOL> print ( '<STR_LIT>' ) <EOL> print ( '<STR_LIT>' , profile_template [ '<STR_LIT>' ] [ '<STR_LIT>' ] ) <EOL> print ( '<STR_LIT>' , profile_template [ '<STR_LIT>' ] [ '<STR_LIT>' ] ) <EOL> print ( '<STR_LIT>' ) <EOL> print ( '<STR_LIT>' , profile_template [ '<STR_LIT>' ] [ '<STR_LIT>' ] ) <EOL> print ( '<STR_LIT>' , profile_template [ '<STR_LIT>' ] [ '<STR_LIT>' ] , '<STR_LIT:\n>' ) <EOL> else : <EOL> pprint ( profile_template ) <EOL> def main ( ) : <EOL> parser = argparse . ArgumentParser ( add_help = True , <EOL> formatter_class = argparse . RawTextHelpFormatter , <EOL> description = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT:host>' , required = True , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT:user>' , required = False , <EOL> default = '<STR_LIT>' , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , required = True , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT:-c>' , dest = '<STR_LIT>' , required = False , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , required = False , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT:name>' , <EOL> required = True , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , <EOL> required = False , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , <EOL> required = False , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , required = True , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , required = True , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , <EOL> required = False , choices = [ '<STR_LIT>' , '<STR_LIT>' ] , <EOL> default = '<STR_LIT>' , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , <EOL> required = False , choices = [ '<STR_LIT:true>' , '<STR_LIT:false>' ] , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , <EOL> required = False , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , required = False , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , <EOL> action = '<STR_LIT:store_true>' , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , required = False , <EOL> nargs = '<STR_LIT:+>' , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , required = False , <EOL> choices = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] , <EOL> default = '<STR_LIT>' , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , required = False , <EOL> choices = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' ] , <EOL> default = '<STR_LIT>' , <EOL> help = '''<STR_LIT>''' ) <EOL> args = parser . parse_args ( ) <EOL> credential = { '<STR_LIT>' : args . user , '<STR_LIT:password>' : args . passwd } <EOL> con = hpov . connection ( args . host ) <EOL> srv = hpov . servers ( con ) <EOL> sts = hpov . settings ( con ) <EOL> if args . proxy : <EOL> con . set_proxy ( args . proxy . split ( '<STR_LIT::>' ) [ <NUM_LIT:0> ] , args . proxy . split ( '<STR_LIT::>' ) [ <NUM_LIT:1> ] ) <EOL> if args . cert : <EOL> con . set_trusted_ssl_bundle ( args . cert ) <EOL> login ( con , credential ) <EOL> acceptEULA ( con ) <EOL> eg_uri = get_eg_uri_from_arg ( srv , args . enc_group ) <EOL> sht = get_sht_from_arg ( srv , args . server_hwt ) <EOL> fw_settings = profile . make_firmware_dict ( sts , args . baseline ) <EOL> boot , bootmode = profile . make_boot_settings_dict ( srv , sht , args . disable_manage_boot , <EOL> args . boot_order , args . boot_mode , args . pxe ) <EOL> define_profile_template ( srv , <EOL> args . name , <EOL> args . desc , <EOL> args . sp_desc , <EOL> sht [ '<STR_LIT>' ] , <EOL> eg_uri , <EOL> args . affinity , <EOL> args . hide_flexnics , <EOL> args . conn_list , <EOL> fw_settings , <EOL> boot , <EOL> bootmode ) <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL> import argparse <EOL> sys . exit ( main ( ) ) </s>
<s> from __future__ import print_function <EOL> from __future__ import unicode_literals <EOL> from __future__ import division <EOL> from __future__ import absolute_import <EOL> from builtins import range <EOL> from future import standard_library <EOL> standard_library . install_aliases ( ) <EOL> import sys <EOL> PYTHON_VERSION = sys . version_info [ : <NUM_LIT:3> ] <EOL> PY2 = ( PYTHON_VERSION [ <NUM_LIT:0> ] == <NUM_LIT:2> ) <EOL> if PY2 : <EOL> if PYTHON_VERSION < ( <NUM_LIT:2> , <NUM_LIT:7> , <NUM_LIT:9> ) : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> elif PYTHON_VERSION < ( <NUM_LIT:3> , <NUM_LIT:4> ) : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> import hpOneView as hpov <EOL> from pprint import pprint <EOL> def acceptEULA ( con ) : <EOL> con . get_eula_status ( ) <EOL> try : <EOL> if con . get_eula_status ( ) is True : <EOL> print ( "<STR_LIT>" ) <EOL> con . set_eula ( '<STR_LIT>' ) <EOL> except Exception as e : <EOL> print ( '<STR_LIT>' ) <EOL> print ( e ) <EOL> def login ( con , credential ) : <EOL> try : <EOL> con . login ( credential ) <EOL> except : <EOL> print ( '<STR_LIT>' ) <EOL> def get_address_pools ( con , srv , types ) : <EOL> if types == '<STR_LIT>' or types == '<STR_LIT>' : <EOL> vmac = srv . get_vmac_pool ( ) <EOL> print ( ) <EOL> for key in sorted ( vmac ) : <EOL> print ( '<STR_LIT>' . format ( key , vmac [ key ] ) ) <EOL> if '<STR_LIT>' in vmac : <EOL> for uri in vmac [ '<STR_LIT>' ] : <EOL> ranges = con . get ( uri ) <EOL> print ( '<STR_LIT>' , ranges [ '<STR_LIT>' ] ) <EOL> print ( '<STR_LIT>' , ranges [ '<STR_LIT>' ] ) <EOL> print ( '<STR_LIT>' , ranges [ '<STR_LIT>' ] ) <EOL> if types == '<STR_LIT>' or types == '<STR_LIT>' : <EOL> vwwn = srv . get_vwwn_pool ( ) <EOL> print ( ) <EOL> for key in sorted ( vwwn ) : <EOL> print ( '<STR_LIT>' . format ( key , vwwn [ key ] ) ) <EOL> if '<STR_LIT>' in vwwn : <EOL> for uri in vwwn [ '<STR_LIT>' ] : <EOL> ranges = con . get ( uri ) <EOL> print ( '<STR_LIT>' , ranges [ '<STR_LIT>' ] ) <EOL> print ( '<STR_LIT>' , ranges [ '<STR_LIT>' ] ) <EOL> print ( '<STR_LIT>' , ranges [ '<STR_LIT>' ] ) <EOL> if types == '<STR_LIT>' or types == '<STR_LIT>' : <EOL> vsn = srv . get_vsn_pool ( ) <EOL> print ( ) <EOL> for key in sorted ( vsn ) : <EOL> print ( '<STR_LIT>' . format ( key , vsn [ key ] ) ) <EOL> if '<STR_LIT>' in vsn : <EOL> for uri in vsn [ '<STR_LIT>' ] : <EOL> ranges = con . get ( uri ) <EOL> print ( '<STR_LIT>' , ranges [ '<STR_LIT>' ] ) <EOL> print ( '<STR_LIT>' , ranges [ '<STR_LIT>' ] ) <EOL> print ( '<STR_LIT>' , ranges [ '<STR_LIT>' ] ) <EOL> def main ( ) : <EOL> parser = argparse . ArgumentParser ( add_help = True , <EOL> formatter_class = argparse . RawTextHelpFormatter , <EOL> description = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT:host>' , required = True , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT:user>' , required = False , <EOL> default = '<STR_LIT>' , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , required = True , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT:-c>' , dest = '<STR_LIT>' , required = False , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , required = False , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , required = False , <EOL> default = '<STR_LIT>' , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , required = False , <EOL> choices = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] , default = '<STR_LIT>' , <EOL> help = '''<STR_LIT>''' ) <EOL> args = parser . parse_args ( ) <EOL> credential = { '<STR_LIT>' : args . domain . upper ( ) , '<STR_LIT>' : args . user , '<STR_LIT:password>' : args . passwd } <EOL> con = hpov . connection ( args . host ) <EOL> srv = hpov . servers ( con ) <EOL> if args . proxy : <EOL> con . set_proxy ( args . proxy . split ( '<STR_LIT::>' ) [ <NUM_LIT:0> ] , args . proxy . split ( '<STR_LIT::>' ) [ <NUM_LIT:1> ] ) <EOL> if args . cert : <EOL> con . set_trusted_ssl_bundle ( args . cert ) <EOL> login ( con , credential ) <EOL> acceptEULA ( con ) <EOL> get_address_pools ( con , srv , args . types ) <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL> import sys <EOL> import argparse <EOL> sys . exit ( main ( ) ) </s>
<s> from __future__ import print_function <EOL> from __future__ import unicode_literals <EOL> from __future__ import division <EOL> from __future__ import absolute_import <EOL> from builtins import range <EOL> from future import standard_library <EOL> standard_library . install_aliases ( ) <EOL> import sys <EOL> import re <EOL> PYTHON_VERSION = sys . version_info [ : <NUM_LIT:3> ] <EOL> PY2 = ( PYTHON_VERSION [ <NUM_LIT:0> ] == <NUM_LIT:2> ) <EOL> if PY2 : <EOL> if PYTHON_VERSION < ( <NUM_LIT:2> , <NUM_LIT:7> , <NUM_LIT:9> ) : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> elif PYTHON_VERSION < ( <NUM_LIT:3> , <NUM_LIT:4> ) : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> import hpOneView as hpov <EOL> from pprint import pprint <EOL> def acceptEULA ( con ) : <EOL> con . get_eula_status ( ) <EOL> try : <EOL> if con . get_eula_status ( ) is True : <EOL> print ( '<STR_LIT>' ) <EOL> con . set_eula ( '<STR_LIT>' ) <EOL> except Exception as e : <EOL> print ( '<STR_LIT>' ) <EOL> print ( e ) <EOL> def login ( con , credential ) : <EOL> try : <EOL> con . login ( credential ) <EOL> except : <EOL> print ( '<STR_LIT>' ) <EOL> def get_managed_sans ( fcs ) : <EOL> sans = fcs . get_managed_sans ( ) <EOL> pprint ( sans ) <EOL> def main ( ) : <EOL> parser = argparse . ArgumentParser ( add_help = True , <EOL> formatter_class = argparse . RawTextHelpFormatter , <EOL> description = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT:host>' , required = True , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT:user>' , required = False , <EOL> default = '<STR_LIT>' , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , required = True , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT:-c>' , dest = '<STR_LIT>' , required = False , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , required = False , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , required = False , <EOL> default = '<STR_LIT>' , <EOL> help = '''<STR_LIT>''' ) <EOL> args = parser . parse_args ( ) <EOL> credential = { '<STR_LIT>' : args . domain . upper ( ) , '<STR_LIT>' : args . user , '<STR_LIT:password>' : args . passwd } <EOL> con = hpov . connection ( args . host ) <EOL> fcs = hpov . fcsans ( con ) <EOL> if args . proxy : <EOL> con . set_proxy ( args . proxy . split ( '<STR_LIT::>' ) [ <NUM_LIT:0> ] , args . proxy . split ( '<STR_LIT::>' ) [ <NUM_LIT:1> ] ) <EOL> if args . cert : <EOL> con . set_trusted_ssl_bundle ( args . cert ) <EOL> login ( con , credential ) <EOL> acceptEULA ( con ) <EOL> get_managed_sans ( fcs ) <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL> import sys <EOL> import argparse <EOL> sys . exit ( main ( ) ) </s>
<s> from __future__ import print_function <EOL> from __future__ import unicode_literals <EOL> from __future__ import division <EOL> from __future__ import absolute_import <EOL> from builtins import range <EOL> from future import standard_library <EOL> standard_library . install_aliases ( ) <EOL> import sys <EOL> PYTHON_VERSION = sys . version_info [ : <NUM_LIT:3> ] <EOL> PY2 = ( PYTHON_VERSION [ <NUM_LIT:0> ] == <NUM_LIT:2> ) <EOL> if PY2 : <EOL> if PYTHON_VERSION < ( <NUM_LIT:2> , <NUM_LIT:7> , <NUM_LIT:9> ) : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> elif PYTHON_VERSION < ( <NUM_LIT:3> , <NUM_LIT:4> ) : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> import hpOneView as hpov <EOL> from pprint import pprint <EOL> def acceptEULA ( con ) : <EOL> con . get_eula_status ( ) <EOL> try : <EOL> if con . get_eula_status ( ) is True : <EOL> print ( '<STR_LIT>' ) <EOL> con . set_eula ( '<STR_LIT>' ) <EOL> except Exception as e : <EOL> print ( '<STR_LIT>' ) <EOL> print ( e ) <EOL> def login ( con , credential ) : <EOL> try : <EOL> con . login ( credential ) <EOL> except : <EOL> print ( '<STR_LIT>' ) <EOL> def getpolicy ( sts ) : <EOL> policy = sts . get_storage_vol_template_policy ( ) <EOL> print ( policy [ '<STR_LIT:value>' ] ) <EOL> def main ( ) : <EOL> parser = argparse . ArgumentParser ( add_help = True , <EOL> formatter_class = argparse . RawTextHelpFormatter , <EOL> description = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT:host>' , required = True , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT:user>' , required = False , <EOL> default = '<STR_LIT>' , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , required = True , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT:-c>' , dest = '<STR_LIT>' , required = False , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , required = False , <EOL> help = '''<STR_LIT>''' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , required = False , <EOL> default = '<STR_LIT>' , <EOL> help = '''<STR_LIT>''' ) <EOL> args = parser . parse_args ( ) <EOL> credential = { '<STR_LIT>' : args . domain . upper ( ) , '<STR_LIT>' : args . user , '<STR_LIT:password>' : args . passwd } <EOL> con = hpov . connection ( args . host ) <EOL> sts = hpov . settings ( con ) <EOL> if args . proxy : <EOL> con . set_proxy ( args . proxy . split ( '<STR_LIT::>' ) [ <NUM_LIT:0> ] , args . proxy . split ( '<STR_LIT::>' ) [ <NUM_LIT:1> ] ) <EOL> if args . cert : <EOL> con . set_trusted_ssl_bundle ( args . cert ) <EOL> login ( con , credential ) <EOL> acceptEULA ( con ) <EOL> getpolicy ( sts ) <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL> import sys <EOL> import argparse <EOL> sys . exit ( main ( ) ) </s>
<s> """<STR_LIT>""" <EOL> from __future__ import unicode_literals <EOL> from __future__ import print_function <EOL> from __future__ import division <EOL> from __future__ import absolute_import <EOL> from future import standard_library <EOL> standard_library . install_aliases ( ) <EOL> from pprint import pprint <EOL> __title__ = '<STR_LIT>' <EOL> __version__ = '<STR_LIT>' <EOL> __copyright__ = '<STR_LIT>' '<STR_LIT>' <EOL> __license__ = '<STR_LIT>' <EOL> __status__ = '<STR_LIT>' <EOL> from hpOneView . common import * <EOL> from hpOneView . connection import * <EOL> from hpOneView . activity import * <EOL> from hpOneView . exceptions import * <EOL> class servers ( object ) : <EOL> def __init__ ( self , con ) : <EOL> self . _con = con <EOL> self . _activity = activity ( con ) <EOL> def get_connections ( self , filter = '<STR_LIT>' ) : <EOL> """<STR_LIT>""" <EOL> return get_members ( self . _con . get ( uri [ '<STR_LIT>' ] + filter ) ) <EOL> def get_connection ( self , server ) : <EOL> """<STR_LIT>""" <EOL> body = self . _con . get ( server [ '<STR_LIT>' ] ) <EOL> return body <EOL> def get_server_by_bay ( self , baynum ) : <EOL> servers = get_members ( self . _con . get ( uri [ '<STR_LIT>' ] ) ) <EOL> for server in servers : <EOL> if server [ '<STR_LIT>' ] == baynum : <EOL> return server <EOL> def get_server_by_name ( self , name ) : <EOL> servers = get_members ( self . _con . get ( uri [ '<STR_LIT>' ] ) ) <EOL> for server in servers : <EOL> if server [ '<STR_LIT:name>' ] == name : <EOL> return server <EOL> def get_available_servers ( self , server_hardware_type = None , <EOL> enclosure_group = None , server_profile = None ) : <EOL> filters = [ ] <EOL> if server_hardware_type : <EOL> filters . append ( '<STR_LIT>' + server_hardware_type [ '<STR_LIT>' ] ) <EOL> if enclosure_group : <EOL> filters . append ( '<STR_LIT>' + enclosure_group [ '<STR_LIT>' ] ) <EOL> if server_profile : <EOL> filters . append ( '<STR_LIT>' + server_profile [ '<STR_LIT>' ] ) <EOL> query_string = '<STR_LIT>' <EOL> if filters : <EOL> query_string = '<STR_LIT:?>' + '<STR_LIT:&>' . join ( filters ) <EOL> return self . _con . get ( uri [ '<STR_LIT>' ] + query_string ) <EOL> def get_servers ( self ) : <EOL> return get_members ( self . _con . get ( uri [ '<STR_LIT>' ] ) ) <EOL> def get_utilization ( self , server ) : <EOL> """<STR_LIT>""" <EOL> body = self . _con . get ( server [ '<STR_LIT>' ] + '<STR_LIT>' ) <EOL> return body <EOL> def get_env_conf ( self , server ) : <EOL> """<STR_LIT>""" <EOL> body = self . _con . get ( server [ '<STR_LIT>' ] + '<STR_LIT>' ) <EOL> return body <EOL> def set_server_powerstate ( self , server , state , force = False , blocking = True , <EOL> verbose = False ) : <EOL> if state == '<STR_LIT>' and force is True : <EOL> powerRequest = make_powerstate_dict ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> elif state == '<STR_LIT>' and force is False : <EOL> powerRequest = make_powerstate_dict ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> elif state == '<STR_LIT>' : <EOL> powerRequest = make_powerstate_dict ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> elif state == '<STR_LIT>' : <EOL> powerRequest = make_powerstate_dict ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> task , body = self . _con . put ( server [ '<STR_LIT>' ] + '<STR_LIT>' , powerRequest ) <EOL> if blocking is True : <EOL> task = self . _activity . wait4task ( task , tout = <NUM_LIT> , verbose = verbose ) <EOL> return task <EOL> def delete_server ( self , server , force = False , blocking = True , verbose = False ) : <EOL> if force : <EOL> task , body = self . _con . delete ( server [ '<STR_LIT>' ] + '<STR_LIT>' ) <EOL> else : <EOL> task , body = self . _con . delete ( server [ '<STR_LIT>' ] ) <EOL> if blocking is True : <EOL> task = self . _activity . wait4task ( task , tout = <NUM_LIT> , verbose = verbose ) <EOL> return task <EOL> def update_server ( self , server ) : <EOL> task , body = self . _con . put ( server [ '<STR_LIT>' ] , server ) <EOL> return body <EOL> def add_server ( self , server , blocking = True , verbose = False ) : <EOL> task , body = self . _con . post ( uri [ '<STR_LIT>' ] , server ) <EOL> if blocking is True : <EOL> task = self . _activity . wait4task ( task , tout = <NUM_LIT> , verbose = verbose ) <EOL> if '<STR_LIT:type>' in task and task [ '<STR_LIT:type>' ] . startswith ( '<STR_LIT>' ) : <EOL> entity = self . _activity . get_task_associated_resource ( task ) <EOL> server = self . _con . get ( entity [ '<STR_LIT>' ] ) <EOL> return server <EOL> return task <EOL> def get_server_schema ( self ) : <EOL> """<STR_LIT>""" <EOL> return self . _con . get ( uri [ '<STR_LIT>' ] + '<STR_LIT>' ) <EOL> def get_bios ( self , server ) : <EOL> """<STR_LIT>""" <EOL> return self . _con . get ( server [ '<STR_LIT>' ] + '<STR_LIT>' ) <EOL> def get_ilo_sso_url ( self , server ) : <EOL> """<STR_LIT>""" <EOL> return self . _con . get ( server [ '<STR_LIT>' ] + '<STR_LIT>' ) <EOL> def get_java_remote_console_url ( self , server ) : <EOL> """<STR_LIT>""" <EOL> return self . _con . get ( server [ '<STR_LIT>' ] + '<STR_LIT>' ) <EOL> def get_remote_console_url ( self , server ) : <EOL> """<STR_LIT>""" <EOL> return self . _con . get ( server [ '<STR_LIT>' ] + '<STR_LIT>' ) <EOL> def get_server_hardware_types ( self ) : <EOL> """<STR_LIT>""" <EOL> body = self . _con . get ( uri [ '<STR_LIT>' ] ) <EOL> return get_members ( body ) <EOL> def remove_server_hardware_type ( self , server_hardware_type , force = False , blocking = True , verbose = False ) : <EOL> """<STR_LIT>""" <EOL> if force : <EOL> task , body = self . _con . delete ( server_hardware_type [ '<STR_LIT>' ] + '<STR_LIT>' ) <EOL> else : <EOL> task , body = self . _con . delete ( server_hardware_type [ '<STR_LIT>' ] ) <EOL> if blocking is True : <EOL> task = self . _activity . wait4task ( task , tout = <NUM_LIT> , verbose = verbose ) <EOL> return task <EOL> def get_server_type_schema ( self ) : <EOL> """<STR_LIT>""" <EOL> return self . _con . get ( uri [ '<STR_LIT>' ] + '<STR_LIT>' ) <EOL> def get_server_hardware_type ( self , server_type ) : <EOL> """<STR_LIT>""" <EOL> return self . _con . get ( server_type [ '<STR_LIT>' ] ) <EOL> def set_server_hardware_type ( self , server_hardware_type , name , description ) : <EOL> """<STR_LIT>""" <EOL> request = make_server_type_dict ( name , description ) <EOL> task , body = self . _con . put ( server_hardware_type [ '<STR_LIT>' ] , request ) <EOL> return task <EOL> def create_server_profile ( self , <EOL> affinity = '<STR_LIT>' , <EOL> biosSettings = None , <EOL> bootSettings = None , <EOL> bootModeSetting = None , <EOL> profileConnectionV4 = None , <EOL> description = None , <EOL> firmwareSettingsV3 = None , <EOL> hideUnusedFlexNics = True , <EOL> localStorageSettingsV3 = None , <EOL> macType = '<STR_LIT>' , <EOL> name = None , <EOL> sanStorageV3 = None , <EOL> serialNumber = None , <EOL> serialNumberType = '<STR_LIT>' , <EOL> serverHardwareTypeUri = None , <EOL> serverHardwareUri = None , <EOL> serverProfileTemplateUri = None , <EOL> uuid = None , <EOL> wwnType = '<STR_LIT>' , <EOL> blocking = True , verbose = False ) : <EOL> """<STR_LIT>""" <EOL> profile = make_ServerProfileV5 ( affinity , biosSettings , bootSettings , <EOL> bootModeSetting , profileConnectionV4 , <EOL> description , firmwareSettingsV3 , <EOL> hideUnusedFlexNics , <EOL> localStorageSettingsV3 , macType , name , <EOL> sanStorageV3 , serialNumber , <EOL> serialNumberType , serverHardwareTypeUri , <EOL> serverHardwareUri , <EOL> serverProfileTemplateUri , uuid , wwnType ) <EOL> task , body = self . _con . post ( uri [ '<STR_LIT>' ] , profile ) <EOL> if profile [ '<STR_LIT>' ] is None : <EOL> tout = <NUM_LIT> <EOL> else : <EOL> tout = <NUM_LIT> <EOL> if blocking is True : <EOL> task = self . _activity . wait4task ( task , tout , verbose = verbose ) <EOL> if '<STR_LIT:type>' in task and task [ '<STR_LIT:type>' ] . startswith ( '<STR_LIT>' ) : <EOL> entity = self . _activity . get_task_associated_resource ( task ) <EOL> profile = self . _con . get ( entity [ '<STR_LIT>' ] ) <EOL> return profile <EOL> return task <EOL> def post_server_profile ( self , profile , blocking = True , verbose = False ) : <EOL> """<STR_LIT>""" <EOL> task , body = self . _con . post ( uri [ '<STR_LIT>' ] , profile ) <EOL> if profile [ '<STR_LIT>' ] is None : <EOL> tout = <NUM_LIT> <EOL> else : <EOL> tout = <NUM_LIT> <EOL> if blocking is True : <EOL> task = self . _activity . wait4task ( task , tout , verbose = verbose ) <EOL> if '<STR_LIT:type>' in task and task [ '<STR_LIT:type>' ] . startswith ( '<STR_LIT>' ) : <EOL> entity = self . _activity . get_task_associated_resource ( task ) <EOL> profile = self . _con . get ( entity [ '<STR_LIT>' ] ) <EOL> return profile <EOL> return task <EOL> def remove_server_profile ( self , profile , force = False , blocking = True , verbose = False ) : <EOL> if force : <EOL> task , body = self . _con . delete ( profile [ '<STR_LIT>' ] + '<STR_LIT>' ) <EOL> else : <EOL> task , body = self . _con . delete ( profile [ '<STR_LIT>' ] ) <EOL> if blocking is True : <EOL> task = self . _activity . wait4task ( task , tout = <NUM_LIT> , verbose = verbose ) <EOL> return task <EOL> def get_server_profiles ( self ) : <EOL> body = self . _con . get ( uri [ '<STR_LIT>' ] ) <EOL> return get_members ( body ) <EOL> def update_server_profile ( self , profile , blocking = True , verbose = False ) : <EOL> task , body = self . _con . put ( profile [ '<STR_LIT>' ] , profile ) <EOL> try : <EOL> if profile [ '<STR_LIT>' ] [ '<STR_LIT>' ] is None : <EOL> tout = <NUM_LIT> <EOL> else : <EOL> tout = <NUM_LIT> <EOL> except Exception : <EOL> tout = <NUM_LIT> <EOL> if blocking is True : <EOL> task = self . _activity . wait4task ( task , tout = tout , verbose = verbose ) <EOL> profileResource = self . _activity . get_task_associated_resource ( task ) <EOL> profile = self . _con . get ( profileResource [ '<STR_LIT>' ] ) <EOL> return profile <EOL> def update_server_profile_from_template ( self , profile , blocking = True , verbose = False ) : <EOL> patch_request = [ { '<STR_LIT>' : '<STR_LIT:replace>' , '<STR_LIT:path>' : '<STR_LIT>' , '<STR_LIT:value>' : '<STR_LIT>' } ] <EOL> task , body = self . _con . patch ( profile [ '<STR_LIT>' ] , patch_request ) <EOL> try : <EOL> if profile [ '<STR_LIT>' ] [ '<STR_LIT>' ] is None : <EOL> tout = <NUM_LIT> <EOL> else : <EOL> tout = <NUM_LIT> <EOL> except Exception : <EOL> tout = <NUM_LIT> <EOL> if blocking is True : <EOL> task = self . _activity . wait4task ( task , tout = tout , verbose = verbose ) <EOL> profileResource = self . _activity . get_task_associated_resource ( task ) <EOL> profile = self . _con . get ( profileResource [ '<STR_LIT>' ] ) <EOL> return profile <EOL> def get_server_profile_by_name ( self , name ) : <EOL> body = self . _con . get_entity_byfield ( uri [ '<STR_LIT>' ] , '<STR_LIT:name>' , name ) <EOL> return body <EOL> def get_profile_message ( self , profile ) : <EOL> """<STR_LIT>""" <EOL> message = self . _con . get ( profile [ '<STR_LIT>' ] + '<STR_LIT>' ) <EOL> return message <EOL> def get_profile_compliance_preview ( self , profile ) : <EOL> """<STR_LIT>""" <EOL> return self . _con . get ( profile [ '<STR_LIT>' ] + '<STR_LIT>' ) <EOL> def create_server_profile_template ( <EOL> self , <EOL> name = None , <EOL> description = None , <EOL> serverProfileDescription = None , <EOL> serverHardwareTypeUri = None , <EOL> enclosureGroupUri = None , <EOL> affinity = None , <EOL> hideUnusedFlexNics = None , <EOL> profileConnectionV4 = None , <EOL> firmwareSettingsV3 = None , <EOL> bootSettings = None , <EOL> bootModeSetting = None , <EOL> blocking = True , <EOL> verbose = False ) : <EOL> """<STR_LIT>""" <EOL> profile_template = make_ServerProfileTemplateV1 ( name , <EOL> description , <EOL> serverProfileDescription , <EOL> serverHardwareTypeUri , <EOL> enclosureGroupUri , <EOL> affinity , <EOL> hideUnusedFlexNics , <EOL> profileConnectionV4 , <EOL> firmwareSettingsV3 , <EOL> bootSettings , <EOL> bootModeSetting ) <EOL> task , body = self . _con . post ( uri [ '<STR_LIT>' ] , profile_template ) <EOL> tout = <NUM_LIT> <EOL> if blocking is True : <EOL> task = self . _activity . wait4task ( task , tout , verbose = verbose ) <EOL> if '<STR_LIT:type>' in task and task [ '<STR_LIT:type>' ] . startswith ( '<STR_LIT>' ) : <EOL> entity = self . _activity . get_task_associated_resource ( task ) <EOL> profile_template = self . _con . get ( entity [ '<STR_LIT>' ] ) <EOL> return profile_template <EOL> return task <EOL> def remove_server_profile_template ( self , profile_template , blocking = True , verbose = False ) : <EOL> task , body = self . _con . delete ( profile_template [ '<STR_LIT>' ] ) <EOL> if blocking is True : <EOL> task = self . _activity . wait4task ( task , tout = <NUM_LIT> , verbose = verbose ) <EOL> return task <EOL> return body <EOL> def get_server_profile_templates ( self ) : <EOL> body = self . _con . get ( uri [ '<STR_LIT>' ] ) <EOL> return get_members ( body ) <EOL> def get_server_profile_template_by_name ( self , name ) : <EOL> body = self . _con . get_entity_byfield ( uri [ '<STR_LIT>' ] , '<STR_LIT:name>' , name ) <EOL> return body <EOL> def update_server_profile_template ( self , profile_template , blocking = True , verbose = False ) : <EOL> task , body = self . _con . put ( profile_template [ '<STR_LIT>' ] , profile_template ) <EOL> tout = <NUM_LIT> <EOL> if blocking is True : <EOL> task = self . _activity . wait4task ( task , tout = tout , verbose = verbose ) <EOL> profileTemplateResource = self . _activity . get_task_associated_resource ( task ) <EOL> profile = self . _con . get ( profileTemplateResource [ '<STR_LIT>' ] ) <EOL> return profile_template <EOL> def get_server_profile_from_template ( self , profile_template ) : <EOL> profile = self . _con . get ( profile_template [ '<STR_LIT>' ] + '<STR_LIT>' ) <EOL> return profile <EOL> def get_enclosures ( self ) : <EOL> body = self . _con . get ( uri [ '<STR_LIT>' ] ) <EOL> return get_members ( body ) <EOL> def add_enclosure ( self , enclosure , blocking = True , verbose = False ) : <EOL> task , body = self . _con . post ( uri [ '<STR_LIT>' ] , enclosure ) <EOL> if enclosure [ '<STR_LIT:state>' ] is '<STR_LIT>' : <EOL> tout = <NUM_LIT> <EOL> elif enclosure [ '<STR_LIT>' ] is None : <EOL> tout = <NUM_LIT> <EOL> else : <EOL> tout = <NUM_LIT> <EOL> if blocking is True : <EOL> task = self . _activity . wait4task ( task , tout , verbose = verbose ) <EOL> if '<STR_LIT:type>' in task and task [ '<STR_LIT:type>' ] . startswith ( '<STR_LIT>' ) : <EOL> entity = self . _activity . get_task_associated_resource ( task ) <EOL> enclosure = self . _con . get ( entity [ '<STR_LIT>' ] ) <EOL> return enclosure <EOL> return task <EOL> def remove_enclosure ( self , enclosure , force = False , blocking = True , <EOL> verbose = False ) : <EOL> if force : <EOL> task , body = self . _con . delete ( enclosure [ '<STR_LIT>' ] + '<STR_LIT>' ) <EOL> else : <EOL> task , body = self . _con . delete ( enclosure [ '<STR_LIT>' ] ) <EOL> if blocking is True : <EOL> task = self . _activity . wait4task ( task , tout = <NUM_LIT> , verbose = verbose ) <EOL> return task <EOL> def create_enclosure_group ( self , associatedLIGs , name , <EOL> powerMode = '<STR_LIT>' ) : <EOL> """<STR_LIT>""" <EOL> egroup = make_EnclosureGroupV200 ( associatedLIGs , name , powerMode ) <EOL> task , body = self . _con . post ( uri [ '<STR_LIT>' ] , egroup ) <EOL> return body <EOL> def delete_enclosure_group ( self , egroup ) : <EOL> self . _con . delete ( egroup [ '<STR_LIT>' ] ) <EOL> def get_enclosure_groups ( self ) : <EOL> return get_members ( self . _con . get ( uri [ '<STR_LIT>' ] ) ) <EOL> def update_enclosure_group ( self , enclosuregroup ) : <EOL> task , body = self . _con . put ( enclosuregroup [ '<STR_LIT>' ] , enclosuregroup ) <EOL> return body <EOL> def get_pool ( self , pooltype ) : <EOL> body = self . _con . get ( uri [ '<STR_LIT>' ] + '<STR_LIT:/>' + pooltype ) <EOL> return body <EOL> def get_vmac_pool ( self ) : <EOL> body = self . _con . get ( uri [ '<STR_LIT>' ] ) <EOL> return body <EOL> def get_vwwn_pool ( self ) : <EOL> body = self . _con . get ( uri [ '<STR_LIT>' ] ) <EOL> return body <EOL> def get_vsn_pool ( self ) : <EOL> body = self . _con . get ( uri [ '<STR_LIT>' ] ) <EOL> return body <EOL> def get_profile_networks ( self ) : <EOL> body = self . _con . get ( uri [ '<STR_LIT>' ] ) <EOL> return body <EOL> def get_profile_schema ( self ) : <EOL> return self . _con . get ( uri [ '<STR_LIT>' ] ) <EOL> def get_profile_available_servers ( self ) : <EOL> body = self . _con . get ( uri [ '<STR_LIT>' ] ) <EOL> return body <EOL> def get_profile_available_storage_systems ( self ) : <EOL> body = self . _con . get ( uri [ '<STR_LIT>' ] ) <EOL> return body <EOL> def get_profile_ports ( self ) : <EOL> body = self . _con . get ( uri [ '<STR_LIT>' ] ) <EOL> return body <EOL> def allocate_pool_ids ( self , url , count ) : <EOL> allocatorUrl = '<STR_LIT>' % url <EOL> allocatorBody = { '<STR_LIT:count>' : count } <EOL> task , body = self . _con . put ( allocatorUrl , allocatorBody ) <EOL> return body <EOL> def release_pool_ids ( self , url , idList ) : <EOL> collectorUrl = '<STR_LIT>' % url <EOL> collectorBody = { '<STR_LIT>' : idList } <EOL> task , body = self . _con . put ( collectorUrl , collectorBody ) <EOL> return body <EOL> def allocate_range_ids ( self , allocatorUrl , count ) : <EOL> task , body = self . _con . put ( allocatorUrl , { '<STR_LIT:count>' : count } ) <EOL> return body <EOL> def release_range_ids ( self , collectorUrl , idList ) : <EOL> task , body = self . _con . put ( collectorUrl , { '<STR_LIT>' : idList } ) <EOL> return body <EOL> def enable_range ( self , url ) : <EOL> prange = self . _con . get ( url ) <EOL> prange [ '<STR_LIT>' ] = True <EOL> task , body = self . _con . put ( url , prange ) <EOL> return body <EOL> def disable_range ( self , url ) : <EOL> prange = self . _con . get ( url ) <EOL> prange [ '<STR_LIT>' ] = False <EOL> task , body = self . _con . put ( url , prange ) <EOL> return body </s>
<s> """<STR_LIT>""" <EOL> import os <EOL> import re <EOL> import sys <EOL> import json <EOL> import locale <EOL> import zipfile <EOL> import logging <EOL> import textwrap <EOL> import validictory <EOL> from . sharedtypes import JSONEncoder <EOL> from ilorest . rest . v1_helper import ( RisObject ) <EOL> LOGGER = logging . getLogger ( __name__ ) <EOL> class ValidationError ( Exception ) : <EOL> """<STR_LIT>""" <EOL> pass <EOL> class SchemaValidationError ( ValidationError ) : <EOL> """<STR_LIT>""" <EOL> pass <EOL> class RegistryValidationError ( ValidationError ) : <EOL> """<STR_LIT>""" <EOL> def __init__ ( self , msg , regentry = None , selector = None ) : <EOL> super ( RegistryValidationError , self ) . __init__ ( msg ) <EOL> self . reg = regentry <EOL> self . sel = selector <EOL> class UnknownValidatorError ( Exception ) : <EOL> """<STR_LIT>""" <EOL> """<STR_LIT>""" <EOL> class ValidationManager ( object ) : <EOL> """<STR_LIT>""" <EOL> """<STR_LIT>""" <EOL> def __init__ ( self , local_path , bios_local_path , romfamily = None , biosversion = None , iloversion = None , monolith = None ) : <EOL> super ( ValidationManager , self ) . __init__ ( ) <EOL> defaultilopath = None <EOL> defaultbiospath = None <EOL> schemamainfolder = None <EOL> if float ( iloversion ) < <NUM_LIT> : <EOL> if os . name == '<STR_LIT>' : <EOL> defaultilopath = r"<STR_LIT>" <EOL> defaultbiospath = r"<STR_LIT>" <EOL> schemamainfolder = os . path . dirname ( sys . executable ) <EOL> else : <EOL> defaultilopath = "<STR_LIT>" <EOL> defaultbiospath = "<STR_LIT>" <EOL> schemamainfolder = "<STR_LIT>" <EOL> if not local_path : <EOL> if not os . path . isdir ( defaultilopath ) : <EOL> ilozip = self . getiloziplocation ( schemamainfolder , iloversion ) <EOL> if ilozip and os . path . exists ( ilozip ) : <EOL> with zipfile . ZipFile ( os . path . join ( schemamainfolder , ilozip ) , "<STR_LIT:r>" ) as zfile : <EOL> zfile . extractall ( os . path . join ( schemamainfolder , "<STR_LIT>" ) ) <EOL> local_path = os . path . join ( schemamainfolder , u'<STR_LIT>' ) <EOL> else : <EOL> raise SchemaValidationError ( u'<STR_LIT>' '<STR_LIT>' '<STR_LIT>' '<STR_LIT>' ) <EOL> else : <EOL> local_path = defaultilopath <EOL> else : <EOL> if not os . path . isdir ( local_path ) : <EOL> raise SchemaValidationError ( u"<STR_LIT>" <EOL> "<STR_LIT>" % local_path ) <EOL> if not bios_local_path : <EOL> if not os . path . isdir ( defaultbiospath ) : <EOL> bioszip = self . getbiosziplocation ( romfamily , schemamainfolder , biosversion ) <EOL> if bioszip and os . path . exists ( bioszip ) : <EOL> with zipfile . ZipFile ( <EOL> os . path . join ( schemamainfolder , bioszip ) , "<STR_LIT:r>" ) as zfile : <EOL> zfile . extractall ( os . path . join ( schemamainfolder , "<STR_LIT>" ) ) <EOL> bios_local_path = os . path . join ( schemamainfolder , u'<STR_LIT>' ) <EOL> else : <EOL> raise SchemaValidationError ( u'<STR_LIT>' '<STR_LIT>' '<STR_LIT>' '<STR_LIT>' ) <EOL> else : <EOL> bios_local_path = defaultbiospath <EOL> else : <EOL> if not os . path . isdir ( bios_local_path ) : <EOL> raise SchemaValidationError ( u"<STR_LIT>" "<STR_LIT>" % bios_local_path ) <EOL> else : <EOL> if monolith . is_redfish : <EOL> local_path = "<STR_LIT>" <EOL> bios_local_path = "<STR_LIT>" <EOL> else : <EOL> local_path = "<STR_LIT>" <EOL> bios_local_path = "<STR_LIT>" <EOL> self . _schema_locations = list ( ) <EOL> self . _classes = list ( ) <EOL> self . _registry_locations = list ( ) <EOL> self . _classes_registry = list ( ) <EOL> self . _bios_schema_locations = list ( ) <EOL> self . _bios_classes = list ( ) <EOL> self . _bios_registry_locations = list ( ) <EOL> self . _bios_classes_registry = list ( ) <EOL> self . _ilo_messages = list ( ) <EOL> self . _base_messages = list ( ) <EOL> self . _hpcommon_messages = list ( ) <EOL> self . _iloevents_messages = list ( ) <EOL> self . _errors = list ( ) <EOL> if monolith . is_redfish : <EOL> self . _schemaid = [ "<STR_LIT>" , "<STR_LIT>" ] <EOL> self . _regid = [ "<STR_LIT>" , "<STR_LIT>" ] <EOL> else : <EOL> self . _schemaid = [ "<STR_LIT>" , "<STR_LIT>" ] <EOL> self . _regid = [ "<STR_LIT>" , "<STR_LIT>" ] <EOL> if local_path : <EOL> self . add_location ( schema_path = local_path , monolith = monolith ) <EOL> self . add_location ( registry_path = local_path , monolith = monolith ) <EOL> if bios_local_path : <EOL> self . add_location ( schema_path = bios_local_path , biossection = True , monolith = monolith ) <EOL> self . add_location ( registry_path = bios_local_path , biossection = True , monolith = monolith ) <EOL> def getbiosziplocation ( self , romfamily , schemadir , biosversion ) : <EOL> """<STR_LIT>""" <EOL> foundfile = None <EOL> currentver = None <EOL> tempstr = "<STR_LIT>" + romfamily + "<STR_LIT:->" + biosversion <EOL> for _ , _ , filenames in os . walk ( schemadir ) : <EOL> for filename in filenames : <EOL> if tempstr in filename : <EOL> regentry = re . compile ( '<STR_LIT>' % tempstr ) <EOL> mentry = regentry . search ( filename ) <EOL> if mentry and currentver : <EOL> if currentver < mentry . group ( <NUM_LIT:1> ) : <EOL> foundfile = filename <EOL> currentver = mentry . group ( <NUM_LIT:1> ) <EOL> elif mentry and not currentver : <EOL> foundfile = filename <EOL> currentver = mentry . group ( <NUM_LIT:1> ) <EOL> if foundfile : <EOL> return os . path . join ( schemadir , foundfile ) <EOL> else : <EOL> return None <EOL> def getiloziplocation ( self , schemadir , iloversion ) : <EOL> """<STR_LIT>""" <EOL> if float ( iloversion ) < <NUM_LIT> : <EOL> iloversion = u'<STR_LIT>' <EOL> tempstr = "<STR_LIT>" + iloversion . replace ( "<STR_LIT:.>" , "<STR_LIT>" ) <EOL> for _ , _ , filenames in os . walk ( schemadir ) : <EOL> for filename in filenames : <EOL> if tempstr in filename : <EOL> return os . path . join ( schemadir , filename ) <EOL> return None <EOL> def add_location ( self , schema_path = None , registry_path = None , <EOL> biossection = False , monolith = None ) : <EOL> """<STR_LIT>""" <EOL> """<STR_LIT>""" <EOL> if schema_path : <EOL> if not biossection : <EOL> self . _schema_locations . append ( schema_path ) <EOL> self . _update_location_map ( monolith = monolith ) <EOL> else : <EOL> self . _bios_schema_locations . append ( schema_path ) <EOL> self . _update_location_map ( biossection = True , monolith = monolith ) <EOL> elif registry_path : <EOL> if not biossection : <EOL> self . _registry_locations . append ( registry_path ) <EOL> self . _update_location_map ( registries = True , monolith = monolith ) <EOL> else : <EOL> self . _bios_registry_locations . append ( registry_path ) <EOL> self . _update_location_map ( biossection = True , registries = True , monolith = monolith ) <EOL> else : <EOL> raise ValueError ( u"<STR_LIT>" "<STR_LIT>" ) <EOL> def _update_location_map ( self , biossection = False , registries = False , <EOL> monolith = None ) : <EOL> """<STR_LIT>""" <EOL> locationslist = list ( ) <EOL> pathjoinstr = None <EOL> if not registries : <EOL> pathjoinstr = "<STR_LIT>" <EOL> if not biossection : <EOL> locationslist = self . _schema_locations <EOL> else : <EOL> locationslist = self . _bios_schema_locations <EOL> else : <EOL> pathjoinstr = "<STR_LIT>" <EOL> if not biossection : <EOL> locationslist = self . _registry_locations <EOL> else : <EOL> locationslist = self . _bios_registry_locations <EOL> for location in locationslist : <EOL> if monolith : <EOL> self . new_load_file ( monolith , root = location , biossection = biossection , registries = registries ) <EOL> elif self . _is_local ( location ) : <EOL> for root , _ , filenames in os . walk ( os . path . join ( location , <EOL> pathjoinstr ) ) : <EOL> for filename in filenames : <EOL> fqpath = os . path . abspath ( os . path . join ( os . path . normpath ( root ) , filename ) ) <EOL> if self . load_file ( fqpath , root = location , biossection = biossection , registries = registries ) : <EOL> LOGGER . info ( "<STR_LIT>" , fqpath ) <EOL> def new_load_file ( self , monolith , root = None , biossection = False , registries = False ) : <EOL> """<STR_LIT>""" <EOL> classesdataholder = [ ] <EOL> for itemtype in monolith . types : <EOL> if itemtype . startswith ( "<STR_LIT>" ) or itemtype . startswith ( "<STR_LIT>" ) and u'<STR_LIT>' in monolith . types [ itemtype ] : <EOL> for instance in monolith . types [ itemtype ] [ u'<STR_LIT>' ] : <EOL> if self . _schemaid [ <NUM_LIT:0> ] in instance . resp . request . path . lower ( ) or self . _regid [ <NUM_LIT:0> ] in instance . resp . request . path . lower ( ) : <EOL> if not registries and self . _schemaid [ <NUM_LIT:0> ] in instance . resp . request . path . lower ( ) : <EOL> if classesdataholder : <EOL> if self . _schemaid [ <NUM_LIT:1> ] in instance . resp . dict : <EOL> classesdataholder [ <NUM_LIT:0> ] [ self . _schemaid [ <NUM_LIT:1> ] ] . extend ( instance . resp . dict [ self . _schemaid [ <NUM_LIT:1> ] ] ) <EOL> else : <EOL> classesdataholder . append ( instance . resp . dict ) <EOL> elif registries and self . _regid [ <NUM_LIT:0> ] in instance . resp . request . path . lower ( ) : <EOL> if classesdataholder : <EOL> if monolith . is_redfish : <EOL> classesdataholder [ <NUM_LIT:0> ] [ self . _regid [ <NUM_LIT:1> ] ] . extend ( instance . resp . dict [ self . _regid [ <NUM_LIT:1> ] ] ) <EOL> else : <EOL> classesdataholder . append ( instance . resp . dict ) <EOL> if classesdataholder : <EOL> classesdataholder = classesdataholder [ <NUM_LIT:0> ] <EOL> try : <EOL> if monolith . _typestring in classesdataholder and ( '<STR_LIT>' in classesdataholder [ monolith . _typestring ] or ( '<STR_LIT>' in classesdataholder [ monolith . _typestring ] and monolith . is_redfish ) ) : <EOL> newclass = Classes . parse ( classesdataholder ) <EOL> newclass . set_root ( root ) <EOL> if not registries : <EOL> if not biossection : <EOL> self . _classes . append ( newclass ) <EOL> else : <EOL> self . _bios_classes . append ( newclass ) <EOL> else : <EOL> if not biossection : <EOL> self . _classes_registry . append ( newclass ) <EOL> else : <EOL> self . _bios_classes_registry . append ( newclass ) <EOL> except BaseException : <EOL> pass <EOL> else : <EOL> pass <EOL> def load_file ( self , filepath , root = None , biossection = False , <EOL> registries = False , datareturn = False ) : <EOL> """<STR_LIT>""" <EOL> result = False <EOL> if os . path . isfile ( filepath ) : <EOL> try : <EOL> filehand = open ( filepath , '<STR_LIT:r>' ) <EOL> data = json . load ( filehand ) <EOL> if datareturn : <EOL> return data <EOL> if u'<STR_LIT>' in data and data [ u'<STR_LIT>' ] == '<STR_LIT>' : <EOL> if biossection and registries : <EOL> itemsreturn = self . bios_helper_function ( data , root ) <EOL> data [ "<STR_LIT>" ] = itemsreturn <EOL> newclass = Classes . parse ( data ) <EOL> newclass . set_root ( root ) <EOL> if not registries : <EOL> if not biossection : <EOL> self . _classes . append ( newclass ) <EOL> else : <EOL> self . _bios_classes . append ( newclass ) <EOL> else : <EOL> if not biossection : <EOL> self . _classes_registry . append ( newclass ) <EOL> else : <EOL> self . _bios_classes_registry . append ( newclass ) <EOL> result = True <EOL> except BaseException : <EOL> pass <EOL> else : <EOL> pass <EOL> finally : <EOL> filehand . close ( ) <EOL> return result <EOL> def bios_helper_function ( self , data , root ) : <EOL> """<STR_LIT>""" <EOL> folderentries = data [ "<STR_LIT>" ] <EOL> datareturn = list ( ) <EOL> for entry in folderentries [ "<STR_LIT>" ] : <EOL> joinstr = entry [ "<STR_LIT>" ] <EOL> if os . name == '<STR_LIT>' and joinstr [ <NUM_LIT:0> ] == "<STR_LIT:/>" : <EOL> joinstr = joinstr . replace ( "<STR_LIT:/>" , "<STR_LIT:\\>" ) [ <NUM_LIT:1> : ] <EOL> elif joinstr [ <NUM_LIT:0> ] == "<STR_LIT:/>" : <EOL> joinstr = joinstr [ <NUM_LIT:1> : ] <EOL> for root , _ , filenames in os . walk ( os . path . join ( root , joinstr ) ) : <EOL> for filename in filenames : <EOL> fqpath = os . path . abspath ( os . path . join ( os . path . normpath ( root ) , filename ) ) <EOL> datareturn . append ( self . load_file ( fqpath , root = root , biossection = True , registries = True , datareturn = True ) ) <EOL> LOGGER . info ( "<STR_LIT>" , fqpath ) <EOL> return datareturn <EOL> def validate ( self , item , selector = None , currdict = None , monolith = None , <EOL> newarg = None , checkall = False , regloc = None ) : <EOL> """<STR_LIT>""" <EOL> """<STR_LIT>""" <EOL> if regloc : <EOL> attrreg = RepoRegistryEntry ( regloc ) <EOL> else : <EOL> attrreg = self . find_schema ( schname = item [ monolith . _typestring ] ) <EOL> if attrreg : <EOL> tempvalue = attrreg . validate ( item , self . _errors , selector = selector , <EOL> currdict = currdict , monolith = monolith , <EOL> newarg = newarg , checkall = checkall ) <EOL> if tempvalue is True : <EOL> return False <EOL> elif tempvalue : <EOL> self . _errors = tempvalue <EOL> return True <EOL> def bios_validate ( self , item , regname , selector = None , currdict = None , <EOL> checkall = False , monolith = None ) : <EOL> """<STR_LIT>""" <EOL> """<STR_LIT>""" <EOL> attrreg = self . find_bios_registry ( regname = regname ) <EOL> if attrreg : <EOL> tempvalue = attrreg . validate_bios_version ( item , self . _errors , selector = selector , currdict = currdict , checkall = checkall , monolith = monolith ) <EOL> if tempvalue == '<STR_LIT>' : <EOL> return tempvalue <EOL> elif tempvalue == '<STR_LIT>' : <EOL> return tempvalue <EOL> elif tempvalue : <EOL> self . _errors = tempvalue <EOL> return True <EOL> def bios_info ( self , item , regname , selector ) : <EOL> """<STR_LIT>""" <EOL> """<STR_LIT>""" <EOL> attrreg = self . find_bios_registry ( regname = regname ) <EOL> if attrreg : <EOL> if attrreg . validate_bios_version ( item , self . _errors , selector = selector ) : <EOL> return False <EOL> return True <EOL> def find_schema ( self , schname ) : <EOL> """<STR_LIT>""" <EOL> """<STR_LIT>""" <EOL> for cls in self . _classes : <EOL> found = cls . find_schema ( schname = schname ) <EOL> if found : <EOL> return found <EOL> return None <EOL> def find_registry ( self , regname ) : <EOL> """<STR_LIT>""" <EOL> """<STR_LIT>""" <EOL> for cls in self . _classes_registry : <EOL> found = cls . find_registry ( regname = regname ) <EOL> if found : <EOL> return found <EOL> return None <EOL> def find_bios_registry ( self , regname ) : <EOL> """<STR_LIT>""" <EOL> """<STR_LIT>""" <EOL> for cls in self . _bios_classes_registry : <EOL> found = cls . find_bios_registry ( regname = regname ) <EOL> if found : <EOL> return found <EOL> return None <EOL> def get_errors ( self ) : <EOL> """<STR_LIT>""" <EOL> return self . _errors <EOL> def _is_local ( self , path ) : <EOL> """<STR_LIT>""" <EOL> if u'<STR_LIT>' in path : <EOL> return False <EOL> return True <EOL> class Classes ( RisObject ) : <EOL> """<STR_LIT>""" <EOL> def __init__ ( self , item ) : <EOL> super ( Classes , self ) . __init__ ( item ) <EOL> self . _root = None <EOL> def set_root ( self , newroot ) : <EOL> """<STR_LIT>""" <EOL> self . _root = newroot <EOL> def find_schema ( self , schname ) : <EOL> """<STR_LIT>""" <EOL> result = None <EOL> if hasattr ( self , '<STR_LIT>' ) and isinstance ( self . Items , list ) : <EOL> for entry in self . Items : <EOL> if entry and u'<STR_LIT>' in entry and entry [ u'<STR_LIT>' ] . lower ( ) == schname . lower ( ) : <EOL> regentry = RepoRegistryEntry . parse ( entry ) <EOL> regentry . set_root ( self . _root ) <EOL> result = regentry <EOL> break <EOL> elif hasattr ( self , '<STR_LIT>' ) and isinstance ( self . Members , list ) : <EOL> schname = schname . split ( '<STR_LIT:.>' ) [ - <NUM_LIT:1> ] <EOL> for entry in self . Members : <EOL> schlink = entry [ u'<STR_LIT>' ] . split ( '<STR_LIT:/>' ) <EOL> schlink = schlink [ len ( schlink ) - <NUM_LIT:2> ] <EOL> if schname . lower ( ) == schlink . lower ( ) : <EOL> result = entry <EOL> break <EOL> return result <EOL> def find_registry ( self , regname ) : <EOL> """<STR_LIT>""" <EOL> result = None <EOL> if hasattr ( self , '<STR_LIT>' ) and isinstance ( self . Items , list ) : <EOL> for entry in self . Items : <EOL> if entry and ( u'<STR_LIT>' in entry and <EOL> entry [ u'<STR_LIT>' ] . lower ( ) . startswith ( regname . lower ( ) ) ) : <EOL> regentry = RepoRegistryEntry . parse ( entry ) <EOL> regentry . set_root ( self . _root ) <EOL> result = regentry <EOL> break <EOL> elif hasattr ( self , '<STR_LIT>' ) and isinstance ( self . Members , list ) : <EOL> regname = regname . split ( '<STR_LIT:.>' ) [ - <NUM_LIT:1> ] <EOL> for entry in self . Members : <EOL> reglink = entry [ u'<STR_LIT>' ] . split ( '<STR_LIT:/>' ) <EOL> reglink = reglink [ len ( reglink ) - <NUM_LIT:2> ] <EOL> if regname . lower ( ) == reglink . lower ( ) : <EOL> result = entry <EOL> break <EOL> return result <EOL> def find_bios_schema ( self , schname ) : <EOL> """<STR_LIT>""" <EOL> result = None <EOL> if hasattr ( self , '<STR_LIT>' ) and isinstance ( self . Items , list ) : <EOL> for entry in self . Items : <EOL> if ( u'<STR_LIT>' in entry and entry [ u'<STR_LIT>' ] . lower ( ) == <EOL> schname . lower ( ) ) : <EOL> regentry = RepoRegistryEntry . parse ( entry ) <EOL> regentry . set_root ( self . _root ) <EOL> result = regentry <EOL> break <EOL> return result <EOL> def find_bios_registry ( self , regname ) : <EOL> """<STR_LIT>""" <EOL> result = None <EOL> if hasattr ( self , '<STR_LIT>' ) and isinstance ( self . Items , list ) : <EOL> for entry in self . Items : <EOL> if entry and ( u'<STR_LIT>' in entry and regname . lower ( ) in entry [ u'<STR_LIT>' ] . lower ( ) ) : <EOL> regentry = RepoRegistryEntry . parse ( entry ) <EOL> regentry . set_root ( self . _root ) <EOL> result = regentry <EOL> break <EOL> return result <EOL> class RepoBaseEntry ( RisObject ) : <EOL> """<STR_LIT>""" <EOL> def __init__ ( self , d ) : <EOL> super ( RepoBaseEntry , self ) . __init__ ( d ) <EOL> self . _root = None <EOL> def set_root ( self , newroot ) : <EOL> """<STR_LIT>""" <EOL> self . _root = newroot <EOL> def _read_location_file ( self , currloc , errlist ) : <EOL> """<STR_LIT>""" <EOL> result = None <EOL> if u'<STR_LIT>' in currloc : <EOL> root = os . path . normpath ( self . _root ) <EOL> xref = os . path . normpath ( currloc . Uri . extref ) . lstrip ( os . path . sep ) <EOL> fqpath = os . path . join ( root , xref ) <EOL> if not os . path . isfile ( fqpath ) : <EOL> errlist . append ( SchemaValidationError ( <EOL> u"<STR_LIT>" % fqpath ) ) <EOL> else : <EOL> result = None <EOL> if fqpath . endswith ( '<STR_LIT>' ) : <EOL> result = open ( fqpath ) . read ( ) <EOL> return result <EOL> class RepoRegistryEntry ( RepoBaseEntry ) : <EOL> """<STR_LIT>""" <EOL> def __init__ ( self , d ) : <EOL> super ( RepoRegistryEntry , self ) . __init__ ( d ) <EOL> def validate ( self , tdict , errlist = None , selector = None , currdict = None , checkall = False , monolith = None , newarg = None ) : <EOL> """<STR_LIT>""" <EOL> if not errlist : <EOL> errlist = list ( ) <EOL> reg = self . get_registry_model ( errlist = errlist , currdict = currdict , monolith = monolith , newarg = newarg ) <EOL> if reg and not checkall : <EOL> try : <EOL> if reg [ selector ] . readonly : <EOL> return True <EOL> except BaseException : <EOL> pass <EOL> else : <EOL> pass <EOL> results = reg . validate_attribute_values ( tdict ) <EOL> errlist . extend ( results ) <EOL> elif checkall and selector is None : <EOL> results = reg . validate_attribute_values ( tdict ) <EOL> errlist . extend ( results ) <EOL> else : <EOL> errlist . append ( RegistryValidationError ( u'<STR_LIT>' '<STR_LIT>' ) ) <EOL> if errlist : <EOL> return errlist <EOL> def validate_bios_version ( self , tdict , errlist = None , selector = None , checkall = False , currdict = None , monolith = None ) : <EOL> """<STR_LIT>""" <EOL> if not errlist : <EOL> errlist = list ( ) <EOL> reg = self . get_registry_model_bios_version ( errlist = errlist , currdict = currdict , monolith = monolith ) <EOL> if reg and not checkall : <EOL> for item in reg . Attributes : <EOL> if not item [ "<STR_LIT:Name>" ] == selector : <EOL> continue <EOL> if item [ "<STR_LIT>" ] is True : <EOL> return '<STR_LIT>' <EOL> try : <EOL> if item [ "<STR_LIT>" ] is True : <EOL> return '<STR_LIT>' <EOL> except BaseException : <EOL> continue <EOL> else : <EOL> continue <EOL> results = reg . validate_att_val_bios ( tdict ) <EOL> errlist . extend ( results ) <EOL> elif checkall and selector is None : <EOL> results = reg . validate_att_val_bios ( tdict ) <EOL> errlist . extend ( results ) <EOL> else : <EOL> errlist . append ( RegistryValidationError ( u'<STR_LIT>' '<STR_LIT>' ) ) <EOL> if errlist : <EOL> return errlist <EOL> def validate_deprecated ( self , tdict , errlist = None ) : <EOL> """<STR_LIT>""" <EOL> if not errlist : <EOL> errlist = list ( ) <EOL> if not hasattr ( self , u'<STR_LIT>' ) : <EOL> errlist . append ( RegistryValidationError ( u'<STR_LIT>' '<STR_LIT>' ) ) <EOL> return errlist <EOL> currloc = None <EOL> defloc = None <EOL> langcode = '<STR_LIT>' <EOL> for loc in self . Location : <EOL> for loclang in loc . keys ( ) : <EOL> if loclang . lower ( ) == langcode . lower ( ) : <EOL> currloc = loc [ loclang ] <EOL> break <EOL> elif loclang . lower ( ) == u'<STR_LIT:default>' : <EOL> defloc = loc [ loclang ] <EOL> if not currloc : <EOL> currloc = defloc <EOL> if not currloc : <EOL> errlist . append ( RegistryValidationError ( u'<STR_LIT>' '<STR_LIT>' ) ) <EOL> return <EOL> location_file = self . _read_location_file ( currloc , errlist = errlist ) <EOL> if not location_file : <EOL> errlist . append ( RegistryValidationError ( u'<STR_LIT>' ) ) <EOL> else : <EOL> jsonreg = json . loads ( location_file ) <EOL> if u'<STR_LIT>' in jsonreg : <EOL> if u'<STR_LIT>' in jsonreg and jsonreg [ u'<STR_LIT>' ] == u'<STR_LIT>' : <EOL> reg = HpPropertiesRegistry . parse ( jsonreg [ u'<STR_LIT>' ] ) <EOL> results = reg . validate_attribute_values ( tdict ) <EOL> errlist . extend ( results ) <EOL> def get_registry_model ( self , currdict = None , monolith = None , errlist = None , skipcommit = False , searchtype = None , newarg = None , latestschema = None ) : <EOL> """<STR_LIT>""" <EOL> if not errlist : <EOL> errlist = list ( ) <EOL> if not hasattr ( self , u'<STR_LIT>' ) : <EOL> errlist . append ( RegistryValidationError ( <EOL> u'<STR_LIT>' ) ) <EOL> return None <EOL> currloc = None <EOL> defloc = "<STR_LIT>" <EOL> langcode = list ( locale . getdefaultlocale ( ) ) <EOL> if not langcode [ <NUM_LIT:0> ] : <EOL> langcode [ <NUM_LIT:0> ] = "<STR_LIT>" <EOL> for loc in self . Location : <EOL> locationlanguage = loc [ "<STR_LIT>" ] . lower ( ) <EOL> locationlanguage = locationlanguage . replace ( "<STR_LIT:->" , "<STR_LIT:_>" ) <EOL> if locationlanguage in langcode [ <NUM_LIT:0> ] . lower ( ) : <EOL> currloc = loc <EOL> break <EOL> if not currloc : <EOL> currloc = defloc <EOL> if not currloc : <EOL> errlist . append ( RegistryValidationError ( u'<STR_LIT>' '<STR_LIT:location>' ) ) <EOL> return None <EOL> if not searchtype : <EOL> searchtype = "<STR_LIT>" <EOL> location_file = None <EOL> if currdict and monolith : <EOL> for itemtype in monolith . types : <EOL> if itemtype . lower ( ) . startswith ( searchtype . lower ( ) ) and u'<STR_LIT>' in monolith . types [ itemtype ] : <EOL> for instance in monolith . types [ itemtype ] [ u'<STR_LIT>' ] : <EOL> try : <EOL> if monolith . is_redfish : <EOL> currtype = currdict [ instance . _typestring ] . split ( '<STR_LIT:#>' ) [ - <NUM_LIT:1> ] <EOL> currtype = currtype . split ( '<STR_LIT:.>' ) [ <NUM_LIT:0> ] + '<STR_LIT:.>' <EOL> else : <EOL> currtype = currdict [ instance . _typestring ] <EOL> if latestschema : <EOL> currtype = currdict [ instance . _typestring ] . split ( '<STR_LIT:.>' ) [ : <NUM_LIT:1> ] <EOL> insttype = instance . resp . dict [ "<STR_LIT:title>" ] . split ( '<STR_LIT:.>' ) [ : <NUM_LIT:1> ] <EOL> if currtype == insttype or currtype == instance . resp . dict [ "<STR_LIT>" ] . split ( '<STR_LIT:.>' ) [ : <NUM_LIT:1> ] : <EOL> location_file = instance . resp . dict <EOL> break <EOL> elif searchtype == "<STR_LIT>" and instance . resp . dict [ "<STR_LIT:title>" ] . startswith ( currtype ) or "<STR_LIT>" in instance . resp . dict . keys ( ) and currdict [ instance . _typestring ] == instance . resp . dict [ "<STR_LIT>" ] : <EOL> location_file = instance . resp . dict <EOL> break <EOL> elif searchtype != "<STR_LIT>" and currdict [ instance . _typestring ] in instance . resp . dict [ "<STR_LIT>" ] : <EOL> location_file = instance . resp . dict <EOL> break <EOL> except BaseException : <EOL> pass <EOL> else : <EOL> pass <EOL> if location_file : <EOL> break <EOL> else : <EOL> location_file = self . _read_location_file ( currloc , errlist = errlist ) <EOL> if not location_file : <EOL> errlist . append ( RegistryValidationError ( u'<STR_LIT>' ) ) <EOL> else : <EOL> if currdict and monolith : <EOL> jsonreg = json . loads ( json . dumps ( location_file , indent = <NUM_LIT:2> , cls = JSONEncoder ) ) <EOL> else : <EOL> jsonreg = json . loads ( location_file ) <EOL> if skipcommit : <EOL> return jsonreg [ "<STR_LIT>" ] <EOL> if u'<STR_LIT>' in jsonreg : <EOL> regitem = jsonreg [ u'<STR_LIT>' ] <EOL> reg = HpPropertiesRegistry . parse ( regitem ) <EOL> if newarg : <EOL> regcopy = reg <EOL> for arg in newarg [ : - <NUM_LIT:1> ] : <EOL> try : <EOL> if '<STR_LIT>' in regcopy [ arg ] . iterkeys ( ) and ( '<STR_LIT>' in regcopy [ arg ] . iterkeys ( ) ) : <EOL> regcopy [ arg ] [ '<STR_LIT>' ] . update ( regcopy [ arg ] [ '<STR_LIT>' ] ) <EOL> regcopy = regcopy [ arg ] [ "<STR_LIT>" ] <EOL> for pattern in regcopy . iterkeys ( ) : <EOL> test = re . compile ( pattern ) <EOL> nextarg = newarg [ newarg . index ( arg ) + <NUM_LIT:1> ] <EOL> match = test . match ( nextarg ) <EOL> if match : <EOL> regcopy [ nextarg ] = regcopy . pop ( pattern ) <EOL> break <EOL> elif '<STR_LIT>' in regcopy [ arg ] : <EOL> oneof = regcopy [ arg ] [ '<STR_LIT>' ] <EOL> for item in oneof : <EOL> regcopy = item [ '<STR_LIT>' ] <EOL> if not arg == newarg [ - <NUM_LIT:1> ] : <EOL> try : <EOL> nextitem = newarg [ newarg . index ( arg ) + <NUM_LIT:1> ] <EOL> regcopy [ nextitem ] <EOL> break <EOL> except Exception : <EOL> continue <EOL> else : <EOL> regcopy = regcopy [ arg ] [ "<STR_LIT>" ] <EOL> except Exception : <EOL> try : <EOL> regcopy = regcopy [ arg ] [ '<STR_LIT>' ] <EOL> for pattern in regcopy . iterkeys ( ) : <EOL> test = re . compile ( pattern ) <EOL> nextarg = newarg [ newarg . index ( arg ) + <NUM_LIT:1> ] <EOL> match = test . match ( nextarg ) <EOL> if match : <EOL> patterninfo = regcopy . pop ( pattern ) <EOL> regcopy [ nextarg ] = patterninfo <EOL> except BaseException : <EOL> return None <EOL> reg = regcopy <EOL> return reg <EOL> return None <EOL> def get_registry_model_bios_version ( self , currdict = None , monolith = None , errlist = None ) : <EOL> """<STR_LIT>""" <EOL> """<STR_LIT>""" <EOL> if not errlist : <EOL> errlist = list ( ) <EOL> if not hasattr ( self , u'<STR_LIT>' ) : <EOL> errlist . append ( RegistryValidationError ( <EOL> u'<STR_LIT>' ) ) <EOL> return None <EOL> currloc = None <EOL> defloc = "<STR_LIT>" <EOL> langcode = list ( locale . getdefaultlocale ( ) ) <EOL> if not langcode [ <NUM_LIT:0> ] : <EOL> langcode [ <NUM_LIT:0> ] = "<STR_LIT>" <EOL> for loc in self . Location : <EOL> locationlanguage = loc [ "<STR_LIT>" ] . lower ( ) <EOL> locationlanguage = locationlanguage . replace ( "<STR_LIT:->" , "<STR_LIT:_>" ) <EOL> if locationlanguage in langcode [ <NUM_LIT:0> ] . lower ( ) : <EOL> currloc = loc <EOL> break <EOL> if not currloc : <EOL> currloc = defloc <EOL> if not currloc : <EOL> errlist . append ( RegistryValidationError ( <EOL> u'<STR_LIT>' ) ) <EOL> return None <EOL> location_file = None <EOL> if currdict and monolith : <EOL> for itemtype in monolith . types : <EOL> if "<STR_LIT>" in itemtype and u'<STR_LIT>' in monolith . types [ itemtype ] : <EOL> for instance in monolith . types [ itemtype ] [ u'<STR_LIT>' ] : <EOL> location_file = instance . resp . dict <EOL> break <EOL> if location_file : <EOL> break <EOL> else : <EOL> location_file = self . _read_location_file ( currloc , errlist = errlist ) <EOL> if not location_file : <EOL> errlist . append ( RegistryValidationError ( u'<STR_LIT>' ) ) <EOL> else : <EOL> if currdict and monolith : <EOL> jsonreg = json . loads ( json . dumps ( location_file , indent = <NUM_LIT:2> , cls = JSONEncoder ) ) <EOL> else : <EOL> jsonreg = json . loads ( location_file ) <EOL> if u'<STR_LIT>' in jsonreg : <EOL> regitem = jsonreg [ u'<STR_LIT>' ] <EOL> reg = HpPropertiesRegistry . parse ( regitem ) <EOL> return reg <EOL> return None <EOL> class RepoSchemaEntry ( RepoBaseEntry ) : <EOL> """<STR_LIT>""" <EOL> def __init__ ( self , item ) : <EOL> super ( RepoSchemaEntry , self ) . __init__ ( item ) <EOL> self . _root = None <EOL> def set_root ( self , newroot ) : <EOL> """<STR_LIT>""" <EOL> self . _root = newroot <EOL> def _read_location_file ( self , currloc , errlist ) : <EOL> """<STR_LIT>""" <EOL> if u'<STR_LIT>' in currloc and u'<STR_LIT>' in currloc : <EOL> fqpath = os . path . join ( self . _root , currloc . ArchiveUri . xref . lstrip ( os . path . sep ) ) <EOL> if not os . path . isfile ( fqpath ) : <EOL> errlist . append ( SchemaValidationError ( u"<STR_LIT>" "<STR_LIT>" % fqpath ) ) <EOL> else : <EOL> archive_file = currloc . ArchiveFile <EOL> archive_fh = None <EOL> result = None <EOL> if fqpath . endswith ( '<STR_LIT>' ) : <EOL> archive_fh = zipfile . ZipFile ( fqpath ) <EOL> infolist = archive_fh . infolist ( ) <EOL> for i in infolist : <EOL> if i . filename . lower ( ) == archive_file . lower ( ) : <EOL> jsonsch_fh = archive_fh . open ( i ) <EOL> result = jsonsch_fh . read ( ) <EOL> jsonsch_fh . close ( ) <EOL> archive_fh . close ( ) <EOL> return result <EOL> def validate ( self , tdict , errlist = None ) : <EOL> """<STR_LIT>""" <EOL> if not errlist : <EOL> errlist = list ( ) <EOL> result = list ( ) <EOL> if not hasattr ( self , u'<STR_LIT>' ) : <EOL> result . append ( SchemaValidationError ( u'<STR_LIT>' '<STR_LIT>' ) ) <EOL> return result <EOL> currloc = None <EOL> defloc = None <EOL> langcode = '<STR_LIT>' <EOL> for loc in self . Location : <EOL> for loclang in loc . keys ( ) : <EOL> if loclang . lower ( ) == langcode . lower ( ) : <EOL> currloc = loc [ loclang ] <EOL> break <EOL> elif loclang . lower ( ) == u'<STR_LIT:default>' : <EOL> defloc = loc [ loclang ] <EOL> if not currloc : <EOL> currloc = defloc <EOL> if not currloc : <EOL> result . append ( SchemaValidationError ( <EOL> u'<STR_LIT>' ) ) <EOL> return <EOL> location_file = self . _read_location_file ( currloc , errlist = result ) <EOL> if not location_file : <EOL> result . append ( SchemaValidationError ( u'<STR_LIT>' ) ) <EOL> else : <EOL> jsonsch = json . loads ( location_file ) <EOL> validictory . validate ( tdict , jsonsch ) <EOL> class HpPropertiesRegistry ( RisObject ) : <EOL> """<STR_LIT>""" <EOL> def __init__ ( self , d ) : <EOL> super ( HpPropertiesRegistry , self ) . __init__ ( d ) <EOL> def validate_attribute_values ( self , tdict ) : <EOL> """<STR_LIT>""" <EOL> result = list ( ) <EOL> for tkey in tdict : <EOL> try : <EOL> if self [ tkey ] and hasattr ( self [ tkey ] , "<STR_LIT:type>" ) : <EOL> temp = self . validate_attribute ( self [ tkey ] , tdict [ tkey ] , tkey ) <EOL> for err in temp : <EOL> if isinstance ( err , RegistryValidationError ) : <EOL> if err . reg : <EOL> err . sel = tkey <EOL> result . extend ( temp ) <EOL> except Exception : <EOL> pass <EOL> return result <EOL> def validate_att_val_bios ( self , tdict ) : <EOL> """<STR_LIT>""" <EOL> result = list ( ) <EOL> for tkey in tdict : <EOL> for item in self . Attributes : <EOL> try : <EOL> if item [ "<STR_LIT:Name>" ] == tkey and hasattr ( item , "<STR_LIT>" ) : <EOL> temp = self . validate_attribute ( item , tdict [ tkey ] , tkey ) <EOL> for err in temp : <EOL> if isinstance ( err , RegistryValidationError ) : <EOL> if err . reg : <EOL> err . sel = tkey <EOL> result . extend ( temp ) <EOL> break <EOL> except Exception : <EOL> pass <EOL> return result <EOL> def get_validator ( self , attrname , newargs = None , oneof = None ) : <EOL> """<STR_LIT>""" <EOL> if oneof : <EOL> self = oneof <EOL> if newargs : <EOL> for arg in newargs : <EOL> try : <EOL> self = self [ '<STR_LIT>' ] <EOL> except Exception : <EOL> pass <EOL> if not hasattr ( self , arg ) : <EOL> return None <EOL> elif not arg == newargs [ - <NUM_LIT:1> ] : <EOL> self = self [ arg ] <EOL> if not hasattr ( self , attrname ) : <EOL> return None <EOL> validator = None <EOL> if EnumValidator . is_type ( self [ attrname ] ) : <EOL> validator = EnumValidator . parse ( self [ attrname ] ) <EOL> elif StringValidator . is_type ( self [ attrname ] ) : <EOL> validator = StringValidator . parse ( self [ attrname ] ) <EOL> elif ObjectValidator . is_type ( self [ attrname ] ) : <EOL> validator = ObjectValidator . parse ( self [ attrname ] ) <EOL> elif IntegerValidator . is_type ( self [ attrname ] ) : <EOL> validator = IntegerValidator . parse ( self [ attrname ] ) <EOL> elif BoolValidator . is_type ( self [ attrname ] ) : <EOL> validator = BoolValidator . parse ( self [ attrname ] ) <EOL> elif PasswordValidator . is_type ( self [ attrname ] ) : <EOL> validator = PasswordValidator . parse ( self [ attrname ] ) <EOL> elif u'<STR_LIT>' in self [ attrname ] . keys ( ) : <EOL> for item in self [ attrname ] [ '<STR_LIT>' ] : <EOL> validator = self . get_validator ( attrname , newargs , HpPropertiesRegistry ( { attrname : item } ) ) <EOL> if validator : <EOL> break <EOL> return validator <EOL> def get_validator_bios ( self , attrname ) : <EOL> """<STR_LIT>""" <EOL> for item in self . Attributes : <EOL> if item [ "<STR_LIT:Name>" ] == attrname : <EOL> validator = None <EOL> if EnumValidator . is_type ( item ) : <EOL> validator = EnumValidator . parse ( item ) <EOL> elif StringValidator . is_type ( item ) : <EOL> validator = StringValidator . parse ( item ) <EOL> elif IntegerValidator . is_type ( item ) : <EOL> validator = IntegerValidator . parse ( item ) <EOL> elif BoolValidator . is_type ( item ) : <EOL> validator = BoolValidator . parse ( item ) <EOL> elif ObjectValidator . is_type ( item ) : <EOL> validator = ObjectValidator . parse ( item ) <EOL> elif PasswordValidator . is_type ( item ) : <EOL> validator = PasswordValidator . parse ( item ) <EOL> return validator <EOL> return None <EOL> def validate_attribute ( self , attrentry , attrval , name ) : <EOL> """<STR_LIT>""" <EOL> result = list ( ) <EOL> validator = None <EOL> if EnumValidator . is_type ( attrentry ) : <EOL> validator = EnumValidator . parse ( attrentry ) <EOL> elif StringValidator . is_type ( attrentry ) : <EOL> validator = StringValidator . parse ( attrentry ) <EOL> elif IntegerValidator . is_type ( attrentry ) : <EOL> validator = IntegerValidator . parse ( attrentry ) <EOL> elif BoolValidator . is_type ( attrentry ) : <EOL> validator = BoolValidator . parse ( attrentry ) <EOL> elif ObjectValidator . is_type ( attrentry ) : <EOL> validator = ObjectValidator . parse ( attrentry ) <EOL> elif PasswordValidator . is_type ( attrentry ) : <EOL> validator = PasswordValidator . parse ( attrentry ) <EOL> else : <EOL> raise UnknownValidatorError ( attrentry ) <EOL> if validator : <EOL> result . extend ( validator . validate ( attrval , name ) ) <EOL> return result <EOL> class BaseValidator ( RisObject ) : <EOL> """<STR_LIT>""" <EOL> def __init__ ( self , d ) : <EOL> super ( BaseValidator , self ) . __init__ ( d ) <EOL> def validate ( self ) : <EOL> """<STR_LIT>""" <EOL> raise RuntimeError ( u'<STR_LIT>' '<STR_LIT:class>' ) <EOL> class EnumValidator ( BaseValidator ) : <EOL> """<STR_LIT>""" <EOL> def __init__ ( self , d ) : <EOL> super ( EnumValidator , self ) . __init__ ( d ) <EOL> @ staticmethod <EOL> def is_type ( attrentry ) : <EOL> """<STR_LIT>""" <EOL> if u'<STR_LIT:type>' in attrentry : <EOL> if isinstance ( attrentry [ u'<STR_LIT:type>' ] , list ) : <EOL> for item in attrentry [ u'<STR_LIT:type>' ] : <EOL> if item . lower ( ) == u'<STR_LIT>' : <EOL> return True <EOL> elif u'<STR_LIT>' in attrentry and item . lower ( ) == u'<STR_LIT:string>' : <EOL> return True <EOL> elif u'<STR_LIT>' in attrentry and attrentry [ u'<STR_LIT:type>' ] == "<STR_LIT>" : <EOL> for key , value in attrentry [ u'<STR_LIT>' ] . iteritems ( ) : <EOL> if key . lower ( ) == "<STR_LIT:type>" and value . lower ( ) == u'<STR_LIT:string>' : <EOL> return True <EOL> else : <EOL> if attrentry [ u'<STR_LIT:type>' ] . lower ( ) == u'<STR_LIT>' : <EOL> return True <EOL> elif u'<STR_LIT>' in attrentry and attrentry [ u'<STR_LIT:type>' ] . lower ( ) == u'<STR_LIT:string>' : <EOL> return True <EOL> elif u'<STR_LIT>' in attrentry : <EOL> if attrentry [ u'<STR_LIT>' ] . lower ( ) == u'<STR_LIT>' : <EOL> return True <EOL> return False <EOL> def validate ( self , newval , name ) : <EOL> """<STR_LIT>""" <EOL> result = list ( ) <EOL> try : <EOL> for possibleval in self . enum : <EOL> if possibleval . lower ( ) == newval . lower ( ) : <EOL> return result <EOL> except Exception : <EOL> for possibleval in self . Value : <EOL> if possibleval . ValueName . lower ( ) == str ( newval ) . lower ( ) : <EOL> return result <EOL> result . append ( RegistryValidationError ( u"<STR_LIT>" <EOL> "<STR_LIT>" % ( newval , name ) , <EOL> regentry = self ) ) <EOL> return result <EOL> def print_help ( self , name , out = sys . stdout ) : <EOL> """<STR_LIT>""" <EOL> wrapper = textwrap . TextWrapper ( ) <EOL> wrapper . initial_indent = '<STR_LIT:U+0020>' * <NUM_LIT:4> <EOL> wrapper . subsequent_indent = '<STR_LIT:U+0020>' * <NUM_LIT:4> <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT:%s>' % name ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT:description>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT:type>' in self and isinstance ( self [ u'<STR_LIT:type>' ] , list ) : <EOL> out . write ( u'<STR_LIT>' ) <EOL> for item in self [ u'<STR_LIT:type>' ] : <EOL> out . write ( '<STR_LIT>' % wrapper . fill ( '<STR_LIT:%s>' % item ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> elif u'<STR_LIT:type>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> elif u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> elif u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> out . write ( u'<STR_LIT>' ) <EOL> try : <EOL> for possibleval in self . enum : <EOL> out . write ( '<STR_LIT>' % possibleval ) <EOL> except Exception : <EOL> for possibleval in self . Value : <EOL> out . write ( '<STR_LIT>' % possibleval ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> class BoolValidator ( BaseValidator ) : <EOL> """<STR_LIT>""" <EOL> def __init__ ( self , d ) : <EOL> super ( BoolValidator , self ) . __init__ ( d ) <EOL> @ staticmethod <EOL> def is_type ( attrentry ) : <EOL> """<STR_LIT>""" <EOL> if u'<STR_LIT:type>' in attrentry : <EOL> if isinstance ( attrentry [ u'<STR_LIT:type>' ] , list ) : <EOL> for item in attrentry [ u'<STR_LIT:type>' ] : <EOL> if item . lower ( ) == u'<STR_LIT>' : <EOL> return True <EOL> elif attrentry [ u'<STR_LIT:type>' ] == "<STR_LIT>" : <EOL> for key , value in attrentry [ u'<STR_LIT>' ] . iteritems ( ) : <EOL> if key . lower ( ) == "<STR_LIT:type>" and value . lower ( ) == u'<STR_LIT>' : <EOL> return True <EOL> else : <EOL> if attrentry [ u'<STR_LIT:type>' ] . lower ( ) == u'<STR_LIT>' : <EOL> return True <EOL> elif u'<STR_LIT>' in attrentry : <EOL> if attrentry [ u'<STR_LIT>' ] . lower ( ) == u'<STR_LIT>' : <EOL> return True <EOL> return False <EOL> def validate ( self , newval , name ) : <EOL> """<STR_LIT>""" <EOL> result = list ( ) <EOL> if newval is False or newval is True : <EOL> return result <EOL> result . append ( <EOL> RegistryValidationError ( <EOL> u"<STR_LIT>" % ( newval , name ) , <EOL> regentry = self <EOL> ) <EOL> ) <EOL> return result <EOL> def print_help ( self , name , out = sys . stdout ) : <EOL> """<STR_LIT>""" <EOL> wrapper = textwrap . TextWrapper ( ) <EOL> wrapper . initial_indent = '<STR_LIT:U+0020>' * <NUM_LIT:4> <EOL> wrapper . subsequent_indent = '<STR_LIT:U+0020>' * <NUM_LIT:4> <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT:%s>' % name ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT:description>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT:type>' in self and isinstance ( self [ u'<STR_LIT:type>' ] , list ) : <EOL> out . write ( u'<STR_LIT>' ) <EOL> for item in self [ u'<STR_LIT:type>' ] : <EOL> out . write ( '<STR_LIT>' % wrapper . fill ( '<STR_LIT:%s>' % item ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> elif u'<STR_LIT:type>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> elif u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> elif u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> class StringValidator ( BaseValidator ) : <EOL> """<STR_LIT>""" <EOL> def __init__ ( self , d ) : <EOL> super ( StringValidator , self ) . __init__ ( d ) <EOL> @ staticmethod <EOL> def is_type ( attrentry ) : <EOL> """<STR_LIT>""" <EOL> if u'<STR_LIT:type>' in attrentry : <EOL> if isinstance ( attrentry [ u'<STR_LIT:type>' ] , list ) : <EOL> for item in attrentry [ u'<STR_LIT:type>' ] : <EOL> if item . lower ( ) == u'<STR_LIT:string>' : <EOL> return True <EOL> elif attrentry [ u'<STR_LIT:type>' ] == "<STR_LIT>" : <EOL> for key , value in attrentry [ u'<STR_LIT>' ] . iteritems ( ) : <EOL> if key . lower ( ) == "<STR_LIT:type>" and u'<STR_LIT:string>' in value : <EOL> return True <EOL> else : <EOL> if attrentry [ u'<STR_LIT:type>' ] . lower ( ) == u'<STR_LIT:string>' : <EOL> return True <EOL> elif u'<STR_LIT>' in attrentry : <EOL> if attrentry [ u'<STR_LIT>' ] . lower ( ) == u'<STR_LIT:string>' : <EOL> return True <EOL> return False <EOL> def validate ( self , newval , name ) : <EOL> """<STR_LIT>""" <EOL> result = list ( ) <EOL> if u'<STR_LIT>' in self : <EOL> if len ( newval ) < int ( self [ u'<STR_LIT>' ] ) : <EOL> result . append ( RegistryValidationError ( <EOL> u"<STR_LIT>" % <EOL> ( self . Name , int ( self [ u'<STR_LIT>' ] ) ) , regentry = self ) ) <EOL> if u'<STR_LIT>' in self : <EOL> if len ( newval ) > int ( self [ u'<STR_LIT>' ] ) : <EOL> result . append ( RegistryValidationError ( <EOL> u"<STR_LIT>" % <EOL> ( self . Name , int ( self [ u'<STR_LIT>' ] ) ) , regentry = self ) ) <EOL> if u'<STR_LIT>' in self : <EOL> if self [ u'<STR_LIT>' ] : <EOL> pat = re . compile ( self [ u'<STR_LIT>' ] ) <EOL> if newval and not pat . match ( newval ) : <EOL> result . append ( RegistryValidationError ( <EOL> u"<STR_LIT>" <EOL> "<STR_LIT>" % ( self ) , regentry = self ) ) <EOL> return result <EOL> def print_help ( self , name , out = sys . stdout ) : <EOL> """<STR_LIT>""" <EOL> wrapper = textwrap . TextWrapper ( ) <EOL> wrapper . initial_indent = '<STR_LIT:U+0020>' * <NUM_LIT:4> <EOL> wrapper . subsequent_indent = '<STR_LIT:U+0020>' * <NUM_LIT:4> <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT:%s>' % name ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT:description>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT:type>' in self and isinstance ( self [ u'<STR_LIT:type>' ] , list ) : <EOL> out . write ( u'<STR_LIT>' ) <EOL> for item in self [ u'<STR_LIT:type>' ] : <EOL> out . write ( '<STR_LIT>' % wrapper . fill ( '<STR_LIT:%s>' % item ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> elif u'<STR_LIT:type>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> elif u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> elif u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> class IntegerValidator ( BaseValidator ) : <EOL> """<STR_LIT>""" <EOL> def __init__ ( self , d ) : <EOL> super ( IntegerValidator , self ) . __init__ ( d ) <EOL> @ staticmethod <EOL> def is_type ( attrentry ) : <EOL> """<STR_LIT>""" <EOL> if u'<STR_LIT:type>' in attrentry : <EOL> if isinstance ( attrentry [ u'<STR_LIT:type>' ] , list ) : <EOL> for item in attrentry [ u'<STR_LIT:type>' ] : <EOL> if item . lower ( ) == u'<STR_LIT>' or item . lower ( ) == u'<STR_LIT>' : <EOL> return True <EOL> elif attrentry [ u'<STR_LIT:type>' ] == "<STR_LIT>" : <EOL> for key , value in attrentry [ u'<STR_LIT>' ] . iteritems ( ) : <EOL> if key . lower ( ) == "<STR_LIT:type>" : <EOL> if value . lower ( ) == u'<STR_LIT>' or value . lower ( ) == u'<STR_LIT>' : <EOL> return True <EOL> else : <EOL> if attrentry [ u'<STR_LIT:type>' ] . lower ( ) == u'<STR_LIT>' or attrentry [ u'<STR_LIT:type>' ] . lower ( ) . lower ( ) == u'<STR_LIT>' : <EOL> return True <EOL> elif u'<STR_LIT>' in attrentry : <EOL> if attrentry [ u'<STR_LIT>' ] . lower ( ) == u'<STR_LIT>' : <EOL> return True <EOL> return False <EOL> def validate ( self , newval , name ) : <EOL> """<STR_LIT>""" <EOL> result = list ( ) <EOL> intval = int ( newval ) <EOL> pat = re . compile ( r'<STR_LIT>' ) <EOL> if newval and not pat . match ( intval ) : <EOL> result . append ( <EOL> RegistryValidationError ( <EOL> u"<STR_LIT>" % ( self ) , <EOL> regentry = self <EOL> ) <EOL> ) <EOL> return result <EOL> if u'<STR_LIT>' in self : <EOL> if intval < int ( self [ u'<STR_LIT>' ] ) : <EOL> result . append ( RegistryValidationError ( u"<STR_LIT>" "<STR_LIT>" % ( self . Name , int ( self [ u'<STR_LIT>' ] ) ) , regentry = self ) ) <EOL> if u'<STR_LIT>' in self : <EOL> if intval > int ( self [ u'<STR_LIT>' ] ) : <EOL> result . append ( RegistryValidationError ( u"<STR_LIT>" "<STR_LIT>" % ( self . Name , int ( self [ u'<STR_LIT>' ] ) ) , regentry = self ) ) <EOL> return result <EOL> def print_help ( self , name , out = sys . stdout ) : <EOL> """<STR_LIT>""" <EOL> wrapper = textwrap . TextWrapper ( ) <EOL> wrapper . initial_indent = '<STR_LIT:U+0020>' * <NUM_LIT:4> <EOL> wrapper . subsequent_indent = '<STR_LIT:U+0020>' * <NUM_LIT:4> <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT:%s>' % name ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT:description>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT:type>' in self and isinstance ( self [ u'<STR_LIT:type>' ] , list ) : <EOL> out . write ( u'<STR_LIT>' ) <EOL> for item in self [ u'<STR_LIT:type>' ] : <EOL> out . write ( '<STR_LIT>' % wrapper . fill ( '<STR_LIT:%s>' % item ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> elif u'<STR_LIT:type>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> elif u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> elif u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> class ObjectValidator ( BaseValidator ) : <EOL> """<STR_LIT>""" <EOL> def __init__ ( self , d ) : <EOL> super ( ObjectValidator , self ) . __init__ ( d ) <EOL> @ staticmethod <EOL> def is_type ( attrentry ) : <EOL> """<STR_LIT>""" <EOL> if u'<STR_LIT:type>' in attrentry : <EOL> if isinstance ( attrentry [ u'<STR_LIT:type>' ] , list ) : <EOL> for item in attrentry [ u'<STR_LIT:type>' ] : <EOL> if item . lower ( ) == u'<STR_LIT:object>' : <EOL> return True <EOL> elif attrentry [ u'<STR_LIT:type>' ] == "<STR_LIT>" : <EOL> for key , value in attrentry [ u'<STR_LIT>' ] . iteritems ( ) : <EOL> if key . lower ( ) == "<STR_LIT:type>" and value . lower ( ) == u'<STR_LIT:object>' : <EOL> return True <EOL> elif key . lower ( ) == "<STR_LIT>" : <EOL> try : <EOL> if value [ <NUM_LIT:0> ] [ u'<STR_LIT:type>' ] == u'<STR_LIT:object>' : <EOL> return True <EOL> except Exception : <EOL> continue <EOL> else : <EOL> if attrentry [ u'<STR_LIT:type>' ] . lower ( ) == u'<STR_LIT:object>' : <EOL> return True <EOL> elif u'<STR_LIT>' in attrentry : <EOL> if attrentry [ u'<STR_LIT>' ] . lower ( ) == u'<STR_LIT:object>' : <EOL> return True <EOL> return False <EOL> def validate ( self , newval , name ) : <EOL> """<STR_LIT>""" <EOL> result = list ( ) <EOL> return result <EOL> def print_help ( self , name , out = sys . stdout ) : <EOL> """<STR_LIT>""" <EOL> wrapper = textwrap . TextWrapper ( ) <EOL> wrapper . initial_indent = '<STR_LIT:U+0020>' * <NUM_LIT:4> <EOL> wrapper . subsequent_indent = '<STR_LIT:U+0020>' * <NUM_LIT:4> <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT:%s>' % name ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT:description>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT:type>' in self and isinstance ( self [ u'<STR_LIT:type>' ] , list ) : <EOL> out . write ( u'<STR_LIT>' ) <EOL> for item in self [ u'<STR_LIT:type>' ] : <EOL> out . write ( '<STR_LIT>' % wrapper . fill ( '<STR_LIT:%s>' % item ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> elif u'<STR_LIT:type>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> elif u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> elif u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> class PasswordValidator ( BaseValidator ) : <EOL> """<STR_LIT>""" <EOL> def __init__ ( self , d ) : <EOL> super ( PasswordValidator , self ) . __init__ ( d ) <EOL> @ staticmethod <EOL> def is_type ( attrentry ) : <EOL> """<STR_LIT>""" <EOL> if u'<STR_LIT:type>' in attrentry : <EOL> if isinstance ( attrentry [ u'<STR_LIT:type>' ] , list ) : <EOL> for item in attrentry [ u'<STR_LIT:type>' ] : <EOL> if item . lower ( ) == u'<STR_LIT:password>' : <EOL> return True <EOL> elif attrentry [ u'<STR_LIT:type>' ] == "<STR_LIT>" : <EOL> for key , value in attrentry [ u'<STR_LIT>' ] . iteritems ( ) : <EOL> if key . lower ( ) == "<STR_LIT:type>" and value . lower ( ) == u'<STR_LIT:password>' : <EOL> return True <EOL> else : <EOL> if attrentry [ u'<STR_LIT:type>' ] . lower ( ) == u'<STR_LIT:password>' : <EOL> return True <EOL> elif u'<STR_LIT>' in attrentry : <EOL> if attrentry [ u'<STR_LIT>' ] . lower ( ) == u'<STR_LIT:password>' : <EOL> return True <EOL> return False <EOL> def validate ( self , newval , name ) : <EOL> """<STR_LIT>""" <EOL> result = list ( ) <EOL> if newval is None : <EOL> return result <EOL> if u'<STR_LIT>' in self : <EOL> if len ( newval ) < int ( self [ u'<STR_LIT>' ] ) : <EOL> result . append ( RegistryValidationError ( u"<STR_LIT>" "<STR_LIT>" % ( self . Name , int ( self [ u'<STR_LIT>' ] ) ) , regentry = self ) ) <EOL> if u'<STR_LIT>' in self : <EOL> if len ( newval ) > int ( self [ u'<STR_LIT>' ] ) : <EOL> result . append ( RegistryValidationError ( u"<STR_LIT>" "<STR_LIT>" % ( self . Name , int ( self [ u'<STR_LIT>' ] ) ) , regentry = self ) ) <EOL> if u'<STR_LIT>' in self : <EOL> if self [ u'<STR_LIT>' ] : <EOL> pat = re . compile ( self [ u'<STR_LIT>' ] ) <EOL> if newval and not pat . match ( newval ) : <EOL> result . append ( RegistryValidationError ( u"<STR_LIT>" "<STR_LIT>" "<STR_LIT>" % ( self ) , regentry = self ) ) <EOL> return result <EOL> def print_help ( self , name , out = sys . stdout ) : <EOL> """<STR_LIT>""" <EOL> wrapper = textwrap . TextWrapper ( ) <EOL> wrapper . initial_indent = '<STR_LIT:U+0020>' * <NUM_LIT:4> <EOL> wrapper . subsequent_indent = '<STR_LIT:U+0020>' * <NUM_LIT:4> <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT:%s>' % name ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT:description>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT:type>' in self and isinstance ( self [ u'<STR_LIT:type>' ] , list ) : <EOL> out . write ( u'<STR_LIT>' ) <EOL> for item in self [ u'<STR_LIT:type>' ] : <EOL> out . write ( '<STR_LIT>' % wrapper . fill ( '<STR_LIT:%s>' % item ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> elif u'<STR_LIT:type>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> elif u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> if u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) <EOL> elif u'<STR_LIT>' in self : <EOL> out . write ( u'<STR_LIT>' ) <EOL> out . write ( '<STR_LIT:%s>' % wrapper . fill ( '<STR_LIT>' % self ) ) <EOL> out . write ( '<STR_LIT:\n>' ) </s>
<s> from . constants import MILLI_MICROS , SECOND_MICROS , MINUTE_MICROS <EOL> import calendar <EOL> from datetime import datetime <EOL> from dateutil import parser <EOL> from dateutil . tz import tzlocal <EOL> from . error import TimeConstructionError <EOL> from . sanedelta import SaneDelta <EOL> import pytz <EOL> MICROS_TRANSLATIONS = ( <EOL> ( ( '<STR_LIT:m>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , MINUTE_MICROS ) , <EOL> ( ( '<STR_LIT:s>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , SECOND_MICROS ) , <EOL> ( ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , MILLI_MICROS ) , <EOL> ( ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , <NUM_LIT:1> ) ) <EOL> MICROS_TRANSLATION_HASH = dict ( ( alt , v ) for k , v in MICROS_TRANSLATIONS for alt in k ) <EOL> class SaneTime ( object ) : <EOL> """<STR_LIT>""" <EOL> """<STR_LIT>""" <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> """<STR_LIT>""" <EOL> super ( time , self ) . __init__ ( ) <EOL> uss = set ( ) <EOL> tzs = set ( ) <EOL> naive_dt = None <EOL> avoid_localize = False <EOL> for k , v in kwargs . iteritems ( ) : <EOL> if k in ( '<STR_LIT>' , '<STR_LIT>' ) : <EOL> tzs . add ( SaneTime . to_timezone ( v ) ) <EOL> elif k in MICROS_TRANSLATION_HASH : <EOL> uss . add ( MICROS_TRANSLATION_HASH [ k ] * v ) <EOL> else : <EOL> raise TimeConstructionError ( "<STR_LIT>" % ( k , v ) ) <EOL> args = list ( args ) <EOL> if len ( args ) > <NUM_LIT:2> and len ( args ) <= <NUM_LIT:8> : <EOL> args = [ datetime ( * args ) ] <EOL> if len ( args ) == <NUM_LIT:2> : <EOL> tzs . add ( SaneTime . to_timezone ( args . pop ( ) ) ) <EOL> if len ( args ) == <NUM_LIT:1> : <EOL> arg = args . pop ( ) <EOL> if hasattr ( arg , '<STR_LIT>' ) : <EOL> uss . add ( int ( arg ) ) <EOL> if hasattr ( arg , '<STR_LIT>' ) : tzs . add ( arg . tz ) <EOL> elif isinstance ( arg , basestring ) : <EOL> parts = arg . strip ( ) . split ( '<STR_LIT:U+0020>' ) <EOL> if len ( parts ) > <NUM_LIT:1> and parts [ - <NUM_LIT:1> ] . startswith ( '<STR_LIT:+>' ) : <EOL> try : <EOL> tzs . add ( SaneTime . to_timezone ( parts [ - <NUM_LIT:1> ] [ <NUM_LIT:1> : ] ) ) <EOL> arg = '<STR_LIT:U+0020>' . join ( parts [ : - <NUM_LIT:1> ] ) <EOL> except : pass <EOL> utc = arg . endswith ( '<STR_LIT>' ) or arg . endswith ( '<STR_LIT>' ) <EOL> arg = parser . parse ( arg ) <EOL> if arg . tzinfo : <EOL> if utc : <EOL> tzs . add ( pytz . utc ) <EOL> arg = arg . replace ( tzinfo = None ) <EOL> elif isinstance ( arg . tzinfo , tzlocal ) : <EOL> arg = arg . replace ( tzinfo = None ) <EOL> else : <EOL> avoid_localize = True <EOL> arg = arg . astimezone ( pytz . utc ) . replace ( tzinfo = None ) <EOL> if type ( arg ) == datetime : <EOL> naive_dt = arg <EOL> if naive_dt . tzinfo : <EOL> tzs . add ( SaneTime . to_timezone ( str ( naive_dt . tzinfo ) ) ) <EOL> naive_dt = naive_dt . replace ( tzinfo = None ) <EOL> if len ( tzs ) > <NUM_LIT:1> : <EOL> raise TimeConstructionError ( "<STR_LIT>" % ( tzs ) ) <EOL> self . tz = len ( tzs ) and tzs . pop ( ) or pytz . utc <EOL> if naive_dt : <EOL> if avoid_localize : <EOL> uss . add ( SaneTime . utc_datetime_to_us ( naive_dt ) ) <EOL> else : <EOL> uss . add ( SaneTime . utc_datetime_to_us ( self . tz . localize ( naive_dt ) . astimezone ( pytz . utc ) ) ) <EOL> if len ( uss ) == <NUM_LIT:0> : <EOL> uss . add ( SaneTime . utc_datetime_to_us ( datetime . utcnow ( ) ) ) <EOL> if len ( uss ) > <NUM_LIT:1> : <EOL> raise TimeConstructionError ( "<STR_LIT>" % ( uss ) ) <EOL> self . us = uss . pop ( ) <EOL> if len ( args ) > <NUM_LIT:0> : <EOL> raise TimeConstructionError ( "<STR_LIT>" ) <EOL> @ property <EOL> def ms ( self ) : return self . us / MILLI_MICROS <EOL> epoch_milliseconds = epoch_millis = milliseconds = millis = ms <EOL> @ property <EOL> def s ( self ) : return self . us / SECOND_MICROS <EOL> epoch_seconds = epoch_secs = seconds = secs = s <EOL> @ property <EOL> def m ( self ) : return self . us / MINUTE_MICROS <EOL> epoch_minutes = epoch_mins = minutes = mins = m <EOL> @ property <EOL> def micros ( self ) : return self . us <EOL> epoch_microseconds = epoch_micros = microseconds = micros <EOL> @ property <EOL> def tz_name ( self ) : return self . tz . zone <EOL> @ property <EOL> def tz_abbr ( self ) : return self . tz . _tzname <EOL> def set_tz ( self , tz ) : <EOL> self . tz = self . __class__ . to_timezone ( tz ) ; return self <EOL> def with_tz ( self , tz ) : <EOL> return self . __class__ ( self . us , tz ) <EOL> @ property <EOL> def _tuple ( self ) : return ( self . us , self . tz ) <EOL> def strftime ( self , * args , ** kwargs ) : return self . datetime . strftime ( * args , ** kwargs ) <EOL> def __cmp__ ( self , other ) : <EOL> if not hasattr ( other , '<STR_LIT>' ) : other = SaneTime ( other ) <EOL> return cmp ( self . us , int ( other ) ) <EOL> def __hash__ ( self ) : return self . us . __hash__ ( ) <EOL> def __add__ ( self , operand ) : <EOL> if not hasattr ( operand , '<STR_LIT>' ) : operand = SaneTime ( operand ) <EOL> return self . __class__ ( self . us + int ( operand ) , tz = self . tz ) <EOL> def __sub__ ( self , operand ) : <EOL> if not hasattr ( operand , '<STR_LIT>' ) : operand = SaneTime ( operand ) <EOL> if isinstance ( operand , SaneTime ) : return SaneDelta ( self . us - int ( operand ) ) <EOL> return self . __add__ ( - int ( operand ) ) <EOL> def __mul__ ( self , operand ) : <EOL> return self . us * int ( operand ) <EOL> def __div__ ( self , operand ) : <EOL> return self . us / int ( operand ) <EOL> def __int__ ( self ) : return int ( self . us ) <EOL> def __long__ ( self ) : return long ( self . us ) <EOL> def __repr__ ( self ) : return u"<STR_LIT>" % ( self . us , repr ( self . tz ) ) <EOL> def __str__ ( self ) : return unicode ( self ) . encode ( '<STR_LIT:utf-8>' ) <EOL> def __unicode__ ( self ) : <EOL> dt = self . datetime <EOL> micros = u"<STR_LIT>" % dt . microsecond if dt . microsecond else '<STR_LIT>' <EOL> time = u"<STR_LIT>" % ( dt . hour , dt . minute , dt . second , micros ) if dt . microsecond or dt . second or dt . minute or dt . hour else '<STR_LIT>' <EOL> return u"<STR_LIT>" % ( dt . year , dt . month , dt . day , time , dt . tzinfo . zone ) <EOL> def clone ( self ) : <EOL> """<STR_LIT>""" <EOL> return self . __class__ ( self . us , self . tz ) <EOL> @ property <EOL> def ny_str ( self ) : <EOL> """<STR_LIT>""" <EOL> return self . ny_ndt . strftime ( '<STR_LIT>' ) <EOL> @ property <EOL> def utc_datetime ( self ) : return SaneTime . us_to_utc_datetime ( self . us ) <EOL> utc_dt = utc_datetime <EOL> @ property <EOL> def utc_naive_datetime ( self ) : return self . utc_datetime . replace ( tzinfo = None ) <EOL> utc_ndt = utc_naive_datetime <EOL> def to_timezoned_datetime ( self , tz ) : return self . utc_datetime . astimezone ( SaneTime . to_timezone ( tz ) ) <EOL> def to_timezoned_naive_datetime ( self , tz ) : return self . to_timezoned_datetime ( tz ) . replace ( tzinfo = None ) <EOL> @ property <EOL> def datetime ( self ) : return self . to_timezoned_datetime ( self . tz ) <EOL> dt = datetime <EOL> @ property <EOL> def naive_datetime ( self ) : return self . to_timezoned_naive_datetime ( self . tz ) <EOL> ndt = naive_datetime <EOL> @ property <EOL> def ny_datetime ( self ) : return self . to_timezoned_datetime ( '<STR_LIT>' ) <EOL> ny_dt = ny_datetime <EOL> @ property <EOL> def ny_naive_datetime ( self ) : return self . to_timezoned_naive_datetime ( '<STR_LIT>' ) <EOL> ny_ndt = ny_naive_datetime <EOL> @ property <EOL> def year ( self ) : return self . dt . year <EOL> @ property <EOL> def month ( self ) : return self . dt . month <EOL> @ property <EOL> def day ( self ) : return self . dt . day <EOL> @ property <EOL> def hour ( self ) : return self . dt . hour <EOL> @ property <EOL> def minute ( self ) : return self . dt . minute <EOL> @ property <EOL> def second ( self ) : return self . dt . second <EOL> @ property <EOL> def microsecond ( self ) : return self . dt . microsecond <EOL> @ classmethod <EOL> def utc_datetime_to_us ( kls , dt ) : <EOL> return calendar . timegm ( dt . timetuple ( ) ) * <NUM_LIT:1000> ** <NUM_LIT:2> + dt . microsecond <EOL> @ classmethod <EOL> def us_to_utc_datetime ( kls , us ) : <EOL> return pytz . utc . localize ( datetime . utcfromtimestamp ( us / <NUM_LIT:10> ** <NUM_LIT:6> ) ) . replace ( microsecond = us % <NUM_LIT:10> ** <NUM_LIT:6> ) <EOL> @ classmethod <EOL> def to_timezone ( kls , tz ) : <EOL> if not isinstance ( tz , basestring ) : return tz <EOL> return pytz . timezone ( tz ) <EOL> def ntime ( * args , ** kwargs ) : <EOL> if args : <EOL> if args [ <NUM_LIT:0> ] is None : return None <EOL> elif kwargs : <EOL> if None in [ v for k , v in kwargs . iteritems ( ) if k != '<STR_LIT>' ] : return None <EOL> return SaneTime ( * args , ** kwargs ) <EOL> time = sanetime = SaneTime <EOL> nsanetime = ntime </s>
<s> from tastypie . authorization import Authorization <EOL> from openpds . authentication import OAuth2Authentication <EOL> from openpds . core . models import Profile , AuditEntry <EOL> import settings <EOL> import pdb <EOL> import traceback <EOL> class PDSAuthorization ( Authorization ) : <EOL> audit_enabled = True <EOL> scope = "<STR_LIT>" <EOL> requester_uuid = "<STR_LIT>" <EOL> def requester ( self ) : <EOL> return self . requester_uuid <EOL> def trustWrapper ( self , datastore_owner ) : <EOL> print "<STR_LIT>" <EOL> def is_authorized ( self , request , object = None ) : <EOL> authenticator = OAuth2Authentication ( self . scope ) <EOL> if "<STR_LIT>" in request . REQUEST : <EOL> authorized = True <EOL> token = request . REQUEST [ "<STR_LIT>" ] if "<STR_LIT>" in request . REQUEST else request . META [ "<STR_LIT>" ] <EOL> datastore_owner_uuid = request . REQUEST [ "<STR_LIT>" ] <EOL> datastore_owner , ds_owner_created = Profile . objects . get_or_create ( uuid = datastore_owner_uuid ) <EOL> self . requester_uuid = authenticator . get_userinfo_from_token ( token , self . scope ) <EOL> if self . requester_uuid is False or self . requester_uuid is None or len ( self . requester_uuid ) == <NUM_LIT:0> : <EOL> self . requester_uuid = "<STR_LIT>" <EOL> authorized = False <EOL> self . trustWrapper ( datastore_owner ) <EOL> try : <EOL> if ( self . audit_enabled ) : <EOL> audit_entry = AuditEntry ( token = token ) <EOL> audit_entry . method = request . method <EOL> audit_entry . scope = self . scope <EOL> audit_entry . purpose = request . REQUEST [ "<STR_LIT>" ] if "<STR_LIT>" in request . REQUEST else "<STR_LIT>" <EOL> audit_entry . system_entity_toggle = request . REQUEST [ "<STR_LIT>" ] if "<STR_LIT>" in request . REQUEST else False <EOL> audit_entry . datastore_owner = datastore_owner <EOL> audit_entry . requester , created = Profile . objects . get_or_create ( uuid = self . requester_uuid ) <EOL> audit_entry . script = request . path <EOL> audit_entry . save ( ) <EOL> except Exception as e : <EOL> print e <EOL> authorized = False <EOL> return authorized <EOL> return False <EOL> def __init__ ( self , scope , audit_enabled = True ) : <EOL> self . scope = scope <EOL> self . audit_enabled = audit_enabled </s>
<s> """<STR_LIT>""" <EOL> from django import template <EOL> register = template . Library ( ) <EOL> class VerbatimNode ( template . Node ) : <EOL> def __init__ ( self , text ) : <EOL> self . text = text <EOL> def render ( self , context ) : <EOL> return self . text <EOL> @ register . tag <EOL> def verbatim ( parser , token ) : <EOL> text = [ ] <EOL> while <NUM_LIT:1> : <EOL> token = parser . tokens . pop ( <NUM_LIT:0> ) <EOL> if token . contents == '<STR_LIT>' : <EOL> break <EOL> if token . token_type == template . TOKEN_VAR : <EOL> text . append ( '<STR_LIT>' ) <EOL> elif token . token_type == template . TOKEN_BLOCK : <EOL> text . append ( '<STR_LIT>' ) <EOL> text . append ( token . contents ) <EOL> if token . token_type == template . TOKEN_VAR : <EOL> text . append ( '<STR_LIT>' ) <EOL> elif token . token_type == template . TOKEN_BLOCK : <EOL> text . append ( '<STR_LIT>' ) <EOL> return VerbatimNode ( '<STR_LIT>' . join ( text ) ) </s>
<s> from django . shortcuts import render_to_response <EOL> from django . template import RequestContext <EOL> import pdb </s>
<s> from werkzeug . utils import cached_property <EOL> from base import db , Base <EOL> from cluster import Cluster <EOL> class Proxy ( Base ) : <EOL> __tablename__ = '<STR_LIT>' <EOL> host = db . Column ( db . String ( <NUM_LIT:255> ) , nullable = False ) <EOL> port = db . Column ( db . Integer , nullable = False ) <EOL> eru_container_id = db . Column ( db . String ( <NUM_LIT:64> ) , index = True ) <EOL> cluster_id = db . Column ( db . ForeignKey ( Cluster . id ) , index = True ) <EOL> suppress_alert = db . Column ( db . Integer , nullable = False , default = <NUM_LIT:1> ) <EOL> __table_args__ = ( db . Index ( '<STR_LIT:address>' , '<STR_LIT:host>' , '<STR_LIT:port>' , unique = True ) , ) <EOL> @ cached_property <EOL> def eru_deployed ( self ) : <EOL> return self . eru_container_id is not None <EOL> @ cached_property <EOL> def eru_info ( self ) : <EOL> import eru_utils <EOL> if eru_utils . eru_client is None or not self . eru_deployed : <EOL> return None <EOL> return eru_utils . eru_client . get_container ( self . eru_container_id ) <EOL> @ cached_property <EOL> def cluster ( self ) : <EOL> return Cluster . query . get ( self . cluster_id ) <EOL> def get_by_host_port ( host , port ) : <EOL> return db . session . query ( Proxy ) . filter ( <EOL> Proxy . host == host , Proxy . port == port ) . first ( ) <EOL> def del_by_host_port ( host , port ) : <EOL> return db . session . query ( Proxy ) . filter ( <EOL> Proxy . host == host , Proxy . port == port ) . delete ( ) <EOL> def get_or_create ( host , port , cluster_id = None ) : <EOL> p = db . session . query ( Proxy ) . filter ( <EOL> Proxy . host == host , Proxy . port == port ) . first ( ) <EOL> if p is None : <EOL> p = Proxy ( host = host , port = port , cluster_id = cluster_id ) <EOL> db . session . add ( p ) <EOL> db . session . flush ( ) <EOL> return p <EOL> def create_eru_instance ( host , port , cluster_id , eru_container_id ) : <EOL> node = Proxy ( host = host , port = port , eru_container_id = eru_container_id , <EOL> cluster_id = cluster_id ) <EOL> db . session . add ( node ) <EOL> db . session . flush ( ) <EOL> return node <EOL> def delete_eru_instance ( eru_container_id ) : <EOL> db . session . query ( Proxy ) . filter ( <EOL> Proxy . eru_container_id == eru_container_id ) . delete ( ) <EOL> def get_eru_by_container_id ( eru_container_id ) : <EOL> return db . session . query ( Proxy ) . filter ( <EOL> Proxy . eru_container_id == eru_container_id ) . first ( ) <EOL> def list_all ( ) : <EOL> return db . session . query ( Proxy ) . all ( ) <EOL> def list_eru_proxies ( offset , limit ) : <EOL> return db . session . query ( Proxy ) . filter ( <EOL> Proxy . eru_container_id != None ) . order_by ( <EOL> Proxy . id . desc ( ) ) . offset ( offset ) . limit ( limit ) . all ( ) <EOL> def list_ip ( ) : <EOL> return db . session . query ( Proxy . host , Proxy . port ) . all ( ) </s>
<s> from ethereum import tester <EOL> import hydrachain . native_contracts as nc <EOL> from fungible_contract import IOU <EOL> import ethereum . slogging as slogging <EOL> log = slogging . get_logger ( '<STR_LIT>' ) <EOL> def test_iou_template ( ) : <EOL> """<STR_LIT>""" <EOL> nc . registry . register ( IOU ) <EOL> state = tester . state ( ) <EOL> logs = [ ] <EOL> issuer_address = tester . a0 <EOL> issuer_key = tester . k0 <EOL> for evt_class in IOU . events : <EOL> nc . listen_logs ( state , evt_class , callback = lambda e : logs . append ( e ) ) <EOL> iou_address = nc . tester_create_native_contract_instance ( state , issuer_key , IOU ) <EOL> iou_as_issuer = nc . tester_nac ( state , issuer_key , iou_address ) <EOL> iou_as_issuer . init ( ) <EOL> assert iou_as_issuer . balanceOf ( issuer_address ) == <NUM_LIT:0> <EOL> amount_issued = <NUM_LIT> <EOL> iou_as_issuer . issue_funds ( amount_issued , '<STR_LIT>' ) <EOL> assert iou_as_issuer . balanceOf ( issuer_address ) == amount_issued <EOL> iou_as_issuer . issue_funds ( amount_issued , '<STR_LIT>' ) <EOL> assert iou_as_issuer . balanceOf ( issuer_address ) == <NUM_LIT:2> * amount_issued <EOL> assert iou_as_issuer . get_issued_amount ( issuer_address ) == <NUM_LIT:2> * amount_issued <EOL> print logs <EOL> while logs and logs . pop ( ) : <EOL> pass <EOL> nc . registry . unregister ( IOU ) </s>
<s> """<STR_LIT>""" <EOL> import json <EOL> import time <EOL> import urllib2 <EOL> import logging <EOL> from view_controls . view import DrawingTool , Event <EOL> from game_objects . item import Item <EOL> from game_objects . state import TrackerState , TrackerStateEncoder <EOL> from log_parser import LogParser <EOL> from options import Options <EOL> class IsaacTracker ( object ) : <EOL> """<STR_LIT>""" <EOL> def __init__ ( self , logging_level = logging . INFO , read_timer = <NUM_LIT:1> ) : <EOL> self . read_timer = read_timer <EOL> self . file_prefix = "<STR_LIT>" <EOL> self . log = logging . getLogger ( "<STR_LIT>" ) <EOL> self . log . addHandler ( logging . FileHandler ( self . file_prefix + "<STR_LIT>" , mode = '<STR_LIT:w>' ) ) <EOL> self . log . setLevel ( logging_level ) <EOL> with open ( self . file_prefix + "<STR_LIT>" , "<STR_LIT:r>" ) as items_file : <EOL> Item . items_info = json . load ( items_file ) <EOL> with open ( self . file_prefix + '<STR_LIT>' , '<STR_LIT:r>' ) as f : <EOL> self . tracker_version = f . read ( ) <EOL> Options ( ) . load_options ( self . file_prefix + "<STR_LIT>" ) <EOL> def __del__ ( self ) : <EOL> Options ( ) . save_options ( self . file_prefix + "<STR_LIT>" ) <EOL> def check_for_update ( self ) : <EOL> """<STR_LIT>""" <EOL> try : <EOL> latest = "<STR_LIT>" <EOL> github_info_json = urllib2 . urlopen ( latest ) . read ( ) <EOL> info = json . loads ( github_info_json ) <EOL> latest_version = info [ "<STR_LIT:name>" ] <EOL> title_text = "<STR_LIT>" + self . tracker_version <EOL> if latest_version != self . tracker_version : <EOL> title_text += "<STR_LIT>" <EOL> return title_text <EOL> except Exception as e : <EOL> self . log . debug ( "<STR_LIT>" + e . message ) <EOL> return "<STR_LIT>" <EOL> def run ( self ) : <EOL> """<STR_LIT>""" <EOL> update_notifier = self . check_for_update ( ) <EOL> framecount = <NUM_LIT:0> <EOL> drawing_tool = DrawingTool ( self . file_prefix ) <EOL> drawing_tool . set_window_title ( update_notifier ) <EOL> parser = LogParser ( self . file_prefix , self . tracker_version ) <EOL> opt = Options ( ) <EOL> log = logging . getLogger ( "<STR_LIT>" ) <EOL> event_result = None <EOL> state = None <EOL> read_from_server = opt . read_from_server <EOL> write_to_server = opt . write_to_server <EOL> state_version = - <NUM_LIT:1> <EOL> twitch_username = None <EOL> new_states_queue = [ ] <EOL> screen_error_message = None <EOL> while event_result != Event . DONE : <EOL> event_result = drawing_tool . handle_events ( ) <EOL> if opt . read_from_server != read_from_server or opt . twitch_name != twitch_username : <EOL> twitch_username = opt . twitch_name <EOL> read_from_server = opt . read_from_server <EOL> new_states_queue = [ ] <EOL> if read_from_server : <EOL> state_version = - <NUM_LIT:1> <EOL> state = None <EOL> drawing_tool . set_window_title ( update_notifier , watching_player = twitch_username , updates_queued = len ( new_states_queue ) ) <EOL> else : <EOL> drawing_tool . set_window_title ( update_notifier ) <EOL> if opt . write_to_server and opt . write_to_server != write_to_server : <EOL> write_to_server = True <EOL> drawing_tool . set_window_title ( update_notifier , uploading = True ) <EOL> if not opt . write_to_server : <EOL> write_to_server = False <EOL> if opt . read_from_server : <EOL> update_timer = <NUM_LIT:2> <EOL> else : <EOL> update_timer = self . read_timer <EOL> if event_result == Event . OPTIONS_UPDATE : <EOL> framecount = <NUM_LIT:0> <EOL> screen_error_message = None <EOL> if state is not None : <EOL> state . modified = True <EOL> if ( framecount % int ( Options ( ) . framerate_limit * update_timer ) == <NUM_LIT:0> ) : <EOL> if opt . read_from_server : <EOL> base_url = opt . trackerserver_url + "<STR_LIT>" + opt . twitch_name <EOL> json_dict = None <EOL> try : <EOL> json_version = urllib2 . urlopen ( base_url + "<STR_LIT>" ) . read ( ) <EOL> if int ( json_version ) > state_version : <EOL> json_state = urllib2 . urlopen ( base_url ) . read ( ) <EOL> json_dict = json . loads ( json_state ) <EOL> new_state = TrackerState . from_json ( json_dict ) <EOL> if new_state is None : <EOL> raise Exception <EOL> state_version = int ( json_version ) <EOL> new_states_queue . append ( ( state_version , new_state ) ) <EOL> drawing_tool . set_window_title ( update_notifier , watching_player = twitch_username , updates_queued = len ( new_states_queue ) , read_delay = opt . read_delay ) <EOL> except Exception : <EOL> state = None <EOL> log . error ( "<STR_LIT>" ) <EOL> import traceback <EOL> log . error ( traceback . format_exc ( ) ) <EOL> if json_dict is not None : <EOL> their_version = "<STR_LIT>" <EOL> if "<STR_LIT>" in json_dict : <EOL> their_version = json_dict [ "<STR_LIT>" ] <EOL> else : <EOL> their_version = "<STR_LIT>" <EOL> if their_version != self . tracker_version : <EOL> screen_error_message = "<STR_LIT>" + their_version + "<STR_LIT>" + self . tracker_version <EOL> else : <EOL> force_draw = state and state . modified <EOL> state = parser . parse ( ) <EOL> if force_draw : <EOL> state . modified = True <EOL> if write_to_server and not opt . trackerserver_authkey : <EOL> screen_error_message = "<STR_LIT>" <EOL> if state is not None and write_to_server and state . modified and screen_error_message is None : <EOL> opener = urllib2 . build_opener ( urllib2 . HTTPHandler ) <EOL> put_url = opt . trackerserver_url + "<STR_LIT>" + opt . trackerserver_authkey <EOL> json_string = json . dumps ( state , cls = TrackerStateEncoder , sort_keys = True ) <EOL> request = urllib2 . Request ( put_url , <EOL> data = json_string ) <EOL> request . add_header ( '<STR_LIT:Content-Type>' , '<STR_LIT:application/json>' ) <EOL> request . get_method = lambda : '<STR_LIT>' <EOL> try : <EOL> result = opener . open ( request ) <EOL> result_json = json . loads ( result . read ( ) ) <EOL> updated_user = result_json [ "<STR_LIT>" ] <EOL> if updated_user is None : <EOL> screen_error_message = "<STR_LIT>" <EOL> else : <EOL> screen_error_message = None <EOL> except Exception as e : <EOL> import traceback <EOL> errmsg = traceback . format_exc ( ) <EOL> log . error ( "<STR_LIT>" ) <EOL> log . error ( errmsg ) <EOL> screen_error_message = "<STR_LIT>" <EOL> if len ( new_states_queue ) > <NUM_LIT:0> : <EOL> ( state_timestamp , new_state ) = new_states_queue [ <NUM_LIT:0> ] <EOL> current_timestamp = int ( time . time ( ) ) <EOL> if current_timestamp - state_timestamp >= opt . read_delay or state is None : <EOL> state = new_state <EOL> new_states_queue . pop ( <NUM_LIT:0> ) <EOL> drawing_tool . set_window_title ( update_notifier , watching_player = twitch_username , updates_queued = len ( new_states_queue ) , read_delay = opt . read_delay ) <EOL> if state is None and screen_error_message is None : <EOL> if read_from_server : <EOL> screen_error_message = "<STR_LIT>" <EOL> else : <EOL> screen_error_message = "<STR_LIT>" <EOL> if screen_error_message is not None : <EOL> drawing_tool . write_error_message ( screen_error_message ) <EOL> else : <EOL> drawing_tool . draw_state ( state ) <EOL> drawing_tool . tick ( ) <EOL> framecount += <NUM_LIT:1> <EOL> drawing_tool . save_window_position ( ) <EOL> def main ( ) : <EOL> """<STR_LIT>""" <EOL> try : <EOL> rt = IsaacTracker ( ) <EOL> rt . run ( ) <EOL> except Exception : <EOL> import traceback <EOL> errmsg = traceback . format_exc ( ) <EOL> print ( errmsg ) <EOL> logging . getLogger ( "<STR_LIT>" ) . error ( errmsg ) <EOL> if __name__ == "<STR_LIT:__main__>" : <EOL> main ( ) </s>
<s> from __future__ import division , print_function , unicode_literals <EOL> from collections import OrderedDict <EOL> from brainstorm . layers . base_layer import Layer <EOL> from brainstorm . structure . buffer_structure import ( BufferStructure , <EOL> StructureTemplate ) <EOL> from brainstorm . structure . construction import ConstructionWrapper <EOL> from brainstorm . utils import flatten_all_but_last <EOL> def BatchNorm ( name = None , decay = <NUM_LIT> , epsilon = <NUM_LIT> ) : <EOL> """<STR_LIT>""" <EOL> return ConstructionWrapper . create ( BatchNormLayerImpl , <EOL> name = name , <EOL> decay = decay , <EOL> epsilon = epsilon ) <EOL> class BatchNormLayerImpl ( Layer ) : <EOL> expected_inputs = { '<STR_LIT:default>' : StructureTemplate ( '<STR_LIT:T>' , '<STR_LIT:B>' , '<STR_LIT>' ) } <EOL> expected_kwargs = { '<STR_LIT>' , '<STR_LIT>' } <EOL> def setup ( self , kwargs , in_shapes ) : <EOL> self . epsilon = kwargs . get ( '<STR_LIT>' , <NUM_LIT> ) <EOL> self . decay = kwargs . get ( '<STR_LIT>' , <NUM_LIT> ) <EOL> assert <NUM_LIT:0.0> <= self . decay <= <NUM_LIT:1.0> , "<STR_LIT>" <EOL> outputs = OrderedDict ( ) <EOL> outputs [ '<STR_LIT:default>' ] = in_shapes [ '<STR_LIT:default>' ] <EOL> parameters = OrderedDict ( ) <EOL> buf = BufferStructure ( self . in_shapes [ '<STR_LIT:default>' ] . feature_shape [ - <NUM_LIT:1> ] ) <EOL> parameters [ '<STR_LIT>' ] = buf <EOL> parameters [ '<STR_LIT>' ] = buf <EOL> parameters [ '<STR_LIT>' ] = buf <EOL> parameters [ '<STR_LIT>' ] = buf <EOL> internals = OrderedDict ( ) <EOL> internals [ '<STR_LIT>' ] = buf <EOL> internals [ '<STR_LIT>' ] = self . in_shapes [ '<STR_LIT:default>' ] <EOL> internals [ '<STR_LIT>' ] = self . in_shapes [ '<STR_LIT:default>' ] <EOL> return outputs , parameters , internals <EOL> def forward_pass ( self , buffers , training_pass = True ) : <EOL> _h = self . handler <EOL> sigma_b , centered , x_hat = buffers . internals <EOL> gamma , beta , mu , sigma = buffers . parameters <EOL> inputs = flatten_all_but_last ( buffers . inputs . default ) <EOL> centered = flatten_all_but_last ( centered ) <EOL> x_hat = flatten_all_but_last ( x_hat ) <EOL> out = flatten_all_but_last ( buffers . outputs . default ) <EOL> m = inputs . shape [ <NUM_LIT:0> ] <EOL> if training_pass : <EOL> mu_b = sigma_b <EOL> _h . sum_t ( inputs , <NUM_LIT:0> , mu_b ) <EOL> _h . mult_st ( - <NUM_LIT:1.0> / m , mu_b , mu_b ) <EOL> _h . mult_st ( self . decay , mu , mu ) <EOL> _h . mult_add_st ( <NUM_LIT:1.0> - self . decay , mu_b , mu ) <EOL> mu = mu_b <EOL> _h . add_mv ( inputs , mu . reshape ( ( <NUM_LIT:1> , mu . size ) ) , centered ) <EOL> if training_pass : <EOL> sigma2 = sigma_b <EOL> centered2 = x_hat <EOL> _h . mult_tt ( centered , centered , centered2 ) <EOL> _h . sum_t ( centered2 , <NUM_LIT:0> , sigma2 ) <EOL> _h . mult_st ( <NUM_LIT:1.0> / m , sigma2 , sigma2 ) <EOL> _h . add_st ( self . epsilon , sigma2 , sigma2 ) <EOL> _h . sqrt_t ( sigma2 , sigma_b ) <EOL> _h . mult_st ( self . decay , sigma , sigma ) <EOL> _h . mult_add_st ( <NUM_LIT:1.0> - self . decay , sigma_b , sigma ) <EOL> sigma = sigma_b <EOL> _h . divide_mv ( centered , sigma . reshape ( ( <NUM_LIT:1> , sigma . size ) ) , x_hat ) <EOL> _h . mult_mv ( x_hat , gamma . reshape ( ( <NUM_LIT:1> , gamma . size ) ) , out ) <EOL> _h . add_mv ( out , beta . reshape ( ( <NUM_LIT:1> , beta . size ) ) , out ) <EOL> def backward_pass ( self , buffers ) : <EOL> _h = self . handler <EOL> sigma_b , centered , x_hat = buffers . internals <EOL> gamma = buffers . parameters . gamma <EOL> dgamma = buffers . gradients . gamma <EOL> dbeta = buffers . gradients . beta <EOL> x_hat = flatten_all_but_last ( x_hat ) <EOL> outdeltas = flatten_all_but_last ( buffers . output_deltas . default ) <EOL> indeltas = flatten_all_but_last ( buffers . input_deltas . default ) <EOL> m = outdeltas . shape [ <NUM_LIT:0> ] <EOL> big_tmp = _h . allocate ( x_hat . shape ) <EOL> small_tmp = _h . allocate ( gamma . shape ) <EOL> tmp = big_tmp <EOL> dgamma_tmp = small_tmp <EOL> _h . mult_tt ( outdeltas , x_hat , tmp ) <EOL> _h . sum_t ( tmp , axis = <NUM_LIT:0> , out = dgamma_tmp ) <EOL> _h . add_tt ( dgamma_tmp , dgamma , dgamma ) <EOL> _h . mult_st ( <NUM_LIT:1> / m , dgamma_tmp , dgamma_tmp ) <EOL> term1 = big_tmp <EOL> _h . mult_mv ( x_hat , dgamma_tmp . reshape ( ( <NUM_LIT:1> , gamma . size ) ) , term1 ) <EOL> dbeta_tmp = small_tmp <EOL> _h . sum_t ( outdeltas , axis = <NUM_LIT:0> , out = dbeta_tmp ) <EOL> _h . add_tt ( dbeta_tmp , dbeta , dbeta ) <EOL> _h . mult_st ( <NUM_LIT:1> / m , dbeta_tmp , dbeta_tmp ) <EOL> term2 = big_tmp <EOL> term3 = big_tmp <EOL> _h . subtract_tt ( outdeltas , term1 , term2 ) <EOL> _h . subtract_mv ( term2 , dbeta_tmp . reshape ( ( <NUM_LIT:1> , dbeta . size ) ) , term3 ) <EOL> coeff = small_tmp <EOL> _h . divide_tt ( gamma , sigma_b , coeff ) <EOL> term4 = big_tmp <EOL> _h . mult_mv ( term3 , coeff . reshape ( ( <NUM_LIT:1> , coeff . size ) ) , term4 ) <EOL> _h . add_tt ( term4 , indeltas , indeltas ) </s>
<s> from __future__ import division , print_function , unicode_literals <EOL> from collections import OrderedDict <EOL> import numpy as np <EOL> from brainstorm . describable import Describable <EOL> class Scorer ( Describable ) : <EOL> def __init__ ( self , out_name = '<STR_LIT>' , targets_name = '<STR_LIT>' , mask_name = '<STR_LIT>' , <EOL> name = None ) : <EOL> self . out_name = out_name <EOL> self . targets_name = targets_name <EOL> self . mask_name = mask_name <EOL> self . __name__ = name if name is not None else self . __class__ . __name__ <EOL> def __call__ ( self , true_labels , predicted , mask = None ) : <EOL> pass <EOL> @ staticmethod <EOL> def aggregate ( errors ) : <EOL> errors = np . array ( errors ) <EOL> assert errors . ndim == <NUM_LIT:2> and errors . shape [ <NUM_LIT:1> ] == <NUM_LIT:2> <EOL> return np . sum ( errors [ : , <NUM_LIT:1> ] ) / np . sum ( errors [ : , <NUM_LIT:0> ] ) <EOL> def gather_losses_and_scores ( net , scorers , scores , out_name = '<STR_LIT>' , <EOL> targets_name = '<STR_LIT>' , mask_name = '<STR_LIT>' ) : <EOL> ls = net . get_loss_values ( ) <EOL> for name , loss in ls . items ( ) : <EOL> scores [ name ] . append ( ( net . _buffer_manager . batch_size , loss ) ) <EOL> for sc in scorers : <EOL> name = sc . __name__ <EOL> predicted = net . get ( sc . out_name or out_name or net . output_name ) <EOL> true_labels = net . get_input ( sc . targets_name ) if sc . targets_name else net . get_input ( targets_name ) <EOL> mask = net . get_input ( sc . mask_name ) if sc . mask_name else ( net . get_input ( mask_name ) if mask_name else None ) <EOL> predicted = _flatten_all_but_last ( predicted ) <EOL> true_labels = _flatten_all_but_last ( true_labels ) <EOL> mask = _flatten_all_but_last ( mask ) <EOL> weight = mask . sum ( ) if mask is not None else predicted . shape [ <NUM_LIT:0> ] <EOL> scores [ name ] . append ( ( weight , sc ( true_labels , predicted , mask ) ) ) <EOL> def aggregate_losses_and_scores ( scores , net , scorers ) : <EOL> results = OrderedDict ( ) <EOL> for name in net . get_loss_values ( ) : <EOL> results [ name ] = _weighted_average ( scores [ name ] ) <EOL> for sc in scorers : <EOL> results [ sc . __name__ ] = sc . aggregate ( scores [ sc . __name__ ] ) <EOL> return results <EOL> class Accuracy ( Scorer ) : <EOL> def __call__ ( self , true_labels , predicted , mask = None ) : <EOL> if predicted . shape [ <NUM_LIT:1> ] > <NUM_LIT:1> : <EOL> predicted = predicted . argmax ( <NUM_LIT:1> ) . reshape ( - <NUM_LIT:1> , <NUM_LIT:1> ) <EOL> correct = ( predicted == true_labels ) . astype ( np . float ) <EOL> if mask is not None : <EOL> correct *= mask <EOL> return np . sum ( correct ) <EOL> class Hamming ( Scorer ) : <EOL> def __init__ ( self , threshold = <NUM_LIT:0.5> , out_name = '<STR_LIT>' , targets_name = '<STR_LIT>' , <EOL> mask_name = '<STR_LIT>' , name = None ) : <EOL> super ( Hamming , self ) . __init__ ( out_name , targets_name , mask_name , name ) <EOL> self . threshold = threshold <EOL> def __call__ ( self , true_labels , predicted , mask = None ) : <EOL> correct = np . logical_xor ( predicted < self . threshold , <EOL> true_labels ) . astype ( np . float ) <EOL> if mask is not None : <EOL> correct *= mask <EOL> return np . sum ( correct ) / true_labels . shape [ <NUM_LIT:1> ] <EOL> class MeanSquaredError ( Scorer ) : <EOL> def __call__ ( self , true_labels , predicted , mask = None ) : <EOL> errors = ( true_labels - predicted ) ** <NUM_LIT:2> <EOL> if mask is not None : <EOL> errors *= mask <EOL> return <NUM_LIT:0.5> * np . sum ( errors ) <EOL> def _flatten_all_but_last ( a ) : <EOL> if a is None : <EOL> return None <EOL> return a . reshape ( - <NUM_LIT:1> , a . shape [ - <NUM_LIT:1> ] ) <EOL> def _weighted_average ( errors ) : <EOL> errors = np . array ( errors ) <EOL> assert errors . ndim == <NUM_LIT:2> and errors . shape [ <NUM_LIT:1> ] == <NUM_LIT:2> <EOL> return np . sum ( errors [ : , <NUM_LIT:1> ] * errors [ : , <NUM_LIT:0> ] / np . sum ( errors [ : , <NUM_LIT:0> ] ) ) </s>
<s> from __future__ import division , print_function , unicode_literals <EOL> import pytest <EOL> import six <EOL> from brainstorm . training . schedules import Exponential , Linear , MultiStep <EOL> def test_linear ( ) : <EOL> sch = Linear ( initial_value = <NUM_LIT:1.0> , final_value = <NUM_LIT:0.5> , num_changes = <NUM_LIT:5> ) <EOL> epochs = [ <NUM_LIT:0> ] * <NUM_LIT:2> + [ <NUM_LIT:1> ] * <NUM_LIT:2> + [ <NUM_LIT:2> ] * <NUM_LIT:2> + [ <NUM_LIT:3> ] * <NUM_LIT:2> + [ <NUM_LIT:4> ] * <NUM_LIT:2> <EOL> updates = range ( <NUM_LIT:10> ) <EOL> values = [ sch ( epoch , update , '<STR_LIT>' , <NUM_LIT:1> , None , None , None ) <EOL> for epoch , update in six . moves . zip ( epochs , updates ) ] <EOL> assert values == [ <NUM_LIT:1.0> , <NUM_LIT:1.0> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ] <EOL> values = [ sch ( epoch , update , '<STR_LIT>' , <NUM_LIT:1> , None , None , None ) <EOL> for epoch , update in six . moves . zip ( epochs , updates ) ] <EOL> assert values == [ <NUM_LIT:1.0> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT:0.5> , <NUM_LIT:0.5> , <NUM_LIT:0.5> , <NUM_LIT:0.5> , <NUM_LIT:0.5> ] <EOL> values = [ sch ( epoch , update , '<STR_LIT>' , <NUM_LIT:3> , None , None , None ) <EOL> for epoch , update in six . moves . zip ( epochs , updates ) ] <EOL> assert values == [ <NUM_LIT:1.0> , <NUM_LIT:1.0> , <NUM_LIT:1.0> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ] <EOL> def test_exponential ( ) : <EOL> sch = Exponential ( initial_value = <NUM_LIT:1.0> , factor = <NUM_LIT> , minimum = <NUM_LIT> ) <EOL> epochs = [ <NUM_LIT:0> ] * <NUM_LIT:4> + [ <NUM_LIT:1> ] * <NUM_LIT:4> + [ <NUM_LIT:2> ] * <NUM_LIT:4> <EOL> updates = range ( <NUM_LIT:12> ) <EOL> values = [ sch ( epoch , update , '<STR_LIT>' , <NUM_LIT:1> , None , None , None ) <EOL> for epoch , update in six . moves . zip ( epochs , updates ) ] <EOL> assert values == [ <NUM_LIT:1.0> ] * <NUM_LIT:4> + [ <NUM_LIT> ] * <NUM_LIT:4> + [ <NUM_LIT> * <NUM_LIT> ] * <NUM_LIT:4> <EOL> values = [ sch ( epoch , update , '<STR_LIT>' , <NUM_LIT:1> , None , None , None ) <EOL> for epoch , update in six . moves . zip ( epochs , updates ) ] <EOL> assert values == [ <NUM_LIT:1.0> * ( <NUM_LIT> ** x ) for x in range ( <NUM_LIT:4> ) ] + [ <NUM_LIT> ] * <NUM_LIT:8> <EOL> values = [ sch ( epoch , update , '<STR_LIT>' , <NUM_LIT:3> , None , None , None ) <EOL> for epoch , update in six . moves . zip ( epochs , updates ) ] <EOL> assert values == [ <NUM_LIT:1.0> ] * <NUM_LIT:3> + [ <NUM_LIT> ] * <NUM_LIT:3> + [ <NUM_LIT> ] * <NUM_LIT:3> + [ <NUM_LIT> ** <NUM_LIT:3> ] * <NUM_LIT:3> <EOL> def test_multistep ( ) : <EOL> sch = MultiStep ( initial_value = <NUM_LIT:1.0> , steps = [ <NUM_LIT:3> , <NUM_LIT:5> , <NUM_LIT:8> ] , <EOL> values = [ <NUM_LIT:0.1> , <NUM_LIT> , <NUM_LIT> ] ) <EOL> epochs = [ <NUM_LIT:0> ] * <NUM_LIT:2> + [ <NUM_LIT:1> ] * <NUM_LIT:2> + [ <NUM_LIT:2> ] * <NUM_LIT:2> + [ <NUM_LIT:3> ] * <NUM_LIT:2> + [ <NUM_LIT:4> ] * <NUM_LIT:2> <EOL> updates = range ( <NUM_LIT:10> ) <EOL> values = [ sch ( epoch , update , '<STR_LIT>' , <NUM_LIT:1> , None , None , None ) <EOL> for epoch , update in six . moves . zip ( epochs , updates ) ] <EOL> assert values == [ <NUM_LIT:1.0> , <NUM_LIT:1.0> , <NUM_LIT:1.0> , <NUM_LIT:1.0> , <NUM_LIT:1.0> , <NUM_LIT:1.0> , <NUM_LIT:0.1> , <NUM_LIT:0.1> , <NUM_LIT:0.1> , <NUM_LIT:0.1> ] <EOL> values = [ sch ( epoch , update , '<STR_LIT>' , <NUM_LIT:1> , None , None , None ) <EOL> for epoch , update in six . moves . zip ( epochs , updates ) ] <EOL> assert values == [ <NUM_LIT:1.0> , <NUM_LIT:1.0> , <NUM_LIT:1.0> , <NUM_LIT:0.1> , <NUM_LIT:0.1> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ] <EOL> with pytest . raises ( AssertionError ) : <EOL> _ = sch ( <NUM_LIT:0> , <NUM_LIT:0> , '<STR_LIT>' , <NUM_LIT:3> , None , None , None ) </s>
<s> import os <EOL> import sys <EOL> try : <EOL> from unittest . mock import MagicMock <EOL> except ImportError : <EOL> from mock import Mock as MagicMock <EOL> class Mock ( MagicMock ) : <EOL> @ classmethod <EOL> def __getattr__ ( cls , name ) : <EOL> return Mock ( ) <EOL> MOCK_MODULES = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> sys . modules . update ( ( mod_name , Mock ( ) ) for mod_name in MOCK_MODULES ) <EOL> cwd = os . getcwd ( ) <EOL> parent = os . path . dirname ( cwd ) <EOL> sys . path . insert ( <NUM_LIT:0> , parent ) <EOL> import brainstorm <EOL> extensions = [ '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' ] <EOL> templates_path = [ '<STR_LIT>' ] <EOL> source_suffix = '<STR_LIT>' <EOL> master_doc = '<STR_LIT:index>' <EOL> project = u'<STR_LIT>' <EOL> copyright = u'<STR_LIT>' <EOL> version = brainstorm . __version__ <EOL> release = brainstorm . __version__ <EOL> exclude_patterns = [ '<STR_LIT>' ] <EOL> pygments_style = '<STR_LIT>' <EOL> on_rtd = os . environ . get ( '<STR_LIT>' , None ) == '<STR_LIT:True>' <EOL> if not on_rtd : <EOL> try : <EOL> import sphinx_rtd_theme <EOL> html_theme = '<STR_LIT>' <EOL> html_theme_path = [ sphinx_rtd_theme . get_html_theme_path ( ) ] <EOL> except ImportError : <EOL> html_theme = '<STR_LIT>' <EOL> html_static_path = [ '<STR_LIT>' ] <EOL> htmlhelp_basename = '<STR_LIT>' <EOL> latex_elements = { <EOL> } <EOL> latex_documents = [ <EOL> ( '<STR_LIT:index>' , '<STR_LIT>' , u'<STR_LIT>' , <EOL> u'<STR_LIT>' , '<STR_LIT>' ) , <EOL> ] <EOL> man_pages = [ <EOL> ( '<STR_LIT:index>' , '<STR_LIT>' , u'<STR_LIT>' , <EOL> [ u'<STR_LIT>' ] , <NUM_LIT:1> ) <EOL> ] <EOL> texinfo_documents = [ <EOL> ( '<STR_LIT:index>' , '<STR_LIT>' , u'<STR_LIT>' , <EOL> u'<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' ) , <EOL> ] </s>
<s> from __future__ import division , print_function , unicode_literals <EOL> from sacred . utils import iter_prefixes , join_paths <EOL> class ConfigSummary ( dict ) : <EOL> def __init__ ( self , added = ( ) , modified = ( ) , typechanged = ( ) , <EOL> ignored_fallbacks = ( ) ) : <EOL> super ( ConfigSummary , self ) . __init__ ( ) <EOL> self . added = set ( added ) <EOL> self . modified = set ( modified ) <EOL> self . typechanged = dict ( typechanged ) <EOL> self . ignored_fallbacks = set ( ignored_fallbacks ) <EOL> self . ensure_coherence ( ) <EOL> def update_from ( self , config_mod , path = '<STR_LIT>' ) : <EOL> added = config_mod . added <EOL> updated = config_mod . modified <EOL> typechanged = config_mod . typechanged <EOL> self . added &= { join_paths ( path , a ) for a in added } <EOL> self . modified |= { join_paths ( path , u ) for u in updated } <EOL> self . typechanged . update ( { join_paths ( path , k ) : v <EOL> for k , v in typechanged . items ( ) } ) <EOL> self . ensure_coherence ( ) <EOL> def update_add ( self , config_mod , path = '<STR_LIT>' ) : <EOL> added = config_mod . added <EOL> updated = config_mod . modified <EOL> typechanged = config_mod . typechanged <EOL> self . added |= { join_paths ( path , a ) for a in added } <EOL> self . modified |= { join_paths ( path , u ) for u in updated } <EOL> self . typechanged . update ( { join_paths ( path , k ) : v <EOL> for k , v in typechanged . items ( ) } ) <EOL> self . ensure_coherence ( ) <EOL> def ensure_coherence ( self ) : <EOL> self . modified |= { p for a in self . added for p in iter_prefixes ( a ) } <EOL> self . modified |= { p for u in self . modified for p in iter_prefixes ( u ) } <EOL> self . modified |= { p for t in self . typechanged <EOL> for p in iter_prefixes ( t ) } <EOL> self . added -= set ( self . typechanged . keys ( ) ) <EOL> self . modified -= set ( self . typechanged . keys ( ) ) <EOL> self . modified -= self . added </s>
<s> from __future__ import division , print_function , unicode_literals <EOL> import pytest <EOL> import sacred . optional as opt <EOL> from sacred . config import ConfigDict <EOL> from sacred . config . custom_containers import DogmaticDict , DogmaticList <EOL> @ pytest . fixture <EOL> def conf_dict ( ) : <EOL> cfg = ConfigDict ( { <EOL> "<STR_LIT:a>" : <NUM_LIT:1> , <EOL> "<STR_LIT:b>" : <NUM_LIT> , <EOL> "<STR_LIT:c>" : True , <EOL> "<STR_LIT:d>" : '<STR_LIT:string>' , <EOL> "<STR_LIT:e>" : [ <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> ] , <EOL> "<STR_LIT:f>" : { '<STR_LIT:a>' : '<STR_LIT:b>' , '<STR_LIT:c>' : '<STR_LIT:d>' } , <EOL> } ) <EOL> return cfg <EOL> def test_config_dict_returns_dict ( conf_dict ) : <EOL> assert isinstance ( conf_dict ( ) , dict ) <EOL> def test_config_dict_result_contains_keys ( conf_dict ) : <EOL> cfg = conf_dict ( ) <EOL> assert set ( cfg . keys ( ) ) == { '<STR_LIT:a>' , '<STR_LIT:b>' , '<STR_LIT:c>' , '<STR_LIT:d>' , '<STR_LIT:e>' , '<STR_LIT:f>' } <EOL> assert cfg [ '<STR_LIT:a>' ] == <NUM_LIT:1> <EOL> assert cfg [ '<STR_LIT:b>' ] == <NUM_LIT> <EOL> assert cfg [ '<STR_LIT:c>' ] <EOL> assert cfg [ '<STR_LIT:d>' ] == '<STR_LIT:string>' <EOL> assert cfg [ '<STR_LIT:e>' ] == [ <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> ] <EOL> assert cfg [ '<STR_LIT:f>' ] == { '<STR_LIT:a>' : '<STR_LIT:b>' , '<STR_LIT:c>' : '<STR_LIT:d>' } <EOL> def test_fixing_values ( conf_dict ) : <EOL> assert conf_dict ( { '<STR_LIT:a>' : <NUM_LIT:100> } ) [ '<STR_LIT:a>' ] == <NUM_LIT:100> <EOL> @ pytest . mark . parametrize ( "<STR_LIT:key>" , [ "<STR_LIT>" , "<STR_LIT>" , <NUM_LIT:12> , "<STR_LIT>" , "<STR_LIT>" ] ) <EOL> def test_config_dict_raises_on_invalid_keys ( key ) : <EOL> with pytest . raises ( KeyError ) : <EOL> ConfigDict ( { key : True } ) <EOL> @ pytest . mark . parametrize ( "<STR_LIT:value>" , [ lambda x : x , pytest , test_fixing_values ] ) <EOL> def test_config_dict_raises_on_invalid_values ( value ) : <EOL> with pytest . raises ( ValueError ) : <EOL> ConfigDict ( { "<STR_LIT>" : value } ) <EOL> def test_fixing_nested_dicts ( conf_dict ) : <EOL> cfg = conf_dict ( { '<STR_LIT:f>' : { '<STR_LIT:c>' : '<STR_LIT:t>' } } ) <EOL> assert cfg [ '<STR_LIT:f>' ] [ '<STR_LIT:a>' ] == '<STR_LIT:b>' <EOL> assert cfg [ '<STR_LIT:f>' ] [ '<STR_LIT:c>' ] == '<STR_LIT:t>' <EOL> def test_adding_values ( conf_dict ) : <EOL> cfg = conf_dict ( { '<STR_LIT:g>' : <NUM_LIT> , '<STR_LIT:h>' : { '<STR_LIT:i>' : <NUM_LIT:10> } } ) <EOL> assert cfg [ '<STR_LIT:g>' ] == <NUM_LIT> <EOL> assert cfg [ '<STR_LIT:h>' ] == { '<STR_LIT:i>' : <NUM_LIT:10> } <EOL> assert cfg . added == { '<STR_LIT:g>' , '<STR_LIT:h>' , '<STR_LIT>' } <EOL> def test_typechange ( conf_dict ) : <EOL> cfg = conf_dict ( { '<STR_LIT:a>' : '<STR_LIT:bar>' , '<STR_LIT:b>' : '<STR_LIT:foo>' , '<STR_LIT:c>' : <NUM_LIT:1> } ) <EOL> assert cfg . typechanged == { '<STR_LIT:a>' : ( int , type ( '<STR_LIT:bar>' ) ) , <EOL> '<STR_LIT:b>' : ( float , type ( '<STR_LIT:foo>' ) ) , <EOL> '<STR_LIT:c>' : ( bool , int ) } <EOL> def test_nested_typechange ( conf_dict ) : <EOL> cfg = conf_dict ( { '<STR_LIT:f>' : { '<STR_LIT:a>' : <NUM_LIT:10> } } ) <EOL> assert cfg . typechanged == { '<STR_LIT>' : ( type ( '<STR_LIT:a>' ) , int ) } <EOL> def is_dogmatic ( a ) : <EOL> if isinstance ( a , ( DogmaticDict , DogmaticList ) ) : <EOL> return True <EOL> elif isinstance ( a , dict ) : <EOL> return any ( is_dogmatic ( v ) for v in a . values ( ) ) <EOL> elif isinstance ( a , ( list , tuple ) ) : <EOL> return any ( is_dogmatic ( v ) for v in a ) <EOL> def test_result_of_conf_dict_is_not_dogmatic ( conf_dict ) : <EOL> cfg = conf_dict ( { '<STR_LIT:e>' : [ <NUM_LIT:1> , <NUM_LIT:1> , <NUM_LIT:1> ] } ) <EOL> assert not is_dogmatic ( cfg ) <EOL> @ pytest . mark . skipif ( not opt . has_numpy , reason = "<STR_LIT>" ) <EOL> def test_conf_scope_handles_numpy_bools ( ) : <EOL> cfg = ConfigDict ( { <EOL> "<STR_LIT:a>" : opt . np . bool_ ( <NUM_LIT:1> ) <EOL> } ) <EOL> assert '<STR_LIT:a>' in cfg ( ) <EOL> assert cfg ( ) [ '<STR_LIT:a>' ] <EOL> def test_conf_scope_contains_presets ( ) : <EOL> conf_dict = ConfigDict ( { <EOL> "<STR_LIT>" : <NUM_LIT> <EOL> } ) <EOL> cfg = conf_dict ( preset = { '<STR_LIT:a>' : <NUM_LIT> , '<STR_LIT>' : True } ) <EOL> assert set ( cfg . keys ( ) ) == { '<STR_LIT:a>' , '<STR_LIT>' , '<STR_LIT>' } <EOL> assert cfg [ '<STR_LIT:a>' ] == <NUM_LIT> <EOL> assert cfg [ '<STR_LIT>' ] == <NUM_LIT> <EOL> assert cfg [ '<STR_LIT>' ] is True <EOL> def test_conf_scope_does_not_contain_fallback ( ) : <EOL> config_dict = ConfigDict ( { <EOL> "<STR_LIT>" : <NUM_LIT> <EOL> } ) <EOL> cfg = config_dict ( fallback = { '<STR_LIT:a>' : <NUM_LIT> , '<STR_LIT:b>' : <NUM_LIT:10> } ) <EOL> assert set ( cfg . keys ( ) ) == { '<STR_LIT>' } <EOL> def test_fixed_subentry_of_preset ( ) : <EOL> config_dict = ConfigDict ( { } ) <EOL> cfg = config_dict ( preset = { '<STR_LIT:d>' : { '<STR_LIT:a>' : <NUM_LIT:1> , '<STR_LIT:b>' : <NUM_LIT:2> } } , fixed = { '<STR_LIT:d>' : { '<STR_LIT:a>' : <NUM_LIT:10> } } ) <EOL> assert set ( cfg . keys ( ) ) == { '<STR_LIT:d>' } <EOL> assert set ( cfg [ '<STR_LIT:d>' ] . keys ( ) ) == { '<STR_LIT:a>' , '<STR_LIT:b>' } <EOL> assert cfg [ '<STR_LIT:d>' ] [ '<STR_LIT:a>' ] == <NUM_LIT:10> <EOL> assert cfg [ '<STR_LIT:d>' ] [ '<STR_LIT:b>' ] == <NUM_LIT:2> </s>
<s> class PID ( object ) : <EOL> def __init__ ( self ) : <EOL> """<STR_LIT>""" <EOL> self . kd = <NUM_LIT:0> <EOL> self . ki = <NUM_LIT:0> <EOL> self . kp = <NUM_LIT:1> <EOL> self . previous_error = <NUM_LIT:0> <EOL> self . integral_error = <NUM_LIT:0> <EOL> def set_k_values ( self , kp , kd , ki ) : <EOL> self . kp = kp <EOL> self . ki = ki <EOL> self . kd = kd <EOL> def clear_error ( self ) : <EOL> self . previous_error = <NUM_LIT:0> <EOL> self . integeral_error = <NUM_LIT:0> <EOL> def pid ( self , target , process_var , timestep ) : <EOL> current_error = ( target - process_var ) <EOL> p_error = self . kp * current_error <EOL> d_error = self . kd * ( current_error - self . previous_error ) / timestep <EOL> self . integral_error = ( <EOL> current_error + self . previous_error ) / <NUM_LIT:2> + self . integral_error <EOL> i_error = self . ki * self . integral_error <EOL> total_error = p_error + d_error + i_error <EOL> self . previous_error = current_error <EOL> return total_error </s>
<s> """<STR_LIT>""" <EOL> import cmd <EOL> import sys <EOL> import os <EOL> import bot . client . ctrl_client as ctrl_client_mod <EOL> import bot . client . sub_client as sub_client_mod <EOL> class CLI ( cmd . Cmd ) : <EOL> """<STR_LIT>""" <EOL> prompt = "<STR_LIT>" <EOL> def __init__ ( self , ctrl_addr , sub_addr ) : <EOL> """<STR_LIT>""" <EOL> cmd . Cmd . __init__ ( self ) <EOL> try : <EOL> self . ctrl_client = ctrl_client_mod . CtrlClient ( ctrl_addr ) <EOL> except Exception , e : <EOL> print "<STR_LIT>" . format ( ctrl_addr , e ) <EOL> sys . exit ( - <NUM_LIT:1> ) <EOL> try : <EOL> self . sub_client = sub_client_mod . SubClient ( sub_addr ) <EOL> except Exception , e : <EOL> print "<STR_LIT>" . format ( sub_addr , e ) <EOL> sys . exit ( - <NUM_LIT:1> ) <EOL> def default ( self , raw_args ) : <EOL> """<STR_LIT>""" <EOL> obj_name , _ , rest = raw_args . partition ( "<STR_LIT:U+0020>" ) <EOL> if obj_name in self . ctrl_client . objects : <EOL> method_name , _ , params = rest . partition ( "<STR_LIT:U+0020>" ) <EOL> if method_name in self . ctrl_client . objects [ obj_name ] : <EOL> try : <EOL> param_dict = { } <EOL> for param in params . split ( ) : <EOL> key , value = param . split ( "<STR_LIT::>" ) <EOL> try : <EOL> if "<STR_LIT:.>" in value : <EOL> value = float ( value ) <EOL> else : <EOL> value = int ( value ) <EOL> except ValueError : <EOL> if value == "<STR_LIT:True>" : <EOL> value = True <EOL> elif value == "<STR_LIT:False>" : <EOL> value = False <EOL> elif value . startswith ( "<STR_LIT:'>" ) and value . endswith ( "<STR_LIT:'>" ) : <EOL> value = value [ <NUM_LIT:1> : - <NUM_LIT:1> ] <EOL> param_dict [ key ] = value <EOL> except IndexError : <EOL> print "<STR_LIT>" <EOL> return <EOL> except ValueError : <EOL> print "<STR_LIT>" <EOL> return <EOL> result = self . ctrl_client . call ( <EOL> obj_name , method_name , param_dict ) <EOL> print "<STR_LIT>" , result <EOL> else : <EOL> print "<STR_LIT>" , method_name <EOL> else : <EOL> print "<STR_LIT>" , obj_name <EOL> def completenames ( self , text , * ignored ) : <EOL> """<STR_LIT>""" <EOL> cmd_match_names = cmd . Cmd . completenames ( self , text , * ignored ) <EOL> obj_names = self . ctrl_client . objects . keys ( ) <EOL> api_match_names = [ x for x in obj_names if x . startswith ( text ) ] <EOL> return cmd_match_names + api_match_names <EOL> def completedefault ( self , text , line , begidx , endidx ) : <EOL> """<STR_LIT>""" <EOL> obj , _ , rest = line . partition ( "<STR_LIT:U+0020>" ) <EOL> if obj in self . ctrl_client . objects : <EOL> method , _ , params = rest . strip ( ) . partition ( "<STR_LIT:U+0020>" ) <EOL> if method == text : <EOL> method_names = self . ctrl_client . objects [ obj ] <EOL> match_names = [ x for x in method_names if x . startswith ( text ) ] <EOL> return match_names <EOL> def do_list ( self , raw_args ) : <EOL> """<STR_LIT>""" <EOL> print <EOL> print "<STR_LIT>" <EOL> print <EOL> for obj_name , methods in sorted ( self . ctrl_client . objects . items ( ) ) : <EOL> print "<STR_LIT>" . format ( obj_name ) <EOL> for method in methods : <EOL> print "<STR_LIT>" . format ( method ) <EOL> print <EOL> def help_list ( self ) : <EOL> """<STR_LIT>""" <EOL> print "<STR_LIT:list>" <EOL> print "<STR_LIT>" <EOL> def do_ping ( self , raw_args ) : <EOL> """<STR_LIT>""" <EOL> reply_time = self . ctrl_client . ping ( ) <EOL> print "<STR_LIT>" . format ( reply_time ) <EOL> def help_ping ( self ) : <EOL> """<STR_LIT>""" <EOL> print "<STR_LIT>" <EOL> print "<STR_LIT>" <EOL> def do_sub_add ( self , raw_args ) : <EOL> """<STR_LIT>""" <EOL> try : <EOL> topic = raw_args . split ( ) [ <NUM_LIT:0> ] <EOL> except ( ValueError , IndexError ) : <EOL> print "<STR_LIT>" <EOL> return <EOL> self . sub_client . add_topic ( topic ) <EOL> def help_sub_add ( self ) : <EOL> """<STR_LIT>""" <EOL> print "<STR_LIT>" <EOL> print "<STR_LIT>" <EOL> def do_sub_del ( self , raw_args ) : <EOL> """<STR_LIT>""" <EOL> try : <EOL> topic = raw_args . split ( ) [ <NUM_LIT:0> ] <EOL> except ( ValueError , IndexError ) : <EOL> print "<STR_LIT>" <EOL> return <EOL> self . sub_client . del_topic ( topic ) <EOL> def help_sub_del ( self ) : <EOL> """<STR_LIT>""" <EOL> print "<STR_LIT>" <EOL> print "<STR_LIT>" <EOL> def do_sub ( self , raw_args ) : <EOL> """<STR_LIT>""" <EOL> self . sub_client . print_msgs ( ) <EOL> def help_sub ( self ) : <EOL> """<STR_LIT>""" <EOL> print "<STR_LIT>" <EOL> print "<STR_LIT>" <EOL> def do_stop ( self , raw_args ) : <EOL> """<STR_LIT>""" <EOL> self . ctrl_client . stop_full ( ) <EOL> def help_stop ( self ) : <EOL> """<STR_LIT>""" <EOL> print "<STR_LIT>" <EOL> print "<STR_LIT>" <EOL> def do_kill ( self , raw_args ) : <EOL> """<STR_LIT>""" <EOL> self . ctrl_client . exit_server ( ) <EOL> def help_kill ( self ) : <EOL> """<STR_LIT>""" <EOL> print "<STR_LIT>" <EOL> print "<STR_LIT>" <EOL> def do_die ( self , raw_args ) : <EOL> """<STR_LIT>""" <EOL> print "<STR_LIT>" <EOL> self . ctrl_client . clean_up ( ) <EOL> self . sub_client . clean_up ( ) <EOL> print "<STR_LIT>" <EOL> return True <EOL> def help_die ( self ) : <EOL> """<STR_LIT>""" <EOL> print "<STR_LIT>" <EOL> print "<STR_LIT>" <EOL> def do_shell ( self , cmd ) : <EOL> """<STR_LIT>""" <EOL> os . system ( cmd ) <EOL> def help_shell ( self ) : <EOL> """<STR_LIT>""" <EOL> print "<STR_LIT>" <EOL> print "<STR_LIT>" <EOL> def do_EOF ( self , raw_args ) : <EOL> """<STR_LIT>""" <EOL> print "<STR_LIT>" <EOL> self . ctrl_client . clean_up ( ) <EOL> self . sub_client . clean_up ( ) <EOL> print "<STR_LIT>" <EOL> return True <EOL> def help_EOF ( self ) : <EOL> """<STR_LIT>""" <EOL> print "<STR_LIT>" <EOL> print "<STR_LIT>" <EOL> def help_help ( self ) : <EOL> """<STR_LIT>""" <EOL> print "<STR_LIT>" <EOL> print "<STR_LIT>" <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL> if len ( sys . argv ) == <NUM_LIT:1> : <EOL> print "<STR_LIT>" <EOL> CLI ( "<STR_LIT>" , "<STR_LIT>" ) . cmdloop ( ) <EOL> elif len ( sys . argv ) == <NUM_LIT:3> : <EOL> ctrl_addr = sys . argv [ <NUM_LIT:1> ] <EOL> sub_addr = sys . argv [ <NUM_LIT:2> ] <EOL> CLI ( ctrl_addr , sub_addr ) . cmdloop ( ) <EOL> else : <EOL> print "<STR_LIT>" </s>
<s> """<STR_LIT>""" <EOL> from random import randint <EOL> from os import path <EOL> import bot . lib . lib as lib <EOL> import bot . hardware . servo as s_mod <EOL> import tests . test_bot as test_bot <EOL> class TestPosition ( test_bot . TestBot ) : <EOL> """<STR_LIT>""" <EOL> def setUp ( self ) : <EOL> """<STR_LIT>""" <EOL> super ( TestPosition , self ) . setUp ( ) <EOL> config = path . dirname ( path . realpath ( __file__ ) ) + "<STR_LIT>" <EOL> self . config = lib . get_config ( config ) <EOL> self . pwm_num = self . config [ '<STR_LIT>' ] <EOL> self . setup_pwm ( self . pwm_num , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ) <EOL> self . servo = s_mod . Servo ( self . pwm_num ) <EOL> def tearDown ( self ) : <EOL> """<STR_LIT>""" <EOL> super ( TestPosition , self ) . tearDown ( ) <EOL> def test_0 ( self ) : <EOL> """<STR_LIT>""" <EOL> self . servo . position = <NUM_LIT:0> <EOL> assert self . servo . position == <NUM_LIT:0> , self . servo . position <EOL> def test_180 ( self ) : <EOL> """<STR_LIT>""" <EOL> self . servo . position = <NUM_LIT> <EOL> assert self . servo . position == <NUM_LIT> , self . servo . position <EOL> def test_middle ( self ) : <EOL> """<STR_LIT>""" <EOL> self . servo . position = <NUM_LIT> <EOL> assert self . servo . position == <NUM_LIT> , self . servo . position <EOL> def test_series ( self ) : <EOL> """<STR_LIT>""" <EOL> for position in range ( <NUM_LIT:0> , <NUM_LIT> , <NUM_LIT> ) : <EOL> self . servo . position = position <EOL> assert self . servo . position == position , self . servo . position <EOL> def test_manually_confirm ( self ) : <EOL> """<STR_LIT>""" <EOL> for i in range ( <NUM_LIT:10> ) : <EOL> test_pos = randint ( <NUM_LIT:0> , <NUM_LIT> ) <EOL> self . servo . position = test_pos <EOL> cur_pwm = self . get_pwm ( self . pwm_num ) <EOL> duty = int ( cur_pwm [ "<STR_LIT>" ] ) <EOL> read_pos = int ( round ( ( ( duty - <NUM_LIT> ) / <NUM_LIT> ) * <NUM_LIT> ) ) <EOL> assert read_pos == test_pos , "<STR_LIT>" . format ( read_pos , test_pos ) <EOL> def test_over_max ( self ) : <EOL> """<STR_LIT>""" <EOL> self . servo . position = <NUM_LIT> <EOL> assert self . servo . position == <NUM_LIT> , "<STR_LIT>" . format ( self . servo . position ) <EOL> def test_under_min ( self ) : <EOL> """<STR_LIT>""" <EOL> self . servo . position = - <NUM_LIT:1> <EOL> assert self . servo . position == <NUM_LIT:0> , "<STR_LIT>" . format ( self . servo . position ) </s>
<s> from django . contrib . syndication . views import Feed as SyndicationFeed <EOL> from django . core . urlresolvers import reverse <EOL> from django . conf import settings <EOL> from lifestream . models import Lifestream , Item <EOL> class RecentItemsFeed ( SyndicationFeed ) : <EOL> title = "<STR_LIT>" <EOL> description = "<STR_LIT>" <EOL> def link ( self , obj ) : <EOL> return reverse ( '<STR_LIT>' , kwargs = { <EOL> '<STR_LIT>' : obj . slug , <EOL> } ) <EOL> def get_object ( self , bits ) : <EOL> return Lifestream . objects . get ( slug = bits [ <NUM_LIT:0> ] ) <EOL> def items ( self , obj ) : <EOL> return Item . objects . published ( ) . filter ( feed__lifestream = obj ) [ : <NUM_LIT:10> ] <EOL> def item_pubdate ( self , item ) : <EOL> return item . date <EOL> def item_categories ( self , item ) : <EOL> def item_categories ( self , item ) : <EOL> if '<STR_LIT>' in settings . INSTALLED_APPS : <EOL> return [ tag . name for tag in item . tag_set ] <EOL> else : <EOL> return [ ] </s>
<s> """<STR_LIT>""" <EOL> from functools import update_wrapper <EOL> from google . appengine . api import users <EOL> from werkzeug import redirect <EOL> from werkzeug . exceptions import Forbidden <EOL> from kay . utils import ( <EOL> create_login_url , create_logout_url <EOL> ) <EOL> from kay . utils . decorators import auto_adapt_to_methods <EOL> def login_required ( func ) : <EOL> def inner ( request , * args , ** kwargs ) : <EOL> if request . user . is_anonymous ( ) : <EOL> if request . is_xhr : <EOL> return Forbidden ( ) <EOL> else : <EOL> return redirect ( create_login_url ( request . url ) ) <EOL> return func ( request , * args , ** kwargs ) <EOL> update_wrapper ( inner , func ) <EOL> return inner <EOL> login_required = auto_adapt_to_methods ( login_required ) <EOL> def admin_required ( func ) : <EOL> def inner ( request , * args , ** kwargs ) : <EOL> if not request . user . is_admin : <EOL> if request . user . is_anonymous ( ) : <EOL> return redirect ( create_login_url ( request . url ) ) <EOL> else : <EOL> raise Forbidden ( <EOL> description = <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' % <EOL> create_logout_url ( request . url ) <EOL> ) <EOL> return func ( request , * args , ** kwargs ) <EOL> update_wrapper ( inner , func ) <EOL> return inner <EOL> admin_required = auto_adapt_to_methods ( admin_required ) </s>
<s> """<STR_LIT>""" <EOL> PARSE_ERROR = - <NUM_LIT> <EOL> INVALID_REQUEST = - <NUM_LIT> <EOL> METHOD_NOT_FOUND = - <NUM_LIT> <EOL> INVALID_PARAMS = - <NUM_LIT> <EOL> INTERNAL_ERROR = - <NUM_LIT> <EOL> errors = { } <EOL> errors [ PARSE_ERROR ] = "<STR_LIT>" <EOL> errors [ INVALID_REQUEST ] = "<STR_LIT>" <EOL> errors [ METHOD_NOT_FOUND ] = "<STR_LIT>" <EOL> errors [ INVALID_PARAMS ] = "<STR_LIT>" <EOL> errors [ INTERNAL_ERROR ] = "<STR_LIT>" <EOL> try : <EOL> import json <EOL> except ImportError : <EOL> try : <EOL> import django . utils . simplejson as json <EOL> except ImportError : <EOL> import simplejson as json <EOL> import sys <EOL> import logging <EOL> import itertools <EOL> from werkzeug import Request , Response <EOL> from werkzeug import exceptions <EOL> class JsonRpcApplication ( object ) : <EOL> def __init__ ( self , methods = None ) : <EOL> if methods is not None : <EOL> self . methods = methods <EOL> else : <EOL> self . methods = { } <EOL> def add_module ( self , mod , namespace = None ) : <EOL> if namespace is None : <EOL> namespace = mod . __name__ <EOL> for k , v in ( ( k , v ) for k , v in mod . __dict__ . iteritems ( ) <EOL> if not k . startswith ( '<STR_LIT:_>' ) and callable ( v ) ) : <EOL> self . add ( namespace + '<STR_LIT:.>' + k , v ) <EOL> def add ( self , name , func ) : <EOL> self . methods [ name ] = func <EOL> def process ( self , data ) : <EOL> if data . get ( '<STR_LIT>' ) != "<STR_LIT>" : <EOL> return { '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:id>' : data . get ( '<STR_LIT:id>' ) , <EOL> '<STR_LIT:error>' : { '<STR_LIT:code>' : INVALID_REQUEST , <EOL> '<STR_LIT:message>' : errors [ INVALID_REQUEST ] } } <EOL> if '<STR_LIT>' not in data : <EOL> return { '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:id>' : data . get ( '<STR_LIT:id>' ) , <EOL> '<STR_LIT:error>' : { '<STR_LIT:code>' : INVALID_REQUEST , <EOL> '<STR_LIT:message>' : errors [ INVALID_REQUEST ] } } <EOL> methodname = data [ '<STR_LIT>' ] <EOL> if not isinstance ( methodname , basestring ) : <EOL> return { '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:id>' : data . get ( '<STR_LIT:id>' ) , <EOL> '<STR_LIT:error>' : { '<STR_LIT:code>' : INVALID_REQUEST , <EOL> '<STR_LIT:message>' : errors [ INVALID_REQUEST ] } } <EOL> if methodname . startswith ( '<STR_LIT:_>' ) : <EOL> return { '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:id>' : data . get ( '<STR_LIT:id>' ) , <EOL> '<STR_LIT:error>' : { '<STR_LIT:code>' : METHOD_NOT_FOUND , <EOL> '<STR_LIT:message>' : errors [ METHOD_NOT_FOUND ] } } <EOL> if methodname not in self . methods : <EOL> return { '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:id>' : data . get ( '<STR_LIT:id>' ) , <EOL> '<STR_LIT:error>' : { '<STR_LIT:code>' : METHOD_NOT_FOUND , <EOL> '<STR_LIT:message>' : errors [ METHOD_NOT_FOUND ] } } <EOL> method = self . methods [ methodname ] <EOL> try : <EOL> params = data . get ( '<STR_LIT>' , [ ] ) <EOL> if isinstance ( params , list ) : <EOL> result = method ( * params ) <EOL> elif isinstance ( params , dict ) : <EOL> result = method ( ** dict ( [ ( str ( k ) , v ) for k , v in params . iteritems ( ) ] ) ) <EOL> else : <EOL> return { '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:id>' : data . get ( '<STR_LIT:id>' ) , <EOL> '<STR_LIT:error>' : { '<STR_LIT:code>' : INVALID_REQUEST , <EOL> '<STR_LIT:message>' : errors [ INVALID_REQUEST ] } } <EOL> resdata = None <EOL> if data . get ( '<STR_LIT:id>' ) : <EOL> resdata = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:id>' : data . get ( '<STR_LIT:id>' ) , <EOL> '<STR_LIT:result>' : result , <EOL> } <EOL> return resdata <EOL> except Exception , e : <EOL> return { '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:id>' : data . get ( '<STR_LIT:id>' ) , <EOL> '<STR_LIT:error>' : { '<STR_LIT:code>' : INTERNAL_ERROR , <EOL> '<STR_LIT:message>' : errors [ INTERNAL_ERROR ] , <EOL> '<STR_LIT:data>' : str ( e ) } } <EOL> def __call__ ( self , environ , start_response ) : <EOL> request = Request ( environ ) <EOL> if request . method != "<STR_LIT:POST>" : <EOL> raise exceptions . MethodNotAllowed <EOL> if not request . content_type . startswith ( '<STR_LIT:application/json>' ) : <EOL> raise exceptions . BadRequest <EOL> try : <EOL> data = json . loads ( request . data ) <EOL> except ValueError , e : <EOL> resdata = { '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:id>' : None , <EOL> '<STR_LIT:error>' : { '<STR_LIT:code>' : PARSE_ERROR , <EOL> '<STR_LIT:message>' : errors [ PARSE_ERROR ] } } <EOL> else : <EOL> if isinstance ( data , dict ) : <EOL> resdata = self . process ( data ) <EOL> elif isinstance ( data , list ) : <EOL> if len ( [ x for x in data if not isinstance ( x , dict ) ] ) : <EOL> resdata = { '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:id>' : None , <EOL> '<STR_LIT:error>' : { '<STR_LIT:code>' : INVALID_REQUEST , <EOL> '<STR_LIT:message>' : errors [ INVALID_REQUEST ] } } <EOL> else : <EOL> resdata = [ d for d in ( self . process ( d ) for d in data ) <EOL> if d is not None ] <EOL> response = Response ( content_type = "<STR_LIT:application/json>" ) <EOL> if resdata : <EOL> response . headers [ "<STR_LIT>" ] = "<STR_LIT>" <EOL> response . headers [ "<STR_LIT>" ] = "<STR_LIT>" <EOL> response . headers [ "<STR_LIT>" ] = "<STR_LIT>" <EOL> response . data = json . dumps ( resdata ) <EOL> return response ( environ , start_response ) <EOL> def getmod ( modname ) : <EOL> try : <EOL> __import__ ( modname ) <EOL> except ImportError , e : <EOL> logging . warn ( "<STR_LIT>" % e ) <EOL> return None <EOL> mod = sys . modules [ modname ] <EOL> return mod <EOL> def HTTPExceptionMiddleware ( app ) : <EOL> def wrap ( environ , start_response ) : <EOL> try : <EOL> return app ( environ , start_response ) <EOL> except exceptions . HTTPException , e : <EOL> return e ( environ , start_response ) <EOL> return wrap <EOL> def make_application ( methods ) : <EOL> app = JsonRpcApplication ( ) <EOL> for name , value in methods . iteritems ( ) : <EOL> if "<STR_LIT::>" in value : <EOL> modname , funcname = value . split ( "<STR_LIT::>" , <NUM_LIT:1> ) <EOL> mod = getmod ( modname ) <EOL> if mod : <EOL> app . add ( name , getattr ( mod , funcname ) ) <EOL> else : <EOL> modname = value <EOL> mod = getmod ( modname ) <EOL> if mod : <EOL> app . add_module ( mod , name ) <EOL> app = HTTPExceptionMiddleware ( app ) <EOL> return app </s>
<s> """<STR_LIT>""" <EOL> import re <EOL> from jinja2 . runtime import Undefined <EOL> __test__ = False <EOL> number_re = re . compile ( r'<STR_LIT>' ) <EOL> regex_type = type ( number_re ) <EOL> try : <EOL> test_callable = callable <EOL> except NameError : <EOL> def test_callable ( x ) : <EOL> return hasattr ( x , '<STR_LIT>' ) <EOL> def test_odd ( value ) : <EOL> """<STR_LIT>""" <EOL> return value % <NUM_LIT:2> == <NUM_LIT:1> <EOL> def test_even ( value ) : <EOL> """<STR_LIT>""" <EOL> return value % <NUM_LIT:2> == <NUM_LIT:0> <EOL> def test_divisibleby ( value , num ) : <EOL> """<STR_LIT>""" <EOL> return value % num == <NUM_LIT:0> <EOL> def test_defined ( value ) : <EOL> """<STR_LIT>""" <EOL> return not isinstance ( value , Undefined ) <EOL> def test_undefined ( value ) : <EOL> """<STR_LIT>""" <EOL> return isinstance ( value , Undefined ) <EOL> def test_none ( value ) : <EOL> """<STR_LIT>""" <EOL> return value is None <EOL> def test_lower ( value ) : <EOL> """<STR_LIT>""" <EOL> return unicode ( value ) . islower ( ) <EOL> def test_upper ( value ) : <EOL> """<STR_LIT>""" <EOL> return unicode ( value ) . isupper ( ) <EOL> def test_string ( value ) : <EOL> """<STR_LIT>""" <EOL> return isinstance ( value , basestring ) <EOL> def test_number ( value ) : <EOL> """<STR_LIT>""" <EOL> return isinstance ( value , ( int , long , float , complex ) ) <EOL> def test_sequence ( value ) : <EOL> """<STR_LIT>""" <EOL> try : <EOL> len ( value ) <EOL> value . __getitem__ <EOL> except : <EOL> return False <EOL> return True <EOL> def test_sameas ( value , other ) : <EOL> """<STR_LIT>""" <EOL> return value is other <EOL> def test_iterable ( value ) : <EOL> """<STR_LIT>""" <EOL> try : <EOL> iter ( value ) <EOL> except TypeError : <EOL> return False <EOL> return True <EOL> def test_escaped ( value ) : <EOL> """<STR_LIT>""" <EOL> return hasattr ( value , '<STR_LIT>' ) <EOL> TESTS = { <EOL> '<STR_LIT>' : test_odd , <EOL> '<STR_LIT>' : test_even , <EOL> '<STR_LIT>' : test_divisibleby , <EOL> '<STR_LIT>' : test_defined , <EOL> '<STR_LIT>' : test_undefined , <EOL> '<STR_LIT:none>' : test_none , <EOL> '<STR_LIT>' : test_lower , <EOL> '<STR_LIT>' : test_upper , <EOL> '<STR_LIT:string>' : test_string , <EOL> '<STR_LIT>' : test_number , <EOL> '<STR_LIT>' : test_sequence , <EOL> '<STR_LIT>' : test_iterable , <EOL> '<STR_LIT>' : test_callable , <EOL> '<STR_LIT>' : test_sameas , <EOL> '<STR_LIT>' : test_escaped <EOL> } </s>
<s> """<STR_LIT>""" <EOL> import re <EOL> import codecs <EOL> import mimetypes <EOL> from werkzeug . _internal import _proxy_repr , _missing , _empty_stream <EOL> _locale_delim_re = re . compile ( r'<STR_LIT>' ) <EOL> def is_immutable ( self ) : <EOL> raise TypeError ( '<STR_LIT>' % self . __class__ . __name__ ) <EOL> def iter_multi_items ( mapping ) : <EOL> """<STR_LIT>""" <EOL> if isinstance ( mapping , MultiDict ) : <EOL> for item in mapping . iteritems ( multi = True ) : <EOL> yield item <EOL> elif isinstance ( mapping , dict ) : <EOL> for key , value in mapping . iteritems ( ) : <EOL> if isinstance ( value , ( tuple , list ) ) : <EOL> for value in value : <EOL> yield key , value <EOL> else : <EOL> yield key , value <EOL> else : <EOL> for item in mapping : <EOL> yield item <EOL> class ImmutableListMixin ( object ) : <EOL> """<STR_LIT>""" <EOL> def __reduce_ex__ ( self , protocol ) : <EOL> return type ( self ) , ( list ( self ) , ) <EOL> def __delitem__ ( self , key ) : <EOL> is_immutable ( self ) <EOL> def __delslice__ ( self , i , j ) : <EOL> is_immutable ( self ) <EOL> def __iadd__ ( self , other ) : <EOL> is_immutable ( self ) <EOL> __imul__ = __iadd__ <EOL> def __setitem__ ( self , key , value ) : <EOL> is_immutable ( self ) <EOL> def __setslice__ ( self , i , j , value ) : <EOL> is_immutable ( self ) <EOL> def append ( self , item ) : <EOL> is_immutable ( self ) <EOL> remove = append <EOL> def extend ( self , iterable ) : <EOL> is_immutable ( self ) <EOL> def insert ( self , pos , value ) : <EOL> is_immutable ( self ) <EOL> def pop ( self , index = - <NUM_LIT:1> ) : <EOL> is_immutable ( self ) <EOL> def reverse ( self ) : <EOL> is_immutable ( self ) <EOL> def sort ( self , cmp = None , key = None , reverse = None ) : <EOL> is_immutable ( self ) <EOL> class ImmutableList ( ImmutableListMixin , list ) : <EOL> """<STR_LIT>""" <EOL> __repr__ = _proxy_repr ( list ) <EOL> class ImmutableDictMixin ( object ) : <EOL> """<STR_LIT>""" <EOL> def __reduce_ex__ ( self , protocol ) : <EOL> return type ( self ) , ( dict ( self ) , ) <EOL> def setdefault ( self , key , default = None ) : <EOL> is_immutable ( self ) <EOL> def update ( self , * args , ** kwargs ) : <EOL> is_immutable ( self ) <EOL> def pop ( self , key , default = None ) : <EOL> is_immutable ( self ) <EOL> def popitem ( self ) : <EOL> is_immutable ( self ) <EOL> def __setitem__ ( self , key , value ) : <EOL> is_immutable ( self ) <EOL> def __delitem__ ( self , key ) : <EOL> is_immutable ( self ) <EOL> def clear ( self ) : <EOL> is_immutable ( self ) <EOL> class ImmutableMultiDictMixin ( ImmutableDictMixin ) : <EOL> """<STR_LIT>""" <EOL> def __reduce_ex__ ( self , protocol ) : <EOL> return type ( self ) , ( self . items ( multi = True ) , ) <EOL> def add ( self , key , value ) : <EOL> is_immutable ( self ) <EOL> def popitemlist ( self ) : <EOL> is_immutable ( self ) <EOL> def poplist ( self , key ) : <EOL> is_immutable ( self ) <EOL> def setlist ( self , key , new_list ) : <EOL> is_immutable ( self ) <EOL> def setlistdefault ( self , key , default_list = None ) : <EOL> is_immutable ( self ) <EOL> class UpdateDictMixin ( object ) : <EOL> """<STR_LIT>""" <EOL> on_update = None <EOL> def calls_update ( name ) : <EOL> def oncall ( self , * args , ** kw ) : <EOL> rv = getattr ( super ( UpdateDictMixin , self ) , name ) ( * args , ** kw ) <EOL> if self . on_update is not None : <EOL> self . on_update ( self ) <EOL> return rv <EOL> oncall . __name__ = name <EOL> return oncall <EOL> __setitem__ = calls_update ( '<STR_LIT>' ) <EOL> __delitem__ = calls_update ( '<STR_LIT>' ) <EOL> clear = calls_update ( '<STR_LIT>' ) <EOL> pop = calls_update ( '<STR_LIT>' ) <EOL> popitem = calls_update ( '<STR_LIT>' ) <EOL> setdefault = calls_update ( '<STR_LIT>' ) <EOL> update = calls_update ( '<STR_LIT>' ) <EOL> del calls_update <EOL> class TypeConversionDict ( dict ) : <EOL> """<STR_LIT>""" <EOL> def get ( self , key , default = None , type = None ) : <EOL> """<STR_LIT>""" <EOL> try : <EOL> rv = self [ key ] <EOL> if type is not None : <EOL> rv = type ( rv ) <EOL> except ( KeyError , ValueError ) : <EOL> rv = default <EOL> return rv <EOL> class ImmutableTypeConversionDict ( ImmutableDictMixin , TypeConversionDict ) : <EOL> """<STR_LIT>""" <EOL> def copy ( self ) : <EOL> """<STR_LIT>""" <EOL> return TypeConversionDict ( self ) <EOL> def __copy__ ( self ) : <EOL> return self <EOL> class MultiDict ( TypeConversionDict ) : <EOL> """<STR_LIT>""" <EOL> KeyError = None <EOL> def __init__ ( self , mapping = None ) : <EOL> if isinstance ( mapping , MultiDict ) : <EOL> dict . __init__ ( self , ( ( k , l [ : ] ) for k , l in mapping . iterlists ( ) ) ) <EOL> elif isinstance ( mapping , dict ) : <EOL> tmp = { } <EOL> for key , value in mapping . iteritems ( ) : <EOL> if isinstance ( value , ( tuple , list ) ) : <EOL> value = list ( value ) <EOL> else : <EOL> value = [ value ] <EOL> tmp [ key ] = value <EOL> dict . __init__ ( self , tmp ) <EOL> else : <EOL> tmp = { } <EOL> for key , value in mapping or ( ) : <EOL> tmp . setdefault ( key , [ ] ) . append ( value ) <EOL> dict . __init__ ( self , tmp ) <EOL> def __getstate__ ( self ) : <EOL> return dict ( self . lists ( ) ) <EOL> def __setstate__ ( self , value ) : <EOL> dict . clear ( self ) <EOL> dict . update ( self , value ) <EOL> def __iter__ ( self ) : <EOL> return self . iterkeys ( ) <EOL> def __getitem__ ( self , key ) : <EOL> """<STR_LIT>""" <EOL> if key in self : <EOL> return dict . __getitem__ ( self , key ) [ <NUM_LIT:0> ] <EOL> raise self . KeyError ( key ) <EOL> def __setitem__ ( self , key , value ) : <EOL> """<STR_LIT>""" <EOL> dict . __setitem__ ( self , key , [ value ] ) <EOL> def add ( self , key , value ) : <EOL> """<STR_LIT>""" <EOL> dict . setdefault ( self , key , [ ] ) . append ( value ) <EOL> def getlist ( self , key , type = None ) : <EOL> """<STR_LIT>""" <EOL> try : <EOL> rv = dict . __getitem__ ( self , key ) <EOL> except KeyError : <EOL> return [ ] <EOL> if type is None : <EOL> return list ( rv ) <EOL> result = [ ] <EOL> for item in rv : <EOL> try : <EOL> result . append ( type ( item ) ) <EOL> except ValueError : <EOL> pass <EOL> return result <EOL> def setlist ( self , key , new_list ) : <EOL> """<STR_LIT>""" <EOL> dict . __setitem__ ( self , key , list ( new_list ) ) <EOL> def setdefault ( self , key , default = None ) : <EOL> """<STR_LIT>""" <EOL> if key not in self : <EOL> self [ key ] = default <EOL> else : <EOL> default = self [ key ] <EOL> return default <EOL> def setlistdefault ( self , key , default_list = None ) : <EOL> """<STR_LIT>""" <EOL> if key not in self : <EOL> default_list = list ( default_list or ( ) ) <EOL> dict . __setitem__ ( self , key , default_list ) <EOL> else : <EOL> default_list = dict . __getitem__ ( self , key ) <EOL> return default_list <EOL> def items ( self , multi = False ) : <EOL> """<STR_LIT>""" <EOL> return list ( self . iteritems ( multi ) ) <EOL> def lists ( self ) : <EOL> """<STR_LIT>""" <EOL> return list ( self . iterlists ( ) ) <EOL> def values ( self ) : <EOL> """<STR_LIT>""" <EOL> return [ self [ key ] for key in self . iterkeys ( ) ] <EOL> def listvalues ( self ) : <EOL> """<STR_LIT>""" <EOL> return list ( self . iterlistvalues ( ) ) <EOL> def iteritems ( self , multi = False ) : <EOL> """<STR_LIT>""" <EOL> for key , values in dict . iteritems ( self ) : <EOL> if multi : <EOL> for value in values : <EOL> yield key , value <EOL> else : <EOL> yield key , values [ <NUM_LIT:0> ] <EOL> def iterlists ( self ) : <EOL> """<STR_LIT>""" <EOL> for key , values in dict . iteritems ( self ) : <EOL> yield key , list ( values ) <EOL> def itervalues ( self ) : <EOL> """<STR_LIT>""" <EOL> for values in dict . itervalues ( self ) : <EOL> yield values [ <NUM_LIT:0> ] <EOL> def iterlistvalues ( self ) : <EOL> """<STR_LIT>""" <EOL> for values in dict . itervalues ( self ) : <EOL> yield list ( values ) <EOL> def copy ( self ) : <EOL> """<STR_LIT>""" <EOL> return self . __class__ ( self ) <EOL> def to_dict ( self , flat = True ) : <EOL> """<STR_LIT>""" <EOL> if flat : <EOL> return dict ( self . iteritems ( ) ) <EOL> return dict ( self . lists ( ) ) <EOL> def update ( self , other_dict ) : <EOL> """<STR_LIT>""" <EOL> for key , value in iter_multi_items ( other_dict ) : <EOL> MultiDict . add ( self , key , value ) <EOL> def pop ( self , key , default = _missing ) : <EOL> """<STR_LIT>""" <EOL> try : <EOL> return dict . pop ( self , key ) [ <NUM_LIT:0> ] <EOL> except KeyError , e : <EOL> if default is not _missing : <EOL> return default <EOL> raise self . KeyError ( str ( e ) ) <EOL> def popitem ( self ) : <EOL> """<STR_LIT>""" <EOL> try : <EOL> item = dict . popitem ( self ) <EOL> return ( item [ <NUM_LIT:0> ] , item [ <NUM_LIT:1> ] [ <NUM_LIT:0> ] ) <EOL> except KeyError , e : <EOL> raise self . KeyError ( str ( e ) ) <EOL> def poplist ( self , key ) : <EOL> """<STR_LIT>""" <EOL> return dict . pop ( self , key , [ ] ) <EOL> def popitemlist ( self ) : <EOL> """<STR_LIT>""" <EOL> try : <EOL> return dict . popitem ( self ) <EOL> except KeyError , e : <EOL> raise self . KeyError ( str ( e ) ) <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % ( self . __class__ . __name__ , self . items ( multi = True ) ) <EOL> class _omd_bucket ( object ) : <EOL> """<STR_LIT>""" <EOL> __slots__ = ( '<STR_LIT>' , '<STR_LIT:key>' , '<STR_LIT:value>' , '<STR_LIT>' ) <EOL> def __init__ ( self , omd , key , value ) : <EOL> self . prev = omd . _last_bucket <EOL> self . key = key <EOL> self . value = value <EOL> self . next = None <EOL> if omd . _first_bucket is None : <EOL> omd . _first_bucket = self <EOL> if omd . _last_bucket is not None : <EOL> omd . _last_bucket . next = self <EOL> omd . _last_bucket = self <EOL> def unlink ( self , omd ) : <EOL> if self . prev : <EOL> self . prev . next = self . next <EOL> if self . next : <EOL> self . next . prev = self . prev <EOL> if omd . _first_bucket is self : <EOL> omd . _first_bucket = self . next <EOL> if omd . _last_bucket is self : <EOL> omd . _last_bucket = self . prev <EOL> class OrderedMultiDict ( MultiDict ) : <EOL> """<STR_LIT>""" <EOL> KeyError = None <EOL> def __init__ ( self , mapping = None ) : <EOL> dict . __init__ ( self ) <EOL> self . _first_bucket = self . _last_bucket = None <EOL> if mapping is not None : <EOL> OrderedMultiDict . update ( self , mapping ) <EOL> def __eq__ ( self , other ) : <EOL> if not isinstance ( other , MultiDict ) : <EOL> return NotImplemented <EOL> if isinstance ( other , OrderedMultiDict ) : <EOL> iter1 = self . iteritems ( multi = True ) <EOL> iter2 = other . iteritems ( multi = True ) <EOL> try : <EOL> for k1 , v1 in iter1 : <EOL> k2 , v2 = iter2 . next ( ) <EOL> if k1 != k2 or v1 != v2 : <EOL> return False <EOL> except StopIteration : <EOL> return False <EOL> try : <EOL> iter2 . next ( ) <EOL> except StopIteration : <EOL> return True <EOL> return False <EOL> if len ( self ) != len ( other ) : <EOL> return False <EOL> for key , values in self . iterlists ( ) : <EOL> if other . getlist ( key ) != values : <EOL> return False <EOL> return True <EOL> def __ne__ ( self , other ) : <EOL> return not self . __eq__ ( other ) <EOL> def __reduce_ex__ ( self , protocol ) : <EOL> return type ( self ) , ( self . items ( multi = True ) , ) <EOL> def __getstate__ ( self ) : <EOL> return self . items ( multi = True ) <EOL> def __setstate__ ( self , values ) : <EOL> dict . clear ( self ) <EOL> for key , value in values : <EOL> self . add ( key , value ) <EOL> def __getitem__ ( self , key ) : <EOL> if key in self : <EOL> return dict . __getitem__ ( self , key ) [ <NUM_LIT:0> ] . value <EOL> raise self . KeyError ( key ) <EOL> def __setitem__ ( self , key , value ) : <EOL> self . poplist ( key ) <EOL> self . add ( key , value ) <EOL> def __delitem__ ( self , key ) : <EOL> self . pop ( key ) <EOL> def iterkeys ( self ) : <EOL> return ( key for key , value in self . iteritems ( ) ) <EOL> def itervalues ( self ) : <EOL> return ( value for key , value in self . iteritems ( ) ) <EOL> def iteritems ( self , multi = False ) : <EOL> ptr = self . _first_bucket <EOL> if multi : <EOL> while ptr is not None : <EOL> yield ptr . key , ptr . value <EOL> ptr = ptr . next <EOL> else : <EOL> returned_keys = set ( ) <EOL> while ptr is not None : <EOL> if ptr . key not in returned_keys : <EOL> returned_keys . add ( ptr . key ) <EOL> yield ptr . key , ptr . value <EOL> ptr = ptr . next <EOL> def iterlists ( self ) : <EOL> returned_keys = set ( ) <EOL> ptr = self . _first_bucket <EOL> while ptr is not None : <EOL> if ptr . key not in returned_keys : <EOL> yield ptr . key , self . getlist ( ptr . key ) <EOL> returned_keys . add ( ptr . key ) <EOL> ptr = ptr . next <EOL> def iterlistvalues ( self ) : <EOL> for key , values in self . iterlists ( ) : <EOL> yield values <EOL> def add ( self , key , value ) : <EOL> dict . setdefault ( self , key , [ ] ) . append ( _omd_bucket ( self , key , value ) ) <EOL> def getlist ( self , key , type = None ) : <EOL> try : <EOL> rv = dict . __getitem__ ( self , key ) <EOL> except KeyError : <EOL> return [ ] <EOL> if type is None : <EOL> return [ x . value for x in rv ] <EOL> result = [ ] <EOL> for item in rv : <EOL> try : <EOL> result . append ( type ( item . value ) ) <EOL> except ValueError : <EOL> pass <EOL> return result <EOL> def setlist ( self , key , new_list ) : <EOL> self . poplist ( key ) <EOL> for value in new_list : <EOL> self . add ( key , value ) <EOL> def setlistdefault ( self , key , default_list = None ) : <EOL> raise TypeError ( '<STR_LIT>' <EOL> '<STR_LIT>' ) <EOL> def update ( self , mapping ) : <EOL> for key , value in iter_multi_items ( mapping ) : <EOL> OrderedMultiDict . add ( self , key , value ) <EOL> def poplist ( self , key ) : <EOL> buckets = dict . pop ( self , key , ( ) ) <EOL> for bucket in buckets : <EOL> bucket . unlink ( self ) <EOL> return [ x . value for x in buckets ] <EOL> def pop ( self , key , default = _missing ) : <EOL> try : <EOL> buckets = dict . pop ( self , key ) <EOL> except KeyError , e : <EOL> if default is not _missing : <EOL> return default <EOL> raise self . KeyError ( str ( e ) ) <EOL> for bucket in buckets : <EOL> bucket . unlink ( self ) <EOL> return buckets [ <NUM_LIT:0> ] . value <EOL> def popitem ( self ) : <EOL> try : <EOL> key , buckets = dict . popitem ( self ) <EOL> except KeyError , e : <EOL> raise self . KeyError ( str ( e ) ) <EOL> for bucket in buckets : <EOL> bucket . unlink ( self ) <EOL> return key , buckets [ <NUM_LIT:0> ] . value <EOL> def popitemlist ( self ) : <EOL> try : <EOL> key , buckets = dict . popitem ( self ) <EOL> except KeyError , e : <EOL> raise self . KeyError ( str ( e ) ) <EOL> for bucket in buckets : <EOL> bucket . unlink ( self ) <EOL> return key , [ x . value for x in buckets ] <EOL> def _options_header_vkw ( value , kw ) : <EOL> if not kw : <EOL> return value <EOL> return dump_options_header ( value , dict ( ( k . replace ( '<STR_LIT:_>' , '<STR_LIT:->' ) , v ) <EOL> for k , v in kw . items ( ) ) ) <EOL> class Headers ( object ) : <EOL> """<STR_LIT>""" <EOL> KeyError = None <EOL> def __init__ ( self , defaults = None , _list = None ) : <EOL> if _list is None : <EOL> _list = [ ] <EOL> self . _list = _list <EOL> if defaults is not None : <EOL> if isinstance ( defaults , ( list , Headers ) ) : <EOL> self . _list . extend ( defaults ) <EOL> else : <EOL> self . extend ( defaults ) <EOL> @ classmethod <EOL> def linked ( cls , headerlist ) : <EOL> """<STR_LIT>""" <EOL> return cls ( _list = headerlist ) <EOL> def __getitem__ ( self , key , _index_operation = True ) : <EOL> if _index_operation : <EOL> if isinstance ( key , ( int , long ) ) : <EOL> return self . _list [ key ] <EOL> elif isinstance ( key , slice ) : <EOL> return self . __class__ ( self . _list [ key ] ) <EOL> ikey = key . lower ( ) <EOL> for k , v in self . _list : <EOL> if k . lower ( ) == ikey : <EOL> return v <EOL> raise self . KeyError ( key ) <EOL> def __eq__ ( self , other ) : <EOL> return other . __class__ is self . __class__ and set ( other . _list ) == set ( self . _list ) <EOL> def __ne__ ( self , other ) : <EOL> return not self . __eq__ ( other ) <EOL> def get ( self , key , default = None , type = None ) : <EOL> """<STR_LIT>""" <EOL> try : <EOL> rv = self . __getitem__ ( key , _index_operation = False ) <EOL> except KeyError : <EOL> return default <EOL> if type is None : <EOL> return rv <EOL> try : <EOL> return type ( rv ) <EOL> except ValueError : <EOL> return default <EOL> def getlist ( self , key , type = None ) : <EOL> """<STR_LIT>""" <EOL> ikey = key . lower ( ) <EOL> result = [ ] <EOL> for k , v in self : <EOL> if k . lower ( ) == ikey : <EOL> if type is not None : <EOL> try : <EOL> v = type ( v ) <EOL> except ValueError : <EOL> continue <EOL> result . append ( v ) <EOL> return result <EOL> def get_all ( self , name ) : <EOL> """<STR_LIT>""" <EOL> return self . getlist ( name ) <EOL> def iteritems ( self , lower = False ) : <EOL> for key , value in self : <EOL> if lower : <EOL> key = key . lower ( ) <EOL> yield key , value <EOL> def iterkeys ( self , lower = False ) : <EOL> for key , _ in self . iteritems ( lower ) : <EOL> yield key <EOL> def itervalues ( self ) : <EOL> for _ , value in self . iteritems ( ) : <EOL> yield value <EOL> def keys ( self , lower = False ) : <EOL> return list ( self . iterkeys ( lower ) ) <EOL> def values ( self ) : <EOL> return list ( self . itervalues ( ) ) <EOL> def items ( self , lower = False ) : <EOL> return list ( self . iteritems ( lower ) ) <EOL> def extend ( self , iterable ) : <EOL> """<STR_LIT>""" <EOL> if isinstance ( iterable , dict ) : <EOL> for key , value in iterable . iteritems ( ) : <EOL> if isinstance ( value , ( tuple , list ) ) : <EOL> for v in value : <EOL> self . add ( key , v ) <EOL> else : <EOL> self . add ( key , value ) <EOL> else : <EOL> for key , value in iterable : <EOL> self . add ( key , value ) <EOL> def __delitem__ ( self , key , _index_operation = True ) : <EOL> if _index_operation and isinstance ( key , ( int , long , slice ) ) : <EOL> del self . _list [ key ] <EOL> return <EOL> key = key . lower ( ) <EOL> new = [ ] <EOL> for k , v in self . _list : <EOL> if k . lower ( ) != key : <EOL> new . append ( ( k , v ) ) <EOL> self . _list [ : ] = new <EOL> def remove ( self , key ) : <EOL> """<STR_LIT>""" <EOL> return self . __delitem__ ( key , _index_operation = False ) <EOL> def pop ( self , key = None , default = _missing ) : <EOL> """<STR_LIT>""" <EOL> if key is None : <EOL> return self . _list . pop ( ) <EOL> if isinstance ( key , ( int , long ) ) : <EOL> return self . _list . pop ( key ) <EOL> try : <EOL> rv = self [ key ] <EOL> self . remove ( key ) <EOL> except KeyError : <EOL> if default is not _missing : <EOL> return default <EOL> raise <EOL> return rv <EOL> def popitem ( self ) : <EOL> """<STR_LIT>""" <EOL> return self . pop ( ) <EOL> def __contains__ ( self , key ) : <EOL> """<STR_LIT>""" <EOL> try : <EOL> self . __getitem__ ( key , _index_operation = False ) <EOL> except KeyError : <EOL> return False <EOL> return True <EOL> has_key = __contains__ <EOL> def __iter__ ( self ) : <EOL> """<STR_LIT>""" <EOL> return iter ( self . _list ) <EOL> def __len__ ( self ) : <EOL> return len ( self . _list ) <EOL> def add ( self , _key , _value , ** kw ) : <EOL> """<STR_LIT>""" <EOL> self . _list . append ( ( _key , _options_header_vkw ( _value , kw ) ) ) <EOL> def add_header ( self , _key , _value , ** _kw ) : <EOL> """<STR_LIT>""" <EOL> self . add ( _key , _value , ** _kw ) <EOL> def clear ( self ) : <EOL> """<STR_LIT>""" <EOL> del self . _list [ : ] <EOL> def set ( self , _key , _value , ** kw ) : <EOL> """<STR_LIT>""" <EOL> lc_key = _key . lower ( ) <EOL> _value = _options_header_vkw ( _value , kw ) <EOL> for idx , ( old_key , old_value ) in enumerate ( self . _list ) : <EOL> if old_key . lower ( ) == lc_key : <EOL> self . _list [ idx ] = ( _key , _value ) <EOL> break <EOL> else : <EOL> return self . add ( _key , _value ) <EOL> self . _list [ idx + <NUM_LIT:1> : ] = [ ( k , v ) for k , v in self . _list [ idx + <NUM_LIT:1> : ] <EOL> if k . lower ( ) != lc_key ] <EOL> def setdefault ( self , key , value ) : <EOL> """<STR_LIT>""" <EOL> if key in self : <EOL> return self [ key ] <EOL> self . set ( key , value ) <EOL> return value <EOL> def __setitem__ ( self , key , value ) : <EOL> """<STR_LIT>""" <EOL> if isinstance ( key , ( slice , int , long ) ) : <EOL> self . _list [ key ] = value <EOL> else : <EOL> self . set ( key , value ) <EOL> def to_list ( self , charset = '<STR_LIT:utf-8>' ) : <EOL> """<STR_LIT>""" <EOL> result = [ ] <EOL> for k , v in self : <EOL> if isinstance ( v , unicode ) : <EOL> v = v . encode ( charset ) <EOL> else : <EOL> v = str ( v ) <EOL> result . append ( ( k , v ) ) <EOL> return result <EOL> def copy ( self ) : <EOL> return self . __class__ ( self . _list ) <EOL> def __copy__ ( self ) : <EOL> return self . copy ( ) <EOL> def __str__ ( self , charset = '<STR_LIT:utf-8>' ) : <EOL> """<STR_LIT>""" <EOL> strs = [ ] <EOL> for key , value in self . to_list ( charset ) : <EOL> strs . append ( '<STR_LIT>' % ( key , value ) ) <EOL> strs . append ( '<STR_LIT:\r\n>' ) <EOL> return '<STR_LIT:\r\n>' . join ( strs ) <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % ( <EOL> self . __class__ . __name__ , <EOL> list ( self ) <EOL> ) <EOL> class ImmutableHeadersMixin ( object ) : <EOL> """<STR_LIT>""" <EOL> def __delitem__ ( self , key ) : <EOL> is_immutable ( self ) <EOL> def __setitem__ ( self , key , value ) : <EOL> is_immutable ( self ) <EOL> set = __setitem__ <EOL> def add ( self , item ) : <EOL> is_immutable ( self ) <EOL> remove = add_header = add <EOL> def extend ( self , iterable ) : <EOL> is_immutable ( self ) <EOL> def insert ( self , pos , value ) : <EOL> is_immutable ( self ) <EOL> def pop ( self , index = - <NUM_LIT:1> ) : <EOL> is_immutable ( self ) <EOL> def popitem ( self ) : <EOL> is_immutable ( self ) <EOL> def setdefault ( self , key , default ) : <EOL> is_immutable ( self ) <EOL> class EnvironHeaders ( ImmutableHeadersMixin , Headers ) : <EOL> """<STR_LIT>""" <EOL> def __init__ ( self , environ ) : <EOL> self . environ = environ <EOL> @ classmethod <EOL> def linked ( cls , environ ) : <EOL> raise TypeError ( '<STR_LIT>' <EOL> '<STR_LIT>' % cls . __name__ ) <EOL> def __eq__ ( self , other ) : <EOL> return self . environ is other . environ <EOL> def __getitem__ ( self , key , _index_operation = False ) : <EOL> key = key . upper ( ) . replace ( '<STR_LIT:->' , '<STR_LIT:_>' ) <EOL> if key in ( '<STR_LIT>' , '<STR_LIT>' ) : <EOL> return self . environ [ key ] <EOL> return self . environ [ '<STR_LIT>' + key ] <EOL> def __len__ ( self ) : <EOL> return len ( list ( iter ( self ) ) ) <EOL> def __iter__ ( self ) : <EOL> for key , value in self . environ . iteritems ( ) : <EOL> if key . startswith ( '<STR_LIT>' ) and key not in ( '<STR_LIT>' , '<STR_LIT>' ) : <EOL> yield key [ <NUM_LIT:5> : ] . replace ( '<STR_LIT:_>' , '<STR_LIT:->' ) . title ( ) , value <EOL> elif key in ( '<STR_LIT>' , '<STR_LIT>' ) : <EOL> yield key . replace ( '<STR_LIT:_>' , '<STR_LIT:->' ) . title ( ) , value <EOL> def copy ( self ) : <EOL> raise TypeError ( '<STR_LIT>' % self . __class__ . __name__ ) <EOL> class CombinedMultiDict ( ImmutableMultiDictMixin , MultiDict ) : <EOL> """<STR_LIT>""" <EOL> def __reduce_ex__ ( self , protocol ) : <EOL> return type ( self ) , ( self . dicts , ) <EOL> def __init__ ( self , dicts = None ) : <EOL> self . dicts = dicts or [ ] <EOL> @ classmethod <EOL> def fromkeys ( cls ) : <EOL> raise TypeError ( '<STR_LIT>' % <EOL> cls . __name__ ) <EOL> def __getitem__ ( self , key ) : <EOL> for d in self . dicts : <EOL> if key in d : <EOL> return d [ key ] <EOL> raise self . KeyError ( key ) <EOL> def get ( self , key , default = None , type = None ) : <EOL> for d in self . dicts : <EOL> if key in d : <EOL> if type is not None : <EOL> try : <EOL> return type ( d [ key ] ) <EOL> except ValueError : <EOL> continue <EOL> return d [ key ] <EOL> return default <EOL> def getlist ( self , key , type = None ) : <EOL> rv = [ ] <EOL> for d in self . dicts : <EOL> rv . extend ( d . getlist ( key , type ) ) <EOL> return rv <EOL> def keys ( self ) : <EOL> rv = set ( ) <EOL> for d in self . dicts : <EOL> rv . update ( d . keys ( ) ) <EOL> return list ( rv ) <EOL> def iteritems ( self , multi = False ) : <EOL> found = set ( ) <EOL> for d in self . dicts : <EOL> for key , value in d . iteritems ( multi ) : <EOL> if multi : <EOL> yield key , value <EOL> elif key not in found : <EOL> found . add ( key ) <EOL> yield key , value <EOL> def itervalues ( self ) : <EOL> for key , value in self . iteritems ( ) : <EOL> yield value <EOL> def values ( self ) : <EOL> return list ( self . itervalues ( ) ) <EOL> def items ( self , multi = False ) : <EOL> return list ( self . iteritems ( multi ) ) <EOL> def iterlists ( self ) : <EOL> rv = { } <EOL> for d in self . dicts : <EOL> for key , values in d . iterlists ( ) : <EOL> rv . setdefault ( key , [ ] ) . extend ( values ) <EOL> return rv . iteritems ( ) <EOL> def lists ( self ) : <EOL> return list ( self . iterlists ( ) ) <EOL> def iterlistvalues ( self ) : <EOL> return ( x [ <NUM_LIT:0> ] for x in self . lists ( ) ) <EOL> def listvalues ( self ) : <EOL> return list ( self . iterlistvalues ( ) ) <EOL> def iterkeys ( self ) : <EOL> return iter ( self . keys ( ) ) <EOL> __iter__ = iterkeys <EOL> def copy ( self ) : <EOL> """<STR_LIT>""" <EOL> return self . __class__ ( self . dicts [ : ] ) <EOL> def to_dict ( self , flat = True ) : <EOL> """<STR_LIT>""" <EOL> rv = { } <EOL> for d in reversed ( self . dicts ) : <EOL> rv . update ( d . to_dict ( flat ) ) <EOL> return rv <EOL> def __len__ ( self ) : <EOL> return len ( self . keys ( ) ) <EOL> def __contains__ ( self , key ) : <EOL> for d in self . dicts : <EOL> if key in d : <EOL> return True <EOL> return False <EOL> has_key = __contains__ <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % ( self . __class__ . __name__ , self . dicts ) <EOL> class FileMultiDict ( MultiDict ) : <EOL> """<STR_LIT>""" <EOL> def add_file ( self , name , file , filename = None , content_type = None ) : <EOL> """<STR_LIT>""" <EOL> if isinstance ( file , FileStorage ) : <EOL> self [ name ] = file <EOL> return <EOL> if isinstance ( file , basestring ) : <EOL> if filename is None : <EOL> filename = file <EOL> file = open ( file , '<STR_LIT:rb>' ) <EOL> if filename and content_type is None : <EOL> content_type = mimetypes . guess_type ( filename ) [ <NUM_LIT:0> ] or '<STR_LIT>' <EOL> self [ name ] = FileStorage ( file , filename , name , content_type ) <EOL> class ImmutableDict ( ImmutableDictMixin , dict ) : <EOL> """<STR_LIT>""" <EOL> __repr__ = _proxy_repr ( dict ) <EOL> def copy ( self ) : <EOL> """<STR_LIT>""" <EOL> return dict ( self ) <EOL> def __copy__ ( self ) : <EOL> return self <EOL> class ImmutableMultiDict ( ImmutableMultiDictMixin , MultiDict ) : <EOL> """<STR_LIT>""" <EOL> def copy ( self ) : <EOL> """<STR_LIT>""" <EOL> return MultiDict ( self ) <EOL> def __copy__ ( self ) : <EOL> return self <EOL> class ImmutableOrderedMultiDict ( ImmutableMultiDictMixin , OrderedMultiDict ) : <EOL> """<STR_LIT>""" <EOL> def copy ( self ) : <EOL> """<STR_LIT>""" <EOL> return OrderedMultiDict ( self ) <EOL> def __copy__ ( self ) : <EOL> return self <EOL> class Accept ( ImmutableList ) : <EOL> """<STR_LIT>""" <EOL> def __init__ ( self , values = ( ) ) : <EOL> if values is None : <EOL> list . __init__ ( self ) <EOL> self . provided = False <EOL> elif isinstance ( values , Accept ) : <EOL> self . provided = values . provided <EOL> list . __init__ ( self , values ) <EOL> else : <EOL> self . provided = True <EOL> values = [ ( a , b ) for b , a in values ] <EOL> values . sort ( ) <EOL> values . reverse ( ) <EOL> list . __init__ ( self , [ ( a , b ) for b , a in values ] ) <EOL> def _value_matches ( self , value , item ) : <EOL> """<STR_LIT>""" <EOL> return item == '<STR_LIT:*>' or item . lower ( ) == value . lower ( ) <EOL> def __getitem__ ( self , key ) : <EOL> """<STR_LIT>""" <EOL> if isinstance ( key , basestring ) : <EOL> return self . quality ( key ) <EOL> return list . __getitem__ ( self , key ) <EOL> def quality ( self , key ) : <EOL> """<STR_LIT>""" <EOL> for item , quality in self : <EOL> if self . _value_matches ( key , item ) : <EOL> return quality <EOL> return <NUM_LIT:0> <EOL> def __contains__ ( self , value ) : <EOL> for item , quality in self : <EOL> if self . _value_matches ( value , item ) : <EOL> return True <EOL> return False <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % ( <EOL> self . __class__ . __name__ , <EOL> '<STR_LIT:U+002CU+0020>' . join ( '<STR_LIT>' % ( x , y ) for x , y in self ) <EOL> ) <EOL> def index ( self , key ) : <EOL> """<STR_LIT>""" <EOL> if isinstance ( key , basestring ) : <EOL> for idx , ( item , quality ) in enumerate ( self ) : <EOL> if self . _value_matches ( key , item ) : <EOL> return idx <EOL> raise ValueError ( key ) <EOL> return list . index ( self , key ) <EOL> def find ( self , key ) : <EOL> """<STR_LIT>""" <EOL> try : <EOL> return self . index ( key ) <EOL> except ValueError : <EOL> return - <NUM_LIT:1> <EOL> def values ( self ) : <EOL> """<STR_LIT>""" <EOL> return list ( self . itervalues ( ) ) <EOL> def itervalues ( self ) : <EOL> """<STR_LIT>""" <EOL> for item in self : <EOL> yield item [ <NUM_LIT:0> ] <EOL> def to_header ( self ) : <EOL> """<STR_LIT>""" <EOL> result = [ ] <EOL> for value , quality in self : <EOL> if quality != <NUM_LIT:1> : <EOL> value = '<STR_LIT>' % ( value , quality ) <EOL> result . append ( value ) <EOL> return '<STR_LIT:U+002C>' . join ( result ) <EOL> def __str__ ( self ) : <EOL> return self . to_header ( ) <EOL> def best_match ( self , matches , default = None ) : <EOL> """<STR_LIT>""" <EOL> best_quality = - <NUM_LIT:1> <EOL> result = default <EOL> for server_item in matches : <EOL> for client_item , quality in self : <EOL> if quality <= best_quality : <EOL> break <EOL> if self . _value_matches ( client_item , server_item ) : <EOL> best_quality = quality <EOL> result = server_item <EOL> return result <EOL> @ property <EOL> def best ( self ) : <EOL> """<STR_LIT>""" <EOL> if self : <EOL> return self [ <NUM_LIT:0> ] [ <NUM_LIT:0> ] <EOL> class MIMEAccept ( Accept ) : <EOL> """<STR_LIT>""" <EOL> def _value_matches ( self , value , item ) : <EOL> def _normalize ( x ) : <EOL> x = x . lower ( ) <EOL> return x == '<STR_LIT:*>' and ( '<STR_LIT:*>' , '<STR_LIT:*>' ) or x . split ( '<STR_LIT:/>' , <NUM_LIT:1> ) <EOL> if '<STR_LIT:/>' not in value : <EOL> raise ValueError ( '<STR_LIT>' % value ) <EOL> value_type , value_subtype = _normalize ( value ) <EOL> if value_type == '<STR_LIT:*>' and value_subtype != '<STR_LIT:*>' : <EOL> raise ValueError ( '<STR_LIT>' % value ) <EOL> if '<STR_LIT:/>' not in item : <EOL> return False <EOL> item_type , item_subtype = _normalize ( item ) <EOL> if item_type == '<STR_LIT:*>' and item_subtype != '<STR_LIT:*>' : <EOL> return False <EOL> return ( <EOL> ( item_type == item_subtype == '<STR_LIT:*>' or <EOL> value_type == value_subtype == '<STR_LIT:*>' ) or <EOL> ( item_type == value_type and ( item_subtype == '<STR_LIT:*>' or <EOL> value_subtype == '<STR_LIT:*>' or <EOL> item_subtype == value_subtype ) ) <EOL> ) <EOL> @ property <EOL> def accept_html ( self ) : <EOL> """<STR_LIT>""" <EOL> return ( <EOL> '<STR_LIT>' in self or <EOL> '<STR_LIT>' in self or <EOL> self . accept_xhtml <EOL> ) <EOL> @ property <EOL> def accept_xhtml ( self ) : <EOL> """<STR_LIT>""" <EOL> return ( <EOL> '<STR_LIT>' in self or <EOL> '<STR_LIT>' in self <EOL> ) <EOL> class LanguageAccept ( Accept ) : <EOL> """<STR_LIT>""" <EOL> def _value_matches ( self , value , item ) : <EOL> def _normalize ( language ) : <EOL> return _locale_delim_re . split ( language . lower ( ) ) <EOL> return item == '<STR_LIT:*>' or _normalize ( value ) == _normalize ( item ) <EOL> class CharsetAccept ( Accept ) : <EOL> """<STR_LIT>""" <EOL> def _value_matches ( self , value , item ) : <EOL> def _normalize ( name ) : <EOL> try : <EOL> return codecs . lookup ( name ) . name <EOL> except LookupError : <EOL> return name . lower ( ) <EOL> return item == '<STR_LIT:*>' or _normalize ( value ) == _normalize ( item ) <EOL> def cache_property ( key , empty , type ) : <EOL> """<STR_LIT>""" <EOL> return property ( lambda x : x . _get_cache_value ( key , empty , type ) , <EOL> lambda x , v : x . _set_cache_value ( key , v , type ) , <EOL> lambda x : x . _del_cache_value ( key ) , <EOL> '<STR_LIT>' % key ) <EOL> class _CacheControl ( UpdateDictMixin , dict ) : <EOL> """<STR_LIT>""" <EOL> no_cache = cache_property ( '<STR_LIT>' , '<STR_LIT:*>' , None ) <EOL> no_store = cache_property ( '<STR_LIT>' , None , bool ) <EOL> max_age = cache_property ( '<STR_LIT>' , - <NUM_LIT:1> , int ) <EOL> no_transform = cache_property ( '<STR_LIT>' , None , None ) <EOL> def __init__ ( self , values = ( ) , on_update = None ) : <EOL> dict . __init__ ( self , values or ( ) ) <EOL> self . on_update = on_update <EOL> self . provided = values is not None <EOL> def _get_cache_value ( self , key , empty , type ) : <EOL> """<STR_LIT>""" <EOL> if type is bool : <EOL> return key in self <EOL> if key in self : <EOL> value = self [ key ] <EOL> if value is None : <EOL> return empty <EOL> elif type is not None : <EOL> try : <EOL> value = type ( value ) <EOL> except ValueError : <EOL> pass <EOL> return value <EOL> def _set_cache_value ( self , key , value , type ) : <EOL> """<STR_LIT>""" <EOL> if type is bool : <EOL> if value : <EOL> self [ key ] = None <EOL> else : <EOL> self . pop ( key , None ) <EOL> else : <EOL> if value is None : <EOL> self . pop ( key ) <EOL> elif value is True : <EOL> self [ key ] = None <EOL> else : <EOL> self [ key ] = value <EOL> def _del_cache_value ( self , key ) : <EOL> """<STR_LIT>""" <EOL> if key in self : <EOL> del self [ key ] <EOL> def to_header ( self ) : <EOL> """<STR_LIT>""" <EOL> return dump_header ( self ) <EOL> def __str__ ( self ) : <EOL> return self . to_header ( ) <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % ( <EOL> self . __class__ . __name__ , <EOL> self . to_header ( ) <EOL> ) <EOL> class RequestCacheControl ( ImmutableDictMixin , _CacheControl ) : <EOL> """<STR_LIT>""" <EOL> max_stale = cache_property ( '<STR_LIT>' , '<STR_LIT:*>' , int ) <EOL> min_fresh = cache_property ( '<STR_LIT>' , '<STR_LIT:*>' , int ) <EOL> no_transform = cache_property ( '<STR_LIT>' , None , None ) <EOL> only_if_cached = cache_property ( '<STR_LIT>' , None , bool ) <EOL> class ResponseCacheControl ( _CacheControl ) : <EOL> """<STR_LIT>""" <EOL> public = cache_property ( '<STR_LIT>' , None , bool ) <EOL> private = cache_property ( '<STR_LIT>' , '<STR_LIT:*>' , None ) <EOL> must_revalidate = cache_property ( '<STR_LIT>' , None , bool ) <EOL> proxy_revalidate = cache_property ( '<STR_LIT>' , None , bool ) <EOL> s_maxage = cache_property ( '<STR_LIT>' , None , None ) <EOL> _CacheControl . cache_property = staticmethod ( cache_property ) <EOL> class CallbackDict ( UpdateDictMixin , dict ) : <EOL> """<STR_LIT>""" <EOL> def __init__ ( self , initial = None , on_update = None ) : <EOL> dict . __init__ ( self , initial or ( ) ) <EOL> self . on_update = on_update <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % ( <EOL> self . __class__ . __name__ , <EOL> dict . __repr__ ( self ) <EOL> ) <EOL> class HeaderSet ( object ) : <EOL> """<STR_LIT>""" <EOL> def __init__ ( self , headers = None , on_update = None ) : <EOL> self . _headers = list ( headers or ( ) ) <EOL> self . _set = set ( [ x . lower ( ) for x in self . _headers ] ) <EOL> self . on_update = on_update <EOL> def add ( self , header ) : <EOL> """<STR_LIT>""" <EOL> self . update ( ( header , ) ) <EOL> def remove ( self , header ) : <EOL> """<STR_LIT>""" <EOL> key = header . lower ( ) <EOL> if key not in self . _set : <EOL> raise KeyError ( header ) <EOL> self . _set . remove ( key ) <EOL> for idx , key in enumerate ( self . _headers ) : <EOL> if key . lower ( ) == header : <EOL> del self . _headers [ idx ] <EOL> break <EOL> if self . on_update is not None : <EOL> self . on_update ( self ) <EOL> def update ( self , iterable ) : <EOL> """<STR_LIT>""" <EOL> inserted_any = False <EOL> for header in iterable : <EOL> key = header . lower ( ) <EOL> if key not in self . _set : <EOL> self . _headers . append ( header ) <EOL> self . _set . add ( key ) <EOL> inserted_any = True <EOL> if inserted_any and self . on_update is not None : <EOL> self . on_update ( self ) <EOL> def discard ( self , header ) : <EOL> """<STR_LIT>""" <EOL> try : <EOL> return self . remove ( header ) <EOL> except KeyError : <EOL> pass <EOL> def find ( self , header ) : <EOL> """<STR_LIT>""" <EOL> header = header . lower ( ) <EOL> for idx , item in enumerate ( self . _headers ) : <EOL> if item . lower ( ) == header : <EOL> return idx <EOL> return - <NUM_LIT:1> <EOL> def index ( self , header ) : <EOL> """<STR_LIT>""" <EOL> rv = self . find ( header ) <EOL> if rv < <NUM_LIT:0> : <EOL> raise IndexError ( header ) <EOL> return rv <EOL> def clear ( self ) : <EOL> """<STR_LIT>""" <EOL> self . _set . clear ( ) <EOL> del self . _headers [ : ] <EOL> if self . on_update is not None : <EOL> self . on_update ( self ) <EOL> def as_set ( self , preserve_casing = False ) : <EOL> """<STR_LIT>""" <EOL> if preserve_casing : <EOL> return set ( self . _headers ) <EOL> return set ( self . _set ) <EOL> def to_header ( self ) : <EOL> """<STR_LIT>""" <EOL> return '<STR_LIT:U+002CU+0020>' . join ( map ( quote_header_value , self . _headers ) ) <EOL> def __getitem__ ( self , idx ) : <EOL> return self . _headers [ idx ] <EOL> def __delitem__ ( self , idx ) : <EOL> rv = self . _headers . pop ( idx ) <EOL> self . _set . remove ( rv . lower ( ) ) <EOL> if self . on_update is not None : <EOL> self . on_update ( self ) <EOL> def __setitem__ ( self , idx , value ) : <EOL> old = self . _headers [ idx ] <EOL> self . _set . remove ( old . lower ( ) ) <EOL> self . _headers [ idx ] = value <EOL> self . _set . add ( value . lower ( ) ) <EOL> if self . on_update is not None : <EOL> self . on_update ( self ) <EOL> def __contains__ ( self , header ) : <EOL> return header . lower ( ) in self . _set <EOL> def __len__ ( self ) : <EOL> return len ( self . _set ) <EOL> def __iter__ ( self ) : <EOL> return iter ( self . _headers ) <EOL> def __nonzero__ ( self ) : <EOL> return bool ( self . _set ) <EOL> def __str__ ( self ) : <EOL> return self . to_header ( ) <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % ( <EOL> self . __class__ . __name__ , <EOL> self . _headers <EOL> ) <EOL> class ETags ( object ) : <EOL> """<STR_LIT>""" <EOL> def __init__ ( self , strong_etags = None , weak_etags = None , star_tag = False ) : <EOL> self . _strong = frozenset ( not star_tag and strong_etags or ( ) ) <EOL> self . _weak = frozenset ( weak_etags or ( ) ) <EOL> self . star_tag = star_tag <EOL> def as_set ( self , include_weak = False ) : <EOL> """<STR_LIT>""" <EOL> rv = set ( self . _strong ) <EOL> if include_weak : <EOL> rv . update ( self . _weak ) <EOL> return rv <EOL> def is_weak ( self , etag ) : <EOL> """<STR_LIT>""" <EOL> return etag in self . _weak <EOL> def contains_weak ( self , etag ) : <EOL> """<STR_LIT>""" <EOL> return self . is_weak ( etag ) or self . contains ( etag ) <EOL> def contains ( self , etag ) : <EOL> """<STR_LIT>""" <EOL> if self . star_tag : <EOL> return True <EOL> return etag in self . _strong <EOL> def contains_raw ( self , etag ) : <EOL> """<STR_LIT>""" <EOL> etag , weak = unquote_etag ( etag ) <EOL> if weak : <EOL> return self . contains_weak ( etag ) <EOL> return self . contains ( etag ) <EOL> def to_header ( self ) : <EOL> """<STR_LIT>""" <EOL> if self . star_tag : <EOL> return '<STR_LIT:*>' <EOL> return '<STR_LIT:U+002CU+0020>' . join ( <EOL> [ '<STR_LIT>' % x for x in self . _strong ] + <EOL> [ '<STR_LIT>' % x for x in self . _weak ] <EOL> ) <EOL> def __call__ ( self , etag = None , data = None , include_weak = False ) : <EOL> if [ etag , data ] . count ( None ) != <NUM_LIT:1> : <EOL> raise TypeError ( '<STR_LIT>' ) <EOL> if etag is None : <EOL> etag = generate_etag ( data ) <EOL> if include_weak : <EOL> if etag in self . _weak : <EOL> return True <EOL> return etag in self . _strong <EOL> def __nonzero__ ( self ) : <EOL> return bool ( self . star_tag or self . _strong ) <EOL> def __str__ ( self ) : <EOL> return self . to_header ( ) <EOL> def __iter__ ( self ) : <EOL> return iter ( self . _strong ) <EOL> def __contains__ ( self , etag ) : <EOL> return self . contains ( etag ) <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % ( self . __class__ . __name__ , str ( self ) ) <EOL> class Authorization ( ImmutableDictMixin , dict ) : <EOL> """<STR_LIT>""" <EOL> def __init__ ( self , auth_type , data = None ) : <EOL> dict . __init__ ( self , data or { } ) <EOL> self . type = auth_type <EOL> username = property ( lambda x : x . get ( '<STR_LIT:username>' ) , doc = '''<STR_LIT>''' ) <EOL> password = property ( lambda x : x . get ( '<STR_LIT:password>' ) , doc = '''<STR_LIT>''' ) <EOL> realm = property ( lambda x : x . get ( '<STR_LIT>' ) , doc = '''<STR_LIT>''' ) <EOL> nonce = property ( lambda x : x . get ( '<STR_LIT>' ) , doc = '''<STR_LIT>''' ) <EOL> uri = property ( lambda x : x . get ( '<STR_LIT>' ) , doc = '''<STR_LIT>''' ) <EOL> nc = property ( lambda x : x . get ( '<STR_LIT>' ) , doc = '''<STR_LIT>''' ) <EOL> cnonce = property ( lambda x : x . get ( '<STR_LIT>' ) , doc = '''<STR_LIT>''' ) <EOL> response = property ( lambda x : x . get ( '<STR_LIT>' ) , doc = '''<STR_LIT>''' ) <EOL> opaque = property ( lambda x : x . get ( '<STR_LIT>' ) , doc = '''<STR_LIT>''' ) <EOL> @ property <EOL> def qop ( self ) : <EOL> """<STR_LIT>""" <EOL> def on_update ( header_set ) : <EOL> if not header_set and '<STR_LIT>' in self : <EOL> del self [ '<STR_LIT>' ] <EOL> elif header_set : <EOL> self [ '<STR_LIT>' ] = header_set . to_header ( ) <EOL> return parse_set_header ( self . get ( '<STR_LIT>' ) , on_update ) <EOL> class WWWAuthenticate ( UpdateDictMixin , dict ) : <EOL> """<STR_LIT>""" <EOL> _require_quoting = frozenset ( [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> def __init__ ( self , auth_type = None , values = None , on_update = None ) : <EOL> dict . __init__ ( self , values or ( ) ) <EOL> if auth_type : <EOL> self [ '<STR_LIT>' ] = auth_type <EOL> self . on_update = on_update <EOL> def set_basic ( self , realm = '<STR_LIT>' ) : <EOL> """<STR_LIT>""" <EOL> dict . clear ( self ) <EOL> dict . update ( self , { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : realm } ) <EOL> if self . on_update : <EOL> self . on_update ( self ) <EOL> def set_digest ( self , realm , nonce , qop = ( '<STR_LIT>' , ) , opaque = None , <EOL> algorithm = None , stale = False ) : <EOL> """<STR_LIT>""" <EOL> d = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : realm , <EOL> '<STR_LIT>' : nonce , <EOL> '<STR_LIT>' : dump_header ( qop ) <EOL> } <EOL> if stale : <EOL> d [ '<STR_LIT>' ] = '<STR_LIT>' <EOL> if opaque is not None : <EOL> d [ '<STR_LIT>' ] = opaque <EOL> if algorithm is not None : <EOL> d [ '<STR_LIT>' ] = algorithm <EOL> dict . clear ( self ) <EOL> dict . update ( self , d ) <EOL> if self . on_update : <EOL> self . on_update ( self ) <EOL> def to_header ( self ) : <EOL> """<STR_LIT>""" <EOL> d = dict ( self ) <EOL> auth_type = d . pop ( '<STR_LIT>' , None ) or '<STR_LIT>' <EOL> return '<STR_LIT>' % ( auth_type . title ( ) , '<STR_LIT:U+002CU+0020>' . join ( [ <EOL> '<STR_LIT>' % ( key , quote_header_value ( value , <EOL> allow_token = key not in self . _require_quoting ) ) <EOL> for key , value in d . iteritems ( ) <EOL> ] ) ) <EOL> def __str__ ( self ) : <EOL> return self . to_header ( ) <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % ( <EOL> self . __class__ . __name__ , <EOL> self . to_header ( ) <EOL> ) <EOL> def auth_property ( name , doc = None ) : <EOL> """<STR_LIT>""" <EOL> def _set_value ( self , value ) : <EOL> if value is None : <EOL> self . pop ( name , None ) <EOL> else : <EOL> self [ name ] = str ( value ) <EOL> return property ( lambda x : x . get ( name ) , _set_value , doc = doc ) <EOL> def _set_property ( name , doc = None ) : <EOL> def fget ( self ) : <EOL> def on_update ( header_set ) : <EOL> if not header_set and name in self : <EOL> del self [ name ] <EOL> elif header_set : <EOL> self [ name ] = header_set . to_header ( ) <EOL> return parse_set_header ( self . get ( name ) , on_update ) <EOL> return property ( fget , doc = doc ) <EOL> type = auth_property ( '<STR_LIT>' , doc = '''<STR_LIT>''' ) <EOL> realm = auth_property ( '<STR_LIT>' , doc = '''<STR_LIT>''' ) <EOL> domain = _set_property ( '<STR_LIT>' , doc = '''<STR_LIT>''' ) <EOL> nonce = auth_property ( '<STR_LIT>' , doc = '''<STR_LIT>''' ) <EOL> opaque = auth_property ( '<STR_LIT>' , doc = '''<STR_LIT>''' ) <EOL> algorithm = auth_property ( '<STR_LIT>' , doc = '''<STR_LIT>''' ) <EOL> qop = _set_property ( '<STR_LIT>' , doc = '''<STR_LIT>''' ) <EOL> def _get_stale ( self ) : <EOL> val = self . get ( '<STR_LIT>' ) <EOL> if val is not None : <EOL> return val . lower ( ) == '<STR_LIT:true>' <EOL> def _set_stale ( self , value ) : <EOL> if value is None : <EOL> self . pop ( '<STR_LIT>' , None ) <EOL> else : <EOL> self [ '<STR_LIT>' ] = value and '<STR_LIT>' or '<STR_LIT>' <EOL> stale = property ( _get_stale , _set_stale , doc = '''<STR_LIT>''' ) <EOL> del _get_stale , _set_stale <EOL> auth_property = staticmethod ( auth_property ) <EOL> del _set_property <EOL> class FileStorage ( object ) : <EOL> """<STR_LIT>""" <EOL> def __init__ ( self , stream = None , filename = None , name = None , <EOL> content_type = '<STR_LIT>' , content_length = - <NUM_LIT:1> , <EOL> headers = None ) : <EOL> self . name = name <EOL> self . stream = stream or _empty_stream <EOL> self . filename = filename or getattr ( stream , '<STR_LIT:name>' , None ) <EOL> self . content_type = content_type <EOL> self . content_length = content_length <EOL> if headers is None : <EOL> headers = Headers ( ) <EOL> self . headers = headers <EOL> def save ( self , dst , buffer_size = <NUM_LIT> ) : <EOL> """<STR_LIT>""" <EOL> from shutil import copyfileobj <EOL> close_dst = False <EOL> if isinstance ( dst , basestring ) : <EOL> dst = file ( dst , '<STR_LIT:wb>' ) <EOL> close_dst = True <EOL> try : <EOL> copyfileobj ( self . stream , dst , buffer_size ) <EOL> finally : <EOL> if close_dst : <EOL> dst . close ( ) <EOL> def close ( self ) : <EOL> """<STR_LIT>""" <EOL> try : <EOL> self . stream . close ( ) <EOL> except : <EOL> pass <EOL> def __nonzero__ ( self ) : <EOL> return bool ( self . filename ) <EOL> def __getattr__ ( self , name ) : <EOL> return getattr ( self . stream , name ) <EOL> def __iter__ ( self ) : <EOL> return iter ( self . readline , '<STR_LIT>' ) <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % ( <EOL> self . __class__ . __name__ , <EOL> self . filename , <EOL> self . content_type <EOL> ) <EOL> from werkzeug . http import dump_options_header , dump_header , generate_etag , quote_header_value , parse_set_header , unquote_etag <EOL> from werkzeug . exceptions import BadRequest <EOL> for _cls in MultiDict , OrderedMultiDict , CombinedMultiDict , Headers , EnvironHeaders : <EOL> _cls . KeyError = BadRequest . wrap ( KeyError , _cls . __name__ + '<STR_LIT>' ) <EOL> del _cls </s>
<s> """<STR_LIT>""" <EOL> import sys <EOL> import os <EOL> from werkzeug . utils import import_string <EOL> from kay . management . shell import ( <EOL> rshell , shell , clear_datastore , create_user , <EOL> ) <EOL> from kay . management . runserver import runserver_passthru_argv <EOL> from kay . management . startapp import startapp <EOL> from kay . management . startapp import startproject <EOL> from kay . management . appcfg import do_appcfg_passthru_argv <EOL> from kay . management . bulkloader import ( <EOL> do_bulkloader_passthru_argv , dump_all , restore_all , <EOL> ) <EOL> from kay . management . test import do_runtest <EOL> from kay . management . preparse import do_preparse_bundle <EOL> from kay . management . preparse import do_preparse_apps <EOL> from kay . management . extract_messages import do_extract_messages <EOL> from kay . management . add_translations import do_add_translations <EOL> from kay . management . update_translations import do_update_translations <EOL> from kay . management . compile_translations import do_compile_translations <EOL> from kay . management . wxadmin import do_wxadmin <EOL> from kay . management . compile_media import do_compile_media <EOL> from kay . conf import settings <EOL> action_dump_all = dump_all <EOL> action_restore_all = restore_all <EOL> action_shell = shell <EOL> action_rshell = rshell <EOL> action_startapp = startapp <EOL> action_startproject = startproject <EOL> action_test = do_runtest <EOL> action_preparse_bundle = do_preparse_bundle <EOL> action_preparse_apps = do_preparse_apps <EOL> action_extract_messages = do_extract_messages <EOL> action_add_translations = do_add_translations <EOL> action_update_translations = do_update_translations <EOL> action_compile_translations = do_compile_translations <EOL> action_appcfg = do_appcfg_passthru_argv <EOL> action_runserver = runserver_passthru_argv <EOL> action_bulkloader = do_bulkloader_passthru_argv <EOL> action_clear_datastore = clear_datastore <EOL> action_create_user = create_user <EOL> action_wxadmin = do_wxadmin <EOL> action_compile_media = do_compile_media <EOL> additional_actions = [ ] <EOL> for app in settings . INSTALLED_APPS : <EOL> try : <EOL> appmod = import_string ( app ) <EOL> if not os . path . exists ( os . path . join ( os . path . dirname ( appmod . __file__ ) , <EOL> '<STR_LIT>' ) ) : <EOL> continue <EOL> management_mod = import_string ( "<STR_LIT>" % app ) <EOL> for name , val in vars ( management_mod ) . iteritems ( ) : <EOL> if name . startswith ( "<STR_LIT>" ) : <EOL> locals ( ) [ name ] = getattr ( management_mod , name ) <EOL> additional_actions . append ( name ) <EOL> except Exception , e : <EOL> import traceback <EOL> sys . stderr . write ( '<STR_LIT:\n>' . join ( traceback . format_exception ( * ( sys . exc_info ( ) ) ) ) ) <EOL> pass <EOL> __all__ = [ <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> ] + additional_actions <EOL> def print_status ( msg ) : <EOL> print ( msg ) <EOL> sys . stdout . flush ( ) </s>
<s> """<STR_LIT>""" <EOL> from kay . routing import ( <EOL> ViewGroup , Rule <EOL> ) <EOL> view_groups = [ <EOL> ViewGroup ( <EOL> Rule ( '<STR_LIT>' , endpoint = '<STR_LIT>' , <EOL> view = ( '<STR_LIT>' , ( ) , { } ) ) , <EOL> Rule ( '<STR_LIT>' , endpoint = '<STR_LIT>' , <EOL> view = ( '<STR_LIT>' , ( ) , { } ) ) , <EOL> Rule ( '<STR_LIT>' , endpoint = '<STR_LIT>' , <EOL> view = '<STR_LIT>' ) , <EOL> ) <EOL> ] </s>
<s> """<STR_LIT>""" <EOL> from google . appengine . ext import db <EOL> from kay . utils . forms import ValidationError <EOL> from kay . utils . forms . modelform import ModelForm <EOL> class MaxLengthValidator ( object ) : <EOL> def __init__ ( self , length ) : <EOL> self . length = length <EOL> def __call__ ( self , val ) : <EOL> if len ( val ) > self . length : <EOL> raise ValidationError ( "<STR_LIT>" ) <EOL> return True <EOL> class TestModel ( db . Model ) : <EOL> number = db . IntegerProperty ( required = True ) <EOL> data_field = db . StringProperty ( required = True , <EOL> validator = MaxLengthValidator ( <NUM_LIT:20> ) ) <EOL> is_active = db . BooleanProperty ( required = True ) <EOL> string_list_field = db . StringListProperty ( required = True ) <EOL> class TestModel2 ( db . Model ) : <EOL> number = db . IntegerProperty ( required = True ) <EOL> data_field = db . StringProperty ( required = True , <EOL> validator = MaxLengthValidator ( <NUM_LIT:20> ) ) <EOL> is_active = db . BooleanProperty ( required = True ) <EOL> string_list_field = db . StringListProperty ( required = True ) <EOL> class TestModelForm ( ModelForm ) : <EOL> csrf_protected = False <EOL> class Meta ( ) : <EOL> model = TestModel <EOL> def __init__ ( self , instance = None , initial = None ) : <EOL> super ( TestModelForm , self ) . __init__ ( instance , initial ) <EOL> self . string_list_field . min_size = <NUM_LIT:1> <EOL> class JsonTestModel ( db . Model ) : <EOL> s = db . StringProperty ( ) <EOL> i = db . IntegerProperty ( ) <EOL> b = db . BooleanProperty ( ) <EOL> l = db . StringListProperty ( ) <EOL> r = db . ReferenceProperty ( ) <EOL> class ModelFormTestModel ( db . Model ) : <EOL> s_name = db . StringProperty ( ) <EOL> zip_code = db . StringProperty ( ) <EOL> addr = db . StringProperty ( ) <EOL> class ModelFormTestForm ( ModelForm ) : <EOL> csrf_protected = False <EOL> class Meta : <EOL> model = ModelFormTestModel <EOL> fields = ( '<STR_LIT>' ) <EOL> class ValidationTestModel ( db . Model ) : <EOL> slist = db . StringListProperty ( ) <EOL> class ValidationTestForm ( ModelForm ) : <EOL> csrf_protected = False <EOL> class Meta : <EOL> model = ValidationTestModel <EOL> def context_validate ( self , data ) : <EOL> raise ValidationError ( "<STR_LIT>" ) </s>
<s> """<STR_LIT>""" <EOL> import re <EOL> import sys <EOL> from os import path , listdir , mkdir <EOL> def compile_file ( env , src_path , dst_path , encoding = '<STR_LIT:utf-8>' , base_dir = '<STR_LIT>' ) : <EOL> """<STR_LIT>""" <EOL> src_file = file ( src_path , '<STR_LIT:r>' ) <EOL> try : <EOL> source = src_file . read ( ) . decode ( encoding ) <EOL> except Exception , e : <EOL> sys . stderr . write ( "<STR_LIT>" <EOL> "<STR_LIT>" % src_path ) <EOL> raise <EOL> src_file . close ( ) <EOL> name = src_path . replace ( base_dir , '<STR_LIT>' ) <EOL> raw = env . compile ( source , name = name , filename = name , raw = True ) <EOL> dst_file = open ( dst_path , '<STR_LIT:wb>' ) <EOL> dst_file . write ( raw ) <EOL> dst_file . close ( ) <EOL> def compile_dir ( env , src_path , dst_path , pattern = r'<STR_LIT>' , <EOL> encoding = '<STR_LIT:utf-8>' , base_dir = None , <EOL> negative_pattern = r'<STR_LIT>' ) : <EOL> """<STR_LIT>""" <EOL> if base_dir is None : <EOL> base_dir = src_path <EOL> for filename in listdir ( src_path ) : <EOL> if filename . startswith ( "<STR_LIT:.>" ) : <EOL> continue <EOL> src_name = path . join ( src_path , filename ) <EOL> dst_name = path . join ( dst_path , filename ) <EOL> if path . isdir ( src_name ) : <EOL> if not path . isdir ( dst_name ) : <EOL> mkdir ( dst_name ) <EOL> compile_dir ( env , src_name , dst_name , encoding = encoding , <EOL> base_dir = base_dir ) <EOL> elif path . isfile ( src_name ) and re . match ( pattern , filename ) and not re . match ( negative_pattern , filename ) : <EOL> compile_file ( env , src_name , dst_name , encoding = encoding , <EOL> base_dir = base_dir ) </s>
<s> """<STR_LIT>""" <EOL> import api <EOL> import random <EOL> import imp <EOL> import shutil <EOL> import os <EOL> from os import path <EOL> from functools import partial <EOL> from bson import json_util <EOL> from api . common import InternalException , SevereInternalException <EOL> log = api . logger . use ( __name__ ) <EOL> modifiable_problem_fields = [ "<STR_LIT:description>" ] <EOL> seed = "<STR_LIT>" <EOL> def is_autogen_problem ( pid ) : <EOL> """<STR_LIT>""" <EOL> return api . problem . get_problem ( pid = pid ) . get ( "<STR_LIT>" , False ) <EOL> def get_metadata_path ( pid , n ) : <EOL> """<STR_LIT>""" <EOL> return path . join ( get_instance_path ( pid , n = n , public = False ) , "<STR_LIT>" ) <EOL> def write_metadata ( pid , n , data ) : <EOL> """<STR_LIT>""" <EOL> metadata_path = get_metadata_path ( pid , n ) <EOL> with open ( metadata_path , "<STR_LIT:w>" ) as f : <EOL> f . write ( json_util . dumps ( data ) ) <EOL> @ api . cache . memoize ( timeout = <NUM_LIT> , fast = True ) <EOL> def read_metadata ( pid , n ) : <EOL> """<STR_LIT>""" <EOL> metadata_path = get_metadata_path ( pid , n ) <EOL> with open ( metadata_path , "<STR_LIT:r>" ) as f : <EOL> return json_util . loads ( f . read ( ) ) <EOL> def build_problem_instances ( pid , instances ) : <EOL> """<STR_LIT>""" <EOL> problem = api . problem . get_problem ( pid = pid ) <EOL> if not is_autogen_problem ( pid ) : <EOL> raise InternalException ( "<STR_LIT>" . format ( problem [ "<STR_LIT:name>" ] ) ) <EOL> previous_state = seed_generator ( "<STR_LIT>" , pid ) <EOL> instance_path , static_instance_path = get_instance_path ( pid ) , get_static_instance_path ( pid ) <EOL> for autogen_path in [ instance_path , static_instance_path ] : <EOL> log . debug ( "<STR_LIT>" , autogen_path ) <EOL> if not path . isdir ( autogen_path ) : <EOL> log . debug ( "<STR_LIT>" ) <EOL> os . makedirs ( autogen_path ) <EOL> for n in range ( instances ) : <EOL> log . debug ( "<STR_LIT>" , problem [ "<STR_LIT:name>" ] , str ( n ) ) <EOL> build = get_generator ( pid ) . generate ( random , pid , api . autogen_tools , n ) <EOL> autogen_instance_path = get_instance_path ( pid , n = n ) <EOL> file_type_paths = { <EOL> "<STR_LIT>" : { <EOL> "<STR_LIT>" : get_instance_path ( pid , n = n , public = True ) , <EOL> "<STR_LIT>" : get_instance_path ( pid , n = n , public = False ) <EOL> } , <EOL> "<STR_LIT>" : { <EOL> "<STR_LIT>" : get_static_instance_path ( pid , public = True ) , <EOL> "<STR_LIT>" : get_static_instance_path ( pid , public = False ) <EOL> } <EOL> } <EOL> for _ , file_types in file_type_paths . items ( ) : <EOL> for _ , autogen_path in file_types . items ( ) : <EOL> if not path . isdir ( autogen_path ) : <EOL> os . makedirs ( autogen_path ) <EOL> problem_updates = build . get ( "<STR_LIT>" , None ) <EOL> if problem_updates is None : <EOL> raise InternalException ( "<STR_LIT>" . format ( problem [ "<STR_LIT>" ] ) ) <EOL> write_metadata ( pid , n , problem_updates ) <EOL> for file_type , listings in build . items ( ) : <EOL> destination_type = file_type_paths . get ( file_type , None ) <EOL> if destination_type is not None : <EOL> for listing in listings : <EOL> destination = destination_type . get ( listing , None ) <EOL> if destination is not None : <EOL> files = listings [ listing ] <EOL> for f , name in files : <EOL> if path . isfile ( f ) : <EOL> shutil . copyfile ( f , path . join ( destination , name ) ) <EOL> elif path . isdir ( f ) : <EOL> shutil . copytree ( f , autogen_instance_path ) <EOL> api . autogen_tools . clear_build_directories ( ) <EOL> log . debug ( "<STR_LIT>" ) <EOL> random . setstate ( previous_state ) <EOL> def get_generator_path ( pid ) : <EOL> """<STR_LIT>""" <EOL> problem = api . problem . get_problem ( pid = pid ) <EOL> if not is_autogen_problem ( pid ) : <EOL> raise InternalException ( "<STR_LIT>" ) <EOL> if not problem . get ( "<STR_LIT>" , False ) : <EOL> raise InternalException ( "<STR_LIT>" . format ( problem [ "<STR_LIT:name>" ] ) ) <EOL> return path . join ( api . problem . grader_base_path , problem [ "<STR_LIT>" ] ) <EOL> def get_generator ( pid ) : <EOL> """<STR_LIT>""" <EOL> generator_path = get_generator_path ( pid ) <EOL> if not path . isfile ( generator_path ) : <EOL> raise InternalException ( "<STR_LIT>" . format ( generator_path ) ) <EOL> return imp . load_source ( generator_path [ : - <NUM_LIT:3> ] , generator_path ) <EOL> def get_seed ( pid , tid ) : <EOL> """<STR_LIT>""" <EOL> return seed + tid + pid <EOL> def seed_generator ( pid , tid ) : <EOL> """<STR_LIT>""" <EOL> previous_state = random . getstate ( ) <EOL> random . seed ( get_seed ( pid , tid ) ) <EOL> return previous_state <EOL> @ api . cache . memoize ( timeout = <NUM_LIT> , fast = True ) <EOL> def get_instance_number ( pid , tid ) : <EOL> """<STR_LIT>""" <EOL> previous_state = seed_generator ( tid , pid ) <EOL> total_instances = get_number_of_instances ( pid ) <EOL> if total_instances == <NUM_LIT:0> : <EOL> raise InternalException ( "<STR_LIT>" . format ( pid ) ) <EOL> instance_number = random . randint ( <NUM_LIT:0> , total_instances - <NUM_LIT:1> ) <EOL> random . setstate ( previous_state ) <EOL> return instance_number <EOL> @ api . cache . memoize ( timeout = <NUM_LIT> , fast = True ) <EOL> def get_number_of_instances ( pid ) : <EOL> """<STR_LIT>""" <EOL> try : <EOL> return [ dirname . isdigit ( ) for dirname in os . listdir ( get_instance_path ( pid , public = False ) ) ] . count ( True ) <EOL> except FileNotFoundError : <EOL> raise InternalException ( "<STR_LIT>" ) <EOL> def get_static_instance_path ( pid , public = True ) : <EOL> """<STR_LIT>""" <EOL> return path . abspath ( path . join ( get_instance_path ( pid , public = public ) , "<STR_LIT>" ) ) <EOL> def get_instance_path ( pid , n = "<STR_LIT>" , public = True ) : <EOL> """<STR_LIT>""" <EOL> generator_path = get_generator_path ( pid ) <EOL> name = api . problem . get_problem ( pid ) [ "<STR_LIT:name>" ] <EOL> instance_path = path . join ( path . dirname ( generator_path ) , "<STR_LIT>" , name , str ( n ) ) <EOL> if public : <EOL> instance_path = path . join ( instance_path , "<STR_LIT>" ) <EOL> return path . abspath ( instance_path ) <EOL> @ api . cache . memoize ( timeout = <NUM_LIT> , fast = True ) <EOL> def get_problem_instance ( pid , tid ) : <EOL> """<STR_LIT>""" <EOL> problem = api . problem . get_problem ( pid = pid ) <EOL> n = get_instance_number ( pid , tid ) <EOL> metadata = read_metadata ( pid , n ) <EOL> if not set ( metadata ) . issubset ( modifiable_problem_fields ) : <EOL> invalid_keys = set ( metadata ) . difference ( modifiable_problem_fields ) <EOL> raise InternalException ( "<STR_LIT>" . format ( pid , invalid_keys ) ) <EOL> problem . update ( metadata ) <EOL> return problem <EOL> def grade_problem_instance ( pid , tid , key ) : <EOL> """<STR_LIT>""" <EOL> if not is_autogen_problem ( pid ) : <EOL> raise InternalException ( "<STR_LIT>" . format ( pid ) ) <EOL> problem = api . problem . get_problem ( pid ) <EOL> n = get_instance_number ( pid , tid ) <EOL> grader_problem_instance = GraderProblemInstance ( pid , tid , n ) <EOL> grader = api . problem . get_grader ( pid ) <EOL> try : <EOL> correct , message = grader . grade ( grader_problem_instance , key ) <EOL> except Exception as e : <EOL> raise SevereInternalException ( "<STR_LIT>" . format ( pid , str ( e ) ) ) <EOL> return { <EOL> "<STR_LIT>" : correct , <EOL> "<STR_LIT>" : problem [ "<STR_LIT>" ] , <EOL> "<STR_LIT:message>" : message <EOL> } <EOL> class GraderProblemInstance ( object ) : <EOL> """<STR_LIT>""" <EOL> def __init__ ( self , pid , tid , n ) : <EOL> self . instance = n <EOL> self . get_instance_path = partial ( get_instance_path , pid , n = n ) <EOL> self . seed_generator = partial ( seed_generator , pid , tid ) <EOL> self . write_metadata = partial ( write_metadata , pid , n ) <EOL> self . read_metadata = partial ( read_metadata , pid ) </s>
<s> """<STR_LIT>""" <EOL> def generate ( random , pid , tools , n ) : <EOL> """<STR_LIT>""" <EOL> f = open ( "<STR_LIT>" , "<STR_LIT:w>" ) <EOL> k = str ( random . randint ( <NUM_LIT:0> , <NUM_LIT:1000> ) ) <EOL> f . write ( k ) <EOL> f . close ( ) <EOL> return { <EOL> "<STR_LIT>" : { <EOL> "<STR_LIT>" : [ ( "<STR_LIT>" , "<STR_LIT>" ) ] , <EOL> "<STR_LIT>" : [ ( "<STR_LIT>" , "<STR_LIT>" ) ] <EOL> } , <EOL> "<STR_LIT>" : { <EOL> "<STR_LIT>" : [ ( "<STR_LIT>" , "<STR_LIT>" ) ] , <EOL> "<STR_LIT>" : [ ( "<STR_LIT>" , "<STR_LIT>" ) ] <EOL> } , <EOL> "<STR_LIT>" : { <EOL> "<STR_LIT:description>" : "<STR_LIT>" + k + "<STR_LIT>" <EOL> } <EOL> } </s>
<s> import IECore <EOL> import GafferUI <EOL> import GafferScene <EOL> import GafferSceneUI <EOL> import os <EOL> scriptNode = script <EOL> scriptWindow = GafferUI . ScriptWindow . acquire ( script ) <EOL> layout = eval ( "<STR_LIT>" ) <EOL> scriptWindow . setLayout ( layout ) <EOL> scriptWindow . _Widget__qtWidget . resize ( <NUM_LIT> , <NUM_LIT> ) <EOL> for nodeName in [ '<STR_LIT>' ] : <EOL> script . selection ( ) . add ( script . descendant ( nodeName ) ) <EOL> script . context ( ) [ "<STR_LIT>" ] = GafferScene . PathMatcherData ( GafferScene . PathMatcher ( [ '<STR_LIT:/>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) ) <EOL> script . context ( ) [ "<STR_LIT>" ] = IECore . StringVectorData ( [ "<STR_LIT>" ] ) </s>
<s> import os <EOL> import glob <EOL> import IECore <EOL> class convertAnimCache ( IECore . Op ) : <EOL> def __init__ ( self ) : <EOL> IECore . Op . __init__ ( self , "<STR_LIT>" , IECore . FileSequenceParameter ( "<STR_LIT:result>" , "<STR_LIT>" ) ) <EOL> self . parameters ( ) . addParameters ( <EOL> [ <EOL> IECore . FileSequenceParameter ( <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> defaultValue = "<STR_LIT>" , <EOL> allowEmptyString = False , <EOL> check = IECore . FileSequenceParameter . CheckType . MustExist , <EOL> extensions = "<STR_LIT>" , <EOL> ) , <EOL> IECore . FileSequenceParameter ( <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> defaultValue = "<STR_LIT>" , <EOL> allowEmptyString = False , <EOL> extensions = "<STR_LIT>" , <EOL> ) , <EOL> ] , <EOL> ) <EOL> def doOperation ( self , args ) : <EOL> src = self . parameters ( ) [ "<STR_LIT>" ] . getFileSequenceValue ( ) <EOL> dst = self . parameters ( ) [ "<STR_LIT>" ] . getFileSequenceValue ( ) <EOL> if isinstance ( dst . frameList , IECore . EmptyFrameList ) : <EOL> dst . frameList = src . frameList <EOL> for ( sf , df ) in zip ( src . fileNames ( ) , dst . fileNames ( ) ) : <EOL> sc = IECore . AttributeCache ( sf , IECore . IndexedIOOpenMode . Read ) <EOL> dc = IECore . AttributeCache ( df , IECore . IndexedIOOpenMode . Write ) <EOL> combinedBound = IECore . Box3f ( ) <EOL> for objectName in sc . objects ( ) : <EOL> p = b = None <EOL> with IECore . IgnoredExceptions ( Exception ) : <EOL> p = sc . read ( objectName , "<STR_LIT>" ) <EOL> b = sc . read ( objectName , "<STR_LIT>" ) <EOL> if p is not None and b is not None : <EOL> combinedBound . extendBy ( b . value ) <EOL> dc . write ( "<STR_LIT:->" + objectName , "<STR_LIT>" , p ) <EOL> dc . write ( "<STR_LIT:->" + objectName , "<STR_LIT>" , b ) <EOL> dc . write ( "<STR_LIT:->" , "<STR_LIT>" , IECore . Box3fData ( combinedBound ) ) <EOL> return args [ "<STR_LIT>" ] . value <EOL> IECore . registerRunTimeTyped ( convertAnimCache ) </s>
<s> import os <EOL> import unittest <EOL> import subprocess32 as subprocess <EOL> import IECore <EOL> import Gaffer <EOL> import GafferTest <EOL> import GafferScene <EOL> import GafferAppleseed <EOL> import GafferAppleseedTest <EOL> class AppleseedRenderTest ( GafferTest . TestCase ) : <EOL> def setUp ( self ) : <EOL> GafferTest . TestCase . setUp ( self ) <EOL> self . __scriptFileName = self . temporaryDirectory ( ) + "<STR_LIT>" <EOL> def testExecute ( self ) : <EOL> s = Gaffer . ScriptNode ( ) <EOL> s [ "<STR_LIT>" ] = GafferScene . Plane ( ) <EOL> s [ "<STR_LIT>" ] = GafferAppleseed . AppleseedRender ( ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setValue ( "<STR_LIT>" ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( s [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) <EOL> s [ "<STR_LIT>" ] = Gaffer . Expression ( ) <EOL> s [ "<STR_LIT>" ] . setExpression ( "<STR_LIT>" + self . temporaryDirectory ( ) + "<STR_LIT>" ) <EOL> s [ "<STR_LIT>" ] . setValue ( self . __scriptFileName ) <EOL> s . save ( ) <EOL> p = subprocess . Popen ( <EOL> "<STR_LIT>" + self . __scriptFileName + "<STR_LIT>" , <EOL> shell = True , <EOL> stderr = subprocess . PIPE , <EOL> ) <EOL> p . wait ( ) <EOL> self . failIf ( p . returncode ) <EOL> for i in range ( <NUM_LIT:1> , <NUM_LIT:4> ) : <EOL> self . failUnless ( os . path . exists ( self . temporaryDirectory ( ) + "<STR_LIT>" % i ) ) <EOL> def testWaitForImage ( self ) : <EOL> s = Gaffer . ScriptNode ( ) <EOL> s [ "<STR_LIT>" ] = GafferScene . Plane ( ) <EOL> s [ "<STR_LIT>" ] = GafferScene . Outputs ( ) <EOL> s [ "<STR_LIT>" ] . addOutput ( <EOL> "<STR_LIT>" , <EOL> IECore . Display ( <EOL> self . temporaryDirectory ( ) + "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> { } <EOL> ) <EOL> ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( s [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) <EOL> s [ "<STR_LIT>" ] = GafferAppleseed . AppleseedRender ( ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( s [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setValue ( "<STR_LIT>" ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setValue ( self . temporaryDirectory ( ) + "<STR_LIT>" ) <EOL> s [ "<STR_LIT>" ] . setValue ( self . __scriptFileName ) <EOL> s . save ( ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] . execute ( ) <EOL> self . failUnless ( os . path . exists ( self . temporaryDirectory ( ) + "<STR_LIT>" ) ) <EOL> def testExecuteWithStringSubstitutions ( self ) : <EOL> s = Gaffer . ScriptNode ( ) <EOL> s [ "<STR_LIT>" ] = GafferScene . Plane ( ) <EOL> s [ "<STR_LIT>" ] = GafferAppleseed . AppleseedRender ( ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setValue ( "<STR_LIT>" ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( s [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setValue ( self . temporaryDirectory ( ) + "<STR_LIT>" ) <EOL> s [ "<STR_LIT>" ] . setValue ( self . __scriptFileName ) <EOL> s . save ( ) <EOL> p = subprocess . Popen ( <EOL> "<STR_LIT>" + self . __scriptFileName + "<STR_LIT>" , <EOL> shell = True , <EOL> stderr = subprocess . PIPE , <EOL> ) <EOL> p . wait ( ) <EOL> self . failIf ( p . returncode ) <EOL> for i in range ( <NUM_LIT:1> , <NUM_LIT:4> ) : <EOL> self . failUnless ( os . path . exists ( self . temporaryDirectory ( ) + "<STR_LIT>" % i ) ) <EOL> def testImageOutput ( self ) : <EOL> s = Gaffer . ScriptNode ( ) <EOL> s [ "<STR_LIT>" ] = GafferScene . Plane ( ) <EOL> s [ "<STR_LIT>" ] = GafferScene . Outputs ( ) <EOL> s [ "<STR_LIT>" ] . addOutput ( <EOL> "<STR_LIT>" , <EOL> IECore . Display ( <EOL> self . temporaryDirectory ( ) + "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> { } <EOL> ) <EOL> ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( s [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) <EOL> s [ "<STR_LIT>" ] = GafferAppleseed . AppleseedRender ( ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( s [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setValue ( "<STR_LIT>" ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setValue ( self . temporaryDirectory ( ) + "<STR_LIT>" ) <EOL> s [ "<STR_LIT>" ] . setValue ( self . __scriptFileName ) <EOL> s . save ( ) <EOL> c = Gaffer . Context ( ) <EOL> for i in range ( <NUM_LIT:1> , <NUM_LIT:4> ) : <EOL> c . setFrame ( i ) <EOL> with c : <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] . execute ( ) <EOL> for i in range ( <NUM_LIT:1> , <NUM_LIT:4> ) : <EOL> self . failUnless ( os . path . exists ( self . temporaryDirectory ( ) + "<STR_LIT>" % i ) ) <EOL> def testTypeNamePrefixes ( self ) : <EOL> self . assertTypeNamesArePrefixed ( GafferAppleseed ) <EOL> self . assertTypeNamesArePrefixed ( GafferAppleseedTest ) <EOL> def testDefaultNames ( self ) : <EOL> self . assertDefaultNamesAreCorrect ( GafferAppleseed ) <EOL> self . assertDefaultNamesAreCorrect ( GafferAppleseedTest ) <EOL> def testNodesConstructWithDefaultValues ( self ) : <EOL> self . assertNodesConstructWithDefaultValues ( GafferAppleseed ) <EOL> self . assertNodesConstructWithDefaultValues ( GafferAppleseedTest ) <EOL> def testDirectoryCreation ( self ) : <EOL> s = Gaffer . ScriptNode ( ) <EOL> s [ "<STR_LIT>" ] . addMember ( "<STR_LIT>" , self . temporaryDirectory ( ) + "<STR_LIT>" ) <EOL> s [ "<STR_LIT>" ] . addMember ( "<STR_LIT>" , self . temporaryDirectory ( ) + "<STR_LIT>" ) <EOL> s [ "<STR_LIT>" ] = GafferScene . Plane ( ) <EOL> s [ "<STR_LIT>" ] = GafferScene . Outputs ( ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( s [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) <EOL> s [ "<STR_LIT>" ] . addOutput ( <EOL> "<STR_LIT>" , <EOL> IECore . Display ( <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> { } <EOL> ) <EOL> ) <EOL> s [ "<STR_LIT>" ] = GafferAppleseed . AppleseedRender ( ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( s [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setValue ( "<STR_LIT>" ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setValue ( "<STR_LIT>" ) <EOL> self . assertFalse ( os . path . exists ( self . temporaryDirectory ( ) + "<STR_LIT>" ) ) <EOL> self . assertFalse ( os . path . exists ( self . temporaryDirectory ( ) + "<STR_LIT>" ) ) <EOL> self . assertFalse ( os . path . exists ( self . temporaryDirectory ( ) + "<STR_LIT>" ) ) <EOL> self . assertFalse ( os . path . exists ( self . __scriptFileName ) ) <EOL> s [ "<STR_LIT>" ] . setValue ( self . __scriptFileName ) <EOL> s . save ( ) <EOL> with s . context ( ) : <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] . execute ( ) <EOL> self . assertTrue ( os . path . exists ( self . temporaryDirectory ( ) + "<STR_LIT>" ) ) <EOL> self . assertTrue ( os . path . exists ( self . temporaryDirectory ( ) + "<STR_LIT>" ) ) <EOL> self . assertTrue ( os . path . exists ( self . temporaryDirectory ( ) + "<STR_LIT>" ) ) <EOL> self . assertTrue ( os . path . exists ( self . __scriptFileName ) ) <EOL> with s . context ( ) : <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] . execute ( ) <EOL> self . assertTrue ( os . path . exists ( self . temporaryDirectory ( ) + "<STR_LIT>" ) ) <EOL> self . assertTrue ( os . path . exists ( self . temporaryDirectory ( ) + "<STR_LIT>" ) ) <EOL> self . assertTrue ( os . path . exists ( self . temporaryDirectory ( ) + "<STR_LIT>" ) ) <EOL> if __name__ == "<STR_LIT:__main__>" : <EOL> unittest . main ( ) </s>
<s> import GafferUITest <EOL> import GafferScene <EOL> import GafferSceneUI <EOL> import GafferArnold <EOL> import GafferArnoldUI <EOL> class DocumentationTest ( GafferUITest . TestCase ) : <EOL> def test ( self ) : <EOL> self . maxDiff = None <EOL> self . assertNodesAreDocumented ( <EOL> GafferArnold , <EOL> additionalTerminalPlugTypes = ( GafferScene . ScenePlug , ) <EOL> ) <EOL> if __name__ == "<STR_LIT:__main__>" : <EOL> unittest . main ( ) </s>
<s> import IECore <EOL> class parameterChangedCallback ( IECore . Parameterised ) : <EOL> def __init__ ( self ) : <EOL> IECore . Parameterised . __init__ ( self , "<STR_LIT>" ) <EOL> self . parameters ( ) . addParameters ( <EOL> [ <EOL> IECore . IntParameter ( <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> <NUM_LIT:0> <EOL> ) , <EOL> IECore . IntParameter ( <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> <NUM_LIT:0> <EOL> ) , <EOL> ] , <EOL> ) <EOL> self . changes = [ ] <EOL> def parameterChanged ( self , parameter ) : <EOL> self . changes . append ( ( parameter , str ( parameter . getValue ( ) ) ) ) <EOL> if parameter . isSame ( self . parameters ( ) [ "<STR_LIT>" ] ) : <EOL> self . parameters ( ) [ "<STR_LIT>" ] . setNumericValue ( self . parameters ( ) [ "<STR_LIT>" ] . getNumericValue ( ) * <NUM_LIT:5> ) <EOL> IECore . registerRunTimeTyped ( parameterChangedCallback ) </s>
<s> import GafferUI <EOL> import GafferCortexUI <EOL> class ToolParameterValueWidget ( GafferCortexUI . ParameterValueWidget ) : <EOL> def __init__ ( self , parameterHandler , parenting = None ) : <EOL> GafferCortexUI . ParameterValueWidget . __init__ ( <EOL> self , <EOL> GafferUI . ToolPlugValueWidget ( parameterHandler . plug ( ) ) , <EOL> parameterHandler , <EOL> parenting = parenting <EOL> ) </s>
<s> import os <EOL> import IECore <EOL> import Gaffer <EOL> import GafferDispatch <EOL> class TextWriter ( GafferDispatch . ExecutableNode ) : <EOL> def __init__ ( self , name = "<STR_LIT>" , requiresSequenceExecution = False ) : <EOL> GafferDispatch . ExecutableNode . __init__ ( self , name ) <EOL> self . __requiresSequenceExecution = requiresSequenceExecution <EOL> self . addChild ( Gaffer . StringPlug ( "<STR_LIT>" , Gaffer . Plug . Direction . In ) ) <EOL> self . addChild ( Gaffer . StringPlug ( "<STR_LIT>" , defaultValue = "<STR_LIT:w>" , direction = Gaffer . Plug . Direction . In ) ) <EOL> self . addChild ( Gaffer . StringPlug ( "<STR_LIT:text>" , Gaffer . Plug . Direction . In ) ) <EOL> def execute ( self ) : <EOL> context = Gaffer . Context . current ( ) <EOL> fileName = self [ "<STR_LIT>" ] . getValue ( ) <EOL> directory = os . path . dirname ( fileName ) <EOL> if directory : <EOL> try : <EOL> os . makedirs ( directory ) <EOL> except OSError : <EOL> if not os . path . isdir ( directory ) : <EOL> raise <EOL> text = self . __processText ( context ) <EOL> with file ( fileName , self [ "<STR_LIT>" ] . getValue ( ) ) as f : <EOL> f . write ( text ) <EOL> def executeSequence ( self , frames ) : <EOL> if not self . __requiresSequenceExecution : <EOL> GafferDispatch . ExecutableNode . executeSequence ( self , frames ) <EOL> return <EOL> context = Gaffer . Context ( Gaffer . Context . current ( ) ) <EOL> fileName = self [ "<STR_LIT>" ] . getValue ( ) <EOL> with file ( fileName , self [ "<STR_LIT>" ] . getValue ( ) ) as f : <EOL> with context : <EOL> for frame in frames : <EOL> context . setFrame ( frame ) <EOL> text = self . __processText ( context ) <EOL> f . write ( text ) <EOL> def hash ( self , context ) : <EOL> h = GafferDispatch . ExecutableNode . hash ( self , context ) <EOL> h . append ( context . getFrame ( ) ) <EOL> h . append ( context . get ( "<STR_LIT>" , IECore . StringVectorData ( ) ) ) <EOL> self [ "<STR_LIT>" ] . hash ( h ) <EOL> self [ "<STR_LIT>" ] . hash ( h ) <EOL> self [ "<STR_LIT:text>" ] . hash ( h ) <EOL> return h <EOL> def requiresSequenceExecution ( self ) : <EOL> return self . __requiresSequenceExecution <EOL> def __processText ( self , context ) : <EOL> text = self [ "<STR_LIT:text>" ] . getValue ( ) <EOL> replace = context . get ( "<STR_LIT>" , IECore . StringVectorData ( ) ) <EOL> if replace and len ( replace ) == <NUM_LIT:2> : <EOL> text = text . replace ( replace [ <NUM_LIT:0> ] , replace [ <NUM_LIT:1> ] ) <EOL> return text <EOL> IECore . registerRunTimeTyped ( TextWriter , typeName = "<STR_LIT>" ) </s>
<s> import os <EOL> import IECore <EOL> import Gaffer <EOL> import GafferImage <EOL> import GafferTest <EOL> import GafferImageTest <EOL> class CopyImageMetadataTest ( GafferImageTest . ImageTestCase ) : <EOL> checkerFile = os . path . expandvars ( "<STR_LIT>" ) <EOL> def test ( self ) : <EOL> r = GafferImage . ImageReader ( ) <EOL> r [ "<STR_LIT>" ] . setValue ( self . checkerFile ) <EOL> inMetadata = r [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) <EOL> d = GafferImage . DeleteImageMetadata ( ) <EOL> d [ "<STR_LIT>" ] . setInput ( r [ "<STR_LIT>" ] ) <EOL> d [ "<STR_LIT>" ] . setValue ( "<STR_LIT:*>" ) <EOL> m = GafferImage . CopyImageMetadata ( ) <EOL> m [ "<STR_LIT>" ] . setInput ( d [ "<STR_LIT>" ] ) <EOL> m [ "<STR_LIT>" ] . setInput ( r [ "<STR_LIT>" ] ) <EOL> m [ "<STR_LIT>" ] . setValue ( "<STR_LIT>" ) <EOL> metadata = m [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) <EOL> self . assertEqual ( m [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) , IECore . CompoundObject ( ) ) <EOL> self . assertEqual ( m [ "<STR_LIT>" ] . image ( ) , d [ "<STR_LIT>" ] . image ( ) ) <EOL> m [ "<STR_LIT>" ] . setValue ( "<STR_LIT>" ) <EOL> metadata = m [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) <EOL> expected = set ( [ "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ] ) <EOL> self . assertEqual ( set ( metadata . keys ( ) ) , expected ) <EOL> for key in metadata . keys ( ) : <EOL> self . assertEqual ( metadata [ key ] , inMetadata [ key ] ) <EOL> m [ "<STR_LIT>" ] . setValue ( True ) <EOL> metadata = m [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) <EOL> expected = set ( [ "<STR_LIT>" , "<STR_LIT>" ] ) <EOL> self . assertEqual ( set ( metadata . keys ( ) ) , expected ) <EOL> for key in metadata . keys ( ) : <EOL> self . assertEqual ( metadata [ key ] , inMetadata [ key ] ) <EOL> def testOverwrite ( self ) : <EOL> r = GafferImage . ImageReader ( ) <EOL> r [ "<STR_LIT>" ] . setValue ( self . checkerFile ) <EOL> inMetadata = r [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) <EOL> a = GafferImage . ImageMetadata ( ) <EOL> a [ "<STR_LIT>" ] . addMember ( "<STR_LIT>" , IECore . StringData ( "<STR_LIT>" ) ) <EOL> m = GafferImage . CopyImageMetadata ( ) <EOL> m [ "<STR_LIT>" ] . setInput ( r [ "<STR_LIT>" ] ) <EOL> m [ "<STR_LIT>" ] . setInput ( a [ "<STR_LIT>" ] ) <EOL> m [ "<STR_LIT>" ] . setValue ( "<STR_LIT>" ) <EOL> metadata = m [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) <EOL> self . assertEqual ( metadata [ "<STR_LIT>" ] , IECore . StringData ( "<STR_LIT>" ) ) <EOL> self . assertEqual ( m [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) , inMetadata ) <EOL> self . assertEqual ( m [ "<STR_LIT>" ] . image ( ) , r [ "<STR_LIT>" ] . image ( ) ) <EOL> m [ "<STR_LIT>" ] . setValue ( "<STR_LIT>" ) <EOL> metadata = m [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) <EOL> self . assertTrue ( "<STR_LIT>" in metadata . keys ( ) ) <EOL> self . assertEqual ( metadata [ "<STR_LIT>" ] , IECore . StringData ( "<STR_LIT>" ) ) <EOL> def testDirtyPropogation ( self ) : <EOL> c = GafferImage . Constant ( ) <EOL> r = GafferImage . ImageReader ( ) <EOL> r [ "<STR_LIT>" ] . setValue ( self . checkerFile ) <EOL> inMetadata = r [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) <EOL> m = GafferImage . CopyImageMetadata ( ) <EOL> m [ "<STR_LIT>" ] . setInput ( c [ "<STR_LIT>" ] ) <EOL> m [ "<STR_LIT>" ] . setInput ( r [ "<STR_LIT>" ] ) <EOL> cs = GafferTest . CapturingSlot ( m . plugDirtiedSignal ( ) ) <EOL> m [ "<STR_LIT>" ] . setInput ( c [ "<STR_LIT>" ] ) <EOL> self . assertTrue ( m [ "<STR_LIT>" ] [ "<STR_LIT>" ] in set ( e [ <NUM_LIT:0> ] for e in cs ) ) <EOL> del cs [ : ] <EOL> m [ "<STR_LIT>" ] . setValue ( "<STR_LIT:test>" ) <EOL> self . assertTrue ( m [ "<STR_LIT>" ] [ "<STR_LIT>" ] in set ( e [ <NUM_LIT:0> ] for e in cs ) ) <EOL> del cs [ : ] <EOL> m [ "<STR_LIT>" ] . setValue ( True ) <EOL> self . assertTrue ( m [ "<STR_LIT>" ] [ "<STR_LIT>" ] in set ( e [ <NUM_LIT:0> ] for e in cs ) ) <EOL> def testPassThrough ( self ) : <EOL> c = GafferImage . Constant ( ) <EOL> i = GafferImage . ImageReader ( ) <EOL> i [ "<STR_LIT>" ] . setValue ( self . checkerFile ) <EOL> m = GafferImage . CopyImageMetadata ( ) <EOL> m [ "<STR_LIT>" ] . setInput ( i [ "<STR_LIT>" ] ) <EOL> m [ "<STR_LIT>" ] . setValue ( "<STR_LIT:*>" ) <EOL> self . assertEqual ( i [ "<STR_LIT>" ] [ "<STR_LIT>" ] . hash ( ) , m [ "<STR_LIT>" ] [ "<STR_LIT>" ] . hash ( ) ) <EOL> self . assertEqual ( i [ "<STR_LIT>" ] [ "<STR_LIT>" ] . hash ( ) , m [ "<STR_LIT>" ] [ "<STR_LIT>" ] . hash ( ) ) <EOL> self . assertEqual ( i [ "<STR_LIT>" ] [ "<STR_LIT>" ] . hash ( ) , m [ "<STR_LIT>" ] [ "<STR_LIT>" ] . hash ( ) ) <EOL> self . assertEqual ( i [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) , m [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) ) <EOL> self . assertEqual ( i [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) , m [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) ) <EOL> self . assertEqual ( i [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) , m [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) ) <EOL> context = Gaffer . Context ( ) <EOL> context [ "<STR_LIT>" ] = IECore . V2i ( <NUM_LIT:0> ) <EOL> with context : <EOL> for c in [ "<STR_LIT>" , "<STR_LIT:B>" , "<STR_LIT:A>" ] : <EOL> context [ "<STR_LIT>" ] = c <EOL> self . assertEqual ( i [ "<STR_LIT>" ] [ "<STR_LIT>" ] . hash ( ) , m [ "<STR_LIT>" ] [ "<STR_LIT>" ] . hash ( ) ) <EOL> self . assertEqual ( i [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) , m [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) ) <EOL> if __name__ == "<STR_LIT:__main__>" : <EOL> unittest . main ( ) </s>
<s> import os <EOL> import unittest <EOL> import IECore <EOL> import Gaffer <EOL> import GafferImage <EOL> import GafferImageTest <EOL> class ObjectToImageTest ( GafferImageTest . ImageTestCase ) : <EOL> fileName = os . path . expandvars ( "<STR_LIT>" ) <EOL> negFileName = os . path . expandvars ( "<STR_LIT>" ) <EOL> def test ( self ) : <EOL> i = IECore . Reader . create ( self . fileName ) . read ( ) <EOL> n = GafferImage . ObjectToImage ( ) <EOL> n [ "<STR_LIT:object>" ] . setValue ( i ) <EOL> self . assertEqual ( n [ "<STR_LIT>" ] . image ( ) , i ) <EOL> def testImageWithANegativeDataWindow ( self ) : <EOL> i = IECore . Reader . create ( self . negFileName ) . read ( ) <EOL> n = GafferImage . ObjectToImage ( ) <EOL> n [ "<STR_LIT:object>" ] . setValue ( i ) <EOL> self . assertEqual ( n [ "<STR_LIT>" ] . image ( ) , i ) <EOL> def testHashVariesPerTileAndChannel ( self ) : <EOL> n = GafferImage . ObjectToImage ( ) <EOL> n [ "<STR_LIT:object>" ] . setValue ( IECore . Reader . create ( self . fileName ) . read ( ) ) <EOL> self . assertNotEqual ( <EOL> n [ "<STR_LIT>" ] . channelDataHash ( "<STR_LIT:R>" , IECore . V2i ( <NUM_LIT:0> ) ) , <EOL> n [ "<STR_LIT>" ] . channelDataHash ( "<STR_LIT>" , IECore . V2i ( <NUM_LIT:0> ) ) <EOL> ) <EOL> self . assertNotEqual ( <EOL> n [ "<STR_LIT>" ] . channelDataHash ( "<STR_LIT:R>" , IECore . V2i ( <NUM_LIT:0> ) ) , <EOL> n [ "<STR_LIT>" ] . channelDataHash ( "<STR_LIT:R>" , IECore . V2i ( GafferImage . ImagePlug . tileSize ( ) ) ) <EOL> ) <EOL> if __name__ == "<STR_LIT:__main__>" : <EOL> unittest . main ( ) </s>
<s> import threading <EOL> import IECore <EOL> import Gaffer <EOL> import GafferUI <EOL> import GafferImage <EOL> __all__ = [ ] <EOL> Gaffer . Metadata . registerNode ( <EOL> GafferImage . Display , <EOL> "<STR_LIT:description>" , <EOL> """<STR_LIT>""" , <EOL> plugs = { <EOL> "<STR_LIT:port>" : [ <EOL> "<STR_LIT:description>" , <EOL> """<STR_LIT>""" , <EOL> ] , <EOL> } <EOL> ) <EOL> __plugsPendingUpdate = [ ] <EOL> __plugsPendingUpdateLock = threading . Lock ( ) <EOL> def __scheduleUpdate ( plug , force = False ) : <EOL> if not force : <EOL> global __plugsPendingUpdate <EOL> global __plugsPendingUpdateLock <EOL> with __plugsPendingUpdateLock : <EOL> for p in __plugsPendingUpdate : <EOL> if plug . isSame ( p ) : <EOL> return <EOL> __plugsPendingUpdate . append ( plug ) <EOL> GafferUI . EventLoop . executeOnUIThread ( lambda : __update ( plug ) ) <EOL> def __update ( plug ) : <EOL> node = plug . node ( ) <EOL> if node : <EOL> updateCountPlug = node [ "<STR_LIT>" ] <EOL> updateCountPlug . setValue ( updateCountPlug . getValue ( ) + <NUM_LIT:1> ) <EOL> global __plugsPendingUpdate <EOL> global __plugsPendingUpdateLock <EOL> with __plugsPendingUpdateLock : <EOL> __plugsPendingUpdate = [ p for p in __plugsPendingUpdate if not p . isSame ( plug ) ] <EOL> __displayDataReceivedConnection = GafferImage . Display . dataReceivedSignal ( ) . connect ( __scheduleUpdate ) <EOL> __displayImageReceivedConnection = GafferImage . Display . imageReceivedSignal ( ) . connect ( IECore . curry ( __scheduleUpdate , force = True ) ) </s>
<s> from _GafferImageUI import * <EOL> import DisplayUI <EOL> from FormatPlugValueWidget import FormatPlugValueWidget <EOL> from ChannelMaskPlugValueWidget import ChannelMaskPlugValueWidget <EOL> import OpenImageIOReaderUI <EOL> import ImageReaderUI <EOL> import ImageViewToolbar <EOL> import ImageTransformUI <EOL> import ConstantUI <EOL> import ImageSwitchUI <EOL> import ColorSpaceUI <EOL> import ImageContextVariablesUI <EOL> import ImageStatsUI <EOL> import DeleteChannelsUI <EOL> import ObjectToImageUI <EOL> import ClampUI <EOL> import ImageWriterUI <EOL> import GradeUI <EOL> import ImageTimeWarpUI <EOL> import ImageSamplerUI <EOL> import MergeUI <EOL> import ImageNodeUI <EOL> import ChannelDataProcessorUI <EOL> import ImageProcessorUI <EOL> import ImageMetadataUI <EOL> import DeleteImageMetadataUI <EOL> import CopyImageMetadataUI <EOL> import ImageLoopUI <EOL> import ShuffleUI <EOL> import PremultiplyUI <EOL> import UnpremultiplyUI <EOL> import CropUI <EOL> import ResizeUI <EOL> import ResampleUI <EOL> import LUTUI <EOL> import CDLUI <EOL> import DisplayTransformUI <EOL> import OffsetUI <EOL> import BlurUI <EOL> import ShapeUI <EOL> import TextUI <EOL> import WarpUI <EOL> import UVWarpUI <EOL> __import__ ( "<STR_LIT>" ) . loadConfig ( "<STR_LIT>" , { } , subdirectory = "<STR_LIT>" ) </s>
<s> import os <EOL> import unittest <EOL> import IECore <EOL> import Gaffer <EOL> import GafferTest <EOL> import GafferScene <EOL> import GafferSceneTest <EOL> import GafferRenderMan <EOL> import GafferRenderManTest <EOL> class RenderManShaderTest ( GafferRenderManTest . RenderManTestCase ) : <EOL> def setUp ( self ) : <EOL> GafferRenderManTest . RenderManTestCase . setUp ( self ) <EOL> GafferRenderMan . RenderManShader . shaderLoader ( ) . clear ( ) <EOL> def test ( self ) : <EOL> n = GafferRenderMan . RenderManShader ( ) <EOL> n . loadShader ( "<STR_LIT>" ) <EOL> self . failUnless ( isinstance ( n [ "<STR_LIT>" ] [ "<STR_LIT>" ] , Gaffer . FloatPlug ) ) <EOL> self . failUnless ( isinstance ( n [ "<STR_LIT>" ] [ "<STR_LIT>" ] , Gaffer . FloatPlug ) ) <EOL> self . failUnless ( isinstance ( n [ "<STR_LIT>" ] [ "<STR_LIT>" ] , Gaffer . FloatPlug ) ) <EOL> self . failUnless ( isinstance ( n [ "<STR_LIT>" ] [ "<STR_LIT>" ] , Gaffer . FloatPlug ) ) <EOL> self . failUnless ( isinstance ( n [ "<STR_LIT>" ] [ "<STR_LIT>" ] , Gaffer . Color3fPlug ) ) <EOL> self . assertEqual ( n [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) , <NUM_LIT:0.5> ) <EOL> self . assertEqual ( n [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) , <NUM_LIT:0.5> ) <EOL> self . assertEqual ( n [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) , <NUM_LIT:1> ) <EOL> self . assertAlmostEqual ( n [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) , <NUM_LIT:0.1> ) <EOL> self . assertEqual ( n [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) , IECore . Color3f ( <NUM_LIT:1> ) ) <EOL> def testSerialisation ( self ) : <EOL> s = Gaffer . ScriptNode ( ) <EOL> s [ "<STR_LIT:n>" ] = GafferRenderMan . RenderManShader ( ) <EOL> s [ "<STR_LIT:n>" ] . loadShader ( "<STR_LIT>" ) <EOL> ss = s . serialise ( ) <EOL> s = Gaffer . ScriptNode ( ) <EOL> s . execute ( ss ) <EOL> st = s [ "<STR_LIT:n>" ] . state ( ) <EOL> self . assertEqual ( len ( st ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( st [ <NUM_LIT:0> ] . type , "<STR_LIT>" ) <EOL> self . assertEqual ( st [ <NUM_LIT:0> ] . name , "<STR_LIT>" ) <EOL> self . failUnless ( isinstance ( s [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] , Gaffer . FloatPlug ) ) <EOL> self . failUnless ( isinstance ( s [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] , Gaffer . FloatPlug ) ) <EOL> self . failUnless ( isinstance ( s [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] , Gaffer . FloatPlug ) ) <EOL> self . failUnless ( isinstance ( s [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] , Gaffer . FloatPlug ) ) <EOL> self . failUnless ( isinstance ( s [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] , Gaffer . Color3fPlug ) ) <EOL> self . assertTrue ( "<STR_LIT>" not in s [ "<STR_LIT:n>" ] ) <EOL> def testShader ( self ) : <EOL> n = GafferRenderMan . RenderManShader ( ) <EOL> n . loadShader ( "<STR_LIT>" ) <EOL> s = n . state ( ) <EOL> self . assertEqual ( len ( s ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( s [ <NUM_LIT:0> ] . type , "<STR_LIT>" ) <EOL> self . assertEqual ( s [ <NUM_LIT:0> ] . name , "<STR_LIT>" ) <EOL> self . assertEqual ( s [ <NUM_LIT:0> ] . parameters [ "<STR_LIT>" ] , IECore . FloatData ( <NUM_LIT> ) ) <EOL> self . assertEqual ( s [ <NUM_LIT:0> ] . parameters [ "<STR_LIT>" ] , IECore . FloatData ( <NUM_LIT> ) ) <EOL> self . assertEqual ( s [ <NUM_LIT:0> ] . parameters [ "<STR_LIT>" ] , IECore . FloatData ( <NUM_LIT:1> ) ) <EOL> self . assertEqual ( s [ <NUM_LIT:0> ] . parameters [ "<STR_LIT>" ] , IECore . FloatData ( <NUM_LIT> ) ) <EOL> self . assertEqual ( s [ <NUM_LIT:0> ] . parameters [ "<STR_LIT>" ] , IECore . Color3fData ( IECore . Color3f ( <NUM_LIT:1> ) ) ) <EOL> def testShaderHash ( self ) : <EOL> n = GafferRenderMan . RenderManShader ( ) <EOL> n . loadShader ( "<STR_LIT>" ) <EOL> h1 = n . stateHash ( ) <EOL> n [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setValue ( <NUM_LIT> ) <EOL> self . assertNotEqual ( n . stateHash ( ) , h1 ) <EOL> def testCoshaderHash ( self ) : <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> shaderNode = GafferRenderMan . RenderManShader ( ) <EOL> shaderNode . loadShader ( shader ) <EOL> self . assertTrue ( "<STR_LIT>" in shaderNode [ "<STR_LIT>" ] ) <EOL> self . assertEqual ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . typeId ( ) , Gaffer . Plug . staticTypeId ( ) ) <EOL> coshader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> coshaderNode = GafferRenderMan . RenderManShader ( ) <EOL> coshaderNode . loadShader ( coshader ) <EOL> shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( coshaderNode [ "<STR_LIT>" ] ) <EOL> h1 = shaderNode . stateHash ( ) <EOL> coshaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setValue ( <NUM_LIT> ) <EOL> self . assertNotEqual ( shaderNode . stateHash ( ) , h1 ) <EOL> def testParameterOrdering ( self ) : <EOL> n = GafferRenderMan . RenderManShader ( ) <EOL> n . loadShader ( "<STR_LIT>" ) <EOL> self . assertEqual ( n [ "<STR_LIT>" ] [ <NUM_LIT:0> ] . getName ( ) , "<STR_LIT>" ) <EOL> self . assertEqual ( n [ "<STR_LIT>" ] [ <NUM_LIT:1> ] . getName ( ) , "<STR_LIT>" ) <EOL> self . assertEqual ( n [ "<STR_LIT>" ] [ <NUM_LIT:2> ] . getName ( ) , "<STR_LIT>" ) <EOL> self . assertEqual ( n [ "<STR_LIT>" ] [ <NUM_LIT:3> ] . getName ( ) , "<STR_LIT>" ) <EOL> self . assertEqual ( n [ "<STR_LIT>" ] [ <NUM_LIT:4> ] . getName ( ) , "<STR_LIT>" ) <EOL> n = GafferRenderMan . RenderManShader ( ) <EOL> n . loadShader ( "<STR_LIT>" ) <EOL> self . assertEqual ( n [ "<STR_LIT>" ] [ <NUM_LIT:0> ] . getName ( ) , "<STR_LIT>" ) <EOL> self . assertEqual ( n [ "<STR_LIT>" ] [ <NUM_LIT:1> ] . getName ( ) , "<STR_LIT>" ) <EOL> def testCoshader ( self ) : <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> shaderNode = GafferRenderMan . RenderManShader ( ) <EOL> shaderNode . loadShader ( shader ) <EOL> self . assertTrue ( "<STR_LIT>" in shaderNode [ "<STR_LIT>" ] ) <EOL> self . assertEqual ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . typeId ( ) , Gaffer . Plug . staticTypeId ( ) ) <EOL> coshader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> coshaderNode = GafferRenderMan . RenderManShader ( ) <EOL> coshaderNode . loadShader ( coshader ) <EOL> shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( coshaderNode [ "<STR_LIT>" ] ) <EOL> s = shaderNode . state ( ) <EOL> self . assertEqual ( len ( s ) , <NUM_LIT:2> ) <EOL> self . assertEqual ( s [ <NUM_LIT:0> ] . name , coshader ) <EOL> self . assertEqual ( s [ <NUM_LIT:1> ] . name , shader ) <EOL> self . assertEqual ( s [ <NUM_LIT:0> ] . parameters [ "<STR_LIT>" ] , s [ <NUM_LIT:1> ] . parameters [ "<STR_LIT>" ] ) <EOL> def testInputAcceptance ( self ) : <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> shaderNode = GafferRenderMan . RenderManShader ( ) <EOL> shaderNode . loadShader ( shader ) <EOL> coshader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> coshaderNode = GafferRenderMan . RenderManShader ( ) <EOL> coshaderNode . loadShader ( coshader ) <EOL> random = Gaffer . Random ( ) <EOL> self . assertTrue ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . acceptsInput ( coshaderNode [ "<STR_LIT>" ] ) ) <EOL> self . assertFalse ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . acceptsInput ( random [ "<STR_LIT>" ] ) ) <EOL> self . assertTrue ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . acceptsInput ( random [ "<STR_LIT>" ] ) ) <EOL> self . assertFalse ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . acceptsInput ( coshaderNode [ "<STR_LIT>" ] ) ) <EOL> self . assertTrue ( coshaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . acceptsInput ( random [ "<STR_LIT>" ] ) ) <EOL> self . assertFalse ( coshaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . acceptsInput ( coshaderNode [ "<STR_LIT>" ] ) ) <EOL> def testParameterDefaultValue ( self ) : <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> shaderNode = GafferRenderMan . RenderManShader ( ) <EOL> shaderNode . loadShader ( shader ) <EOL> self . assertEqual ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . defaultValue ( ) , <NUM_LIT:1> ) <EOL> def testParameterMinMax ( self ) : <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> shaderNode = GafferRenderMan . RenderManShader ( ) <EOL> shaderNode . loadShader ( shader ) <EOL> self . assertEqual ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . minValue ( ) , - <NUM_LIT:1> ) <EOL> self . assertEqual ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . maxValue ( ) , <NUM_LIT:10> ) <EOL> def testReload ( self ) : <EOL> shader1 = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> shaderNode = GafferRenderMan . RenderManShader ( ) <EOL> shaderNode . loadShader ( shader1 ) <EOL> shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setValue ( <NUM_LIT:0.1> ) <EOL> shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setValue ( "<STR_LIT:test>" ) <EOL> shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setValue ( IECore . Color3f ( <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> ) ) <EOL> self . assertAlmostEqual ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) , <NUM_LIT:0.1> ) <EOL> self . assertEqual ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) , "<STR_LIT:test>" ) <EOL> self . assertEqual ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) , IECore . Color3f ( <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> ) ) <EOL> shader2 = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> shaderNode . loadShader ( shader2 , keepExistingValues = True ) <EOL> self . assertEqual ( shaderNode [ "<STR_LIT>" ] . keys ( ) , [ "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ] ) <EOL> self . assertAlmostEqual ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) , <NUM_LIT:0.1> ) <EOL> self . assertEqual ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) , "<STR_LIT:test>" ) <EOL> self . assertEqual ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) , IECore . Color3f ( <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> ) ) <EOL> shaderNode . loadShader ( shader1 , keepExistingValues = True ) <EOL> self . assertEqual ( shaderNode [ "<STR_LIT>" ] . keys ( ) , [ "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ] ) <EOL> self . assertAlmostEqual ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) , <NUM_LIT:0.1> ) <EOL> self . assertEqual ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) , "<STR_LIT:test>" ) <EOL> self . assertEqual ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) , IECore . Color3f ( <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> ) ) <EOL> shaderNode . loadShader ( shader1 , keepExistingValues = False ) <EOL> self . assertEqual ( shaderNode [ "<STR_LIT>" ] . keys ( ) , [ "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ] ) <EOL> self . assertEqual ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) , "<STR_LIT>" ) <EOL> self . assertEqual ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) , IECore . Color3f ( <NUM_LIT:1> , <NUM_LIT:1> , <NUM_LIT:1> ) ) <EOL> def testReloadRemovesOldParameters ( self ) : <EOL> shader2 = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> shaderNode = GafferRenderMan . RenderManShader ( ) <EOL> shaderNode . loadShader ( shader2 ) <EOL> self . assertEqual ( shaderNode [ "<STR_LIT>" ] . keys ( ) , [ "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ] ) <EOL> shader3 = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> shaderNode . loadShader ( shader3 ) <EOL> self . assertEqual ( shaderNode [ "<STR_LIT>" ] . keys ( ) , [ "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ] ) <EOL> def testAutomaticReloadOnScriptLoad ( self ) : <EOL> shader1 = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" , shaderName = "<STR_LIT>" ) <EOL> s = Gaffer . ScriptNode ( ) <EOL> s [ "<STR_LIT>" ] = GafferRenderMan . RenderManShader ( ) <EOL> s [ "<STR_LIT>" ] . loadShader ( shader1 ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setValue ( <NUM_LIT:0.1> ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setValue ( "<STR_LIT:test>" ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setValue ( IECore . Color3f ( <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> ) ) <EOL> ss = s . serialise ( ) <EOL> self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" , shaderName = "<STR_LIT>" ) <EOL> GafferRenderMan . RenderManShader . shaderLoader ( ) . clear ( ) <EOL> s = Gaffer . ScriptNode ( ) <EOL> s . execute ( ss ) <EOL> self . assertEqual ( s [ "<STR_LIT>" ] [ "<STR_LIT>" ] . keys ( ) , [ "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ] ) <EOL> self . assertAlmostEqual ( s [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) , <NUM_LIT:0.1> ) <EOL> self . assertEqual ( s [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) , "<STR_LIT:test>" ) <EOL> self . assertEqual ( s [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) , IECore . Color3f ( <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> ) ) <EOL> def testReloadPreservesConnections ( self ) : <EOL> n = GafferRenderMan . RenderManShader ( ) <EOL> n . loadShader ( "<STR_LIT>" ) <EOL> random = Gaffer . Random ( ) <EOL> n [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( random [ "<STR_LIT>" ] ) <EOL> n [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( random [ "<STR_LIT>" ] ) <EOL> n . loadShader ( "<STR_LIT>" , keepExistingValues = True ) <EOL> self . assertTrue ( n [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getInput ( ) . isSame ( random [ "<STR_LIT>" ] ) ) <EOL> self . assertTrue ( n [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getInput ( ) . isSame ( random [ "<STR_LIT>" ] ) ) <EOL> def testReloadPreservesConnectionsWhenMinMaxOrDefaultChanges ( self ) : <EOL> shader1 = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" , shaderName = "<STR_LIT>" ) <EOL> n = GafferRenderMan . RenderManShader ( ) <EOL> n . loadShader ( shader1 ) <EOL> self . assertFalse ( n [ "<STR_LIT>" ] [ "<STR_LIT>" ] . hasMinValue ( ) ) <EOL> self . assertFalse ( n [ "<STR_LIT>" ] [ "<STR_LIT>" ] . hasMaxValue ( ) ) <EOL> self . assertEqual ( n [ "<STR_LIT>" ] [ "<STR_LIT>" ] . defaultValue ( ) , "<STR_LIT>" ) <EOL> nn = Gaffer . Node ( ) <EOL> nn [ "<STR_LIT>" ] = Gaffer . FloatPlug ( direction = Gaffer . Plug . Direction . Out ) <EOL> nn [ "<STR_LIT>" ] = Gaffer . StringPlug ( direction = Gaffer . Plug . Direction . Out ) <EOL> n [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( nn [ "<STR_LIT>" ] ) <EOL> n [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( nn [ "<STR_LIT>" ] ) <EOL> shader2 = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" , shaderName = "<STR_LIT>" ) <EOL> GafferRenderMan . RenderManShader . shaderLoader ( ) . clear ( ) <EOL> n . loadShader ( shader1 , keepExistingValues = True ) <EOL> self . assertTrue ( n [ "<STR_LIT>" ] [ "<STR_LIT>" ] . hasMinValue ( ) ) <EOL> self . assertTrue ( n [ "<STR_LIT>" ] [ "<STR_LIT>" ] . hasMaxValue ( ) ) <EOL> self . assertEqual ( n [ "<STR_LIT>" ] [ "<STR_LIT>" ] . minValue ( ) , - <NUM_LIT:1> ) <EOL> self . assertEqual ( n [ "<STR_LIT>" ] [ "<STR_LIT>" ] . maxValue ( ) , <NUM_LIT:2> ) <EOL> self . assertEqual ( n [ "<STR_LIT>" ] [ "<STR_LIT>" ] . defaultValue ( ) , "<STR_LIT>" ) <EOL> self . assertTrue ( n [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getInput ( ) . isSame ( nn [ "<STR_LIT>" ] ) ) <EOL> self . assertTrue ( n [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getInput ( ) . isSame ( nn [ "<STR_LIT>" ] ) ) <EOL> def testReloadPreservesPartialConnectionsWhenMinMaxOrDefaultChanges ( self ) : <EOL> shader1 = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" , shaderName = "<STR_LIT>" ) <EOL> n = GafferRenderMan . RenderManShader ( ) <EOL> n . loadShader ( shader1 ) <EOL> nn = Gaffer . Node ( ) <EOL> nn [ "<STR_LIT>" ] = Gaffer . FloatPlug ( direction = Gaffer . Plug . Direction . Out ) <EOL> n [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:0> ] . setInput ( nn [ "<STR_LIT>" ] ) <EOL> n [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:1> ] . setInput ( nn [ "<STR_LIT>" ] ) <EOL> n [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:2> ] . setValue ( <NUM_LIT> ) <EOL> shader2 = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" , shaderName = "<STR_LIT>" ) <EOL> GafferRenderMan . RenderManShader . shaderLoader ( ) . clear ( ) <EOL> n . loadShader ( shader1 , keepExistingValues = True ) <EOL> self . assertTrue ( n [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:0> ] . getInput ( ) . isSame ( nn [ "<STR_LIT>" ] ) ) <EOL> self . assertTrue ( n [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:1> ] . getInput ( ) . isSame ( nn [ "<STR_LIT>" ] ) ) <EOL> self . assertEqual ( n [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:2> ] . getValue ( ) , <NUM_LIT> ) <EOL> def testReloadPreservesValuesWhenMinMaxOrDefaultChanges ( self ) : <EOL> shader1 = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" , shaderName = "<STR_LIT>" ) <EOL> n = GafferRenderMan . RenderManShader ( ) <EOL> n . loadShader ( shader1 ) <EOL> n [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setValue ( <NUM_LIT> ) <EOL> n [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setValue ( "<STR_LIT>" ) <EOL> n [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setValue ( IECore . Color3f ( <NUM_LIT:0.1> , <NUM_LIT> , <NUM_LIT:0.5> ) ) <EOL> shader2 = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" , shaderName = "<STR_LIT>" ) <EOL> GafferRenderMan . RenderManShader . shaderLoader ( ) . clear ( ) <EOL> n . loadShader ( shader1 , keepExistingValues = True ) <EOL> self . assertEqual ( n [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) , <NUM_LIT> ) <EOL> self . assertEqual ( n [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) , "<STR_LIT>" ) <EOL> self . assertEqual ( n [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) , IECore . Color3f ( <NUM_LIT:0.1> , <NUM_LIT> , <NUM_LIT:0.5> ) ) <EOL> def testOutputParameters ( self ) : <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> n = GafferRenderMan . RenderManShader ( ) <EOL> n . loadShader ( shader ) <EOL> self . failIf ( "<STR_LIT>" in n [ "<STR_LIT>" ] . keys ( ) ) <EOL> def testAssignmentDirtyPropagation ( self ) : <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> shaderNode = GafferRenderMan . RenderManShader ( ) <EOL> shaderNode . loadShader ( shader ) <EOL> coshader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> coshaderNode = GafferRenderMan . RenderManShader ( ) <EOL> coshaderNode . loadShader ( coshader ) <EOL> shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( coshaderNode [ "<STR_LIT>" ] ) <EOL> plane = GafferScene . Plane ( ) <EOL> assignment = GafferScene . ShaderAssignment ( ) <EOL> assignment [ "<STR_LIT>" ] . setInput ( plane [ "<STR_LIT>" ] ) <EOL> assignment [ "<STR_LIT>" ] . setInput ( shaderNode [ "<STR_LIT>" ] ) <EOL> cs = GafferTest . CapturingSlot ( assignment . plugDirtiedSignal ( ) ) <EOL> coshaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setValue ( <NUM_LIT:12> ) <EOL> dirtiedNames = [ x [ <NUM_LIT:0> ] . fullName ( ) for x in cs ] <EOL> self . assertEqual ( len ( dirtiedNames ) , <NUM_LIT:3> ) <EOL> self . assertEqual ( dirtiedNames [ <NUM_LIT:0> ] , "<STR_LIT>" ) <EOL> self . assertEqual ( dirtiedNames [ <NUM_LIT:1> ] , "<STR_LIT>" ) <EOL> self . assertEqual ( dirtiedNames [ <NUM_LIT:2> ] , "<STR_LIT>" ) <EOL> def testArrayParameters ( self ) : <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> n = GafferRenderMan . RenderManShader ( ) <EOL> n . loadShader ( shader ) <EOL> expected = { <EOL> "<STR_LIT>" : IECore . FloatVectorData ( [ ] ) , <EOL> "<STR_LIT>" : IECore . FloatVectorData ( [ <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:4> ] ) , <EOL> "<STR_LIT>" : IECore . StringVectorData ( [ "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ] ) , <EOL> "<STR_LIT>" : IECore . StringVectorData ( [ "<STR_LIT:hello>" , "<STR_LIT>" ] ) , <EOL> "<STR_LIT>" : IECore . Color3fVectorData ( [ IECore . Color3f ( <NUM_LIT:1> ) , IECore . Color3f ( <NUM_LIT:2> ) ] ) , <EOL> "<STR_LIT>" : IECore . Color3fVectorData ( [ IECore . Color3f ( <NUM_LIT:1> ) , IECore . Color3f ( <NUM_LIT:2> ) ] ) , <EOL> "<STR_LIT>" : IECore . V3fVectorData ( [ ] , IECore . GeometricData . Interpretation . Vector ) , <EOL> "<STR_LIT>" : IECore . V3fVectorData ( [ IECore . V3f ( x ) for x in range ( <NUM_LIT:1> , <NUM_LIT:6> ) ] , IECore . GeometricData . Interpretation . Vector ) , <EOL> "<STR_LIT>" : IECore . V3fVectorData ( [ ] , IECore . GeometricData . Interpretation . Point ) , <EOL> "<STR_LIT>" : IECore . V3fVectorData ( [ IECore . V3f ( x ) for x in range ( <NUM_LIT:1> , <NUM_LIT:6> ) ] , IECore . GeometricData . Interpretation . Point ) , <EOL> "<STR_LIT>" : IECore . V3fVectorData ( [ ] , IECore . GeometricData . Interpretation . Normal ) , <EOL> "<STR_LIT>" : IECore . V3fVectorData ( [ IECore . V3f ( x ) for x in range ( <NUM_LIT:1> , <NUM_LIT:6> ) ] , IECore . GeometricData . Interpretation . Normal ) , <EOL> } <EOL> self . assertEqual ( set ( n [ "<STR_LIT>" ] . keys ( ) ) , set ( expected . keys ( ) ) ) <EOL> for name , value in expected . items ( ) : <EOL> self . assertEqual ( n [ "<STR_LIT>" ] [ name ] . defaultValue ( ) , value ) <EOL> self . assertEqual ( n [ "<STR_LIT>" ] [ name ] . getValue ( ) , value ) <EOL> s = n . state ( ) [ <NUM_LIT:0> ] <EOL> for name , value in expected . items ( ) : <EOL> self . assertEqual ( s . parameters [ name ] , value ) <EOL> def testFixedCoshaderArrayParameters ( self ) : <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> n = GafferRenderMan . RenderManShader ( ) <EOL> n . loadShader ( shader ) <EOL> self . assertEqual ( n [ "<STR_LIT>" ] . keys ( ) , [ "<STR_LIT>" , "<STR_LIT>" ] ) <EOL> self . assertTrue ( isinstance ( n [ "<STR_LIT>" ] [ "<STR_LIT>" ] , Gaffer . ArrayPlug ) ) <EOL> self . assertEqual ( len ( n [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) , <NUM_LIT:4> ) <EOL> self . assertTrue ( isinstance ( n [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] , Gaffer . Plug ) ) <EOL> self . assertTrue ( isinstance ( n [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] , Gaffer . Plug ) ) <EOL> self . assertTrue ( isinstance ( n [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] , Gaffer . Plug ) ) <EOL> self . assertTrue ( isinstance ( n [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] , Gaffer . Plug ) ) <EOL> state = n . state ( ) <EOL> self . assertEqual ( state [ <NUM_LIT:0> ] . parameters [ "<STR_LIT>" ] , IECore . StringVectorData ( [ "<STR_LIT>" ] * <NUM_LIT:4> ) ) <EOL> coshader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> coshaderNode = GafferRenderMan . RenderManShader ( ) <EOL> coshaderNode . loadShader ( coshader ) <EOL> n [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( coshaderNode [ "<STR_LIT>" ] ) <EOL> state = n . state ( ) <EOL> self . assertEqual ( state [ <NUM_LIT:1> ] . parameters [ "<STR_LIT>" ] , IECore . StringVectorData ( [ state [ <NUM_LIT:0> ] . parameters [ "<STR_LIT>" ] . value , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ] ) ) <EOL> def testCoshaderType ( self ) : <EOL> coshader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> coshaderNode = GafferRenderMan . RenderManShader ( ) <EOL> coshaderNode . loadShader ( coshader ) <EOL> self . assertEqual ( coshaderNode . state ( ) [ <NUM_LIT:0> ] . type , "<STR_LIT>" ) <EOL> def testCantConnectSurfaceShaderIntoCoshaderInput ( self ) : <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> n1 = GafferRenderMan . RenderManShader ( ) <EOL> n1 . loadShader ( shader ) <EOL> n2 = GafferRenderMan . RenderManShader ( ) <EOL> n2 . loadShader ( "<STR_LIT>" ) <EOL> self . assertFalse ( n1 [ "<STR_LIT>" ] [ "<STR_LIT>" ] . acceptsInput ( n2 [ "<STR_LIT>" ] ) ) <EOL> coshader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> n3 = GafferRenderMan . RenderManShader ( ) <EOL> n3 . loadShader ( coshader ) <EOL> self . assertTrue ( n1 [ "<STR_LIT>" ] [ "<STR_LIT>" ] . acceptsInput ( n3 [ "<STR_LIT>" ] ) ) <EOL> arrayShader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> n4 = GafferRenderMan . RenderManShader ( ) <EOL> n4 . loadShader ( arrayShader ) <EOL> self . assertFalse ( n4 [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . acceptsInput ( n2 [ "<STR_LIT>" ] ) ) <EOL> self . assertTrue ( n4 [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . acceptsInput ( n3 [ "<STR_LIT>" ] ) ) <EOL> def testConnectionsBetweenParameters ( self ) : <EOL> s = GafferRenderMan . RenderManShader ( ) <EOL> s . loadShader ( "<STR_LIT>" ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setValue ( <NUM_LIT> ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( s [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) <EOL> shader = s . state ( ) [ <NUM_LIT:0> ] <EOL> self . assertEqual ( shader . parameters [ "<STR_LIT>" ] . value , <NUM_LIT> ) <EOL> self . assertEqual ( shader . parameters [ "<STR_LIT>" ] . value , <NUM_LIT> ) <EOL> def testFixedCoshaderArrayParameterHash ( self ) : <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> n = GafferRenderMan . RenderManShader ( ) <EOL> n . loadShader ( shader ) <EOL> h1 = n . stateHash ( ) <EOL> coshader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> coshaderNode = GafferRenderMan . RenderManShader ( ) <EOL> coshaderNode . loadShader ( coshader ) <EOL> n [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( coshaderNode [ "<STR_LIT>" ] ) <EOL> h2 = n . stateHash ( ) <EOL> self . assertNotEqual ( h2 , h1 ) <EOL> n [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( coshaderNode [ "<STR_LIT>" ] ) <EOL> h3 = n . stateHash ( ) <EOL> self . assertNotEqual ( h3 , h2 ) <EOL> self . assertNotEqual ( h3 , h1 ) <EOL> n [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( None ) <EOL> n [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( coshaderNode [ "<STR_LIT>" ] ) <EOL> h4 = n . stateHash ( ) <EOL> self . assertNotEqual ( h4 , h3 ) <EOL> self . assertNotEqual ( h4 , h2 ) <EOL> self . assertNotEqual ( h4 , h1 ) <EOL> def testDisabling ( self ) : <EOL> s = GafferRenderMan . RenderManShader ( ) <EOL> s . loadShader ( "<STR_LIT>" ) <EOL> stateHash = s . stateHash ( ) <EOL> state = s . state ( ) <EOL> self . assertEqual ( len ( state ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( state [ <NUM_LIT:0> ] . name , "<STR_LIT>" ) <EOL> self . assertTrue ( s [ "<STR_LIT>" ] . isSame ( s . enabledPlug ( ) ) ) <EOL> s [ "<STR_LIT>" ] . setValue ( False ) <EOL> stateHash2 = s . stateHash ( ) <EOL> self . assertNotEqual ( stateHash2 , stateHash ) <EOL> state2 = s . state ( ) <EOL> self . assertEqual ( len ( state2 ) , <NUM_LIT:0> ) <EOL> def testDisablingCoshaders ( self ) : <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> shaderNode = GafferRenderMan . RenderManShader ( ) <EOL> shaderNode . loadShader ( shader ) <EOL> coshader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> coshaderNode = GafferRenderMan . RenderManShader ( ) <EOL> coshaderNode . loadShader ( coshader ) <EOL> shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( coshaderNode [ "<STR_LIT>" ] ) <EOL> s = shaderNode . state ( ) <EOL> self . assertEqual ( len ( s ) , <NUM_LIT:2> ) <EOL> self . assertEqual ( s [ <NUM_LIT:0> ] . name , coshader ) <EOL> self . assertEqual ( s [ <NUM_LIT:1> ] . name , shader ) <EOL> h = shaderNode . stateHash ( ) <EOL> coshaderNode [ "<STR_LIT>" ] . setValue ( False ) <EOL> s2 = shaderNode . state ( ) <EOL> self . assertEqual ( len ( s2 ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( s2 [ <NUM_LIT:0> ] . name , shader ) <EOL> self . assertTrue ( "<STR_LIT>" not in s2 [ <NUM_LIT:0> ] . parameters ) <EOL> self . assertNotEqual ( shaderNode . stateHash ( ) , h ) <EOL> def testDisablingCoshaderArrayInputs ( self ) : <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> n = GafferRenderMan . RenderManShader ( ) <EOL> n . loadShader ( shader ) <EOL> coshader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> coshaderNode1 = GafferRenderMan . RenderManShader ( ) <EOL> coshaderNode1 . loadShader ( coshader ) <EOL> coshaderNode2 = GafferRenderMan . RenderManShader ( ) <EOL> coshaderNode2 . loadShader ( coshader ) <EOL> n [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:0> ] . setInput ( coshaderNode1 [ "<STR_LIT>" ] ) <EOL> n [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:2> ] . setInput ( coshaderNode2 [ "<STR_LIT>" ] ) <EOL> state = n . state ( ) <EOL> h1 = n . stateHash ( ) <EOL> self . assertEqual ( <EOL> state [ <NUM_LIT:2> ] . parameters [ "<STR_LIT>" ] , <EOL> IECore . StringVectorData ( [ <EOL> state [ <NUM_LIT:0> ] . parameters [ "<STR_LIT>" ] . value , <EOL> "<STR_LIT>" , <EOL> state [ <NUM_LIT:1> ] . parameters [ "<STR_LIT>" ] . value , <EOL> "<STR_LIT>" <EOL> ] ) <EOL> ) <EOL> coshaderNode1 [ "<STR_LIT>" ] . setValue ( False ) <EOL> state = n . state ( ) <EOL> self . assertEqual ( <EOL> state [ <NUM_LIT:1> ] . parameters [ "<STR_LIT>" ] , <EOL> IECore . StringVectorData ( [ <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> state [ <NUM_LIT:0> ] . parameters [ "<STR_LIT>" ] . value , <EOL> "<STR_LIT>" <EOL> ] ) <EOL> ) <EOL> h2 = n . stateHash ( ) <EOL> self . assertNotEqual ( h2 , h1 ) <EOL> coshaderNode2 [ "<STR_LIT>" ] . setValue ( False ) <EOL> state = n . state ( ) <EOL> self . assertEqual ( <EOL> state [ <NUM_LIT:0> ] . parameters [ "<STR_LIT>" ] , <EOL> IECore . StringVectorData ( [ <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" <EOL> ] ) <EOL> ) <EOL> self . assertNotEqual ( n . stateHash ( ) , h1 ) <EOL> self . assertNotEqual ( n . stateHash ( ) , h2 ) <EOL> def testCorrespondingInput ( self ) : <EOL> coshader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> coshaderNode = GafferRenderMan . RenderManShader ( ) <EOL> coshaderNode . loadShader ( coshader ) <EOL> self . assertEqual ( coshaderNode . correspondingInput ( coshaderNode [ "<STR_LIT>" ] ) , None ) <EOL> coshader2 = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> coshaderNode2 = GafferRenderMan . RenderManShader ( ) <EOL> coshaderNode2 . loadShader ( coshader2 ) <EOL> self . assertTrue ( coshaderNode2 . correspondingInput ( coshaderNode2 [ "<STR_LIT>" ] ) . isSame ( coshaderNode2 [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) ) <EOL> def testCoshaderPassThrough ( self ) : <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> shaderNode = GafferRenderMan . RenderManShader ( ) <EOL> shaderNode . loadShader ( shader ) <EOL> passThroughCoshader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> passThroughCoshaderNode = GafferRenderMan . RenderManShader ( ) <EOL> passThroughCoshaderNode . loadShader ( passThroughCoshader ) <EOL> coshader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> coshaderNode = GafferRenderMan . RenderManShader ( ) <EOL> coshaderNode . loadShader ( coshader ) <EOL> shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( passThroughCoshaderNode [ "<STR_LIT>" ] ) <EOL> passThroughCoshaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( coshaderNode [ "<STR_LIT>" ] ) <EOL> h = shaderNode . stateHash ( ) <EOL> s = shaderNode . state ( ) <EOL> self . assertEqual ( len ( s ) , <NUM_LIT:3> ) <EOL> self . assertEqual ( s [ <NUM_LIT:2> ] . parameters [ "<STR_LIT>" ] , s [ <NUM_LIT:1> ] . parameters [ "<STR_LIT>" ] ) <EOL> self . assertEqual ( s [ <NUM_LIT:1> ] . name , passThroughCoshader ) <EOL> self . assertEqual ( s [ <NUM_LIT:1> ] . parameters [ "<STR_LIT>" ] , s [ <NUM_LIT:0> ] . parameters [ "<STR_LIT>" ] ) <EOL> self . assertEqual ( s [ <NUM_LIT:0> ] . name , coshader ) <EOL> passThroughCoshaderNode [ "<STR_LIT>" ] . setValue ( False ) <EOL> s = shaderNode . state ( ) <EOL> self . assertEqual ( len ( s ) , <NUM_LIT:2> ) <EOL> self . assertEqual ( s [ <NUM_LIT:1> ] . parameters [ "<STR_LIT>" ] , s [ <NUM_LIT:0> ] . parameters [ "<STR_LIT>" ] ) <EOL> self . assertEqual ( s [ <NUM_LIT:0> ] . name , coshader ) <EOL> def testSplineParameters ( self ) : <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> n = GafferRenderMan . RenderManShader ( ) <EOL> n . loadShader ( shader ) <EOL> self . assertEqual ( n [ "<STR_LIT>" ] . keys ( ) , [ "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ] ) <EOL> self . assertTrue ( isinstance ( n [ "<STR_LIT>" ] [ "<STR_LIT>" ] , Gaffer . SplineffPlug ) ) <EOL> self . assertTrue ( isinstance ( n [ "<STR_LIT>" ] [ "<STR_LIT>" ] , Gaffer . SplinefColor3fPlug ) ) <EOL> self . assertEqual ( <EOL> n [ "<STR_LIT>" ] [ "<STR_LIT>" ] . defaultValue ( ) , <EOL> IECore . Splineff ( <EOL> IECore . CubicBasisf . catmullRom ( ) , <EOL> [ <EOL> ( <NUM_LIT:0> , <NUM_LIT:0> ) , <EOL> ( <NUM_LIT:0> , <NUM_LIT:0> ) , <EOL> ( <NUM_LIT:1> , <NUM_LIT:1> ) , <EOL> ( <NUM_LIT:1> , <NUM_LIT:1> ) , <EOL> ] <EOL> ) <EOL> ) <EOL> self . assertEqual ( <EOL> n [ "<STR_LIT>" ] [ "<STR_LIT>" ] . defaultValue ( ) , <EOL> IECore . SplinefColor3f ( <EOL> IECore . CubicBasisf . catmullRom ( ) , <EOL> [ <EOL> ( <NUM_LIT:0> , IECore . Color3f ( <NUM_LIT:0> ) ) , <EOL> ( <NUM_LIT:0> , IECore . Color3f ( <NUM_LIT:0> ) ) , <EOL> ( <NUM_LIT:1> , IECore . Color3f ( <NUM_LIT:1> ) ) , <EOL> ( <NUM_LIT:1> , IECore . Color3f ( <NUM_LIT:1> ) ) , <EOL> ] <EOL> ) <EOL> ) <EOL> floatValue = IECore . Splineff ( <EOL> IECore . CubicBasisf . catmullRom ( ) , <EOL> [ <EOL> ( <NUM_LIT:0> , <NUM_LIT:0> ) , <EOL> ( <NUM_LIT:0> , <NUM_LIT:0> ) , <EOL> ( <NUM_LIT:1> , <NUM_LIT:2> ) , <EOL> ( <NUM_LIT:1> , <NUM_LIT:2> ) , <EOL> ] <EOL> ) <EOL> colorValue = IECore . SplinefColor3f ( <EOL> IECore . CubicBasisf . catmullRom ( ) , <EOL> [ <EOL> ( <NUM_LIT:0> , IECore . Color3f ( <NUM_LIT:0> ) ) , <EOL> ( <NUM_LIT:0> , IECore . Color3f ( <NUM_LIT:0> ) ) , <EOL> ( <NUM_LIT:1> , IECore . Color3f ( <NUM_LIT> ) ) , <EOL> ( <NUM_LIT:1> , IECore . Color3f ( <NUM_LIT> ) ) , <EOL> ] <EOL> ) <EOL> n [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setValue ( floatValue ) <EOL> n [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setValue ( colorValue ) <EOL> s = n . state ( ) [ <NUM_LIT:0> ] <EOL> self . assertEqual ( s . parameters [ "<STR_LIT>" ] . value , floatValue ) <EOL> self . assertEqual ( s . parameters [ "<STR_LIT>" ] . value , colorValue ) <EOL> def testSplineParameterSerialisationKeepsExistingValues ( self ) : <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> s = Gaffer . ScriptNode ( ) <EOL> s [ "<STR_LIT:n>" ] = GafferRenderMan . RenderManShader ( ) <EOL> s [ "<STR_LIT:n>" ] . loadShader ( shader ) <EOL> s [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setValue ( <EOL> IECore . Splineff ( <EOL> IECore . CubicBasisf . catmullRom ( ) , <EOL> [ <EOL> ( <NUM_LIT:0> , <NUM_LIT:0> ) , <EOL> ( <NUM_LIT:0> , <NUM_LIT:0> ) , <EOL> ( <NUM_LIT:1> , <NUM_LIT:2> ) , <EOL> ( <NUM_LIT:1> , <NUM_LIT:2> ) , <EOL> ] <EOL> ) <EOL> ) <EOL> self . assertEqual ( <EOL> s [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) , <EOL> IECore . Splineff ( <EOL> IECore . CubicBasisf . catmullRom ( ) , <EOL> [ <EOL> ( <NUM_LIT:0> , <NUM_LIT:0> ) , <EOL> ( <NUM_LIT:0> , <NUM_LIT:0> ) , <EOL> ( <NUM_LIT:1> , <NUM_LIT:2> ) , <EOL> ( <NUM_LIT:1> , <NUM_LIT:2> ) , <EOL> ] <EOL> ) , <EOL> ) <EOL> ss = s . serialise ( ) <EOL> s2 = Gaffer . ScriptNode ( ) <EOL> s2 . execute ( ss ) <EOL> self . assertEqual ( <EOL> s2 [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) , <EOL> IECore . Splineff ( <EOL> IECore . CubicBasisf . catmullRom ( ) , <EOL> [ <EOL> ( <NUM_LIT:0> , <NUM_LIT:0> ) , <EOL> ( <NUM_LIT:0> , <NUM_LIT:0> ) , <EOL> ( <NUM_LIT:1> , <NUM_LIT:2> ) , <EOL> ( <NUM_LIT:1> , <NUM_LIT:2> ) , <EOL> ] <EOL> ) , <EOL> ) <EOL> def testSplineParameterDefaultValueAnnotation ( self ) : <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> n = GafferRenderMan . RenderManShader ( ) <EOL> n . loadShader ( shader ) <EOL> self . assertEqual ( <EOL> n [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) , <EOL> IECore . SplinefColor3f ( <EOL> IECore . CubicBasisf . catmullRom ( ) , <EOL> [ <EOL> ( <NUM_LIT:0> , IECore . Color3f ( <NUM_LIT:1> ) ) , <EOL> ( <NUM_LIT:0> , IECore . Color3f ( <NUM_LIT:1> ) ) , <EOL> ( <NUM_LIT:0.5> , IECore . Color3f ( <NUM_LIT:1> , <NUM_LIT:0.5> , <NUM_LIT> ) ) , <EOL> ( <NUM_LIT:1> , IECore . Color3f ( <NUM_LIT:0> ) ) , <EOL> ( <NUM_LIT:1> , IECore . Color3f ( <NUM_LIT:0> ) ) , <EOL> ] <EOL> ) , <EOL> ) <EOL> def testCoshadersInBox ( self ) : <EOL> s = Gaffer . ScriptNode ( ) <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> s [ "<STR_LIT>" ] = GafferRenderMan . RenderManShader ( ) <EOL> s [ "<STR_LIT>" ] . loadShader ( shader ) <EOL> coshader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> s [ "<STR_LIT>" ] = GafferRenderMan . RenderManShader ( ) <EOL> s [ "<STR_LIT>" ] . loadShader ( coshader ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( s [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) <EOL> b = Gaffer . Box . create ( s , Gaffer . StandardSet ( [ s [ "<STR_LIT>" ] ] ) ) <EOL> self . assertTrue ( s [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getInput ( ) . parent ( ) . isSame ( b ) ) <EOL> s = s [ "<STR_LIT>" ] . state ( ) <EOL> self . assertEqual ( len ( s ) , <NUM_LIT:2> ) <EOL> self . assertEqual ( s [ <NUM_LIT:1> ] . parameters [ "<STR_LIT>" ] , s [ <NUM_LIT:0> ] . parameters [ "<STR_LIT>" ] ) <EOL> self . assertEqual ( s [ <NUM_LIT:0> ] . name , coshader ) <EOL> def testShaderInBoxWithExternalCoshader ( self ) : <EOL> s = Gaffer . ScriptNode ( ) <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> s [ "<STR_LIT>" ] = GafferRenderMan . RenderManShader ( ) <EOL> s [ "<STR_LIT>" ] . loadShader ( shader ) <EOL> coshader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> s [ "<STR_LIT>" ] = GafferRenderMan . RenderManShader ( ) <EOL> s [ "<STR_LIT>" ] . loadShader ( coshader ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( s [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) <EOL> b = Gaffer . Box . create ( s , Gaffer . StandardSet ( [ s [ "<STR_LIT>" ] ] ) ) <EOL> self . assertTrue ( b [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getInput ( ) . parent ( ) . isSame ( b ) ) <EOL> s = b [ "<STR_LIT>" ] . state ( ) <EOL> self . assertEqual ( len ( s ) , <NUM_LIT:2> ) <EOL> self . assertEqual ( s [ <NUM_LIT:1> ] . parameters [ "<STR_LIT>" ] , s [ <NUM_LIT:0> ] . parameters [ "<STR_LIT>" ] ) <EOL> self . assertEqual ( s [ <NUM_LIT:0> ] . name , coshader ) <EOL> def testNumericTypeAnnotations ( self ) : <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> shaderNode = GafferRenderMan . RenderManShader ( ) <EOL> shaderNode . loadShader ( shader ) <EOL> self . assertTrue ( isinstance ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] , Gaffer . FloatPlug ) ) <EOL> self . assertTrue ( isinstance ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] , Gaffer . FloatPlug ) ) <EOL> self . assertTrue ( isinstance ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] , Gaffer . IntPlug ) ) <EOL> self . assertTrue ( isinstance ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] , Gaffer . BoolPlug ) ) <EOL> self . assertEqual ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . defaultValue ( ) , <NUM_LIT> ) <EOL> self . assertEqual ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . defaultValue ( ) , <NUM_LIT> ) <EOL> self . assertEqual ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . defaultValue ( ) , <NUM_LIT:10> ) <EOL> self . assertEqual ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . defaultValue ( ) , True ) <EOL> self . assertEqual ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) , <NUM_LIT> ) <EOL> self . assertEqual ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) , <NUM_LIT> ) <EOL> self . assertEqual ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) , <NUM_LIT:10> ) <EOL> self . assertEqual ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) , True ) <EOL> def testCoshaderTypeAnnotations ( self ) : <EOL> coshader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> coshaderNode = GafferRenderMan . RenderManShader ( ) <EOL> coshaderNode . loadShader ( coshader ) <EOL> coshaderType1 = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> coshaderType1Node = GafferRenderMan . RenderManShader ( ) <EOL> coshaderType1Node . loadShader ( coshaderType1 ) <EOL> coshaderType2 = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> coshaderType2Node = GafferRenderMan . RenderManShader ( ) <EOL> coshaderType2Node . loadShader ( coshaderType2 ) <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> shaderNode = GafferRenderMan . RenderManShader ( ) <EOL> shaderNode . loadShader ( shader ) <EOL> self . assertTrue ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . acceptsInput ( coshaderNode [ "<STR_LIT>" ] ) ) <EOL> self . assertTrue ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . acceptsInput ( coshaderType1Node [ "<STR_LIT>" ] ) ) <EOL> self . assertTrue ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . acceptsInput ( coshaderType2Node [ "<STR_LIT>" ] ) ) <EOL> self . assertFalse ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . acceptsInput ( coshaderNode [ "<STR_LIT>" ] ) ) <EOL> self . assertTrue ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . acceptsInput ( coshaderType1Node [ "<STR_LIT>" ] ) ) <EOL> self . assertFalse ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . acceptsInput ( coshaderType2Node [ "<STR_LIT>" ] ) ) <EOL> self . assertFalse ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . acceptsInput ( coshaderNode [ "<STR_LIT>" ] ) ) <EOL> self . assertFalse ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . acceptsInput ( coshaderType1Node [ "<STR_LIT>" ] ) ) <EOL> self . assertTrue ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . acceptsInput ( coshaderType2Node [ "<STR_LIT>" ] ) ) <EOL> self . assertTrue ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . acceptsInput ( coshaderNode [ "<STR_LIT>" ] ) ) <EOL> self . assertTrue ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . acceptsInput ( coshaderType1Node [ "<STR_LIT>" ] ) ) <EOL> self . assertTrue ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . acceptsInput ( coshaderType2Node [ "<STR_LIT>" ] ) ) <EOL> self . assertFalse ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . acceptsInput ( coshaderNode [ "<STR_LIT>" ] ) ) <EOL> self . assertTrue ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . acceptsInput ( coshaderType1Node [ "<STR_LIT>" ] ) ) <EOL> self . assertFalse ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . acceptsInput ( coshaderType2Node [ "<STR_LIT>" ] ) ) <EOL> self . assertFalse ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:0> ] . acceptsInput ( coshaderNode [ "<STR_LIT>" ] ) ) <EOL> self . assertFalse ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:0> ] . acceptsInput ( coshaderType1Node [ "<STR_LIT>" ] ) ) <EOL> self . assertTrue ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:0> ] . acceptsInput ( coshaderType2Node [ "<STR_LIT>" ] ) ) <EOL> def testMultipleCoshaderTypeAnnotations ( self ) : <EOL> coshaderType1And2 = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> coshaderType1And2Node = GafferRenderMan . RenderManShader ( ) <EOL> coshaderType1And2Node . loadShader ( coshaderType1And2 ) <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> shaderNode = GafferRenderMan . RenderManShader ( ) <EOL> shaderNode . loadShader ( shader ) <EOL> self . assertTrue ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . acceptsInput ( coshaderType1And2Node [ "<STR_LIT>" ] ) ) <EOL> self . assertTrue ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . acceptsInput ( coshaderType1And2Node [ "<STR_LIT>" ] ) ) <EOL> self . assertTrue ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . acceptsInput ( coshaderType1And2Node [ "<STR_LIT>" ] ) ) <EOL> self . assertFalse ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . acceptsInput ( coshaderType1And2Node [ "<STR_LIT>" ] ) ) <EOL> def testSplitCoshaderPassThrough ( self ) : <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> S = GafferRenderMan . RenderManShader ( ) <EOL> S . loadShader ( shader ) <EOL> passThroughCoshader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> D = GafferRenderMan . RenderManShader ( ) <EOL> D . loadShader ( passThroughCoshader ) <EOL> coshader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> C = GafferRenderMan . RenderManShader ( ) <EOL> C . loadShader ( coshader ) <EOL> S [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:0> ] . setInput ( C [ "<STR_LIT>" ] ) <EOL> S [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:1> ] . setInput ( D [ "<STR_LIT>" ] ) <EOL> D [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( C [ "<STR_LIT>" ] ) <EOL> h = S . stateHash ( ) <EOL> s = S . state ( ) <EOL> self . assertEqual ( len ( s ) , <NUM_LIT:3> ) <EOL> self . assertEqual ( s [ <NUM_LIT:2> ] . parameters [ "<STR_LIT>" ] , IECore . StringVectorData ( [ s [ <NUM_LIT:0> ] . parameters [ "<STR_LIT>" ] . value , s [ <NUM_LIT:1> ] . parameters [ "<STR_LIT>" ] . value , "<STR_LIT>" , "<STR_LIT>" ] ) ) <EOL> self . assertEqual ( s [ <NUM_LIT:0> ] . name , coshader ) <EOL> self . assertEqual ( s [ <NUM_LIT:1> ] . parameters [ "<STR_LIT>" ] , s [ <NUM_LIT:0> ] . parameters [ "<STR_LIT>" ] ) <EOL> self . assertEqual ( s [ <NUM_LIT:1> ] . name , passThroughCoshader ) <EOL> D [ "<STR_LIT>" ] . setValue ( False ) <EOL> self . assertNotEqual ( S . stateHash ( ) , h ) <EOL> s = S . state ( ) <EOL> self . assertEqual ( len ( s ) , <NUM_LIT:2> ) <EOL> self . assertEqual ( s [ <NUM_LIT:1> ] . parameters [ "<STR_LIT>" ] , IECore . StringVectorData ( [ s [ <NUM_LIT:0> ] . parameters [ "<STR_LIT>" ] . value , s [ <NUM_LIT:0> ] . parameters [ "<STR_LIT>" ] . value , "<STR_LIT>" , "<STR_LIT>" ] ) ) <EOL> self . assertEqual ( s [ <NUM_LIT:0> ] . name , coshader ) <EOL> def testSerialDisabledShaders ( self ) : <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> S = GafferRenderMan . RenderManShader ( ) <EOL> S . loadShader ( shader ) <EOL> passThroughCoshader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> D1 = GafferRenderMan . RenderManShader ( ) <EOL> D1 . loadShader ( passThroughCoshader ) <EOL> D2 = GafferRenderMan . RenderManShader ( ) <EOL> D2 . loadShader ( passThroughCoshader ) <EOL> coshader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> C = GafferRenderMan . RenderManShader ( ) <EOL> C . loadShader ( coshader ) <EOL> S [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( D2 [ "<STR_LIT>" ] ) <EOL> D2 [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( D1 [ "<STR_LIT>" ] ) <EOL> D1 [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( C [ "<STR_LIT>" ] ) <EOL> h1 = S . stateHash ( ) <EOL> s = S . state ( ) <EOL> self . assertEqual ( len ( s ) , <NUM_LIT:4> ) <EOL> self . assertEqual ( s [ <NUM_LIT:0> ] . name , coshader ) <EOL> self . assertEqual ( s [ <NUM_LIT:1> ] . name , passThroughCoshader ) <EOL> self . assertEqual ( s [ <NUM_LIT:2> ] . name , passThroughCoshader ) <EOL> self . assertEqual ( s [ <NUM_LIT:3> ] . name , shader ) <EOL> self . assertEqual ( s [ <NUM_LIT:3> ] . parameters [ "<STR_LIT>" ] , s [ <NUM_LIT:2> ] . parameters [ "<STR_LIT>" ] ) <EOL> self . assertEqual ( s [ <NUM_LIT:2> ] . parameters [ "<STR_LIT>" ] , s [ <NUM_LIT:1> ] . parameters [ "<STR_LIT>" ] ) <EOL> self . assertEqual ( s [ <NUM_LIT:1> ] . parameters [ "<STR_LIT>" ] , s [ <NUM_LIT:0> ] . parameters [ "<STR_LIT>" ] ) <EOL> D2 [ "<STR_LIT>" ] . setValue ( False ) <EOL> h2 = S . stateHash ( ) <EOL> self . assertNotEqual ( h1 , h2 ) <EOL> s = S . state ( ) <EOL> self . assertEqual ( len ( s ) , <NUM_LIT:3> ) <EOL> self . assertEqual ( s [ <NUM_LIT:0> ] . name , coshader ) <EOL> self . assertEqual ( s [ <NUM_LIT:1> ] . name , passThroughCoshader ) <EOL> self . assertEqual ( s [ <NUM_LIT:2> ] . name , shader ) <EOL> self . assertEqual ( s [ <NUM_LIT:2> ] . parameters [ "<STR_LIT>" ] , s [ <NUM_LIT:1> ] . parameters [ "<STR_LIT>" ] ) <EOL> self . assertEqual ( s [ <NUM_LIT:1> ] . parameters [ "<STR_LIT>" ] , s [ <NUM_LIT:0> ] . parameters [ "<STR_LIT>" ] ) <EOL> D1 [ "<STR_LIT>" ] . setValue ( False ) <EOL> h3 = S . stateHash ( ) <EOL> self . assertNotEqual ( h3 , h2 ) <EOL> self . assertNotEqual ( h3 , h1 ) <EOL> s = S . state ( ) <EOL> self . assertEqual ( len ( s ) , <NUM_LIT:2> ) <EOL> self . assertEqual ( s [ <NUM_LIT:0> ] . name , coshader ) <EOL> self . assertEqual ( s [ <NUM_LIT:1> ] . name , shader ) <EOL> self . assertEqual ( s [ <NUM_LIT:1> ] . parameters [ "<STR_LIT>" ] , s [ <NUM_LIT:0> ] . parameters [ "<STR_LIT>" ] ) <EOL> def testDynamicCoshaderArrayParameters ( self ) : <EOL> coshader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> coshaderNode = GafferRenderMan . RenderManShader ( ) <EOL> coshaderNode . loadShader ( coshader ) <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> shaderNode = GafferRenderMan . RenderManShader ( ) <EOL> shaderNode . loadShader ( shader ) <EOL> self . assertEqual ( len ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) , <NUM_LIT:1> ) <EOL> self . assertTrue ( isinstance ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:0> ] , Gaffer . Plug ) ) <EOL> self . assertTrue ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:0> ] . getInput ( ) is None ) <EOL> shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:0> ] . setInput ( coshaderNode [ "<STR_LIT>" ] ) <EOL> self . assertEqual ( len ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) , <NUM_LIT:2> ) <EOL> self . assertTrue ( isinstance ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:0> ] , Gaffer . Plug ) ) <EOL> self . assertTrue ( isinstance ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:1> ] , Gaffer . Plug ) ) <EOL> self . assertTrue ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:0> ] . getInput ( ) . isSame ( coshaderNode [ "<STR_LIT>" ] ) ) <EOL> self . assertTrue ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:1> ] . getInput ( ) is None ) <EOL> shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:0> ] . setInput ( None ) <EOL> self . assertEqual ( len ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) , <NUM_LIT:1> ) <EOL> self . assertTrue ( isinstance ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:0> ] , Gaffer . Plug ) ) <EOL> self . assertTrue ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:0> ] . getInput ( ) is None ) <EOL> def testSerialiseDynamicCoshaderArrayParameters ( self ) : <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> coshader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> s = Gaffer . ScriptNode ( ) <EOL> s [ "<STR_LIT:n>" ] = GafferRenderMan . RenderManShader ( ) <EOL> s [ "<STR_LIT:n>" ] . loadShader ( shader ) <EOL> s [ "<STR_LIT:c>" ] = GafferRenderMan . RenderManShader ( ) <EOL> s [ "<STR_LIT:c>" ] . loadShader ( coshader ) <EOL> s [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:0> ] . setInput ( s [ "<STR_LIT:c>" ] [ "<STR_LIT>" ] ) <EOL> s [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:1> ] . setInput ( s [ "<STR_LIT:c>" ] [ "<STR_LIT>" ] ) <EOL> s [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:2> ] . setInput ( s [ "<STR_LIT:c>" ] [ "<STR_LIT>" ] ) <EOL> s [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:1> ] . setInput ( None ) <EOL> self . assertEqual ( len ( s [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) , <NUM_LIT:4> ) <EOL> s2 = Gaffer . ScriptNode ( ) <EOL> s2 . execute ( s . serialise ( ) ) <EOL> self . assertEqual ( len ( s2 [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) , <NUM_LIT:4> ) <EOL> self . assertTrue ( s2 [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:0> ] . getInput ( ) . isSame ( s2 [ "<STR_LIT:c>" ] [ "<STR_LIT>" ] ) ) <EOL> self . assertTrue ( s2 [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:1> ] . getInput ( ) is None ) <EOL> self . assertTrue ( s2 [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:2> ] . getInput ( ) . isSame ( s2 [ "<STR_LIT:c>" ] [ "<STR_LIT>" ] ) ) <EOL> self . assertTrue ( s2 [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:3> ] . getInput ( ) is None ) <EOL> s2 [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:3> ] . setInput ( s2 [ "<STR_LIT:c>" ] [ "<STR_LIT>" ] ) <EOL> self . assertEqual ( len ( s2 [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) , <NUM_LIT:5> ) <EOL> self . assertTrue ( s2 [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:0> ] . getInput ( ) . isSame ( s2 [ "<STR_LIT:c>" ] [ "<STR_LIT>" ] ) ) <EOL> self . assertTrue ( s2 [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:1> ] . getInput ( ) is None ) <EOL> self . assertTrue ( s2 [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:2> ] . getInput ( ) . isSame ( s2 [ "<STR_LIT:c>" ] [ "<STR_LIT>" ] ) ) <EOL> self . assertTrue ( s2 [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:3> ] . getInput ( ) . isSame ( s2 [ "<STR_LIT:c>" ] [ "<STR_LIT>" ] ) ) <EOL> self . assertTrue ( s2 [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:4> ] . getInput ( ) is None ) <EOL> def testConvertFixedCoshaderArrayToDynamic ( self ) : <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> shaderV2 = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> coshader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> s = Gaffer . ScriptNode ( ) <EOL> s [ "<STR_LIT:n>" ] = GafferRenderMan . RenderManShader ( ) <EOL> s [ "<STR_LIT:n>" ] . loadShader ( shader ) <EOL> s [ "<STR_LIT:c>" ] = GafferRenderMan . RenderManShader ( ) <EOL> s [ "<STR_LIT:c>" ] . loadShader ( coshader ) <EOL> s [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:0> ] . setInput ( s [ "<STR_LIT:c>" ] [ "<STR_LIT>" ] ) <EOL> self . assertTrue ( len ( s [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) , <NUM_LIT:4> ) <EOL> s [ "<STR_LIT:n>" ] . loadShader ( shaderV2 , keepExistingValues = True ) <EOL> self . assertTrue ( s [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:0> ] . getInput ( ) . isSame ( s [ "<STR_LIT:c>" ] [ "<STR_LIT>" ] ) ) <EOL> self . assertTrue ( s [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:1> ] . getInput ( ) is None ) <EOL> s [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:0> ] . setInput ( None ) <EOL> self . assertEqual ( len ( s [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) , <NUM_LIT:1> ) <EOL> self . assertTrue ( s [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:0> ] . getInput ( ) is None ) <EOL> def testConvertFixedCoshaderArrayToDynamicWithFirstPlugUnconnected ( self ) : <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> shaderV2 = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> coshader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> s = Gaffer . ScriptNode ( ) <EOL> s [ "<STR_LIT:n>" ] = GafferRenderMan . RenderManShader ( ) <EOL> s [ "<STR_LIT:n>" ] . loadShader ( shader ) <EOL> s [ "<STR_LIT:c>" ] = GafferRenderMan . RenderManShader ( ) <EOL> s [ "<STR_LIT:c>" ] . loadShader ( coshader ) <EOL> s [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:1> ] . setInput ( s [ "<STR_LIT:c>" ] [ "<STR_LIT>" ] ) <EOL> self . assertTrue ( len ( s [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) , <NUM_LIT:4> ) <EOL> s [ "<STR_LIT:n>" ] . loadShader ( shaderV2 , keepExistingValues = True ) <EOL> self . assertTrue ( s [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:1> ] . getInput ( ) . isSame ( s [ "<STR_LIT:c>" ] [ "<STR_LIT>" ] ) ) <EOL> self . assertTrue ( s [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:0> ] . getInput ( ) is None ) <EOL> s [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:1> ] . setInput ( None ) <EOL> self . assertEqual ( len ( s [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) , <NUM_LIT:1> ) <EOL> self . assertTrue ( s [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:0> ] . getInput ( ) is None ) <EOL> def testConvertFixedCoshaderArrayToDynamicDuringLoading ( self ) : <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> coshader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> s = Gaffer . ScriptNode ( ) <EOL> s [ "<STR_LIT:n>" ] = GafferRenderMan . RenderManShader ( ) <EOL> s [ "<STR_LIT:n>" ] . loadShader ( shader ) <EOL> s [ "<STR_LIT:c>" ] = GafferRenderMan . RenderManShader ( ) <EOL> s [ "<STR_LIT:c>" ] . loadShader ( coshader ) <EOL> s [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:1> ] . setInput ( s [ "<STR_LIT:c>" ] [ "<STR_LIT>" ] ) <EOL> self . assertTrue ( len ( s [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) , <NUM_LIT:4> ) <EOL> GafferRenderMan . RenderManShader . shaderLoader ( ) . clear ( ) <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" , shaderName = "<STR_LIT>" ) <EOL> s2 = Gaffer . ScriptNode ( ) <EOL> s2 . execute ( s . serialise ( ) ) <EOL> self . assertTrue ( s2 [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:1> ] . getInput ( ) . isSame ( s2 [ "<STR_LIT:c>" ] [ "<STR_LIT>" ] ) ) <EOL> self . assertTrue ( s2 [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:0> ] . getInput ( ) is None ) <EOL> s2 [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:1> ] . setInput ( None ) <EOL> self . assertEqual ( len ( s2 [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) , <NUM_LIT:1> ) <EOL> self . assertTrue ( s2 [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:0> ] . getInput ( ) is None ) <EOL> def testHashThroughBox ( self ) : <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> shaderNode = GafferRenderMan . RenderManShader ( ) <EOL> shaderNode . loadShader ( shader ) <EOL> b = Gaffer . Box ( ) <EOL> b . addChild ( Gaffer . Plug ( "<STR_LIT>" ) ) <EOL> b . addChild ( Gaffer . Plug ( "<STR_LIT>" , direction = Gaffer . Plug . Direction . Out ) ) <EOL> intermediateCoshader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> intermediateCoshaderNode = GafferRenderMan . RenderManShader ( ) <EOL> intermediateCoshaderNode . loadShader ( intermediateCoshader ) <EOL> coshader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> coshaderNode = GafferRenderMan . RenderManShader ( ) <EOL> coshaderNode . loadShader ( coshader ) <EOL> b [ "<STR_LIT>" ] . setInput ( coshaderNode [ "<STR_LIT>" ] ) <EOL> intermediateCoshaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( b [ "<STR_LIT>" ] ) <EOL> b [ "<STR_LIT>" ] . setInput ( intermediateCoshaderNode [ "<STR_LIT>" ] ) <EOL> shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( b [ "<STR_LIT>" ] ) <EOL> h1 = shaderNode . stateHash ( ) <EOL> coshaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setValue ( <NUM_LIT> ) <EOL> self . assertNotEqual ( shaderNode . stateHash ( ) , h1 ) <EOL> def testDanglingBoxConnection ( self ) : <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> shaderNode1 = GafferRenderMan . RenderManShader ( ) <EOL> shaderNode1 . loadShader ( shader ) <EOL> shaderNode2 = GafferRenderMan . RenderManShader ( ) <EOL> shaderNode2 . loadShader ( shader ) <EOL> b = Gaffer . Box ( ) <EOL> b . addChild ( Gaffer . Plug ( "<STR_LIT>" ) ) <EOL> b . addChild ( Gaffer . Plug ( "<STR_LIT>" , direction = Gaffer . Plug . Direction . Out ) ) <EOL> b [ "<STR_LIT>" ] = shaderNode1 <EOL> shaderNode1 [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( b [ "<STR_LIT>" ] ) <EOL> shaderNode2 [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( b [ "<STR_LIT>" ] ) <EOL> def testUnconnectedCustomBoxInput ( self ) : <EOL> class CustomBox ( Gaffer . Box ) : <EOL> def __init__ ( self , name = "<STR_LIT>" ) : <EOL> Gaffer . Box . __init__ ( self , name ) <EOL> IECore . registerRunTimeTyped ( CustomBox ) <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> b = CustomBox ( ) <EOL> b [ "<STR_LIT:s>" ] = GafferRenderMan . RenderManShader ( ) <EOL> b [ "<STR_LIT:s>" ] . loadShader ( shader ) <EOL> b [ "<STR_LIT>" ] = b [ "<STR_LIT:s>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . createCounterpart ( "<STR_LIT>" , Gaffer . Plug . Direction . In ) <EOL> b [ "<STR_LIT:s>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( b [ "<STR_LIT>" ] ) <EOL> s = b [ "<STR_LIT:s>" ] . state ( ) <EOL> self . assertEqual ( len ( s ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( s [ <NUM_LIT:0> ] . name , shader ) <EOL> self . assertTrue ( b [ "<STR_LIT:s>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getInput ( ) . isSame ( b [ "<STR_LIT>" ] ) ) <EOL> coshader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> c = GafferRenderMan . RenderManShader ( ) <EOL> c . loadShader ( coshader ) <EOL> self . assertTrue ( b [ "<STR_LIT>" ] . acceptsInput ( c [ "<STR_LIT>" ] ) ) <EOL> b [ "<STR_LIT>" ] . setInput ( c [ "<STR_LIT>" ] ) <EOL> s = b [ "<STR_LIT:s>" ] . state ( ) <EOL> self . assertEqual ( len ( s ) , <NUM_LIT:2> ) <EOL> self . assertEqual ( s [ <NUM_LIT:1> ] . parameters [ "<STR_LIT>" ] , s [ <NUM_LIT:0> ] . parameters [ "<STR_LIT>" ] ) <EOL> n = Gaffer . Node ( ) <EOL> n [ "<STR_LIT>" ] = b [ "<STR_LIT>" ] . createCounterpart ( "<STR_LIT>" , Gaffer . Plug . Direction . Out ) <EOL> self . assertFalse ( b [ "<STR_LIT>" ] . acceptsInput ( n [ "<STR_LIT>" ] ) ) <EOL> self . assertRaises ( RuntimeError , b [ "<STR_LIT>" ] . setInput , n [ "<STR_LIT>" ] ) <EOL> b [ "<STR_LIT:s>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( None ) <EOL> self . assertTrue ( b [ "<STR_LIT>" ] . acceptsInput ( n [ "<STR_LIT>" ] ) ) <EOL> b [ "<STR_LIT>" ] . setInput ( n [ "<STR_LIT>" ] ) <EOL> self . assertTrue ( b [ "<STR_LIT>" ] . getInput ( ) . isSame ( n [ "<STR_LIT>" ] ) ) <EOL> self . assertFalse ( b [ "<STR_LIT:s>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . acceptsInput ( b [ "<STR_LIT>" ] ) ) <EOL> self . assertRaises ( RuntimeError , b [ "<STR_LIT:s>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput , b [ "<STR_LIT>" ] ) <EOL> def testCoshaderSwitching ( self ) : <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> coshader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> coshaderNode0 = GafferRenderMan . RenderManShader ( ) <EOL> coshaderNode0 . loadShader ( coshader ) <EOL> coshaderNode1 = GafferRenderMan . RenderManShader ( ) <EOL> coshaderNode1 . loadShader ( coshader ) <EOL> coshaderNode0 [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setValue ( <NUM_LIT:0> ) <EOL> coshaderNode1 [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setValue ( <NUM_LIT:1> ) <EOL> shaderNode = GafferRenderMan . RenderManShader ( ) <EOL> shaderNode . loadShader ( shader ) <EOL> switch = GafferScene . ShaderSwitch ( ) <EOL> switch [ "<STR_LIT>" ] . setInput ( coshaderNode0 [ "<STR_LIT>" ] ) <EOL> switch [ "<STR_LIT>" ] . setInput ( coshaderNode1 [ "<STR_LIT>" ] ) <EOL> shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( switch [ "<STR_LIT>" ] ) <EOL> self . assertEqual ( shaderNode . state ( ) [ <NUM_LIT:0> ] . parameters [ "<STR_LIT>" ] . value , <NUM_LIT:0> ) <EOL> switch [ "<STR_LIT:index>" ] . setValue ( <NUM_LIT:1> ) <EOL> self . assertEqual ( shaderNode . state ( ) [ <NUM_LIT:0> ] . parameters [ "<STR_LIT>" ] . value , <NUM_LIT:1> ) <EOL> switch [ "<STR_LIT>" ] . setValue ( False ) <EOL> self . assertEqual ( shaderNode . state ( ) [ <NUM_LIT:0> ] . parameters [ "<STR_LIT>" ] . value , <NUM_LIT:0> ) <EOL> def testCoshaderTypingPreventsNewInvalidSwitchInputs ( self ) : <EOL> coshaderType1 = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> coshaderType1Node = GafferRenderMan . RenderManShader ( ) <EOL> coshaderType1Node . loadShader ( coshaderType1 ) <EOL> coshaderType2 = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> coshaderType2Node = GafferRenderMan . RenderManShader ( ) <EOL> coshaderType2Node . loadShader ( coshaderType2 ) <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> shaderNode = GafferRenderMan . RenderManShader ( ) <EOL> shaderNode . loadShader ( shader ) <EOL> switch = GafferScene . ShaderSwitch ( ) <EOL> switch [ "<STR_LIT>" ] . setInput ( coshaderType1Node [ "<STR_LIT>" ] ) <EOL> shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( switch [ "<STR_LIT>" ] ) <EOL> self . assertFalse ( switch [ "<STR_LIT>" ] . acceptsInput ( coshaderType2Node [ "<STR_LIT>" ] ) ) <EOL> self . assertTrue ( switch [ "<STR_LIT>" ] . acceptsInput ( coshaderType1Node [ "<STR_LIT>" ] ) ) <EOL> def testAcceptInputFromEmptySwitch ( self ) : <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> shaderNode = GafferRenderMan . RenderManShader ( ) <EOL> shaderNode . loadShader ( shader ) <EOL> switch = GafferScene . ShaderSwitch ( ) <EOL> self . assertTrue ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . acceptsInput ( switch [ "<STR_LIT>" ] ) ) <EOL> def testCoshaderSwitchingInBox ( self ) : <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> coshader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> script = Gaffer . ScriptNode ( ) <EOL> script [ "<STR_LIT>" ] = GafferRenderMan . RenderManShader ( ) <EOL> script [ "<STR_LIT>" ] . loadShader ( coshader ) <EOL> script [ "<STR_LIT>" ] = GafferRenderMan . RenderManShader ( ) <EOL> script [ "<STR_LIT>" ] . loadShader ( coshader ) <EOL> script [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setValue ( <NUM_LIT:0> ) <EOL> script [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setValue ( <NUM_LIT:1> ) <EOL> script [ "<STR_LIT>" ] = GafferRenderMan . RenderManShader ( ) <EOL> script [ "<STR_LIT>" ] . loadShader ( shader ) <EOL> script [ "<STR_LIT>" ] = GafferScene . ShaderSwitch ( ) <EOL> script [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( script [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) <EOL> script [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( script [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) <EOL> script [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( script [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) <EOL> self . assertEqual ( script [ "<STR_LIT>" ] . state ( ) [ <NUM_LIT:0> ] . parameters [ "<STR_LIT>" ] . value , <NUM_LIT:0> ) <EOL> box = Gaffer . Box . create ( script , Gaffer . StandardSet ( script . children ( Gaffer . Node ) ) ) <EOL> self . assertEqual ( box [ "<STR_LIT>" ] . state ( ) [ <NUM_LIT:0> ] . parameters [ "<STR_LIT>" ] . value , <NUM_LIT:0> ) <EOL> promotedIndex = box . promotePlug ( box [ "<STR_LIT>" ] [ "<STR_LIT:index>" ] ) <EOL> self . assertEqual ( box [ "<STR_LIT>" ] . state ( ) [ <NUM_LIT:0> ] . parameters [ "<STR_LIT>" ] . value , <NUM_LIT:0> ) <EOL> promotedIndex . setValue ( <NUM_LIT:1> ) <EOL> self . assertEqual ( box [ "<STR_LIT>" ] . state ( ) [ <NUM_LIT:0> ] . parameters [ "<STR_LIT>" ] . value , <NUM_LIT:1> ) <EOL> def testRepeatability ( self ) : <EOL> s1 = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> s2 = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> sn1 = GafferRenderMan . RenderManShader ( ) <EOL> sn2 = GafferRenderMan . RenderManShader ( ) <EOL> sn1 . loadShader ( s1 ) <EOL> sn2 . loadShader ( s2 ) <EOL> sn2 [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( sn1 [ "<STR_LIT>" ] ) <EOL> self . assertEqual ( sn2 . stateHash ( ) , sn2 . stateHash ( ) ) <EOL> self . assertEqual ( sn2 . state ( ) , sn2 . state ( ) ) <EOL> def testHandlesAreHumanReadable ( self ) : <EOL> s1 = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> s2 = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> sn1 = GafferRenderMan . RenderManShader ( "<STR_LIT>" ) <EOL> sn2 = GafferRenderMan . RenderManShader ( "<STR_LIT>" ) <EOL> sn1 . loadShader ( s1 ) <EOL> sn2 . loadShader ( s2 ) <EOL> sn2 [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( sn1 [ "<STR_LIT>" ] ) <EOL> state = sn2 . state ( ) <EOL> self . assertTrue ( "<STR_LIT>" in state [ <NUM_LIT:0> ] . parameters [ "<STR_LIT>" ] . value ) <EOL> def testHandlesAreUniqueEvenIfNodeNamesArent ( self ) : <EOL> s1 = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> s2 = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> script = Gaffer . ScriptNode ( ) <EOL> script [ "<STR_LIT>" ] = GafferRenderMan . RenderManShader ( ) <EOL> script [ "<STR_LIT>" ] . loadShader ( s1 ) <EOL> script [ "<STR_LIT>" ] = GafferRenderMan . RenderManShader ( ) <EOL> script [ "<STR_LIT>" ] . loadShader ( s1 ) <EOL> script [ "<STR_LIT>" ] = GafferRenderMan . RenderManShader ( ) <EOL> script [ "<STR_LIT>" ] . loadShader ( s2 ) <EOL> script [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:0> ] . setInput ( script [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) <EOL> script [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ <NUM_LIT:1> ] . setInput ( script [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) <EOL> box = Gaffer . Box . create ( script , Gaffer . StandardSet ( [ script [ "<STR_LIT>" ] ] ) ) <EOL> box [ "<STR_LIT>" ] . setName ( "<STR_LIT>" ) <EOL> script [ "<STR_LIT>" ] . setName ( "<STR_LIT>" ) <EOL> state = script [ "<STR_LIT>" ] . state ( ) <EOL> self . assertNotEqual ( state [ <NUM_LIT:0> ] . parameters [ "<STR_LIT>" ] , state [ <NUM_LIT:1> ] . parameters [ "<STR_LIT>" ] ) <EOL> def testShaderTypesInState ( self ) : <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> shaderNode = GafferRenderMan . RenderManShader ( ) <EOL> shaderNode . loadShader ( shader ) <EOL> coshader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> coshaderNode = GafferRenderMan . RenderManShader ( ) <EOL> coshaderNode . loadShader ( coshader ) <EOL> shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( coshaderNode [ "<STR_LIT>" ] ) <EOL> state = shaderNode . state ( ) <EOL> self . assertEqual ( state [ <NUM_LIT:0> ] . type , "<STR_LIT>" ) <EOL> self . assertEqual ( state [ <NUM_LIT:1> ] . type , "<STR_LIT>" ) <EOL> def testAssignmentAttributeName ( self ) : <EOL> p = GafferScene . Plane ( ) <EOL> s = GafferRenderMan . RenderManShader ( ) <EOL> s . loadShader ( "<STR_LIT>" ) <EOL> a = GafferScene . ShaderAssignment ( ) <EOL> a [ "<STR_LIT>" ] . setInput ( p [ "<STR_LIT>" ] ) <EOL> a [ "<STR_LIT>" ] . setInput ( s [ "<STR_LIT>" ] ) <EOL> self . assertEqual ( a [ "<STR_LIT>" ] . attributes ( "<STR_LIT>" ) . keys ( ) , [ "<STR_LIT>" ] ) <EOL> def testVolumeShader ( self ) : <EOL> s = GafferRenderMan . RenderManShader ( ) <EOL> s . loadShader ( "<STR_LIT>" ) <EOL> self . assertEqual ( s [ "<STR_LIT:type>" ] . getValue ( ) , "<STR_LIT>" ) <EOL> s [ "<STR_LIT:type>" ] . setValue ( "<STR_LIT>" ) <EOL> s . loadShader ( "<STR_LIT>" , keepExistingValues = True ) <EOL> self . assertEqual ( s [ "<STR_LIT:type>" ] . getValue ( ) , "<STR_LIT>" ) <EOL> s . loadShader ( "<STR_LIT>" , keepExistingValues = False ) <EOL> self . assertEqual ( s [ "<STR_LIT:type>" ] . getValue ( ) , "<STR_LIT>" ) <EOL> def testInputAcceptanceFromDots ( self ) : <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> shaderNode = GafferRenderMan . RenderManShader ( ) <EOL> shaderNode . loadShader ( shader ) <EOL> coshader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> coshaderNode = GafferRenderMan . RenderManShader ( ) <EOL> coshaderNode . loadShader ( coshader ) <EOL> dot = Gaffer . Dot ( ) <EOL> dot . setup ( coshaderNode [ "<STR_LIT>" ] ) <EOL> self . assertTrue ( shaderNode [ "<STR_LIT>" ] [ "<STR_LIT>" ] . acceptsInput ( dot [ "<STR_LIT>" ] ) ) <EOL> def testShaderTypeOverride ( self ) : <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> shaderNode = GafferRenderMan . RenderManShader ( ) <EOL> shaderNode . loadShader ( shader ) <EOL> self . assertEqual ( shaderNode [ '<STR_LIT:type>' ] . getValue ( ) , "<STR_LIT>" ) <EOL> def testReferencePromotedCoshader ( self ) : <EOL> s = Gaffer . ScriptNode ( ) <EOL> shader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> coshader = self . compileShader ( os . path . dirname ( __file__ ) + "<STR_LIT>" ) <EOL> s [ "<STR_LIT:b>" ] = Gaffer . Box ( ) <EOL> s [ "<STR_LIT:b>" ] [ "<STR_LIT:s>" ] = GafferRenderMan . RenderManShader ( ) <EOL> s [ "<STR_LIT:b>" ] [ "<STR_LIT:s>" ] . loadShader ( shader ) <EOL> p = s [ "<STR_LIT:b>" ] . promotePlug ( s [ "<STR_LIT:b>" ] [ "<STR_LIT:s>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) <EOL> p . setName ( "<STR_LIT:p>" ) <EOL> s [ "<STR_LIT:c>" ] = GafferRenderMan . RenderManShader ( ) <EOL> s [ "<STR_LIT:c>" ] . loadShader ( coshader ) <EOL> self . assertTrue ( s [ "<STR_LIT:b>" ] [ "<STR_LIT:p>" ] . acceptsInput ( s [ "<STR_LIT:c>" ] [ "<STR_LIT>" ] ) ) <EOL> s [ "<STR_LIT:b>" ] . exportForReference ( self . temporaryDirectory ( ) + "<STR_LIT>" ) <EOL> s [ "<STR_LIT:r>" ] = Gaffer . Reference ( ) <EOL> s [ "<STR_LIT:r>" ] . load ( self . temporaryDirectory ( ) + "<STR_LIT>" ) <EOL> self . assertTrue ( s [ "<STR_LIT:r>" ] [ "<STR_LIT:p>" ] . acceptsInput ( s [ "<STR_LIT:c>" ] [ "<STR_LIT>" ] ) ) <EOL> def testLoadAndGIL ( self ) : <EOL> script = Gaffer . ScriptNode ( ) <EOL> script [ "<STR_LIT>" ] = GafferScene . Plane ( ) <EOL> script [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setValue ( IECore . V2i ( <NUM_LIT:20> ) ) <EOL> script [ "<STR_LIT>" ] = GafferScene . Sphere ( ) <EOL> script [ "<STR_LIT>" ] = Gaffer . Expression ( ) <EOL> script [ "<STR_LIT>" ] . setExpression ( "<STR_LIT>" ) <EOL> script [ "<STR_LIT>" ] = GafferScene . Instancer ( ) <EOL> script [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( script [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) <EOL> script [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( script [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) <EOL> script [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setValue ( "<STR_LIT>" ) <EOL> script [ "<STR_LIT>" ] = GafferRenderMan . RenderManShader ( ) <EOL> script [ "<STR_LIT>" ] = GafferScene . ShaderAssignment ( ) <EOL> script [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( script [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) <EOL> script [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( script [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) <EOL> traverseConnection = Gaffer . ScopedConnection ( GafferSceneTest . connectTraverseSceneToPlugDirtiedSignal ( script [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) ) <EOL> script [ "<STR_LIT>" ] . loadShader ( "<STR_LIT>" ) <EOL> if __name__ == "<STR_LIT:__main__>" : <EOL> unittest . main ( ) </s>
<s> import os <EOL> import unittest <EOL> import IECore <EOL> import Gaffer <EOL> import GafferImage <EOL> import GafferScene <EOL> import GafferSceneTest <EOL> @ unittest . skipIf ( "<STR_LIT>" in os . environ , "<STR_LIT>" ) <EOL> class OpenGLRenderTest ( GafferSceneTest . SceneTestCase ) : <EOL> def test ( self ) : <EOL> self . assertFalse ( os . path . exists ( self . temporaryDirectory ( ) + "<STR_LIT>" ) ) <EOL> s = Gaffer . ScriptNode ( ) <EOL> s [ "<STR_LIT>" ] = GafferScene . Plane ( ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setValue ( IECore . V3f ( <NUM_LIT:0> , <NUM_LIT:0> , - <NUM_LIT:5> ) ) <EOL> s [ "<STR_LIT:image>" ] = GafferImage . ImageReader ( ) <EOL> s [ "<STR_LIT:image>" ] [ "<STR_LIT>" ] . setValue ( os . path . expandvars ( "<STR_LIT>" ) ) <EOL> s [ "<STR_LIT>" ] = GafferScene . OpenGLShader ( ) <EOL> s [ "<STR_LIT>" ] . loadShader ( "<STR_LIT>" ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( s [ "<STR_LIT:image>" ] [ "<STR_LIT>" ] ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setValue ( <NUM_LIT:1> ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setValue ( IECore . Color4f ( <NUM_LIT:1> ) ) <EOL> s [ "<STR_LIT>" ] = GafferScene . ShaderAssignment ( ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( s [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( s [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) <EOL> s [ "<STR_LIT>" ] = GafferScene . Outputs ( ) <EOL> s [ "<STR_LIT>" ] . addOutput ( <EOL> "<STR_LIT>" , <EOL> IECore . Display ( <EOL> self . temporaryDirectory ( ) + "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> { } <EOL> ) <EOL> ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( s [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) <EOL> s [ "<STR_LIT>" ] = GafferScene . OpenGLRender ( ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( s [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) <EOL> s [ "<STR_LIT>" ] . setValue ( self . temporaryDirectory ( ) + "<STR_LIT>" ) <EOL> s . save ( ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] . execute ( ) <EOL> self . assertTrue ( os . path . exists ( self . temporaryDirectory ( ) + "<STR_LIT>" ) ) <EOL> i = IECore . EXRImageReader ( self . temporaryDirectory ( ) + "<STR_LIT>" ) . read ( ) <EOL> e = IECore . ImagePrimitiveEvaluator ( i ) <EOL> r = e . createResult ( ) <EOL> e . pointAtUV ( IECore . V2f ( <NUM_LIT:0.5> ) , r ) <EOL> self . assertAlmostEqual ( r . floatPrimVar ( e . R ( ) ) , <NUM_LIT> , <NUM_LIT:5> ) <EOL> self . assertAlmostEqual ( r . floatPrimVar ( e . G ( ) ) , <NUM_LIT> , <NUM_LIT:5> ) <EOL> self . assertEqual ( r . floatPrimVar ( e . B ( ) ) , <NUM_LIT:0> ) <EOL> def testOutputDirectoryCreation ( self ) : <EOL> s = Gaffer . ScriptNode ( ) <EOL> s [ "<STR_LIT>" ] . addMember ( "<STR_LIT>" , self . temporaryDirectory ( ) + "<STR_LIT>" ) <EOL> s [ "<STR_LIT>" ] = GafferScene . Plane ( ) <EOL> s [ "<STR_LIT>" ] = GafferScene . Outputs ( ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( s [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) <EOL> s [ "<STR_LIT>" ] . addOutput ( <EOL> "<STR_LIT>" , <EOL> IECore . Display ( <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> { } <EOL> ) <EOL> ) <EOL> s [ "<STR_LIT>" ] = GafferScene . OpenGLRender ( ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( s [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) <EOL> self . assertFalse ( os . path . exists ( self . temporaryDirectory ( ) + "<STR_LIT>" ) ) <EOL> self . assertFalse ( os . path . exists ( self . temporaryDirectory ( ) + "<STR_LIT>" ) ) <EOL> s [ "<STR_LIT>" ] . setValue ( "<STR_LIT>" ) <EOL> with s . context ( ) : <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] . execute ( ) <EOL> self . assertTrue ( os . path . exists ( self . temporaryDirectory ( ) + "<STR_LIT>" ) ) <EOL> self . assertTrue ( os . path . exists ( self . temporaryDirectory ( ) + "<STR_LIT>" ) ) <EOL> def testHash ( self ) : <EOL> c = Gaffer . Context ( ) <EOL> c . setFrame ( <NUM_LIT:1> ) <EOL> c2 = Gaffer . Context ( ) <EOL> c2 . setFrame ( <NUM_LIT:2> ) <EOL> s = Gaffer . ScriptNode ( ) <EOL> s [ "<STR_LIT>" ] = GafferScene . Plane ( ) <EOL> s [ "<STR_LIT>" ] = GafferScene . Outputs ( ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( s [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) <EOL> s [ "<STR_LIT>" ] . addOutput ( "<STR_LIT>" , IECore . Display ( "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , { } ) ) <EOL> s [ "<STR_LIT>" ] = GafferScene . OpenGLRender ( ) <EOL> self . assertEqual ( s [ "<STR_LIT>" ] . hash ( c ) , IECore . MurmurHash ( ) ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( s [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) <EOL> self . assertNotEqual ( s [ "<STR_LIT>" ] . hash ( c ) , IECore . MurmurHash ( ) ) <EOL> self . assertNotEqual ( s [ "<STR_LIT>" ] . hash ( c ) , s [ "<STR_LIT>" ] . hash ( c2 ) ) <EOL> current = s [ "<STR_LIT>" ] . hash ( c ) <EOL> c [ "<STR_LIT>" ] = self . temporaryDirectory ( ) + "<STR_LIT>" <EOL> self . assertNotEqual ( s [ "<STR_LIT>" ] . hash ( c ) , current ) <EOL> current = s [ "<STR_LIT>" ] . hash ( c ) <EOL> c [ "<STR_LIT>" ] = self . temporaryDirectory ( ) + "<STR_LIT>" <EOL> self . assertNotEqual ( s [ "<STR_LIT>" ] . hash ( c ) , current ) <EOL> current = s [ "<STR_LIT>" ] . hash ( c ) <EOL> c [ "<STR_LIT>" ] = "<STR_LIT>" <EOL> self . assertEqual ( s [ "<STR_LIT>" ] . hash ( c ) , current ) <EOL> current = s [ "<STR_LIT>" ] . hash ( c ) <EOL> s [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setInput ( s [ "<STR_LIT>" ] [ "<STR_LIT>" ] ) <EOL> self . assertNotEqual ( s [ "<STR_LIT>" ] . hash ( c ) , current ) <EOL> if __name__ == "<STR_LIT:__main__>" : <EOL> unittest . main ( ) </s>
<s> import unittest <EOL> import IECore <EOL> import Gaffer <EOL> import GafferTest <EOL> import GafferScene <EOL> import GafferSceneTest <EOL> class SceneTimeWarpTest ( GafferSceneTest . SceneTestCase ) : <EOL> def testConstruct ( self ) : <EOL> s = Gaffer . ScriptNode ( ) <EOL> s [ "<STR_LIT:n>" ] = GafferScene . SceneTimeWarp ( ) <EOL> self . assertEqual ( s [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] . getValue ( ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( s [ "<STR_LIT:n>" ] [ "<STR_LIT>" ] . getValue ( ) , <NUM_LIT:0> ) <EOL> def testRunTimeTyped ( self ) : <EOL> n = GafferScene . SceneTimeWarp ( ) <EOL> self . failUnless ( n . isInstanceOf ( GafferScene . SceneTimeWarp . staticTypeId ( ) ) ) <EOL> self . failUnless ( n . isInstanceOf ( GafferScene . SceneContextProcessor . staticTypeId ( ) ) ) <EOL> self . failUnless ( n . isInstanceOf ( GafferScene . SceneProcessor . staticTypeId ( ) ) ) <EOL> self . failUnless ( n . isInstanceOf ( GafferScene . SceneNode . staticTypeId ( ) ) ) <EOL> self . failUnless ( n . isInstanceOf ( Gaffer . Node . staticTypeId ( ) ) ) <EOL> baseTypeIds = IECore . RunTimeTyped . baseTypeIds ( n . typeId ( ) ) <EOL> self . failUnless ( GafferScene . SceneContextProcessor . staticTypeId ( ) in baseTypeIds ) <EOL> self . failUnless ( GafferScene . SceneProcessor . staticTypeId ( ) in baseTypeIds ) <EOL> self . failUnless ( GafferScene . SceneNode . staticTypeId ( ) in baseTypeIds ) <EOL> self . failUnless ( Gaffer . Node . staticTypeId ( ) in baseTypeIds ) <EOL> def testAffects ( self ) : <EOL> n = GafferScene . SceneTimeWarp ( ) <EOL> c = GafferTest . CapturingSlot ( n . plugDirtiedSignal ( ) ) <EOL> n [ "<STR_LIT>" ] . setValue ( <NUM_LIT:2> ) <EOL> found = False <EOL> for cc in c : <EOL> if cc [ <NUM_LIT:0> ] . isSame ( n [ "<STR_LIT>" ] ) : <EOL> found = True <EOL> self . failUnless ( found ) <EOL> del c [ : ] <EOL> n [ "<STR_LIT>" ] . setValue ( <NUM_LIT:2> ) <EOL> found = False <EOL> for cc in c : <EOL> if cc [ <NUM_LIT:0> ] . isSame ( n [ "<STR_LIT>" ] ) : <EOL> found = True <EOL> self . failUnless ( found ) <EOL> def testNoExtraInputs ( self ) : <EOL> p = GafferScene . Plane ( ) <EOL> n = GafferScene . SceneTimeWarp ( ) <EOL> n [ "<STR_LIT>" ] . setInput ( p [ "<STR_LIT>" ] ) <EOL> self . assertTrue ( "<STR_LIT>" not in n ) <EOL> if __name__ == "<STR_LIT:__main__>" : <EOL> unittest . main ( ) </s>
<s> import Gaffer <EOL> import GafferScene <EOL> Gaffer . Metadata . registerNode ( <EOL> GafferScene . Cube , <EOL> "<STR_LIT:description>" , <EOL> """<STR_LIT>""" , <EOL> plugs = { <EOL> "<STR_LIT>" : [ <EOL> "<STR_LIT:description>" , <EOL> """<STR_LIT>""" , <EOL> ] , <EOL> } <EOL> ) </s>
<s> import Gaffer <EOL> import GafferScene <EOL> import GafferUI <EOL> Gaffer . Metadata . registerNode ( <EOL> GafferScene . ObjectSource , <EOL> "<STR_LIT:description>" , <EOL> """<STR_LIT>""" , <EOL> plugs = { <EOL> "<STR_LIT:name>" : [ <EOL> "<STR_LIT:description>" , <EOL> """<STR_LIT>""" , <EOL> ] , <EOL> "<STR_LIT>" : [ <EOL> "<STR_LIT:description>" , <EOL> """<STR_LIT>""" , <EOL> "<STR_LIT>" , "<STR_LIT>" , <EOL> ] , <EOL> "<STR_LIT>" : [ <EOL> "<STR_LIT:description>" , <EOL> """<STR_LIT>""" , <EOL> ] , <EOL> } <EOL> ) </s>
<s> import functools <EOL> import IECore <EOL> import Gaffer <EOL> import GafferUI <EOL> import GafferScene <EOL> import GafferSceneUI <EOL> Gaffer . Metadata . registerNode ( <EOL> GafferSceneUI . SceneView , <EOL> plugs = { <EOL> "<STR_LIT>" : [ <EOL> "<STR_LIT>" , <NUM_LIT:2> , <EOL> "<STR_LIT>" , True , <EOL> "<STR_LIT>" , "<STR_LIT>" , <EOL> ] , <EOL> "<STR_LIT>" : [ <EOL> "<STR_LIT>" , "<STR_LIT>" , <EOL> "<STR_LIT>" , True , <EOL> ] , <EOL> "<STR_LIT>" : [ <EOL> "<STR_LIT>" , "<STR_LIT>" , <EOL> "<STR_LIT>" , True , <EOL> "<STR_LIT>" , "<STR_LIT>" , <EOL> ] , <EOL> "<STR_LIT>" : [ <EOL> "<STR_LIT:description>" , <EOL> """<STR_LIT>""" , <EOL> ] , <EOL> "<STR_LIT>" : [ <EOL> "<STR_LIT:description>" , <EOL> """<STR_LIT>""" , <EOL> ] , <EOL> "<STR_LIT>" : [ <EOL> "<STR_LIT>" , "<STR_LIT>" , <EOL> ] , <EOL> "<STR_LIT>" : [ <EOL> "<STR_LIT>" , "<STR_LIT>" , <EOL> ] , <EOL> } <EOL> ) <EOL> class _ShadingModePlugValueWidget ( GafferUI . PlugValueWidget ) : <EOL> def __init__ ( self , plug , parenting = None ) : <EOL> menuButton = GafferUI . MenuButton ( <EOL> image = "<STR_LIT>" , <EOL> menu = GafferUI . Menu ( Gaffer . WeakMethod ( self . __menuDefinition ) ) , <EOL> hasFrame = False , <EOL> ) <EOL> GafferUI . PlugValueWidget . __init__ ( self , menuButton , plug , parenting = parenting ) <EOL> def hasLabel ( self ) : <EOL> return True <EOL> def _updateFromPlug ( self ) : <EOL> pass <EOL> def __menuDefinition ( self ) : <EOL> m = IECore . MenuDefinition ( ) <EOL> currentName = self . getPlug ( ) . getValue ( ) <EOL> for name in [ "<STR_LIT>" ] + GafferSceneUI . SceneView . registeredShadingModes ( ) : <EOL> m . append ( <EOL> "<STR_LIT:/>" + name if name else "<STR_LIT>" , <EOL> { <EOL> "<STR_LIT>" : name == currentName , <EOL> "<STR_LIT>" : functools . partial ( Gaffer . WeakMethod ( self . __setValue ) , name if name != currentName else "<STR_LIT>" ) , <EOL> } <EOL> ) <EOL> if not name : <EOL> m . append ( "<STR_LIT>" , { "<STR_LIT>" : True } ) <EOL> return m <EOL> def __setValue ( self , value , * unused ) : <EOL> self . getPlug ( ) . setValue ( value ) <EOL> class _ExpansionPlugValueWidget ( GafferUI . PlugValueWidget ) : <EOL> def __init__ ( self , plug , parenting = None ) : <EOL> menu = GafferUI . Menu ( Gaffer . WeakMethod ( self . __menuDefinition ) ) <EOL> menuButton = GafferUI . MenuButton ( menu = menu , image = "<STR_LIT>" , hasFrame = False ) <EOL> GafferUI . PlugValueWidget . __init__ ( self , menuButton , plug , parenting = parenting ) <EOL> def hasLabel ( self ) : <EOL> return True <EOL> def _updateFromPlug ( self ) : <EOL> pass <EOL> def __menuDefinition ( self ) : <EOL> expandAll = bool ( self . getPlug ( ) . getValue ( ) ) <EOL> m = IECore . MenuDefinition ( ) <EOL> m . append ( "<STR_LIT>" , { "<STR_LIT>" : self . getPlug ( ) . node ( ) . expandSelection , "<STR_LIT>" : not expandAll , "<STR_LIT>" : "<STR_LIT>" } ) <EOL> m . append ( "<STR_LIT>" , { "<STR_LIT>" : IECore . curry ( self . getPlug ( ) . node ( ) . expandSelection , depth = <NUM_LIT> ) , "<STR_LIT>" : not expandAll , "<STR_LIT>" : "<STR_LIT>" } ) <EOL> m . append ( "<STR_LIT>" , { "<STR_LIT>" : self . getPlug ( ) . node ( ) . collapseSelection , "<STR_LIT>" : not expandAll , "<STR_LIT>" : "<STR_LIT>" } ) <EOL> m . append ( "<STR_LIT>" , { "<STR_LIT>" : True } ) <EOL> m . append ( "<STR_LIT>" , { "<STR_LIT>" : expandAll , "<STR_LIT>" : Gaffer . WeakMethod ( self . __toggleMinimumExpansionDepth ) } ) <EOL> return m <EOL> def __toggleMinimumExpansionDepth ( self , * unused ) : <EOL> self . getPlug ( ) . setValue ( <NUM_LIT:0> if self . getPlug ( ) . getValue ( ) else <NUM_LIT> ) <EOL> class _LookThroughPlugValueWidget ( GafferUI . PlugValueWidget ) : <EOL> def __init__ ( self , plug , parenting = None ) : <EOL> row = GafferUI . ListContainer ( GafferUI . ListContainer . Orientation . Horizontal ) <EOL> GafferUI . PlugValueWidget . __init__ ( self , row , plug , parenting = parenting ) <EOL> with row : <EOL> self . __enabledWidget = GafferUI . BoolPlugValueWidget ( plug [ "<STR_LIT>" ] , displayMode = GafferUI . BoolWidget . DisplayMode . Switch ) <EOL> self . __cameraWidget = GafferSceneUI . ScenePathPlugValueWidget ( <EOL> plug [ "<STR_LIT>" ] , <EOL> path = GafferScene . ScenePath ( <EOL> plug . node ( ) [ "<STR_LIT>" ] , <EOL> plug . node ( ) . getContext ( ) , <EOL> "<STR_LIT:/>" , <EOL> filter = GafferScene . ScenePath . createStandardFilter ( [ "<STR_LIT>" ] , "<STR_LIT>" ) <EOL> ) , <EOL> ) <EOL> self . __cameraWidget . pathWidget ( ) . setFixedCharacterWidth ( <NUM_LIT> ) <EOL> if hasattr ( self . __cameraWidget . pathWidget ( ) . _qtWidget ( ) , "<STR_LIT>" ) : <EOL> self . __cameraWidget . pathWidget ( ) . _qtWidget ( ) . setPlaceholderText ( "<STR_LIT>" ) <EOL> self . _updateFromPlug ( ) <EOL> def _updateFromPlug ( self ) : <EOL> with self . getContext ( ) : <EOL> self . __cameraWidget . setEnabled ( self . getPlug ( ) [ "<STR_LIT>" ] . getValue ( ) ) <EOL> class _GridPlugValueWidget ( GafferUI . PlugValueWidget ) : <EOL> def __init__ ( self , plug , parenting = None ) : <EOL> menu = GafferUI . Menu ( Gaffer . WeakMethod ( self . __menuDefinition ) ) <EOL> menuButton = GafferUI . MenuButton ( menu = menu , image = "<STR_LIT>" , hasFrame = False ) <EOL> GafferUI . PlugValueWidget . __init__ ( self , menuButton , plug , parenting = parenting ) <EOL> def hasLabel ( self ) : <EOL> return True <EOL> def _updateFromPlug ( self ) : <EOL> pass <EOL> def __menuDefinition ( self ) : <EOL> m = IECore . MenuDefinition ( ) <EOL> m . append ( <EOL> "<STR_LIT>" , <EOL> { <EOL> "<STR_LIT>" : self . getPlug ( ) [ "<STR_LIT>" ] . getValue ( ) , <EOL> "<STR_LIT>" : self . getPlug ( ) [ "<STR_LIT>" ] . setValue , <EOL> } <EOL> ) <EOL> m . append ( <EOL> "<STR_LIT>" , <EOL> { <EOL> "<STR_LIT>" : self . getPlug ( ) . node ( ) [ "<STR_LIT>" ] [ "<STR_LIT>" ] . getValue ( ) , <EOL> "<STR_LIT>" : self . getPlug ( ) . node ( ) [ "<STR_LIT>" ] [ "<STR_LIT>" ] . setValue , <EOL> } <EOL> ) <EOL> return m </s>
<s> import IECore <EOL> import Gaffer <EOL> class AddNode ( Gaffer . ComputeNode ) : <EOL> def __init__ ( self , name = "<STR_LIT>" ) : <EOL> Gaffer . ComputeNode . __init__ ( self , name ) <EOL> p1 = Gaffer . IntPlug ( "<STR_LIT>" , Gaffer . Plug . Direction . In ) <EOL> p2 = Gaffer . IntPlug ( "<STR_LIT>" , Gaffer . Plug . Direction . In ) <EOL> self . addChild ( Gaffer . BoolPlug ( "<STR_LIT>" , defaultValue = True ) ) <EOL> self . addChild ( p1 ) <EOL> self . addChild ( p2 ) <EOL> p3 = Gaffer . IntPlug ( "<STR_LIT>" , Gaffer . Plug . Direction . Out ) <EOL> self . addChild ( p3 ) <EOL> self . numHashCalls = <NUM_LIT:0> <EOL> self . numComputeCalls = <NUM_LIT:0> <EOL> def enabledPlug ( self ) : <EOL> return self [ "<STR_LIT>" ] <EOL> def correspondingInput ( self , output ) : <EOL> if output . isSame ( self [ "<STR_LIT>" ] ) : <EOL> return self [ "<STR_LIT>" ] <EOL> return Gaffer . ComputeNode . correspondingInput ( self , output ) <EOL> def affects ( self , input ) : <EOL> outputs = Gaffer . ComputeNode . affects ( self , input ) <EOL> if input . getName ( ) in ( "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ) : <EOL> outputs . append ( self . getChild ( "<STR_LIT>" ) ) <EOL> return outputs <EOL> def hash ( self , output , context , h ) : <EOL> assert ( output . isSame ( self . getChild ( "<STR_LIT>" ) ) or plug . getFlags ( ) & plug . Flags . Dynamic ) <EOL> self . getChild ( "<STR_LIT>" ) . hash ( h ) <EOL> self . getChild ( "<STR_LIT>" ) . hash ( h ) <EOL> self . getChild ( "<STR_LIT>" ) . hash ( h ) <EOL> self . numHashCalls += <NUM_LIT:1> <EOL> def compute ( self , plug , context ) : <EOL> assert ( plug . isSame ( self . getChild ( "<STR_LIT>" ) ) or plug . getFlags ( ) & plug . Flags . Dynamic ) <EOL> assert ( isinstance ( context , Gaffer . Context ) ) <EOL> assert ( plug . settable ( ) ) <EOL> assert ( not self [ "<STR_LIT>" ] . settable ( ) ) <EOL> assert ( not self [ "<STR_LIT>" ] . settable ( ) ) <EOL> if self [ "<STR_LIT>" ] . getValue ( ) : <EOL> plug . setValue ( self . getChild ( "<STR_LIT>" ) . getValue ( ) + self . getChild ( "<STR_LIT>" ) . getValue ( ) ) <EOL> else : <EOL> plug . setValue ( self . getChild ( "<STR_LIT>" ) . getValue ( ) ) <EOL> self . numComputeCalls += <NUM_LIT:1> <EOL> IECore . registerRunTimeTyped ( AddNode , typeName = "<STR_LIT>" ) </s>
<s> from __future__ import with_statement <EOL> import unittest <EOL> import time <EOL> import datetime <EOL> import pwd <EOL> import grp <EOL> import os <EOL> import IECore <EOL> import Gaffer <EOL> import GafferTest <EOL> class FileSystemPathTest ( GafferTest . TestCase ) : <EOL> def test ( self ) : <EOL> p = Gaffer . FileSystemPath ( __file__ ) <EOL> self . assert_ ( p . isValid ( ) ) <EOL> self . assert_ ( p . isLeaf ( ) ) <EOL> while len ( p ) : <EOL> del p [ - <NUM_LIT:1> ] <EOL> self . assert_ ( p . isValid ( ) ) <EOL> self . assert_ ( not p . isLeaf ( ) ) <EOL> def testIsLeaf ( self ) : <EOL> path = Gaffer . FileSystemPath ( "<STR_LIT>" ) <EOL> self . assert_ ( not path . isLeaf ( ) ) <EOL> def testConstructWithFilter ( self ) : <EOL> p = Gaffer . FileSystemPath ( __file__ ) <EOL> self . failUnless ( p . getFilter ( ) is None ) <EOL> f = Gaffer . FileNamePathFilter ( [ "<STR_LIT>" ] ) <EOL> p = Gaffer . FileSystemPath ( __file__ , filter = f ) <EOL> self . failUnless ( p . getFilter ( ) . isSame ( f ) ) <EOL> def testBrokenSymbolicLinks ( self ) : <EOL> os . symlink ( self . temporaryDirectory ( ) + "<STR_LIT>" , self . temporaryDirectory ( ) + "<STR_LIT>" ) <EOL> d = Gaffer . FileSystemPath ( self . temporaryDirectory ( ) ) <EOL> c = d . children ( ) <EOL> self . assertEqual ( len ( c ) , <NUM_LIT:1> ) <EOL> l = c [ <NUM_LIT:0> ] <EOL> self . assertEqual ( str ( l ) , self . temporaryDirectory ( ) + "<STR_LIT>" ) <EOL> self . assertEqual ( l . isValid ( ) , True ) <EOL> info = l . info ( ) <EOL> self . failUnless ( info is not None ) <EOL> def testSymLinkInfo ( self ) : <EOL> with open ( self . temporaryDirectory ( ) + "<STR_LIT>" , "<STR_LIT:w>" ) as f : <EOL> f . write ( "<STR_LIT>" ) <EOL> os . symlink ( self . temporaryDirectory ( ) + "<STR_LIT>" , self . temporaryDirectory ( ) + "<STR_LIT>" ) <EOL> a = Gaffer . FileSystemPath ( self . temporaryDirectory ( ) + "<STR_LIT>" ) <EOL> l = Gaffer . FileSystemPath ( self . temporaryDirectory ( ) + "<STR_LIT>" ) <EOL> aInfo = a . info ( ) <EOL> self . assertEqual ( aInfo [ "<STR_LIT>" ] , l . info ( ) [ "<STR_LIT>" ] ) <EOL> os . remove ( str ( a ) ) <EOL> self . assertNotEqual ( aInfo [ "<STR_LIT>" ] , l . info ( ) [ "<STR_LIT>" ] ) <EOL> def testCopy ( self ) : <EOL> p = Gaffer . FileSystemPath ( self . temporaryDirectory ( ) ) <EOL> p2 = p . copy ( ) <EOL> self . assertEqual ( p , p2 ) <EOL> self . assertEqual ( str ( p ) , str ( p2 ) ) <EOL> def testEmptyPath ( self ) : <EOL> p = Gaffer . FileSystemPath ( ) <EOL> self . assertEqual ( str ( p ) , "<STR_LIT>" ) <EOL> self . assertTrue ( p . isEmpty ( ) ) <EOL> self . assertFalse ( p . isValid ( ) ) <EOL> def testRelativePath ( self ) : <EOL> os . chdir ( self . temporaryDirectory ( ) ) <EOL> with open ( self . temporaryDirectory ( ) + "<STR_LIT>" , "<STR_LIT:w>" ) as f : <EOL> f . write ( "<STR_LIT>" ) <EOL> p = Gaffer . FileSystemPath ( "<STR_LIT:a>" ) <EOL> self . assertEqual ( str ( p ) , "<STR_LIT:a>" ) <EOL> self . assertFalse ( p . isEmpty ( ) ) <EOL> self . assertTrue ( p . isValid ( ) ) <EOL> p2 = Gaffer . FileSystemPath ( "<STR_LIT>" ) <EOL> self . assertEqual ( str ( p2 ) , "<STR_LIT>" ) <EOL> self . assertFalse ( p2 . isEmpty ( ) ) <EOL> self . assertFalse ( p2 . isValid ( ) ) <EOL> def testRelativePathChildren ( self ) : <EOL> os . chdir ( self . temporaryDirectory ( ) ) <EOL> os . mkdir ( "<STR_LIT>" ) <EOL> with open ( self . temporaryDirectory ( ) + "<STR_LIT>" , "<STR_LIT:w>" ) as f : <EOL> f . write ( "<STR_LIT>" ) <EOL> p = Gaffer . FileSystemPath ( "<STR_LIT>" ) <EOL> c = p . children ( ) <EOL> self . assertEqual ( len ( c ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( str ( c [ <NUM_LIT:0> ] ) , "<STR_LIT>" ) <EOL> self . assertTrue ( c [ <NUM_LIT:0> ] . isValid ( ) ) <EOL> def testChildrenOfFile ( self ) : <EOL> p = Gaffer . FileSystemPath ( __file__ ) <EOL> self . assertEqual ( p . children ( ) , [ ] ) <EOL> def testModificationTimes ( self ) : <EOL> p = Gaffer . FileSystemPath ( self . temporaryDirectory ( ) ) <EOL> p . append ( "<STR_LIT:t>" ) <EOL> with open ( str ( p ) , "<STR_LIT:w>" ) as f : <EOL> f . write ( "<STR_LIT>" ) <EOL> mt = p . property ( "<STR_LIT>" ) <EOL> self . assertTrue ( isinstance ( mt , datetime . datetime ) ) <EOL> self . assertLess ( ( datetime . datetime . utcnow ( ) - mt ) . total_seconds ( ) , <NUM_LIT:2> ) <EOL> time . sleep ( <NUM_LIT:1> ) <EOL> with open ( str ( p ) , "<STR_LIT:w>" ) as f : <EOL> f . write ( "<STR_LIT>" ) <EOL> mt = p . property ( "<STR_LIT>" ) <EOL> self . assertTrue ( isinstance ( mt , datetime . datetime ) ) <EOL> self . assertLess ( ( datetime . datetime . utcnow ( ) - mt ) . total_seconds ( ) , <NUM_LIT:2> ) <EOL> def testOwner ( self ) : <EOL> p = Gaffer . FileSystemPath ( self . temporaryDirectory ( ) ) <EOL> p . append ( "<STR_LIT:t>" ) <EOL> with open ( str ( p ) , "<STR_LIT:w>" ) as f : <EOL> f . write ( "<STR_LIT>" ) <EOL> o = p . property ( "<STR_LIT>" ) <EOL> self . assertTrue ( isinstance ( o , str ) ) <EOL> self . assertEqual ( o , pwd . getpwuid ( os . stat ( str ( p ) ) . st_uid ) . pw_name ) <EOL> def testGroup ( self ) : <EOL> p = Gaffer . FileSystemPath ( self . temporaryDirectory ( ) ) <EOL> p . append ( "<STR_LIT:t>" ) <EOL> with open ( str ( p ) , "<STR_LIT:w>" ) as f : <EOL> f . write ( "<STR_LIT>" ) <EOL> g = p . property ( "<STR_LIT>" ) <EOL> self . assertTrue ( isinstance ( g , str ) ) <EOL> self . assertEqual ( g , grp . getgrgid ( os . stat ( str ( p ) ) . st_gid ) . gr_name ) <EOL> def testPropertyNames ( self ) : <EOL> p = Gaffer . FileSystemPath ( self . temporaryDirectory ( ) ) <EOL> a = p . propertyNames ( ) <EOL> self . assertTrue ( isinstance ( a , list ) ) <EOL> self . assertTrue ( "<STR_LIT>" in a ) <EOL> self . assertTrue ( "<STR_LIT>" in a ) <EOL> self . assertTrue ( "<STR_LIT>" in a ) <EOL> self . assertTrue ( "<STR_LIT>" in a ) <EOL> self . assertTrue ( "<STR_LIT>" not in a ) <EOL> p = Gaffer . FileSystemPath ( self . temporaryDirectory ( ) , includeSequences = True ) <EOL> self . assertTrue ( "<STR_LIT>" in p . propertyNames ( ) ) <EOL> def testSequences ( self ) : <EOL> os . mkdir ( self . temporaryDirectory ( ) + "<STR_LIT>" ) <EOL> for n in [ "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ] : <EOL> with open ( self . temporaryDirectory ( ) + "<STR_LIT:/>" + n , "<STR_LIT:w>" ) as f : <EOL> f . write ( "<STR_LIT>" ) <EOL> p = Gaffer . FileSystemPath ( self . temporaryDirectory ( ) , includeSequences = True ) <EOL> self . assertTrue ( p . getIncludeSequences ( ) ) <EOL> c = p . children ( ) <EOL> self . assertEqual ( len ( c ) , <NUM_LIT:8> ) <EOL> s = sorted ( c , key = str ) <EOL> self . assertEqual ( str ( s [ <NUM_LIT:0> ] ) , self . temporaryDirectory ( ) + "<STR_LIT>" ) <EOL> self . assertEqual ( str ( s [ <NUM_LIT:1> ] ) , self . temporaryDirectory ( ) + "<STR_LIT>" ) <EOL> self . assertEqual ( str ( s [ <NUM_LIT:2> ] ) , self . temporaryDirectory ( ) + "<STR_LIT>" ) <EOL> self . assertEqual ( str ( s [ <NUM_LIT:3> ] ) , self . temporaryDirectory ( ) + "<STR_LIT>" ) <EOL> self . assertEqual ( str ( s [ <NUM_LIT:4> ] ) , self . temporaryDirectory ( ) + "<STR_LIT>" ) <EOL> self . assertEqual ( str ( s [ <NUM_LIT:5> ] ) , self . temporaryDirectory ( ) + "<STR_LIT>" ) <EOL> self . assertEqual ( str ( s [ <NUM_LIT:6> ] ) , self . temporaryDirectory ( ) + "<STR_LIT>" ) <EOL> self . assertEqual ( str ( s [ <NUM_LIT:7> ] ) , self . temporaryDirectory ( ) + "<STR_LIT>" ) <EOL> for x in s : <EOL> self . assertTrue ( x . isValid ( ) ) <EOL> if not os . path . isdir ( str ( x ) ) : <EOL> self . assertTrue ( x . isLeaf ( ) ) <EOL> self . assertEqual ( x . property ( "<STR_LIT>" ) , pwd . getpwuid ( os . stat ( str ( p ) ) . st_uid ) . pw_name ) <EOL> self . assertEqual ( x . property ( "<STR_LIT>" ) , grp . getgrgid ( os . stat ( str ( p ) ) . st_gid ) . gr_name ) <EOL> self . assertLess ( ( datetime . datetime . utcnow ( ) - x . property ( "<STR_LIT>" ) ) . total_seconds ( ) , <NUM_LIT:2> ) <EOL> if "<STR_LIT>" not in str ( x ) : <EOL> self . assertFalse ( x . isFileSequence ( ) ) <EOL> self . assertEqual ( x . fileSequence ( ) , None ) <EOL> self . assertEqual ( x . property ( "<STR_LIT>" ) , "<STR_LIT>" ) <EOL> if os . path . isdir ( str ( x ) ) : <EOL> self . assertEqual ( x . property ( "<STR_LIT>" ) , <NUM_LIT:0> ) <EOL> else : <EOL> self . assertEqual ( x . property ( "<STR_LIT>" ) , <NUM_LIT:4> ) <EOL> self . assertEqual ( s [ <NUM_LIT:0> ] . property ( "<STR_LIT>" ) , "<STR_LIT>" ) <EOL> self . assertTrue ( s [ <NUM_LIT:0> ] . isFileSequence ( ) ) <EOL> self . assertTrue ( isinstance ( s [ <NUM_LIT:0> ] . fileSequence ( ) , IECore . FileSequence ) ) <EOL> self . assertEqual ( s [ <NUM_LIT:0> ] . fileSequence ( ) , IECore . FileSequence ( str ( s [ <NUM_LIT:0> ] ) , IECore . frameListFromList ( [ <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:4> ] ) ) ) <EOL> self . assertEqual ( s [ <NUM_LIT:0> ] . property ( "<STR_LIT>" ) , <NUM_LIT:4> * <NUM_LIT:3> ) <EOL> self . assertEqual ( s [ <NUM_LIT:4> ] . property ( "<STR_LIT>" ) , "<STR_LIT:3>" ) <EOL> self . assertTrue ( s [ <NUM_LIT:4> ] . isFileSequence ( ) ) <EOL> self . assertTrue ( isinstance ( s [ <NUM_LIT:4> ] . fileSequence ( ) , IECore . FileSequence ) ) <EOL> self . assertEqual ( s [ <NUM_LIT:4> ] . fileSequence ( ) , IECore . FileSequence ( str ( s [ <NUM_LIT:4> ] ) , IECore . frameListFromList ( [ <NUM_LIT:3> ] ) ) ) <EOL> self . assertEqual ( s [ <NUM_LIT:4> ] . property ( "<STR_LIT>" ) , <NUM_LIT:4> ) <EOL> p2 = p . copy ( ) <EOL> self . assertTrue ( p2 . getIncludeSequences ( ) ) <EOL> self . assertEqual ( len ( p2 . children ( ) ) , <NUM_LIT:8> ) <EOL> p = Gaffer . FileSystemPath ( self . temporaryDirectory ( ) , includeSequences = False ) <EOL> self . assertFalse ( p . getIncludeSequences ( ) ) <EOL> c = p . children ( ) <EOL> self . assertEqual ( len ( c ) , <NUM_LIT:6> ) <EOL> s = sorted ( c , key = str ) <EOL> self . assertEqual ( str ( s [ <NUM_LIT:0> ] ) , self . temporaryDirectory ( ) + "<STR_LIT>" ) <EOL> self . assertEqual ( str ( s [ <NUM_LIT:1> ] ) , self . temporaryDirectory ( ) + "<STR_LIT>" ) <EOL> self . assertEqual ( str ( s [ <NUM_LIT:2> ] ) , self . temporaryDirectory ( ) + "<STR_LIT>" ) <EOL> self . assertEqual ( str ( s [ <NUM_LIT:3> ] ) , self . temporaryDirectory ( ) + "<STR_LIT>" ) <EOL> self . assertEqual ( str ( s [ <NUM_LIT:4> ] ) , self . temporaryDirectory ( ) + "<STR_LIT>" ) <EOL> self . assertEqual ( str ( s [ <NUM_LIT:5> ] ) , self . temporaryDirectory ( ) + "<STR_LIT>" ) <EOL> p . setIncludeSequences ( True ) <EOL> self . assertTrue ( p . getIncludeSequences ( ) ) <EOL> c = p . children ( ) <EOL> self . assertEqual ( len ( c ) , <NUM_LIT:8> ) <EOL> def setUp ( self ) : <EOL> GafferTest . TestCase . setUp ( self ) <EOL> self . __originalCWD = os . getcwd ( ) <EOL> def tearDown ( self ) : <EOL> GafferTest . TestCase . tearDown ( self ) <EOL> os . chdir ( self . __originalCWD ) <EOL> if __name__ == "<STR_LIT:__main__>" : <EOL> unittest . main ( ) </s>
<s> import unittest <EOL> import IECore <EOL> import Gaffer <EOL> import GafferTest <EOL> class SequencePathTest ( GafferTest . TestCase ) : <EOL> def __dictPath ( self ) : <EOL> dict = { } <EOL> dict [ "<STR_LIT>" ] = { } <EOL> for f in IECore . FileSequence ( "<STR_LIT>" ) . fileNames ( ) : <EOL> dict [ "<STR_LIT>" ] [ f ] = <NUM_LIT:1> <EOL> for f in IECore . FileSequence ( "<STR_LIT>" ) . fileNames ( ) : <EOL> dict [ "<STR_LIT>" ] [ f ] = <NUM_LIT:1> <EOL> return Gaffer . DictPath ( dict , "<STR_LIT:/>" ) <EOL> def test ( self ) : <EOL> path = Gaffer . SequencePath ( self . __dictPath ( ) ) <EOL> self . failUnless ( path . isValid ( ) ) <EOL> self . failUnless ( not path . isLeaf ( ) ) <EOL> path . append ( "<STR_LIT>" ) <EOL> self . failUnless ( path . isValid ( ) ) <EOL> self . failUnless ( not path . isLeaf ( ) ) <EOL> path [ <NUM_LIT:0> ] = "<STR_LIT>" <EOL> self . failIf ( path . isValid ( ) ) <EOL> self . failIf ( path . isLeaf ( ) ) <EOL> path [ : ] = [ "<STR_LIT>" ] <EOL> children = path . children ( ) <EOL> for child in children : <EOL> self . failUnless ( isinstance ( child , Gaffer . SequencePath ) ) <EOL> self . assertEqual ( len ( children ) , <NUM_LIT:2> ) <EOL> childrenStrings = [ str ( c ) for c in children ] <EOL> self . failUnless ( "<STR_LIT>" in childrenStrings ) <EOL> self . failUnless ( "<STR_LIT>" in childrenStrings ) <EOL> def testNonLeafChildren ( self ) : <EOL> path = Gaffer . SequencePath ( self . __dictPath ( ) ) <EOL> children = path . children ( ) <EOL> for child in children : <EOL> self . failUnless ( isinstance ( child , Gaffer . SequencePath ) ) <EOL> self . assertEqual ( len ( children ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( str ( children [ <NUM_LIT:0> ] ) , "<STR_LIT>" ) <EOL> def testCopy ( self ) : <EOL> path = Gaffer . SequencePath ( self . __dictPath ( ) ) <EOL> path . append ( "<STR_LIT>" ) <EOL> path2 = path . copy ( ) <EOL> self . failUnless ( isinstance ( path2 , Gaffer . SequencePath ) ) <EOL> self . assertEqual ( path [ : ] , path2 [ : ] ) <EOL> self . failUnless ( path . getFilter ( ) is path2 . getFilter ( ) ) <EOL> c = [ str ( p ) for p in path . children ( ) ] <EOL> c2 = [ str ( p ) for p in path2 . children ( ) ] <EOL> self . assertEqual ( c , c2 ) <EOL> def testInfo ( self ) : <EOL> dictPath = self . __dictPath ( ) <EOL> path = Gaffer . SequencePath ( dictPath ) <EOL> self . assertEqual ( dictPath . info ( ) , path . info ( ) ) <EOL> def testInfoOfInvalidPath ( self ) : <EOL> fp = Gaffer . FileSystemPath ( "<STR_LIT>" ) <EOL> self . assertEqual ( fp . isValid ( ) , False ) <EOL> self . assertEqual ( fp . info ( ) , None ) <EOL> sp = Gaffer . SequencePath ( fp ) <EOL> self . assertEqual ( sp . isValid ( ) , False ) <EOL> self . assertEqual ( sp . info ( ) , None ) <EOL> def testFilter ( self ) : <EOL> dictPath = self . __dictPath ( ) <EOL> path = Gaffer . SequencePath ( dictPath ) <EOL> def testIsEmpty ( self ) : <EOL> dictPath = self . __dictPath ( ) <EOL> path = Gaffer . SequencePath ( dictPath ) <EOL> path . setFromString ( "<STR_LIT>" ) <EOL> self . assertTrue ( path . isEmpty ( ) ) <EOL> path2 = path . copy ( ) <EOL> self . assertTrue ( path2 . isEmpty ( ) ) <EOL> def testProperties ( self ) : <EOL> dictPath = self . __dictPath ( ) <EOL> path = Gaffer . SequencePath ( dictPath ) <EOL> self . assertEqual ( dictPath . propertyNames ( ) , path . propertyNames ( ) ) <EOL> self . assertEqual ( dictPath . property ( "<STR_LIT>" ) , path . property ( "<STR_LIT>" ) ) <EOL> if __name__ == "<STR_LIT:__main__>" : <EOL> unittest . main ( ) </s>
<s> assert ( __name__ == "<STR_LIT:__main__>" ) </s>
<s> from __future__ import with_statement <EOL> import IECore <EOL> import Gaffer <EOL> import GafferUI <EOL> class CompoundDataPlugValueWidget ( GafferUI . PlugValueWidget ) : <EOL> def __init__ ( self , plug , parenting = None ) : <EOL> self . __column = GafferUI . ListContainer ( spacing = <NUM_LIT:6> ) <EOL> GafferUI . PlugValueWidget . __init__ ( self , self . __column , plug , parenting = parenting ) <EOL> with self . __column : <EOL> self . __layout = GafferUI . PlugLayout ( plug ) <EOL> with GafferUI . ListContainer ( GafferUI . ListContainer . Orientation . Horizontal ) as self . __editRow : <EOL> GafferUI . Spacer ( IECore . V2i ( GafferUI . PlugWidget . labelWidth ( ) , <NUM_LIT:1> ) ) <EOL> GafferUI . MenuButton ( <EOL> image = "<STR_LIT>" , <EOL> hasFrame = False , <EOL> menu = GafferUI . Menu ( Gaffer . WeakMethod ( self . __addMenuDefinition ) ) <EOL> ) <EOL> GafferUI . Spacer ( IECore . V2i ( <NUM_LIT:1> ) , IECore . V2i ( <NUM_LIT> , <NUM_LIT:1> ) , parenting = { "<STR_LIT>" : True } ) <EOL> self . _updateFromPlug ( ) <EOL> def hasLabel ( self ) : <EOL> return True <EOL> def setPlug ( self , plug ) : <EOL> GafferUI . PlugValueWidget . setPlug ( self , plug ) <EOL> self . __layout = GafferUI . PlugLayout ( plug ) <EOL> self . __column [ <NUM_LIT:0> ] = self . __layout <EOL> def setReadOnly ( self , readOnly ) : <EOL> if readOnly == self . getReadOnly ( ) : <EOL> return <EOL> GafferUI . PlugValueWidget . setReadOnly ( self , readOnly ) <EOL> self . __layout . setReadOnly ( readOnly ) <EOL> def childPlugValueWidget ( self , childPlug , lazy = True ) : <EOL> return self . __layout . plugValueWidget ( childPlug , lazy ) <EOL> def _updateFromPlug ( self ) : <EOL> editable = True <EOL> if self . getPlug ( ) is not None : <EOL> editable = Gaffer . Metadata . plugValue ( self . getPlug ( ) , "<STR_LIT>" ) <EOL> editable = editable if editable is not None else True <EOL> self . __editRow . setVisible ( editable ) <EOL> def __addMenuDefinition ( self ) : <EOL> result = IECore . MenuDefinition ( ) <EOL> result . append ( "<STR_LIT>" , { "<STR_LIT>" : IECore . curry ( Gaffer . WeakMethod ( self . __addItem ) , "<STR_LIT>" , IECore . BoolData ( False ) ) } ) <EOL> result . append ( "<STR_LIT>" , { "<STR_LIT>" : IECore . curry ( Gaffer . WeakMethod ( self . __addItem ) , "<STR_LIT>" , IECore . FloatData ( <NUM_LIT:0> ) ) } ) <EOL> result . append ( "<STR_LIT>" , { "<STR_LIT>" : IECore . curry ( Gaffer . WeakMethod ( self . __addItem ) , "<STR_LIT>" , IECore . IntData ( <NUM_LIT:0> ) ) } ) <EOL> result . append ( "<STR_LIT>" , { "<STR_LIT>" : True } ) <EOL> result . append ( "<STR_LIT>" , { "<STR_LIT>" : IECore . curry ( Gaffer . WeakMethod ( self . __addItem ) , "<STR_LIT>" , IECore . StringData ( "<STR_LIT>" ) ) } ) <EOL> result . append ( "<STR_LIT>" , { "<STR_LIT>" : True } ) <EOL> result . append ( "<STR_LIT>" , { "<STR_LIT>" : IECore . curry ( Gaffer . WeakMethod ( self . __addItem ) , "<STR_LIT>" , IECore . V2iData ( IECore . V2i ( <NUM_LIT:0> ) ) ) } ) <EOL> result . append ( "<STR_LIT>" , { "<STR_LIT>" : IECore . curry ( Gaffer . WeakMethod ( self . __addItem ) , "<STR_LIT>" , IECore . V3iData ( IECore . V3i ( <NUM_LIT:0> ) ) ) } ) <EOL> result . append ( "<STR_LIT>" , { "<STR_LIT>" : IECore . curry ( Gaffer . WeakMethod ( self . __addItem ) , "<STR_LIT>" , IECore . V2fData ( IECore . V2f ( <NUM_LIT:0> ) ) ) } ) <EOL> result . append ( "<STR_LIT>" , { "<STR_LIT>" : IECore . curry ( Gaffer . WeakMethod ( self . __addItem ) , "<STR_LIT>" , IECore . V3fData ( IECore . V3f ( <NUM_LIT:0> ) ) ) } ) <EOL> result . append ( "<STR_LIT>" , { "<STR_LIT>" : True } ) <EOL> result . append ( "<STR_LIT>" , { "<STR_LIT>" : IECore . curry ( Gaffer . WeakMethod ( self . __addItem ) , "<STR_LIT>" , IECore . Color3fData ( IECore . Color3f ( <NUM_LIT:0> ) ) ) } ) <EOL> result . append ( "<STR_LIT>" , { "<STR_LIT>" : IECore . curry ( Gaffer . WeakMethod ( self . __addItem ) , "<STR_LIT>" , IECore . Color4fData ( IECore . Color4f ( <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:1> ) ) ) } ) <EOL> return result <EOL> def __addItem ( self , name , value ) : <EOL> with Gaffer . UndoContext ( self . getPlug ( ) . ancestor ( Gaffer . ScriptNode . staticTypeId ( ) ) ) : <EOL> self . getPlug ( ) . addOptionalMember ( name , value , enabled = True ) <EOL> class _MemberPlugValueWidget ( GafferUI . PlugValueWidget ) : <EOL> def __init__ ( self , childPlug ) : <EOL> self . __row = GafferUI . ListContainer ( GafferUI . ListContainer . Orientation . Horizontal , spacing = <NUM_LIT:4> ) <EOL> GafferUI . PlugValueWidget . __init__ ( self , self . __row , childPlug ) <EOL> if not childPlug . getFlags ( Gaffer . Plug . Flags . Dynamic ) : <EOL> nameWidget = GafferUI . LabelPlugValueWidget ( <EOL> childPlug , <EOL> horizontalAlignment = GafferUI . Label . HorizontalAlignment . Right , <EOL> verticalAlignment = GafferUI . Label . VerticalAlignment . Center , <EOL> ) <EOL> nameWidget . label ( ) . _qtWidget ( ) . setFixedWidth ( GafferUI . PlugWidget . labelWidth ( ) ) <EOL> nameWidget . label ( ) . _qtWidget ( ) . setFixedHeight ( <NUM_LIT:20> ) <EOL> else : <EOL> nameWidget = GafferUI . StringPlugValueWidget ( childPlug [ "<STR_LIT:name>" ] ) <EOL> nameWidget . textWidget ( ) . _qtWidget ( ) . setFixedWidth ( GafferUI . PlugWidget . labelWidth ( ) ) <EOL> self . __row . append ( nameWidget , <EOL> verticalAlignment = GafferUI . Label . VerticalAlignment . Top <EOL> ) <EOL> if "<STR_LIT>" in childPlug : <EOL> self . __row . append ( <EOL> GafferUI . BoolPlugValueWidget ( <EOL> childPlug [ "<STR_LIT>" ] , <EOL> displayMode = GafferUI . BoolWidget . DisplayMode . Switch <EOL> ) , <EOL> verticalAlignment = GafferUI . Label . VerticalAlignment . Top , <EOL> ) <EOL> self . __row . append ( GafferUI . PlugValueWidget . create ( childPlug [ "<STR_LIT:value>" ] ) , expand = True ) <EOL> self . _updateFromPlug ( ) <EOL> def setPlug ( self , plug ) : <EOL> GafferUI . PlugValueWidget . setPlug ( self , plug ) <EOL> if isinstance ( self . __row [ <NUM_LIT:0> ] , GafferUI . LabelPlugValueWidget ) : <EOL> self . __row [ <NUM_LIT:0> ] . setPlug ( plug ) <EOL> else : <EOL> self . __row [ <NUM_LIT:0> ] . setPlug ( plug [ "<STR_LIT:name>" ] ) <EOL> if "<STR_LIT>" in plug : <EOL> self . __row [ <NUM_LIT:1> ] . setPlug ( plug [ "<STR_LIT>" ] ) <EOL> self . __row [ - <NUM_LIT:1> ] . setPlug ( plug [ "<STR_LIT:value>" ] ) <EOL> def hasLabel ( self ) : <EOL> return True <EOL> def childPlugValueWidget ( self , childPlug , lazy = True ) : <EOL> for w in self . __row : <EOL> if w . getPlug ( ) . isSame ( childPlug ) : <EOL> return w <EOL> return None <EOL> def setReadOnly ( self , readOnly ) : <EOL> if readOnly == self . getReadOnly ( ) : <EOL> return <EOL> GafferUI . PlugValueWidget . setReadOnly ( self , readOnly ) <EOL> for w in self . __row : <EOL> w . setReadOnly ( readOnly ) <EOL> def _updateFromPlug ( self ) : <EOL> if "<STR_LIT>" in self . getPlug ( ) : <EOL> with self . getContext ( ) : <EOL> enabled = self . getPlug ( ) [ "<STR_LIT>" ] . getValue ( ) <EOL> if isinstance ( self . __row [ <NUM_LIT:0> ] , GafferUI . StringPlugValueWidget ) : <EOL> self . __row [ <NUM_LIT:0> ] . setEnabled ( enabled ) <EOL> self . __row [ - <NUM_LIT:1> ] . setEnabled ( enabled ) <EOL> GafferUI . PlugValueWidget . registerType ( Gaffer . CompoundDataPlug , CompoundDataPlugValueWidget ) <EOL> GafferUI . PlugValueWidget . registerType ( Gaffer . CompoundDataPlug . MemberPlug , _MemberPlugValueWidget ) <EOL> def __deletePlug ( plug ) : <EOL> with Gaffer . UndoContext ( plug . ancestor ( Gaffer . ScriptNode ) ) : <EOL> plug . parent ( ) . removeChild ( plug ) <EOL> def __plugPopupMenu ( menuDefinition , plugValueWidget ) : <EOL> plug = plugValueWidget . getPlug ( ) <EOL> memberPlug = plug if isinstance ( plug , Gaffer . CompoundDataPlug . MemberPlug ) else None <EOL> memberPlug = memberPlug if memberPlug is not None else plug . ancestor ( Gaffer . CompoundDataPlug . MemberPlug ) <EOL> if memberPlug is None : <EOL> return <EOL> if not memberPlug . getFlags ( Gaffer . Plug . Flags . Dynamic ) : <EOL> return <EOL> menuDefinition . append ( "<STR_LIT>" , { "<STR_LIT>" : True } ) <EOL> menuDefinition . append ( "<STR_LIT>" , { "<STR_LIT>" : IECore . curry ( __deletePlug , memberPlug ) , "<STR_LIT>" : not plugValueWidget . getReadOnly ( ) } ) <EOL> __plugPopupMenuConnection = GafferUI . PlugValueWidget . popupMenuSignal ( ) . connect ( __plugPopupMenu ) </s>
<s> import Gaffer <EOL> import GafferUI <EOL> class FileSystemPathPlugValueWidget ( GafferUI . PathPlugValueWidget ) : <EOL> def __init__ ( self , plug , path = None , parenting = None ) : <EOL> GafferUI . PathPlugValueWidget . __init__ ( <EOL> self , <EOL> plug , <EOL> path , <EOL> parenting = parenting <EOL> ) <EOL> self . _updateFromPlug ( ) <EOL> self . __plugMetadataChangedConnection = Gaffer . Metadata . plugValueChangedSignal ( ) . connect ( Gaffer . WeakMethod ( self . __plugMetadataChanged ) ) <EOL> def getToolTip ( self ) : <EOL> result = GafferUI . PathPlugValueWidget . getToolTip ( self ) <EOL> extensions = self . __extensions ( ) <EOL> if extensions : <EOL> result += "<STR_LIT>" + "<STR_LIT:U+002CU+0020>" . join ( extensions ) <EOL> return result <EOL> def _pathChooserDialogue ( self ) : <EOL> dialogue = GafferUI . PathPlugValueWidget . _pathChooserDialogue ( self ) <EOL> if Gaffer . Metadata . plugValue ( self . getPlug ( ) , "<STR_LIT>" ) : <EOL> columns = dialogue . pathChooserWidget ( ) . pathListingWidget ( ) . getColumns ( ) <EOL> columns . append ( GafferUI . PathListingWidget . StandardColumn ( "<STR_LIT>" , "<STR_LIT>" ) ) <EOL> dialogue . pathChooserWidget ( ) . pathListingWidget ( ) . setColumns ( columns ) <EOL> return dialogue <EOL> def _updateFromPlug ( self ) : <EOL> GafferUI . PathPlugValueWidget . _updateFromPlug ( self ) <EOL> includeSequences = Gaffer . Metadata . plugValue ( self . getPlug ( ) , "<STR_LIT>" ) or False <EOL> self . path ( ) . setFilter ( <EOL> Gaffer . FileSystemPath . createStandardFilter ( <EOL> self . __extensions ( ) , <EOL> Gaffer . Metadata . plugValue ( self . getPlug ( ) , "<STR_LIT>" ) or "<STR_LIT>" , <EOL> includeSequenceFilter = includeSequences , <EOL> ) <EOL> ) <EOL> self . path ( ) . setIncludeSequences ( includeSequences ) <EOL> def _setPlugFromPath ( self , path ) : <EOL> if Gaffer . Metadata . plugValue ( self . getPlug ( ) , "<STR_LIT>" ) : <EOL> sequence = path . fileSequence ( ) <EOL> if sequence : <EOL> self . getPlug ( ) . setValue ( str ( sequence ) ) <EOL> return <EOL> GafferUI . PathPlugValueWidget . _setPlugFromPath ( self , path ) <EOL> def __plugMetadataChanged ( self , nodeTypeId , plugPath , key , plug ) : <EOL> if self . getPlug ( ) is None : <EOL> return <EOL> if plug is not None and not plug . isSame ( self . getPlug ( ) ) : <EOL> return <EOL> if not self . getPlug ( ) . node ( ) . isInstanceOf ( nodeTypeId ) : <EOL> return <EOL> if key . startswith ( "<STR_LIT>" ) : <EOL> self . _updateFromPlug ( ) <EOL> def __extensions ( self ) : <EOL> if self . getPlug ( ) is None : <EOL> return [ ] <EOL> extensions = Gaffer . Metadata . plugValue ( self . getPlug ( ) , "<STR_LIT>" ) or [ ] <EOL> if isinstance ( extensions , str ) : <EOL> extensions = extensions . split ( ) <EOL> else : <EOL> extensions = list ( extensions ) <EOL> return extensions </s>
<s> import IECore <EOL> import Gaffer <EOL> import GafferUI <EOL> class NameLabel ( GafferUI . Label ) : <EOL> def __init__ ( self , graphComponent , horizontalAlignment = GafferUI . Label . HorizontalAlignment . Left , verticalAlignment = GafferUI . Label . VerticalAlignment . Center , numComponents = <NUM_LIT:1> , formatter = None , parenting = None ) : <EOL> GafferUI . Label . __init__ ( self , "<STR_LIT>" , horizontalAlignment , verticalAlignment , parenting = parenting ) <EOL> self . __formatter = formatter if formatter is not None else self . defaultFormatter <EOL> self . __numComponents = numComponents <EOL> self . __connections = [ ] <EOL> self . __graphComponent = False <EOL> self . setGraphComponent ( graphComponent ) <EOL> self . __buttonPressConnection = self . buttonPressSignal ( ) . connect ( Gaffer . WeakMethod ( self . __buttonPress ) ) <EOL> self . __dragBeginConnection = self . dragBeginSignal ( ) . connect ( Gaffer . WeakMethod ( self . __dragBegin ) ) <EOL> self . __dragEndConnection = self . dragEndSignal ( ) . connect ( Gaffer . WeakMethod ( self . __dragEnd ) ) <EOL> def setText ( self , text ) : <EOL> GafferUI . Label . setText ( self , text ) <EOL> self . __connections = [ ] <EOL> def setGraphComponent ( self , graphComponent ) : <EOL> if graphComponent is not None and self . __graphComponent is not False : <EOL> if graphComponent . isSame ( self . __graphComponent ) : <EOL> return <EOL> elif self . __graphComponent is None : <EOL> return <EOL> self . __graphComponent = graphComponent <EOL> self . __setupConnections ( ) <EOL> self . __setText ( ) <EOL> def getGraphComponent ( self ) : <EOL> return self . __graphComponent <EOL> def setNumComponents ( self , numComponents ) : <EOL> assert ( numComponents > <NUM_LIT:0> ) <EOL> if numComponents == self . __numComponents : <EOL> return <EOL> self . __numComponents = numComponents <EOL> self . __setupConnections ( ) <EOL> self . __setText ( ) <EOL> def getNumComponents ( self ) : <EOL> return self . __numComponents <EOL> def setFormatter ( self , formatter ) : <EOL> self . __formatter = formatter <EOL> self . __setText ( ) <EOL> def getFormatter ( self ) : <EOL> return self . __formatter <EOL> @ staticmethod <EOL> def defaultFormatter ( graphComponents ) : <EOL> return "<STR_LIT:.>" . join ( IECore . CamelCase . toSpaced ( g . getName ( ) ) for g in graphComponents ) <EOL> def __setupConnections ( self , reuseUntil = None ) : <EOL> if self . __graphComponent is None : <EOL> self . __connections = [ ] <EOL> return <EOL> updatedConnections = [ ] <EOL> n = <NUM_LIT:0> <EOL> g = self . __graphComponent <EOL> reuse = reuseUntil is not None <EOL> while g is not None and n < self . __numComponents : <EOL> if reuse : <EOL> updatedConnections . extend ( self . __connections [ n * <NUM_LIT:2> : n * <NUM_LIT:2> + <NUM_LIT:2> ] ) <EOL> else : <EOL> updatedConnections . append ( g . nameChangedSignal ( ) . connect ( Gaffer . WeakMethod ( self . __setText ) ) ) <EOL> if n < self . __numComponents - <NUM_LIT:1> : <EOL> updatedConnections . append ( g . parentChangedSignal ( ) . connect ( Gaffer . WeakMethod ( self . __parentChanged ) ) ) <EOL> if g . isSame ( reuseUntil ) : <EOL> reuse = False <EOL> g = g . parent ( ) <EOL> n += <NUM_LIT:1> <EOL> self . __connections = updatedConnections <EOL> def __parentChanged ( self , child , oldParent ) : <EOL> self . __setText ( ) <EOL> self . __setupConnections ( reuseUntil = child ) <EOL> def __setText ( self , * unwantedArgs ) : <EOL> graphComponents = [ ] <EOL> n = <NUM_LIT:0> <EOL> g = self . __graphComponent <EOL> while g is not None and n < self . __numComponents : <EOL> graphComponents . append ( g ) <EOL> g = g . parent ( ) <EOL> n += <NUM_LIT:1> <EOL> graphComponents . reverse ( ) <EOL> GafferUI . Label . setText ( self , self . __formatter ( graphComponents ) ) <EOL> def __buttonPress ( self , widget , event ) : <EOL> return self . getGraphComponent ( ) is not None and event . buttons & ( event . Buttons . Left | event . Buttons . Middle ) <EOL> def __dragBegin ( self , widget , event ) : <EOL> if event . buttons & ( event . Buttons . Left | event . Buttons . Middle ) : <EOL> GafferUI . Pointer . setCurrent ( "<STR_LIT>" ) <EOL> return self . getGraphComponent ( ) <EOL> return None <EOL> def __dragEnd ( self , widget , event ) : <EOL> GafferUI . Pointer . setCurrent ( None ) </s>
<s> import functools <EOL> import IECore <EOL> import Gaffer <EOL> import GafferUI <EOL> class PresetsPlugValueWidget ( GafferUI . PlugValueWidget ) : <EOL> def __init__ ( self , plug , parenting = None ) : <EOL> self . __menuButton = GafferUI . MenuButton ( "<STR_LIT>" , menu = GafferUI . Menu ( Gaffer . WeakMethod ( self . __menuDefinition ) ) ) <EOL> GafferUI . PlugValueWidget . __init__ ( self , self . __menuButton , plug , parenting = parenting ) <EOL> self . __plugMetadataChangedConnection = Gaffer . Metadata . plugValueChangedSignal ( ) . connect ( Gaffer . WeakMethod ( self . __plugMetadataChanged ) ) <EOL> self . _addPopupMenu ( self . __menuButton ) <EOL> self . _updateFromPlug ( ) <EOL> def _updateFromPlug ( self ) : <EOL> self . __menuButton . setEnabled ( self . _editable ( ) ) <EOL> text = "<STR_LIT>" <EOL> if self . getPlug ( ) is not None : <EOL> with self . getContext ( ) : <EOL> text = Gaffer . NodeAlgo . currentPreset ( self . getPlug ( ) ) or "<STR_LIT>" <EOL> self . __menuButton . setText ( text ) <EOL> def __menuDefinition ( self ) : <EOL> result = IECore . MenuDefinition ( ) <EOL> if self . getPlug ( ) is None : <EOL> return result <EOL> currentPreset = Gaffer . NodeAlgo . currentPreset ( self . getPlug ( ) ) <EOL> for n in Gaffer . NodeAlgo . presets ( self . getPlug ( ) ) : <EOL> result . append ( <EOL> "<STR_LIT:/>" + n , <EOL> { <EOL> "<STR_LIT>" : functools . partial ( Gaffer . WeakMethod ( self . __applyPreset ) , preset = n ) , <EOL> "<STR_LIT>" : n == currentPreset , <EOL> } <EOL> ) <EOL> return result <EOL> def __applyPreset ( self , unused , preset ) : <EOL> with Gaffer . UndoContext ( self . getPlug ( ) . ancestor ( Gaffer . ScriptNode ) ) : <EOL> Gaffer . NodeAlgo . applyPreset ( self . getPlug ( ) , preset ) <EOL> def __plugMetadataChanged ( self , nodeTypeId , plugPath , key , plug ) : <EOL> if self . getPlug ( ) is None : <EOL> return <EOL> if plug is not None and not plug . isSame ( self . getPlug ( ) ) : <EOL> return <EOL> if not self . getPlug ( ) . node ( ) . isInstanceOf ( nodeTypeId ) : <EOL> return <EOL> if key . startswith ( "<STR_LIT>" ) : <EOL> self . _updateFromPlug ( ) </s>
<s> import weakref <EOL> import functools <EOL> import types <EOL> import re <EOL> import collections <EOL> import IECore <EOL> import Gaffer <EOL> import GafferUI <EOL> class UIEditor ( GafferUI . NodeSetEditor ) : <EOL> def __init__ ( self , scriptNode , parenting = None ) : <EOL> self . __frame = GafferUI . Frame ( borderWidth = <NUM_LIT:4> , borderStyle = GafferUI . Frame . BorderStyle . None ) <EOL> GafferUI . NodeSetEditor . __init__ ( self , self . __frame , scriptNode , parenting = parenting ) <EOL> self . __nodeMetadataWidgets = [ ] <EOL> self . __plugMetadataWidgets = [ ] <EOL> with self . __frame : <EOL> self . __tabbedContainer = GafferUI . TabbedContainer ( ) <EOL> with self . __tabbedContainer : <EOL> with GafferUI . ListContainer ( spacing = <NUM_LIT:4> , borderWidth = <NUM_LIT:8> , parenting = { "<STR_LIT:label>" : "<STR_LIT>" } ) as self . __nodeTab : <EOL> with _Row ( ) : <EOL> _Label ( "<STR_LIT:Name>" ) <EOL> self . __nodeNameWidget = GafferUI . NameWidget ( None ) <EOL> with _Row ( ) : <EOL> _Label ( "<STR_LIT>" , parenting = { "<STR_LIT>" : GafferUI . ListContainer . VerticalAlignment . Top } ) <EOL> self . __nodeMetadataWidgets . append ( <EOL> _MultiLineStringMetadataWidget ( key = "<STR_LIT:description>" ) <EOL> ) <EOL> with _Row ( ) : <EOL> _Label ( "<STR_LIT>" ) <EOL> self . __nodeMetadataWidgets . append ( <EOL> _ColorSwatchMetadataWidget ( key = "<STR_LIT>" ) <EOL> ) <EOL> with GafferUI . SplitContainer ( orientation = GafferUI . SplitContainer . Orientation . Horizontal , borderWidth = <NUM_LIT:8> , parenting = { "<STR_LIT:label>" : "<STR_LIT>" } ) as self . __plugTab : <EOL> self . __plugListing = _PlugListing ( ) <EOL> self . __plugListingSelectionChangedConnection = self . __plugListing . selectionChangedSignal ( ) . connect ( Gaffer . WeakMethod ( self . __plugListingSelectionChanged ) ) <EOL> with GafferUI . TabbedContainer ( ) as self . __plugAndSectionEditorsContainer : <EOL> self . __plugEditor = _PlugEditor ( ) <EOL> self . __sectionEditor = _SectionEditor ( ) <EOL> self . __sectionEditorNameChangedConnection = self . __sectionEditor . nameChangedSignal ( ) . connect ( Gaffer . WeakMethod ( self . __sectionEditorNameChanged ) ) <EOL> self . __plugAndSectionEditorsContainer . setTabsVisible ( False ) <EOL> self . __plugTab . setSizes ( [ <NUM_LIT> , <NUM_LIT> ] ) <EOL> self . __node = None <EOL> self . __selectedPlug = None <EOL> self . __updateFromSetInternal ( lazy = False ) <EOL> def setSelection ( self , selection ) : <EOL> self . __plugListing . setSelection ( selection ) <EOL> def getSelection ( self ) : <EOL> return self . __plugListing . getSelection ( ) <EOL> def nodeEditor ( self ) : <EOL> return self . __nodeTab <EOL> def plugEditor ( self ) : <EOL> return self . __plugTab <EOL> @ classmethod <EOL> def appendNodeContextMenuDefinitions ( cls , nodeGraph , node , menuDefinition ) : <EOL> menuDefinition . append ( "<STR_LIT>" , { "<STR_LIT>" : True } ) <EOL> menuDefinition . append ( "<STR_LIT>" , { "<STR_LIT>" : functools . partial ( cls . __setColor , node = node ) } ) <EOL> @ classmethod <EOL> def appendNodeEditorToolMenuDefinitions ( cls , nodeEditor , node , menuDefinition ) : <EOL> menuDefinition . append ( <EOL> "<STR_LIT>" , <EOL> { <EOL> "<STR_LIT>" : functools . partial ( GafferUI . UIEditor . acquire , node ) , <EOL> "<STR_LIT>" : isinstance ( node , Gaffer . Box ) or nodeEditor . nodeUI ( ) . plugValueWidget ( node [ "<STR_LIT:user>" ] ) is not None <EOL> } <EOL> ) <EOL> def _updateFromSet ( self ) : <EOL> GafferUI . NodeSetEditor . _updateFromSet ( self ) <EOL> self . __updateFromSetInternal ( ) <EOL> def __updateFromSetInternal ( self , lazy = True ) : <EOL> node = self . _lastAddedNode ( ) <EOL> if lazy and node == self . __node : <EOL> return <EOL> self . __node = node <EOL> self . __nodeNameWidget . setGraphComponent ( self . __node ) <EOL> self . __nodeTab . setEnabled ( self . __node is not None ) <EOL> if self . __node is None : <EOL> self . __plugListing . setPlugParent ( None ) <EOL> self . __sectionEditor . setPlugParent ( None ) <EOL> else : <EOL> plugParent = self . __node [ "<STR_LIT:user>" ] <EOL> if isinstance ( self . __node , Gaffer . Box ) : <EOL> plugParent = self . __node <EOL> self . __plugListing . setPlugParent ( plugParent ) <EOL> self . __sectionEditor . setPlugParent ( plugParent ) <EOL> for widget in self . __nodeMetadataWidgets : <EOL> widget . setTarget ( self . __node ) <EOL> self . setSelection ( None ) <EOL> def __plugListingSelectionChanged ( self , listing ) : <EOL> selection = listing . getSelection ( ) <EOL> if selection is None or isinstance ( selection , Gaffer . Plug ) : <EOL> self . __plugEditor . setPlug ( selection ) <EOL> self . __plugAndSectionEditorsContainer . setCurrent ( self . __plugEditor ) <EOL> elif isinstance ( selection , basestring ) : <EOL> self . __plugEditor . setPlug ( None ) <EOL> self . __sectionEditor . setSection ( selection ) <EOL> self . __plugAndSectionEditorsContainer . setCurrent ( self . __sectionEditor ) <EOL> def __sectionEditorNameChanged ( self , sectionEditor , oldName , newName ) : <EOL> self . __plugListing . setSelection ( newName ) <EOL> def __repr__ ( self ) : <EOL> return "<STR_LIT>" <EOL> @ classmethod <EOL> def __setColor ( cls , menu , node ) : <EOL> color = Gaffer . Metadata . nodeValue ( node , "<STR_LIT>" ) or IECore . Color3f ( <NUM_LIT:1> ) <EOL> dialogue = GafferUI . ColorChooserDialogue ( color = color , useDisplayTransform = False ) <EOL> color = dialogue . waitForColor ( parentWindow = menu . ancestor ( GafferUI . Window ) ) <EOL> if color is not None : <EOL> with Gaffer . UndoContext ( node . ancestor ( Gaffer . ScriptNode ) ) : <EOL> Gaffer . Metadata . registerNodeValue ( node , "<STR_LIT>" , color ) <EOL> GafferUI . EditorWidget . registerType ( "<STR_LIT>" , UIEditor ) <EOL> def __editPlugUI ( node , plug ) : <EOL> editor = GafferUI . UIEditor . acquire ( node ) <EOL> editor . setSelection ( plug ) <EOL> editor . plugEditor ( ) . reveal ( ) <EOL> def __plugPopupMenu ( menuDefinition , plugValueWidget ) : <EOL> plug = plugValueWidget . getPlug ( ) <EOL> node = plug . node ( ) <EOL> if node is None : <EOL> return <EOL> if isinstance ( node , Gaffer . Box ) : <EOL> if not plug . parent ( ) . isSame ( node ) : <EOL> return <EOL> else : <EOL> if not plug . parent ( ) . isSame ( node [ "<STR_LIT:user>" ] ) : <EOL> return <EOL> menuDefinition . append ( "<STR_LIT>" , { "<STR_LIT>" : True } ) <EOL> menuDefinition . append ( "<STR_LIT>" , { "<STR_LIT>" : IECore . curry ( __editPlugUI , node , plug ) , "<STR_LIT>" : not plugValueWidget . getReadOnly ( ) } ) <EOL> __plugPopupMenuConnection = GafferUI . PlugValueWidget . popupMenuSignal ( ) . connect ( __plugPopupMenu ) <EOL> class _Label ( GafferUI . Label ) : <EOL> def __init__ ( self , * args , ** kw ) : <EOL> GafferUI . Label . __init__ ( <EOL> self , <EOL> horizontalAlignment = GafferUI . Label . HorizontalAlignment . Right , <EOL> * args , ** kw <EOL> ) <EOL> self . _qtWidget ( ) . setFixedWidth ( <NUM_LIT> ) <EOL> class _Row ( GafferUI . ListContainer ) : <EOL> def __init__ ( self , * args , ** kw ) : <EOL> GafferUI . ListContainer . __init__ ( self , GafferUI . ListContainer . Orientation . Horizontal , spacing = <NUM_LIT:4> , * args , ** kw ) <EOL> class _MetadataWidget ( GafferUI . Widget ) : <EOL> def __init__ ( self , topLevelWidget , key , target = None , parenting = None ) : <EOL> GafferUI . Widget . __init__ ( self , topLevelWidget , parenting = parenting ) <EOL> self . __key = key <EOL> self . __target = None <EOL> self . setTarget ( target ) <EOL> def setTarget ( self , target ) : <EOL> assert ( isinstance ( target , ( Gaffer . Node , Gaffer . Plug , type ( None ) ) ) ) <EOL> self . __target = target <EOL> self . setEnabled ( self . __target is not None ) <EOL> if isinstance ( self . __target , Gaffer . Node ) : <EOL> self . __metadataChangedConnection = Gaffer . Metadata . nodeValueChangedSignal ( ) . connect ( <EOL> Gaffer . WeakMethod ( self . __nodeMetadataChanged ) <EOL> ) <EOL> elif isinstance ( self . __target , Gaffer . Plug ) : <EOL> self . __metadataChangedConnection = Gaffer . Metadata . plugValueChangedSignal ( ) . connect ( <EOL> Gaffer . WeakMethod ( self . __plugMetadataChanged ) <EOL> ) <EOL> else : <EOL> self . __metadataChangedConnection = None <EOL> self . __update ( ) <EOL> def getTarget ( self ) : <EOL> return self . __target <EOL> def setKey ( self , key ) : <EOL> if key == self . __key : <EOL> return <EOL> self . __key = key <EOL> self . __update ( ) <EOL> def getKey ( self , key ) : <EOL> return self . __key <EOL> def _updateFromValue ( self , value ) : <EOL> raise NotImplementedError <EOL> def _updateFromWidget ( self , value ) : <EOL> if self . __target is None : <EOL> return <EOL> with Gaffer . UndoContext ( self . __target . ancestor ( Gaffer . ScriptNode ) ) : <EOL> _registerMetadata ( self . __target , self . __key , value ) <EOL> def _deregisterValue ( self ) : <EOL> if self . __target is None : <EOL> return <EOL> with Gaffer . UndoContext ( self . __target . ancestor ( Gaffer . ScriptNode ) ) : <EOL> _deregisterMetadata ( self . __target , self . __key ) <EOL> def __update ( self ) : <EOL> if isinstance ( self . __target , Gaffer . Node ) : <EOL> self . _updateFromValue ( Gaffer . Metadata . nodeValue ( self . __target , self . __key ) ) <EOL> elif isinstance ( self . __target , Gaffer . Plug ) : <EOL> self . _updateFromValue ( Gaffer . Metadata . plugValue ( self . __target , self . __key ) ) <EOL> else : <EOL> self . _updateFromValue ( None ) <EOL> def __nodeMetadataChanged ( self , nodeTypeId , key , node ) : <EOL> if self . __key != key : <EOL> return <EOL> if node is not None and not node . isSame ( self . __target ) : <EOL> return <EOL> if not self . __target . isInstanceOf ( nodeTypeId ) : <EOL> return <EOL> self . __update ( ) <EOL> def __plugMetadataChanged ( self , nodeTypeId , plugPath , key , plug ) : <EOL> if self . __key != key : <EOL> return <EOL> if plug is not None and not plug . isSame ( self . __target ) : <EOL> return <EOL> if not self . __target . node ( ) . isInstanceOf ( nodeTypeId ) : <EOL> return <EOL> if not Gaffer . match ( self . __target . relativeName ( self . __target . node ( ) ) , plugPath ) : <EOL> return <EOL> self . __update ( ) <EOL> class _BoolMetadataWidget ( _MetadataWidget ) : <EOL> def __init__ ( self , key , target = None , parenting = None ) : <EOL> self . __boolWidget = GafferUI . BoolWidget ( ) <EOL> _MetadataWidget . __init__ ( self , self . __boolWidget , key , target , parenting = parenting ) <EOL> self . __stateChangedConnection = self . __boolWidget . stateChangedSignal ( ) . connect ( <EOL> Gaffer . WeakMethod ( self . __stateChanged ) <EOL> ) <EOL> def _updateFromValue ( self , value ) : <EOL> self . __boolWidget . setState ( value if value is not None else False ) <EOL> def __stateChanged ( self , * unused ) : <EOL> self . _updateFromWidget ( self . __boolWidget . getState ( ) ) <EOL> class _StringMetadataWidget ( _MetadataWidget ) : <EOL> def __init__ ( self , key , target = None , acceptEmptyString = True , parenting = None ) : <EOL> self . __textWidget = GafferUI . TextWidget ( ) <EOL> _MetadataWidget . __init__ ( self , self . __textWidget , key , target , parenting = None ) <EOL> self . __acceptEmptyString = acceptEmptyString <EOL> self . __editingFinishedConnection = self . __textWidget . editingFinishedSignal ( ) . connect ( <EOL> Gaffer . WeakMethod ( self . __editingFinished ) <EOL> ) <EOL> def textWidget ( self ) : <EOL> return self . __textWidget <EOL> def _updateFromValue ( self , value ) : <EOL> self . __textWidget . setText ( value if value is not None else "<STR_LIT>" ) <EOL> def __editingFinished ( self , * unused ) : <EOL> text = self . __textWidget . getText ( ) <EOL> if text or self . __acceptEmptyString : <EOL> self . _updateFromWidget ( text ) <EOL> else : <EOL> self . _deregisterValue ( ) <EOL> class _MultiLineStringMetadataWidget ( _MetadataWidget ) : <EOL> def __init__ ( self , key , target = None , parenting = None ) : <EOL> self . __textWidget = GafferUI . MultiLineTextWidget ( ) <EOL> _MetadataWidget . __init__ ( self , self . __textWidget , key , target , parenting = None ) <EOL> self . __editingFinishedConnection = self . __textWidget . editingFinishedSignal ( ) . connect ( <EOL> Gaffer . WeakMethod ( self . __editingFinished ) <EOL> ) <EOL> def textWidget ( self ) : <EOL> return self . __textWidget <EOL> def _updateFromValue ( self , value ) : <EOL> self . __textWidget . setText ( value if value is not None else "<STR_LIT>" ) <EOL> def __editingFinished ( self , * unused ) : <EOL> self . _updateFromWidget ( self . __textWidget . getText ( ) ) <EOL> class _ColorSwatchMetadataWidget ( _MetadataWidget ) : <EOL> def __init__ ( self , key , target = None , parenting = None ) : <EOL> self . __swatch = GafferUI . ColorSwatch ( useDisplayTransform = False ) <EOL> _MetadataWidget . __init__ ( self , self . __swatch , key , target , parenting = parenting ) <EOL> self . __swatch . _qtWidget ( ) . setFixedHeight ( <NUM_LIT> ) <EOL> self . __swatch . _qtWidget ( ) . setMaximumWidth ( <NUM_LIT> ) <EOL> self . __value = None <EOL> self . __buttonReleaseConnection = self . __swatch . buttonReleaseSignal ( ) . connect ( Gaffer . WeakMethod ( self . __buttonRelease ) ) <EOL> def _updateFromValue ( self , value ) : <EOL> if value is not None : <EOL> self . __swatch . setColor ( value ) <EOL> else : <EOL> self . __swatch . setColor ( IECore . Color4f ( <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> ) ) <EOL> self . __value = value <EOL> def __buttonRelease ( self , swatch , event ) : <EOL> if event . button != event . Buttons . Left : <EOL> return False <EOL> color = self . __value if self . __value is not None else IECore . Color3f ( <NUM_LIT:1> ) <EOL> dialogue = GafferUI . ColorChooserDialogue ( color = color , useDisplayTransform = False ) <EOL> color = dialogue . waitForColor ( parentWindow = self . ancestor ( GafferUI . Window ) ) <EOL> if color is not None : <EOL> self . _updateFromWidget ( color ) <EOL> class _MenuMetadataWidget ( _MetadataWidget ) : <EOL> def __init__ ( self , key , labelsAndValues , target = None , parenting = None ) : <EOL> self . __menuButton = GafferUI . MenuButton ( <EOL> menu = GafferUI . Menu ( Gaffer . WeakMethod ( self . __menuDefinition ) ) <EOL> ) <EOL> self . __labelsAndValues = labelsAndValues <EOL> self . __currentValue = None <EOL> _MetadataWidget . __init__ ( self , self . __menuButton , key , target , parenting = parenting ) <EOL> def _updateFromValue ( self , value ) : <EOL> self . __currentValue = value <EOL> buttonText = str ( value ) <EOL> for label , value in self . __labelsAndValues : <EOL> if value == self . __currentValue : <EOL> buttonText = label <EOL> break <EOL> self . __menuButton . setText ( buttonText ) <EOL> def __menuDefinition ( self ) : <EOL> result = IECore . MenuDefinition ( ) <EOL> for label , value in self . __labelsAndValues : <EOL> result . append ( <EOL> "<STR_LIT:/>" + label , <EOL> { <EOL> "<STR_LIT>" : functools . partial ( Gaffer . WeakMethod ( self . __setValue ) , value = value ) , <EOL> "<STR_LIT>" : value == self . __currentValue <EOL> } <EOL> ) <EOL> return result <EOL> def __setValue ( self , unused , value ) : <EOL> self . _updateFromWidget ( value ) <EOL> class _LayoutItem ( object ) : <EOL> def __init__ ( self ) : <EOL> self . __parent = None <EOL> self . __children = [ ] <EOL> def parent ( self ) : <EOL> if self . __parent is None : <EOL> return None <EOL> else : <EOL> return self . __parent ( ) <EOL> def child ( self , name ) : <EOL> for c in self . __children : <EOL> if c . name ( ) == name : <EOL> return c <EOL> return None <EOL> def isAncestorOf ( self , item ) : <EOL> while item is not None : <EOL> parent = item . parent ( ) <EOL> if parent is self : <EOL> return True <EOL> item = parent <EOL> return False <EOL> def append ( self , child ) : <EOL> self . insert ( len ( self ) , child ) <EOL> def insert ( self , index , child ) : <EOL> assert ( child . parent ( ) is None ) <EOL> self . __children . insert ( index , child ) <EOL> child . __parent = weakref . ref ( self ) <EOL> def remove ( self , child ) : <EOL> assert ( child . parent ( ) is self ) <EOL> self . __children . remove ( child ) <EOL> child . __parent = None <EOL> def index ( self , child ) : <EOL> return self . __children . index ( child ) <EOL> def name ( self ) : <EOL> raise NotImplementedError <EOL> def fullName ( self ) : <EOL> result = "<STR_LIT>" <EOL> item = self <EOL> while item . parent ( ) is not None : <EOL> if result : <EOL> result = item . name ( ) + "<STR_LIT:.>" + result <EOL> else : <EOL> result = item . name ( ) <EOL> item = item . parent ( ) <EOL> return result <EOL> def __len__ ( self ) : <EOL> return len ( self . __children ) <EOL> def __getitem__ ( self , index ) : <EOL> return self . __children [ index ] <EOL> class _SectionLayoutItem ( _LayoutItem ) : <EOL> def __init__ ( self , sectionName ) : <EOL> _LayoutItem . __init__ ( self ) <EOL> self . __sectionName = sectionName <EOL> def name ( self ) : <EOL> return self . __sectionName <EOL> class _PlugLayoutItem ( _LayoutItem ) : <EOL> def __init__ ( self , plug ) : <EOL> _LayoutItem . __init__ ( self ) <EOL> self . plug = plug <EOL> self . __name = plug . getName ( ) <EOL> def name ( self ) : <EOL> return self . __name <EOL> class _PlugListing ( GafferUI . Widget ) : <EOL> class __LayoutPath ( Gaffer . Path ) : <EOL> def __init__ ( self , rootItem , path , root = "<STR_LIT:/>" , filter = None ) : <EOL> Gaffer . Path . __init__ ( self , path , root , filter ) <EOL> self . __rootItem = rootItem <EOL> def rootItem ( self ) : <EOL> return self . __rootItem <EOL> def item ( self ) : <EOL> result = self . __rootItem <EOL> for name in self : <EOL> result = result . child ( name ) <EOL> if result is None : <EOL> return None <EOL> return result <EOL> def copy ( self ) : <EOL> return self . __class__ ( self . __rootItem , self [ : ] , self . root ( ) , self . getFilter ( ) ) <EOL> def isLeaf ( self ) : <EOL> return not isinstance ( self . item ( ) , _SectionLayoutItem ) <EOL> def isValid ( self ) : <EOL> return self . item ( ) is not None <EOL> def _children ( self ) : <EOL> item = self . item ( ) <EOL> if item is None : <EOL> return [ ] <EOL> result = [ <EOL> self . __class__ ( self . __rootItem , self [ : ] + [ c . name ( ) ] , self . root ( ) , self . getFilter ( ) ) <EOL> for c in item <EOL> ] <EOL> if len ( result ) == <NUM_LIT:0> and isinstance ( item , _SectionLayoutItem ) : <EOL> result . append ( self . __class__ ( self . __rootItem , self [ : ] + [ "<STR_LIT:U+0020>" ] , self . root ( ) , self . getFilter ( ) ) ) <EOL> return result <EOL> def __init__ ( self , parenting = None ) : <EOL> column = GafferUI . ListContainer ( spacing = <NUM_LIT:4> ) <EOL> GafferUI . Widget . __init__ ( self , column , parenting = parenting ) <EOL> with column : <EOL> self . __pathListing = GafferUI . PathListingWidget ( <EOL> self . __LayoutPath ( _SectionLayoutItem ( "<STR_LIT>" ) , "<STR_LIT:/>" ) , <EOL> columns = ( GafferUI . PathListingWidget . defaultNameColumn , ) , <EOL> displayMode = GafferUI . PathListingWidget . DisplayMode . Tree , <EOL> ) <EOL> self . __pathListing . setDragPointer ( "<STR_LIT>" ) <EOL> self . __pathListing . setSortable ( False ) <EOL> self . __pathListing . setHeaderVisible ( False ) <EOL> with GafferUI . ListContainer ( GafferUI . ListContainer . Orientation . Horizontal , spacing = <NUM_LIT:4> ) : <EOL> GafferUI . MenuButton ( <EOL> image = "<STR_LIT>" , <EOL> hasFrame = False , <EOL> menu = GafferUI . Menu ( <EOL> definition = Gaffer . WeakMethod ( self . __addMenuDefinition ) <EOL> ) <EOL> ) <EOL> self . __deleteButton = GafferUI . Button ( image = "<STR_LIT>" , hasFrame = False ) <EOL> self . __deleteButtonClickedConnection = self . __deleteButton . clickedSignal ( ) . connect ( Gaffer . WeakMethod ( self . __deleteButtonClicked ) ) <EOL> self . __parent = None <EOL> self . __dragItem = None <EOL> self . __selectionChangedSignal = Gaffer . Signal1 ( ) <EOL> self . __dragEnterConnection = self . __pathListing . dragEnterSignal ( ) . connect ( Gaffer . WeakMethod ( self . __dragEnter ) ) <EOL> self . __dragMoveConnection = self . __pathListing . dragMoveSignal ( ) . connect ( Gaffer . WeakMethod ( self . __dragMove ) ) <EOL> self . __dragEndConnection = self . __pathListing . dragEndSignal ( ) . connect ( Gaffer . WeakMethod ( self . __dragEnd ) ) <EOL> self . __selectionChangedConnection = self . __pathListing . selectionChangedSignal ( ) . connect ( Gaffer . WeakMethod ( self . __selectionChanged ) ) <EOL> self . __keyPressConnection = self . keyPressSignal ( ) . connect ( Gaffer . WeakMethod ( self . __keyPress ) ) <EOL> self . __nodeMetadataChangedConnection = Gaffer . Metadata . nodeValueChangedSignal ( ) . connect ( Gaffer . WeakMethod ( self . __nodeMetadataChanged ) ) <EOL> self . __plugMetadataChangedConnection = Gaffer . Metadata . plugValueChangedSignal ( ) . connect ( Gaffer . WeakMethod ( self . __plugMetadataChanged ) ) <EOL> def setPlugParent ( self , parent ) : <EOL> assert ( isinstance ( parent , ( Gaffer . Plug , Gaffer . Node , types . NoneType ) ) ) <EOL> self . __parent = parent <EOL> self . __childAddedConnection = None <EOL> self . __childRemovedConnection = None <EOL> self . __childNameChangedConnections = { } <EOL> if self . __parent is not None : <EOL> self . __childAddedConnection = self . __parent . childAddedSignal ( ) . connect ( Gaffer . WeakMethod ( self . __childAddedOrRemoved ) ) <EOL> self . __childRemovedConnection = self . __parent . childRemovedSignal ( ) . connect ( Gaffer . WeakMethod ( self . __childAddedOrRemoved ) ) <EOL> for child in self . __parent . children ( ) : <EOL> self . __updateChildNameChangedConnection ( child ) <EOL> self . __updatePath ( ) <EOL> def getPlugParent ( self ) : <EOL> return self . __parent <EOL> def setSelection ( self , selection ) : <EOL> self . __updatePathLazily . flush ( self ) <EOL> def findPlugPath ( path , plug ) : <EOL> item = path . item ( ) <EOL> if isinstance ( item , _PlugLayoutItem ) and item . plug . isSame ( plug ) : <EOL> return path <EOL> else : <EOL> for child in path . children ( ) : <EOL> r = findPlugPath ( child , plug ) <EOL> if r is not None : <EOL> return r <EOL> return None <EOL> if isinstance ( selection , Gaffer . Plug ) : <EOL> path = findPlugPath ( self . __pathListing . getPath ( ) , selection ) <EOL> if path is None : <EOL> self . __pathListing . setSelectedPaths ( [ ] ) <EOL> else : <EOL> self . __pathListing . setSelectedPaths ( [ path ] ) <EOL> elif isinstance ( selection , basestring ) : <EOL> path = self . __pathListing . getPath ( ) . copy ( ) <EOL> path [ : ] = selection . split ( "<STR_LIT:.>" ) <EOL> self . __pathListing . setSelectedPaths ( [ path ] ) <EOL> else : <EOL> assert ( selection is None ) <EOL> self . __pathListing . setSelectedPaths ( [ ] ) <EOL> def getSelection ( self ) : <EOL> item = self . __selectedItem ( ) <EOL> if item is None : <EOL> return None <EOL> elif isinstance ( item , _PlugLayoutItem ) : <EOL> return item . plug <EOL> elif isinstance ( item , _SectionLayoutItem ) : <EOL> return item . fullName ( ) <EOL> else : <EOL> return None <EOL> def selectionChangedSignal ( self ) : <EOL> return self . __selectionChangedSignal <EOL> def __updatePath ( self ) : <EOL> if self . __parent is None : <EOL> self . __pathListing . setPath ( self . __LayoutPath ( _SectionLayoutItem ( "<STR_LIT>" ) , "<STR_LIT:/>" ) ) <EOL> return <EOL> def section ( rootLayoutItem , sectionPath ) : <EOL> sectionItem = rootLayoutItem <EOL> if sectionPath != "<STR_LIT>" : <EOL> for sectionName in sectionPath . split ( "<STR_LIT:.>" ) : <EOL> childSectionItem = sectionItem . child ( sectionName ) <EOL> if childSectionItem is None : <EOL> childSectionItem = _SectionLayoutItem ( sectionName ) <EOL> sectionItem . append ( childSectionItem ) <EOL> sectionItem = childSectionItem <EOL> return sectionItem <EOL> layout = _SectionLayoutItem ( "<STR_LIT>" ) <EOL> for sectionPath in GafferUI . PlugLayout . layoutSections ( self . __parent ) : <EOL> if sectionPath == "<STR_LIT>" and isinstance ( self . __parent , Gaffer . Node ) : <EOL> continue <EOL> sectionItem = section ( layout , sectionPath ) <EOL> for plug in GafferUI . PlugLayout . layoutOrder ( self . __parent , section = sectionPath ) : <EOL> sectionItem . append ( _PlugLayoutItem ( plug ) ) <EOL> emptySections = _metadata ( self . getPlugParent ( ) , "<STR_LIT>" ) <EOL> emptySectionIndices = _metadata ( self . getPlugParent ( ) , "<STR_LIT>" ) <EOL> if emptySections and emptySectionIndices : <EOL> for sectionPath , sectionIndex in zip ( emptySections , emptySectionIndices ) : <EOL> parentPath , unused , sectionName = sectionPath . rpartition ( "<STR_LIT:.>" ) <EOL> parentSection = section ( layout , parentPath ) <EOL> if parentSection . child ( sectionName ) is None : <EOL> parentSection . insert ( sectionIndex , _SectionLayoutItem ( sectionName ) ) <EOL> if len ( layout ) == <NUM_LIT:0> and isinstance ( self . __parent , Gaffer . Node ) : <EOL> layout . append ( _SectionLayoutItem ( "<STR_LIT>" ) ) <EOL> expandedPaths = self . __pathListing . getExpandedPaths ( ) <EOL> self . __pathListing . setPath ( self . __LayoutPath ( layout , "<STR_LIT:/>" ) ) <EOL> self . __pathListing . setExpandedPaths ( expandedPaths ) <EOL> @ GafferUI . LazyMethod ( ) <EOL> def __updatePathLazily ( self ) : <EOL> self . __updatePath ( ) <EOL> def __updateMetadata ( self ) : <EOL> emptySections = IECore . StringVectorData ( ) <EOL> emptySectionIndices = IECore . IntVectorData ( ) <EOL> def walk ( layoutItem , path = "<STR_LIT>" , index = <NUM_LIT:0> ) : <EOL> for childItem in layoutItem : <EOL> if isinstance ( childItem , _PlugLayoutItem ) : <EOL> Gaffer . Metadata . registerPlugValue ( childItem . plug , "<STR_LIT>" , path ) <EOL> Gaffer . Metadata . registerPlugValue ( childItem . plug , "<STR_LIT>" , index ) <EOL> index += <NUM_LIT:1> <EOL> elif isinstance ( childItem , _SectionLayoutItem ) : <EOL> childPath = path + "<STR_LIT:.>" + childItem . name ( ) if path else childItem . name ( ) <EOL> if len ( childItem ) : <EOL> index = walk ( childItem , childPath , index ) <EOL> else : <EOL> emptySections . append ( childPath ) <EOL> emptySectionIndices . append ( layoutItem . index ( childItem ) ) <EOL> return index <EOL> with Gaffer . BlockedConnection ( self . __plugMetadataChangedConnection ) : <EOL> walk ( self . __pathListing . getPath ( ) . copy ( ) . setFromString ( "<STR_LIT:/>" ) . item ( ) ) <EOL> _registerMetadata ( self . getPlugParent ( ) , "<STR_LIT>" , emptySections ) <EOL> _registerMetadata ( self . getPlugParent ( ) , "<STR_LIT>" , emptySectionIndices ) <EOL> def __childAddedOrRemoved ( self , parent , child ) : <EOL> assert ( parent . isSame ( self . __parent ) ) <EOL> self . __updateChildNameChangedConnection ( child ) <EOL> self . __updatePathLazily ( ) <EOL> def __childNameChanged ( self , child ) : <EOL> selection = self . getSelection ( ) <EOL> self . __updatePath ( ) <EOL> if isinstance ( selection , Gaffer . Plug ) and child . isSame ( selection ) : <EOL> self . setSelection ( selection ) <EOL> def __updateChildNameChangedConnection ( self , child ) : <EOL> if self . __parent . isSame ( child . parent ( ) ) : <EOL> if child not in self . __childNameChangedConnections : <EOL> self . __childNameChangedConnections [ child ] = child . nameChangedSignal ( ) . connect ( Gaffer . WeakMethod ( self . __childNameChanged ) ) <EOL> else : <EOL> if child in self . __childNameChangedConnections : <EOL> del self . __childNameChangedConnections [ child ] <EOL> def __dragEnter ( self , listing , event ) : <EOL> if event . sourceWidget is not self . __pathListing : <EOL> return False <EOL> if not isinstance ( event . data , IECore . StringVectorData ) : <EOL> return False <EOL> dragPath = self . __pathListing . getPath ( ) . copy ( ) . setFromString ( event . data [ <NUM_LIT:0> ] ) <EOL> self . __dragItem = dragPath . item ( ) <EOL> self . __pathListing . setPathExpanded ( dragPath , False ) <EOL> return True <EOL> def __dragMove ( self , listing , event ) : <EOL> if self . __dragItem is None : <EOL> return False <EOL> targetPath = self . __pathListing . pathAt ( event . line . p0 ) <EOL> if targetPath is not None : <EOL> targetItem = targetPath . item ( ) <EOL> if targetItem is not None : <EOL> if isinstance ( targetItem , _SectionLayoutItem ) and self . __pathListing . getPathExpanded ( targetPath ) and targetItem . parent ( ) is self . __dragItem . parent ( ) : <EOL> newParent = targetItem <EOL> newIndex = <NUM_LIT:0> <EOL> else : <EOL> newParent = targetItem . parent ( ) <EOL> newIndex = newParent . index ( targetItem ) <EOL> else : <EOL> newParent = targetPath . copy ( ) . truncateUntilValid ( ) . item ( ) <EOL> newIndex = <NUM_LIT:0> <EOL> else : <EOL> newParent = self . __pathListing . getPath ( ) . rootItem ( ) <EOL> newIndex = <NUM_LIT:0> if event . line . p0 . y < <NUM_LIT:1> else len ( newParent ) <EOL> if newParent is self . __dragItem or self . __dragItem . isAncestorOf ( newParent ) : <EOL> return True <EOL> firstNonPlugIndex = next ( <EOL> ( x [ <NUM_LIT:0> ] for x in enumerate ( newParent ) if not isinstance ( x [ <NUM_LIT:1> ] , _PlugLayoutItem ) ) , <EOL> len ( newParent ) <EOL> ) <EOL> if self . __dragItem . parent ( ) is newParent and newParent . index ( self . __dragItem ) < firstNonPlugIndex : <EOL> firstNonPlugIndex -= <NUM_LIT:1> <EOL> if isinstance ( self . __dragItem , _PlugLayoutItem ) : <EOL> if newIndex > firstNonPlugIndex : <EOL> return True <EOL> else : <EOL> if newIndex < firstNonPlugIndex : <EOL> newIndex = max ( newIndex , firstNonPlugIndex ) <EOL> self . __dragItem . parent ( ) . remove ( self . __dragItem ) <EOL> newParent . insert ( newIndex , self . __dragItem ) <EOL> self . __pathListing . getPath ( ) . pathChangedSignal ( ) ( self . __pathListing . getPath ( ) ) <EOL> selection = self . __pathListing . getPath ( ) . copy ( ) <EOL> selection [ : ] = self . __dragItem . fullName ( ) . split ( "<STR_LIT:.>" ) <EOL> self . __pathListing . setSelectedPaths ( [ selection ] , scrollToFirst = False , expandNonLeaf = False ) <EOL> return True <EOL> def __dragEnd ( self , listing , event ) : <EOL> if self . __dragItem is None : <EOL> return False <EOL> with Gaffer . UndoContext ( self . __parent . ancestor ( Gaffer . ScriptNode ) ) : <EOL> self . __updateMetadata ( ) <EOL> self . __dragItem = None <EOL> return True <EOL> def __selectionChanged ( self , pathListing ) : <EOL> self . __deleteButton . setEnabled ( bool ( pathListing . getSelectedPaths ( ) ) ) <EOL> self . __selectionChangedSignal ( self ) <EOL> def __deleteButtonClicked ( self , button ) : <EOL> self . __deleteSelected ( ) <EOL> def __nodeMetadataChanged ( self , nodeTypeId , key , node ) : <EOL> if self . __parent is None : <EOL> return <EOL> if node is not None and not self . __parent . isSame ( node ) : <EOL> return <EOL> if not self . __parent . isInstanceOf ( nodeTypeId ) : <EOL> return <EOL> if key in ( "<STR_LIT>" , "<STR_LIT>" ) : <EOL> self . __updatePathLazily ( ) <EOL> def __plugMetadataChanged ( self , nodeTypeId , plugPath , key , plug ) : <EOL> if self . __parent is None : <EOL> return <EOL> if plug is not None and not self . __parent . isSame ( plug ) and not self . __parent . isSame ( plug . parent ( ) ) : <EOL> return <EOL> node = self . __parent . node ( ) if isinstance ( self . __parent , Gaffer . Plug ) else self . __parent <EOL> if not node . isInstanceOf ( nodeTypeId ) : <EOL> return <EOL> if key in ( "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ) : <EOL> self . __updatePathLazily ( ) <EOL> def __keyPress ( self , widget , event ) : <EOL> assert ( widget is self ) <EOL> if event . key == "<STR_LIT>" or event . key == "<STR_LIT>" : <EOL> self . __deleteSelected ( ) <EOL> return True <EOL> return False <EOL> def __addMenuDefinition ( self ) : <EOL> m = IECore . MenuDefinition ( ) <EOL> m . append ( "<STR_LIT>" , { "<STR_LIT>" : functools . partial ( Gaffer . WeakMethod ( self . __addPlug ) , Gaffer . BoolPlug ) } ) <EOL> m . append ( "<STR_LIT>" , { "<STR_LIT>" : functools . partial ( Gaffer . WeakMethod ( self . __addPlug ) , Gaffer . FloatPlug ) } ) <EOL> m . append ( "<STR_LIT>" , { "<STR_LIT>" : functools . partial ( Gaffer . WeakMethod ( self . __addPlug ) , Gaffer . IntPlug ) } ) <EOL> m . append ( "<STR_LIT>" , { "<STR_LIT>" : True } ) <EOL> m . append ( "<STR_LIT>" , { "<STR_LIT>" : functools . partial ( Gaffer . WeakMethod ( self . __addPlug ) , Gaffer . StringPlug ) } ) <EOL> m . append ( "<STR_LIT>" , { "<STR_LIT>" : True } ) <EOL> m . append ( "<STR_LIT>" , { "<STR_LIT>" : functools . partial ( Gaffer . WeakMethod ( self . __addPlug ) , Gaffer . V2iPlug ) } ) <EOL> m . append ( "<STR_LIT>" , { "<STR_LIT>" : functools . partial ( Gaffer . WeakMethod ( self . __addPlug ) , Gaffer . V3iPlug ) } ) <EOL> m . append ( "<STR_LIT>" , { "<STR_LIT>" : functools . partial ( Gaffer . WeakMethod ( self . __addPlug ) , Gaffer . V2fPlug ) } ) <EOL> m . append ( "<STR_LIT>" , { "<STR_LIT>" : functools . partial ( Gaffer . WeakMethod ( self . __addPlug ) , Gaffer . V3fPlug ) } ) <EOL> m . append ( "<STR_LIT>" , { "<STR_LIT>" : True } ) <EOL> m . append ( "<STR_LIT>" , { "<STR_LIT>" : functools . partial ( Gaffer . WeakMethod ( self . __addPlug ) , Gaffer . Color3fPlug ) } ) <EOL> m . append ( "<STR_LIT>" , { "<STR_LIT>" : functools . partial ( Gaffer . WeakMethod ( self . __addPlug ) , Gaffer . Color4fPlug ) } ) <EOL> m . append ( "<STR_LIT>" , { "<STR_LIT>" : True } ) <EOL> m . append ( "<STR_LIT>" , { "<STR_LIT>" : Gaffer . WeakMethod ( self . __addSection ) } ) <EOL> return m <EOL> def __addPlug ( self , plugType ) : <EOL> plug = plugType ( flags = Gaffer . Plug . Flags . Default | Gaffer . Plug . Flags . Dynamic ) <EOL> _registerMetadata ( plug , "<STR_LIT>" , "<STR_LIT>" ) <EOL> parentItem = self . __selectedItem ( ) <EOL> if parentItem is not None : <EOL> while not isinstance ( parentItem , _SectionLayoutItem ) : <EOL> parentItem = parentItem . parent ( ) <EOL> else : <EOL> parentItem = self . __pathListing . getPath ( ) . rootItem ( ) <EOL> parentItem = next ( <EOL> ( c for c in parentItem if isinstance ( c , _SectionLayoutItem ) ) , <EOL> parentItem <EOL> ) <EOL> _registerMetadata ( plug , "<STR_LIT>" , parentItem . fullName ( ) ) <EOL> with Gaffer . UndoContext ( self . __parent . ancestor ( Gaffer . ScriptNode ) ) : <EOL> self . getPlugParent ( ) . addChild ( plug ) <EOL> self . __updatePathLazily . flush ( self ) <EOL> self . setSelection ( plug ) <EOL> def __addSection ( self ) : <EOL> rootItem = self . __pathListing . getPath ( ) . rootItem ( ) <EOL> existingSectionNames = set ( c . name ( ) for c in rootItem if isinstance ( c , _SectionLayoutItem ) ) <EOL> name = "<STR_LIT>" <EOL> index = <NUM_LIT:1> <EOL> while name in existingSectionNames : <EOL> name = "<STR_LIT>" % index <EOL> index += <NUM_LIT:1> <EOL> rootItem . append ( _SectionLayoutItem ( name ) ) <EOL> self . __pathListing . getPath ( ) . pathChangedSignal ( ) ( self . __pathListing . getPath ( ) ) <EOL> with Gaffer . UndoContext ( self . __parent . ancestor ( Gaffer . ScriptNode ) ) : <EOL> self . __updateMetadata ( ) <EOL> self . __pathListing . setSelectedPaths ( <EOL> self . __pathListing . getPath ( ) . copy ( ) . setFromString ( "<STR_LIT:/>" + name ) <EOL> ) <EOL> def __selectedItem ( self ) : <EOL> selectedPaths = self . __pathListing . getSelectedPaths ( ) <EOL> if not len ( selectedPaths ) : <EOL> return None <EOL> assert ( len ( selectedPaths ) == <NUM_LIT:1> ) <EOL> return selectedPaths [ <NUM_LIT:0> ] . item ( ) <EOL> def __deleteSelected ( self ) : <EOL> selectedItem = self . __selectedItem ( ) <EOL> if selectedItem is None : <EOL> return <EOL> selectedItem . parent ( ) . remove ( selectedItem ) <EOL> def deletePlugsWalk ( item ) : <EOL> if isinstance ( item , _PlugLayoutItem ) : <EOL> item . plug . parent ( ) . removeChild ( item . plug ) <EOL> else : <EOL> for childItem in item : <EOL> deletePlugsWalk ( childItem ) <EOL> with Gaffer . UndoContext ( self . __parent . ancestor ( Gaffer . ScriptNode ) ) : <EOL> deletePlugsWalk ( selectedItem ) <EOL> self . __updateMetadata ( ) <EOL> class _PresetsEditor ( GafferUI . Widget ) : <EOL> def __init__ ( self , parenting = None ) : <EOL> row = GafferUI . ListContainer ( GafferUI . ListContainer . Orientation . Horizontal , spacing = <NUM_LIT:8> ) <EOL> GafferUI . Widget . __init__ ( self , row , parenting = parenting ) <EOL> with row : <EOL> with GafferUI . ListContainer ( spacing = <NUM_LIT:4> ) : <EOL> self . __pathListing = GafferUI . PathListingWidget ( <EOL> Gaffer . DictPath ( collections . OrderedDict ( ) , "<STR_LIT:/>" ) , <EOL> columns = ( GafferUI . PathListingWidget . defaultNameColumn , ) , <EOL> ) <EOL> self . __pathListing . setDragPointer ( "<STR_LIT>" ) <EOL> self . __pathListing . setSortable ( False ) <EOL> self . __pathListing . setHeaderVisible ( False ) <EOL> self . __pathListing . _qtWidget ( ) . setFixedWidth ( <NUM_LIT:200> ) <EOL> self . __pathListing . _qtWidget ( ) . setFixedHeight ( <NUM_LIT:200> ) <EOL> self . __pathListingSelectionChangedConnection = self . __pathListing . selectionChangedSignal ( ) . connect ( Gaffer . WeakMethod ( self . __selectionChanged ) ) <EOL> self . __dragEnterConnection = self . __pathListing . dragEnterSignal ( ) . connect ( Gaffer . WeakMethod ( self . __dragEnter ) ) <EOL> self . __dragMoveConnection = self . __pathListing . dragMoveSignal ( ) . connect ( Gaffer . WeakMethod ( self . __dragMove ) ) <EOL> self . __dragEndConnection = self . __pathListing . dragEndSignal ( ) . connect ( Gaffer . WeakMethod ( self . __dragEnd ) ) <EOL> with GafferUI . ListContainer ( GafferUI . ListContainer . Orientation . Horizontal , spacing = <NUM_LIT:4> ) : <EOL> self . __addButton = GafferUI . Button ( image = "<STR_LIT>" , hasFrame = False ) <EOL> self . __addButtonClickedConnection = self . __addButton . clickedSignal ( ) . connect ( Gaffer . WeakMethod ( self . __addButtonClicked ) ) <EOL> self . __deleteButton = GafferUI . Button ( image = "<STR_LIT>" , hasFrame = False ) <EOL> self . __deleteButtonClickedConnection = self . __deleteButton . clickedSignal ( ) . connect ( Gaffer . WeakMethod ( self . __deleteButtonClicked ) ) <EOL> with GafferUI . ListContainer ( spacing = <NUM_LIT:4> ) as self . __editingColumn : <EOL> GafferUI . Label ( "<STR_LIT:Name>" ) <EOL> self . __nameWidget = GafferUI . TextWidget ( ) <EOL> self . __nameEditingFinishedConnection = self . __nameWidget . editingFinishedSignal ( ) . connect ( Gaffer . WeakMethod ( self . __nameEditingFinished ) ) <EOL> GafferUI . Spacer ( IECore . V2i ( <NUM_LIT:4> ) , maximumSize = IECore . V2i ( <NUM_LIT:4> ) ) <EOL> GafferUI . Label ( "<STR_LIT>" ) <EOL> self . __valueNode = Gaffer . Node ( "<STR_LIT>" ) <EOL> self . __valuePlugSetConnection = self . __valueNode . plugSetSignal ( ) . connect ( Gaffer . WeakMethod ( self . __valuePlugSet ) ) <EOL> def setPlug ( self , plug ) : <EOL> self . __plug = plug <EOL> self . __plugMetadataChangedConnection = None <EOL> del self . __editingColumn [ <NUM_LIT:4> : ] <EOL> plugValueWidget = None <EOL> if self . __plug is not None : <EOL> self . __plugMetadataChangedConnection = Gaffer . Metadata . plugValueChangedSignal ( ) . connect ( Gaffer . WeakMethod ( self . __plugMetadataChanged ) ) <EOL> self . __valueNode [ "<STR_LIT>" ] = plug . createCounterpart ( "<STR_LIT>" , plug . Direction . In ) <EOL> if hasattr ( self . __plug , "<STR_LIT>" ) : <EOL> plugValueWidget = GafferUI . PlugValueWidget . create ( self . __valueNode [ "<STR_LIT>" ] , useTypeOnly = True ) <EOL> self . __editingColumn . append ( plugValueWidget if plugValueWidget is not None else GafferUI . TextWidget ( ) ) <EOL> self . __editingColumn . append ( GafferUI . Spacer ( IECore . V2i ( <NUM_LIT:0> ) , parenting = { "<STR_LIT>" : True } ) ) <EOL> self . __updatePath ( ) <EOL> self . __addButton . setEnabled ( hasattr ( self . __plug , "<STR_LIT>" ) ) <EOL> def getPlug ( self ) : <EOL> return self . __plug <EOL> def __updatePath ( self ) : <EOL> d = self . __pathListing . getPath ( ) . dict ( ) <EOL> d . clear ( ) <EOL> if self . __plug is not None : <EOL> for name in _registeredMetadata ( self . __plug , instanceOnly = True , persistentOnly = True ) : <EOL> if name . startswith ( "<STR_LIT>" ) : <EOL> d [ name [ <NUM_LIT:7> : ] ] = _metadata ( self . __plug , name ) <EOL> self . __pathListing . getPath ( ) . pathChangedSignal ( ) ( self . __pathListing . getPath ( ) ) <EOL> def __plugMetadataChanged ( self , nodeTypeId , plugPath , key , plug ) : <EOL> if plug is None or not plug . isSame ( self . __plug ) : <EOL> return <EOL> if key . startswith ( "<STR_LIT>" ) : <EOL> self . __updatePath ( ) <EOL> def __selectionChanged ( self , listing ) : <EOL> selectedPaths = listing . getSelectedPaths ( ) <EOL> self . __nameWidget . setText ( selectedPaths [ <NUM_LIT:0> ] [ <NUM_LIT:0> ] if selectedPaths else "<STR_LIT>" ) <EOL> if selectedPaths : <EOL> with Gaffer . BlockedConnection ( self . __valuePlugSetConnection ) : <EOL> self . __valueNode [ "<STR_LIT>" ] . setValue ( <EOL> Gaffer . Metadata . plugValue ( self . getPlug ( ) , "<STR_LIT>" + selectedPaths [ <NUM_LIT:0> ] [ <NUM_LIT:0> ] ) <EOL> ) <EOL> self . __editingColumn . setEnabled ( bool ( selectedPaths ) ) <EOL> self . __deleteButton . setEnabled ( bool ( selectedPaths ) ) <EOL> def __dragEnter ( self , listing , event ) : <EOL> if event . sourceWidget is not self . __pathListing : <EOL> return False <EOL> if not isinstance ( event . data , IECore . StringVectorData ) : <EOL> return False <EOL> return True <EOL> def __dragMove ( self , listing , event ) : <EOL> d = self . __pathListing . getPath ( ) . dict ( ) <EOL> srcPath = self . __pathListing . getPath ( ) . copy ( ) . setFromString ( event . data [ <NUM_LIT:0> ] ) <EOL> srcIndex = d . keys ( ) . index ( srcPath [ <NUM_LIT:0> ] ) <EOL> targetPath = self . __pathListing . pathAt ( event . line . p0 ) <EOL> if targetPath is not None : <EOL> targetIndex = d . keys ( ) . index ( targetPath [ <NUM_LIT:0> ] ) <EOL> else : <EOL> targetIndex = <NUM_LIT:0> if event . line . p0 . y < <NUM_LIT:1> else len ( d ) <EOL> if srcIndex == targetIndex : <EOL> return True <EOL> items = d . items ( ) <EOL> item = items [ srcIndex ] <EOL> del items [ srcIndex ] <EOL> items . insert ( targetIndex , item ) <EOL> d . clear ( ) <EOL> d . update ( items ) <EOL> self . __pathListing . getPath ( ) . pathChangedSignal ( ) ( self . __pathListing . getPath ( ) ) <EOL> return True <EOL> def __dragEnd ( self , listing , event ) : <EOL> d = self . __pathListing . getPath ( ) . dict ( ) <EOL> with Gaffer . BlockedConnection ( self . __plugMetadataChangedConnection ) : <EOL> with Gaffer . UndoContext ( self . getPlug ( ) . ancestor ( Gaffer . ScriptNode ) ) : <EOL> for item in d . items ( ) : <EOL> Gaffer . Metadata . deregisterPlugValue ( self . getPlug ( ) , "<STR_LIT>" + item [ <NUM_LIT:0> ] ) <EOL> for item in d . items ( ) : <EOL> Gaffer . Metadata . registerPlugValue ( self . getPlug ( ) , "<STR_LIT>" + item [ <NUM_LIT:0> ] , item [ <NUM_LIT:1> ] ) <EOL> self . __updatePath ( ) <EOL> return True <EOL> def __addButtonClicked ( self , button ) : <EOL> existingNames = [ p [ <NUM_LIT:0> ] for p in self . __pathListing . getPath ( ) . children ( ) ] <EOL> name = "<STR_LIT>" <EOL> index = <NUM_LIT:1> <EOL> while name in existingNames : <EOL> name = "<STR_LIT>" % index <EOL> index += <NUM_LIT:1> <EOL> with Gaffer . UndoContext ( self . __plug . ancestor ( Gaffer . ScriptNode ) ) : <EOL> Gaffer . Metadata . registerPlugValue ( self . __plug , "<STR_LIT>" + name , self . __plug . getValue ( ) ) <EOL> self . __pathListing . setSelectedPaths ( <EOL> self . __pathListing . getPath ( ) . copy ( ) . setFromString ( "<STR_LIT:/>" + name ) <EOL> ) <EOL> self . __nameWidget . grabFocus ( ) <EOL> self . __nameWidget . setSelection ( <NUM_LIT:0> , len ( name ) ) <EOL> return True <EOL> def __deleteButtonClicked ( self , button ) : <EOL> paths = self . __pathListing . getPath ( ) . children ( ) <EOL> selectedPreset = self . __pathListing . getSelectedPaths ( ) [ <NUM_LIT:0> ] [ <NUM_LIT:0> ] <EOL> selectedIndex = [ p [ <NUM_LIT:0> ] for p in paths ] . index ( selectedPreset ) <EOL> with Gaffer . UndoContext ( self . __plug . ancestor ( Gaffer . ScriptNode ) ) : <EOL> Gaffer . Metadata . deregisterPlugValue ( self . __plug , "<STR_LIT>" + selectedPreset ) <EOL> del paths [ selectedIndex ] <EOL> if len ( paths ) : <EOL> self . __pathListing . setSelectedPaths ( [ paths [ min ( selectedIndex , len ( paths ) - <NUM_LIT:1> ) ] ] ) <EOL> return True <EOL> def __nameEditingFinished ( self , nameWidget ) : <EOL> selectedPaths = self . __pathListing . getSelectedPaths ( ) <EOL> if not len ( selectedPaths ) : <EOL> return True <EOL> oldName = selectedPaths [ <NUM_LIT:0> ] [ <NUM_LIT:0> ] <EOL> newName = nameWidget . getText ( ) <EOL> items = self . __pathListing . getPath ( ) . dict ( ) . items ( ) <EOL> with Gaffer . BlockedConnection ( self . __plugMetadataChangedConnection ) : <EOL> with Gaffer . UndoContext ( self . getPlug ( ) . ancestor ( Gaffer . ScriptNode ) ) : <EOL> for item in items : <EOL> Gaffer . Metadata . deregisterPlugValue ( self . getPlug ( ) , "<STR_LIT>" + item [ <NUM_LIT:0> ] ) <EOL> for item in items : <EOL> Gaffer . Metadata . registerPlugValue ( self . getPlug ( ) , "<STR_LIT>" + ( item [ <NUM_LIT:0> ] if item [ <NUM_LIT:0> ] != oldName else newName ) , item [ <NUM_LIT:1> ] ) <EOL> self . __updatePath ( ) <EOL> self . __pathListing . setSelectedPaths ( [ self . __pathListing . getPath ( ) . copy ( ) . setFromString ( "<STR_LIT:/>" + newName ) ] ) <EOL> return True <EOL> def __valuePlugSet ( self , plug ) : <EOL> if not plug . isSame ( self . __valueNode [ "<STR_LIT>" ] ) : <EOL> return <EOL> selectedPaths = self . __pathListing . getSelectedPaths ( ) <EOL> preset = selectedPaths [ <NUM_LIT:0> ] [ <NUM_LIT:0> ] <EOL> with Gaffer . UndoContext ( self . getPlug ( ) . ancestor ( Gaffer . ScriptNode ) ) : <EOL> Gaffer . Metadata . registerPlugValue ( self . getPlug ( ) , "<STR_LIT>" + preset , plug . getValue ( ) ) <EOL> class _PlugEditor ( GafferUI . Widget ) : <EOL> def __init__ ( self , parenting = None ) : <EOL> scrolledContainer = GafferUI . ScrolledContainer ( horizontalMode = GafferUI . ScrolledContainer . ScrollMode . Never , borderWidth = <NUM_LIT:8> ) <EOL> GafferUI . Widget . __init__ ( self , scrolledContainer , parenting = parenting ) <EOL> self . __metadataWidgets = { } <EOL> scrolledContainer . setChild ( GafferUI . ListContainer ( spacing = <NUM_LIT:4> ) ) <EOL> with scrolledContainer . getChild ( ) : <EOL> with _Row ( ) : <EOL> _Label ( "<STR_LIT:Name>" ) <EOL> self . __nameWidget = GafferUI . NameWidget ( None ) <EOL> with _Row ( ) : <EOL> _Label ( "<STR_LIT>" ) <EOL> self . __metadataWidgets [ "<STR_LIT:label>" ] = _StringMetadataWidget ( key = "<STR_LIT:label>" , acceptEmptyString = False ) <EOL> with _Row ( ) : <EOL> _Label ( "<STR_LIT>" , parenting = { "<STR_LIT>" : GafferUI . ListContainer . VerticalAlignment . Top } ) <EOL> self . __metadataWidgets [ "<STR_LIT:description>" ] = _MultiLineStringMetadataWidget ( key = "<STR_LIT:description>" ) <EOL> self . __metadataWidgets [ "<STR_LIT:description>" ] . textWidget ( ) . setFixedLineHeight ( <NUM_LIT:10> ) <EOL> with _Row ( ) : <EOL> _Label ( "<STR_LIT>" ) <EOL> self . __widgetMenu = GafferUI . MenuButton ( <EOL> menu = GafferUI . Menu ( Gaffer . WeakMethod ( self . __widgetMenuDefinition ) ) <EOL> ) <EOL> with GafferUI . Collapsible ( "<STR_LIT>" , collapsed = True ) : <EOL> with _Row ( ) : <EOL> _Label ( "<STR_LIT>" ) <EOL> self . __presetsEditor = _PresetsEditor ( ) <EOL> with GafferUI . Collapsible ( "<STR_LIT>" , collapsed = True ) : <EOL> with GafferUI . ListContainer ( spacing = <NUM_LIT:4> ) : <EOL> with _Row ( ) : <EOL> _Label ( "<STR_LIT>" ) <EOL> self . __metadataWidgets [ "<STR_LIT>" ] = _BoolMetadataWidget ( key = "<STR_LIT>" ) <EOL> for m in self . __metadataDefinitions : <EOL> with _Row ( ) : <EOL> _Label ( m . label ) <EOL> self . __metadataWidgets [ m . key ] = m . metadataWidgetType ( key = m . key ) <EOL> with GafferUI . Collapsible ( "<STR_LIT>" , collapsed = True ) : <EOL> with GafferUI . ListContainer ( spacing = <NUM_LIT:4> ) as self . __nodeGraphSection : <EOL> with _Row ( ) : <EOL> _Label ( "<STR_LIT>" ) <EOL> self . __gadgetMenu = GafferUI . MenuButton ( <EOL> menu = GafferUI . Menu ( Gaffer . WeakMethod ( self . __gadgetMenuDefinition ) ) <EOL> ) <EOL> with _Row ( ) : <EOL> _Label ( "<STR_LIT>" ) <EOL> self . __metadataWidgets [ "<STR_LIT>" ] = _MenuMetadataWidget ( <EOL> key = "<STR_LIT>" , <EOL> labelsAndValues = [ <EOL> ( "<STR_LIT>" , None ) , <EOL> ( "<STR_LIT>" , "<STR_LIT>" ) , <EOL> ( "<STR_LIT>" , "<STR_LIT>" ) , <EOL> ( "<STR_LIT>" , "<STR_LIT:left>" ) , <EOL> ( "<STR_LIT>" , "<STR_LIT:right>" ) , <EOL> ] <EOL> ) <EOL> with _Row ( ) : <EOL> _Label ( "<STR_LIT>" ) <EOL> self . __metadataWidgets [ "<STR_LIT>" ] = _ColorSwatchMetadataWidget ( key = "<STR_LIT>" ) <EOL> with _Row ( ) : <EOL> _Label ( "<STR_LIT>" ) <EOL> self . __metadataWidgets [ "<STR_LIT>" ] = _ColorSwatchMetadataWidget ( key = "<STR_LIT>" ) <EOL> GafferUI . Spacer ( IECore . V2i ( <NUM_LIT:0> ) , parenting = { "<STR_LIT>" : True } ) <EOL> self . __plugMetadataChangedConnection = Gaffer . Metadata . plugValueChangedSignal ( ) . connect ( Gaffer . WeakMethod ( self . __plugMetadataChanged ) ) <EOL> self . __plug = None <EOL> def setPlug ( self , plug ) : <EOL> self . __plug = plug <EOL> self . __nameWidget . setGraphComponent ( self . __plug ) <EOL> for widget in self . __metadataWidgets . values ( ) : <EOL> widget . setTarget ( self . __plug ) <EOL> self . __updateWidgetMenuText ( ) <EOL> self . __updateWidgetSettings ( ) <EOL> self . __updateGadgetMenuText ( ) <EOL> self . __presetsEditor . setPlug ( plug ) <EOL> self . __nodeGraphSection . setEnabled ( self . __plug is not None and self . __plug . parent ( ) . isSame ( self . __plug . node ( ) ) ) <EOL> self . setEnabled ( self . __plug is not None ) <EOL> def getPlug ( self ) : <EOL> return self . __plug <EOL> def __plugMetadataChanged ( self , nodeTypeId , plugPath , key , plug ) : <EOL> if self . getPlug ( ) is None : <EOL> return <EOL> if plug is not None and not plug . isSame ( self . getPlug ( ) ) : <EOL> return <EOL> if not self . getPlug ( ) . node ( ) . isInstanceOf ( nodeTypeId ) : <EOL> return <EOL> if key == "<STR_LIT>" : <EOL> self . __updateWidgetMenuText ( ) <EOL> self . __updateWidgetSettings ( ) <EOL> elif key == "<STR_LIT>" : <EOL> self . __updateGadgetMenuText ( ) <EOL> def __updateWidgetMenuText ( self ) : <EOL> if self . getPlug ( ) is None : <EOL> self . __widgetMenu . setText ( "<STR_LIT>" ) <EOL> return <EOL> metadata = Gaffer . Metadata . plugValue ( self . getPlug ( ) , "<STR_LIT>" ) <EOL> for w in self . __widgetDefinitions : <EOL> if w . metadata == metadata : <EOL> self . __widgetMenu . setText ( w . label ) <EOL> return <EOL> self . __widgetMenu . setText ( metadata ) <EOL> def __updateWidgetSettings ( self ) : <EOL> widgetType = None <EOL> if self . getPlug ( ) is not None : <EOL> widgetType = Gaffer . Metadata . plugValue ( self . getPlug ( ) , "<STR_LIT>" ) <EOL> for m in self . __metadataDefinitions : <EOL> widget = self . __metadataWidgets [ m . key ] <EOL> widget . parent ( ) . setEnabled ( m . plugValueWidgetType == widgetType ) <EOL> self . __metadataWidgets [ "<STR_LIT>" ] . parent ( ) . setEnabled ( <EOL> self . getPlug ( ) is not None and self . getPlug ( ) . direction ( ) == Gaffer . Plug . Direction . In <EOL> ) <EOL> def __widgetMenuDefinition ( self ) : <EOL> result = IECore . MenuDefinition ( ) <EOL> if self . getPlug ( ) is None : <EOL> return result <EOL> metadata = Gaffer . Metadata . plugValue ( self . getPlug ( ) , "<STR_LIT>" ) <EOL> for w in self . __widgetDefinitions : <EOL> if not isinstance ( self . getPlug ( ) , w . plugType ) : <EOL> continue <EOL> result . append ( <EOL> "<STR_LIT:/>" + w . label , <EOL> { <EOL> "<STR_LIT>" : functools . partial ( Gaffer . WeakMethod ( self . __registerOrDeregisterMetadata ) , key = "<STR_LIT>" , value = w . metadata ) , <EOL> "<STR_LIT>" : metadata == w . metadata , <EOL> } <EOL> ) <EOL> return result <EOL> def __updateGadgetMenuText ( self ) : <EOL> if self . getPlug ( ) is None : <EOL> self . __gadgetMenu . setText ( "<STR_LIT>" ) <EOL> return <EOL> metadata = Gaffer . Metadata . plugValue ( self . getPlug ( ) , "<STR_LIT>" ) <EOL> metadata = None if metadata == "<STR_LIT>" else metadata <EOL> for g in self . __gadgetDefinitions : <EOL> if g . metadata == metadata : <EOL> self . __gadgetMenu . setText ( g . label ) <EOL> return <EOL> self . __gadgetMenu . setText ( metadata ) <EOL> def __gadgetMenuDefinition ( self ) : <EOL> result = IECore . MenuDefinition ( ) <EOL> if self . getPlug ( ) is None : <EOL> return result <EOL> metadata = Gaffer . Metadata . plugValue ( self . getPlug ( ) , "<STR_LIT>" ) <EOL> for g in self . __gadgetDefinitions : <EOL> if not isinstance ( self . getPlug ( ) , g . plugType ) : <EOL> continue <EOL> result . append ( <EOL> "<STR_LIT:/>" + g . label , <EOL> { <EOL> "<STR_LIT>" : functools . partial ( Gaffer . WeakMethod ( self . __registerOrDeregisterMetadata ) , key = "<STR_LIT>" , value = g . metadata ) , <EOL> "<STR_LIT>" : metadata == g . metadata , <EOL> } <EOL> ) <EOL> return result <EOL> def __registerOrDeregisterMetadata ( self , unused , key , value ) : <EOL> with Gaffer . UndoContext ( self . getPlug ( ) . ancestor ( Gaffer . ScriptNode ) ) : <EOL> if value is not None : <EOL> Gaffer . Metadata . registerPlugValue ( self . getPlug ( ) , key , value ) <EOL> else : <EOL> Gaffer . Metadata . deregisterPlugValue ( self . getPlug ( ) , key ) <EOL> __WidgetDefinition = collections . namedtuple ( "<STR_LIT>" , ( "<STR_LIT:label>" , "<STR_LIT>" , "<STR_LIT>" ) ) <EOL> __widgetDefinitions = ( <EOL> __WidgetDefinition ( "<STR_LIT>" , Gaffer . Plug , None ) , <EOL> __WidgetDefinition ( "<STR_LIT>" , Gaffer . IntPlug , "<STR_LIT>" ) , <EOL> __WidgetDefinition ( "<STR_LIT>" , Gaffer . StringPlug , "<STR_LIT>" ) , <EOL> __WidgetDefinition ( "<STR_LIT>" , Gaffer . StringPlug , "<STR_LIT>" ) , <EOL> __WidgetDefinition ( "<STR_LIT>" , Gaffer . ValuePlug , "<STR_LIT>" ) , <EOL> __WidgetDefinition ( "<STR_LIT>" , Gaffer . Plug , "<STR_LIT>" ) , <EOL> __WidgetDefinition ( "<STR_LIT:None>" , Gaffer . Plug , "<STR_LIT>" ) , <EOL> ) <EOL> __MetadataDefinition = collections . namedtuple ( "<STR_LIT>" , ( "<STR_LIT:key>" , "<STR_LIT:label>" , "<STR_LIT>" , "<STR_LIT>" ) ) <EOL> __metadataDefinitions = ( <EOL> __MetadataDefinition ( "<STR_LIT>" , "<STR_LIT>" , _StringMetadataWidget , "<STR_LIT>" ) , <EOL> __MetadataDefinition ( "<STR_LIT>" , "<STR_LIT>" , _StringMetadataWidget , "<STR_LIT>" ) , <EOL> __MetadataDefinition ( "<STR_LIT>" , "<STR_LIT>" , _BoolMetadataWidget , "<STR_LIT>" ) , <EOL> __MetadataDefinition ( "<STR_LIT>" , "<STR_LIT>" , _BoolMetadataWidget , "<STR_LIT>" ) , <EOL> __MetadataDefinition ( "<STR_LIT>" , "<STR_LIT>" , _BoolMetadataWidget , "<STR_LIT>" ) , <EOL> __MetadataDefinition ( "<STR_LIT>" , "<STR_LIT>" , _BoolMetadataWidget , "<STR_LIT>" ) , <EOL> ) <EOL> __GadgetDefinition = collections . namedtuple ( "<STR_LIT>" , ( "<STR_LIT:label>" , "<STR_LIT>" , "<STR_LIT>" ) ) <EOL> __gadgetDefinitions = ( <EOL> __GadgetDefinition ( "<STR_LIT>" , Gaffer . Plug , None ) , <EOL> __GadgetDefinition ( "<STR_LIT>" , Gaffer . ArrayPlug , "<STR_LIT>" ) , <EOL> __GadgetDefinition ( "<STR_LIT:None>" , Gaffer . Plug , "<STR_LIT>" ) , <EOL> ) <EOL> class _SectionEditor ( GafferUI . Widget ) : <EOL> def __init__ ( self , parenting = None ) : <EOL> column = GafferUI . ListContainer ( spacing = <NUM_LIT:4> , borderWidth = <NUM_LIT:8> ) <EOL> GafferUI . Widget . __init__ ( self , column , parenting = parenting ) <EOL> with column : <EOL> with _Row ( ) : <EOL> _Label ( "<STR_LIT:Name>" ) <EOL> self . __nameWidget = GafferUI . TextWidget ( ) <EOL> self . __nameWidgetEditingFinishedConnection = self . __nameWidget . editingFinishedSignal ( ) . connect ( Gaffer . WeakMethod ( self . __nameWidgetEditingFinished ) ) <EOL> with _Row ( ) : <EOL> _Label ( "<STR_LIT>" , parenting = { "<STR_LIT>" : GafferUI . ListContainer . VerticalAlignment . Top } ) <EOL> self . __summaryMetadataWidget = _MultiLineStringMetadataWidget ( key = "<STR_LIT>" ) <EOL> self . __section = "<STR_LIT>" <EOL> self . __plugParent = None <EOL> self . __nameChangedSignal = Gaffer . Signal3 ( ) <EOL> def setPlugParent ( self , plugParent ) : <EOL> self . __plugParent = plugParent <EOL> self . __summaryMetadataWidget . setTarget ( self . __plugParent ) <EOL> def getPlugParent ( self ) : <EOL> return self . __plugParent <EOL> def setSection ( self , section ) : <EOL> assert ( isinstance ( section , basestring ) ) <EOL> self . __section = section <EOL> self . __nameWidget . setText ( section . rpartition ( "<STR_LIT:.>" ) [ - <NUM_LIT:1> ] ) <EOL> self . __summaryMetadataWidget . setKey ( "<STR_LIT>" + self . __section + "<STR_LIT>" ) <EOL> def getSection ( self ) : <EOL> return self . __section <EOL> def nameChangedSignal ( self ) : <EOL> return self . __nameChangedSignal <EOL> def __nameWidgetEditingFinished ( self , nameWidget ) : <EOL> if nameWidget . getText ( ) == "<STR_LIT>" : <EOL> self . setSection ( self . __section ) <EOL> return <EOL> oldSectionPath = self . __section . split ( "<STR_LIT:.>" ) <EOL> newSectionPath = oldSectionPath [ : ] <EOL> newSectionPath [ - <NUM_LIT:1> ] = nameWidget . getText ( ) . replace ( "<STR_LIT:.>" , "<STR_LIT>" ) <EOL> if oldSectionPath == newSectionPath : <EOL> return <EOL> def newSection ( oldSection ) : <EOL> s = oldSection . split ( "<STR_LIT:.>" ) <EOL> if s [ : len ( oldSectionPath ) ] == oldSectionPath : <EOL> s [ : len ( oldSectionPath ) ] = newSectionPath <EOL> return "<STR_LIT:.>" . join ( s ) <EOL> else : <EOL> return oldSection <EOL> with Gaffer . UndoContext ( self . __plugParent . ancestor ( Gaffer . ScriptNode ) ) : <EOL> for plug in self . __plugParent . children ( Gaffer . Plug ) : <EOL> s = _metadata ( plug , "<STR_LIT>" ) <EOL> if s is not None : <EOL> _registerMetadata ( plug , "<STR_LIT>" , newSection ( s ) ) <EOL> emptySections = _metadata ( self . getPlugParent ( ) , "<STR_LIT>" ) <EOL> if emptySections : <EOL> for i in range ( <NUM_LIT:0> , len ( emptySections ) ) : <EOL> emptySections [ i ] = newSection ( emptySections [ i ] ) <EOL> _registerMetadata ( self . getPlugParent ( ) , "<STR_LIT>" , emptySections ) <EOL> for name in _registeredMetadata ( self . getPlugParent ( ) , instanceOnly = True , persistentOnly = True ) : <EOL> m = re . match ( "<STR_LIT>" , name ) <EOL> if m : <EOL> if newSection ( m . group ( <NUM_LIT:2> ) ) != m . group ( <NUM_LIT:2> ) : <EOL> _registerMetadata ( <EOL> self . getPlugParent ( ) , <EOL> m . group ( <NUM_LIT:1> ) + newSection ( m . group ( <NUM_LIT:2> ) ) + m . group ( <NUM_LIT:3> ) , <EOL> _metadata ( self . getPlugParent ( ) , name ) <EOL> ) <EOL> _deregisterMetadata ( self . getPlugParent ( ) , name ) <EOL> self . setSection ( "<STR_LIT:.>" . join ( newSectionPath ) ) <EOL> self . nameChangedSignal ( ) ( self , "<STR_LIT:.>" . join ( oldSectionPath ) , "<STR_LIT:.>" . join ( newSectionPath ) ) <EOL> def _registerMetadata ( target , name , value ) : <EOL> if isinstance ( target , Gaffer . Node ) : <EOL> Gaffer . Metadata . registerNodeValue ( target , name , value ) <EOL> else : <EOL> Gaffer . Metadata . registerPlugValue ( target , name , value ) <EOL> def _registeredMetadata ( target , inherit = True , instanceOnly = False , persistentOnly = False ) : <EOL> if isinstance ( target , Gaffer . Node ) : <EOL> return Gaffer . Metadata . registeredNodeValues ( target , inherit , instanceOnly , persistentOnly ) <EOL> else : <EOL> return Gaffer . Metadata . registeredPlugValues ( target , inherit , instanceOnly , persistentOnly ) <EOL> def _metadata ( target , name ) : <EOL> if isinstance ( target , Gaffer . Node ) : <EOL> return Gaffer . Metadata . nodeValue ( target , name ) <EOL> else : <EOL> return Gaffer . Metadata . plugValue ( target , name ) <EOL> def _deregisterMetadata ( target , name ) : <EOL> if isinstance ( target , Gaffer . Node ) : <EOL> return Gaffer . Metadata . deregisterNodeValue ( target , name ) <EOL> else : <EOL> return Gaffer . Metadata . deregisterPlugValue ( target , name ) </s>
<s> import unittest <EOL> import GafferTest <EOL> import GafferUI <EOL> class NumericSliderTest ( unittest . TestCase ) : <EOL> def testConstruction ( self ) : <EOL> s = GafferUI . NumericSlider ( value = <NUM_LIT:0> , min = <NUM_LIT:0> , max = <NUM_LIT:1> ) <EOL> self . assertEqual ( s . getPosition ( ) , <NUM_LIT:0> ) <EOL> self . assertEqual ( s . getValue ( ) , <NUM_LIT:0> ) <EOL> self . assertEqual ( s . getRange ( ) , ( <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:0> , <NUM_LIT:1> ) ) <EOL> def testSetValue ( self ) : <EOL> s = GafferUI . NumericSlider ( value = <NUM_LIT:0> , min = <NUM_LIT:0> , max = <NUM_LIT:2> ) <EOL> self . assertEqual ( s . getPosition ( ) , <NUM_LIT:0> ) <EOL> self . assertEqual ( s . getValue ( ) , <NUM_LIT:0> ) <EOL> s . setValue ( <NUM_LIT:0.5> ) <EOL> self . assertEqual ( s . getPosition ( ) , <NUM_LIT> ) <EOL> self . assertEqual ( s . getValue ( ) , <NUM_LIT:0.5> ) <EOL> def testSetRange ( self ) : <EOL> s = GafferUI . NumericSlider ( value = <NUM_LIT:1> , min = <NUM_LIT:0> , max = <NUM_LIT:2> ) <EOL> self . assertEqual ( s . getPosition ( ) , <NUM_LIT:0.5> ) <EOL> self . assertEqual ( s . getValue ( ) , <NUM_LIT:1> ) <EOL> s . setRange ( <NUM_LIT:0> , <NUM_LIT:1> ) <EOL> self . assertEqual ( s . getPosition ( ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( s . getValue ( ) , <NUM_LIT:1> ) <EOL> def testSetZeroRange ( self ) : <EOL> s = GafferUI . NumericSlider ( value = <NUM_LIT:1> , min = <NUM_LIT:1> , max = <NUM_LIT:2> ) <EOL> self . assertEqual ( s . getPosition ( ) , <NUM_LIT:0> ) <EOL> self . assertEqual ( s . getValue ( ) , <NUM_LIT:1> ) <EOL> s . setRange ( <NUM_LIT:1> , <NUM_LIT:1> ) <EOL> self . assertEqual ( s . getValue ( ) , <NUM_LIT:1> ) <EOL> def testSetPosition ( self ) : <EOL> s = GafferUI . NumericSlider ( value = <NUM_LIT:0> , min = <NUM_LIT:0> , max = <NUM_LIT:2> ) <EOL> self . assertEqual ( s . getPosition ( ) , <NUM_LIT:0> ) <EOL> self . assertEqual ( s . getValue ( ) , <NUM_LIT:0> ) <EOL> s . setPosition ( <NUM_LIT:0.5> ) <EOL> self . assertEqual ( s . getPosition ( ) , <NUM_LIT:0.5> ) <EOL> self . assertEqual ( s . getValue ( ) , <NUM_LIT:1> ) <EOL> def testValuesOutsideRangeAreClamped ( self ) : <EOL> s = GafferUI . NumericSlider ( value = <NUM_LIT:0.1> , min = <NUM_LIT:0> , max = <NUM_LIT:2> ) <EOL> cs = GafferTest . CapturingSlot ( s . valueChangedSignal ( ) , s . positionChangedSignal ( ) ) <EOL> s . setValue ( <NUM_LIT:3> ) <EOL> self . assertEqual ( s . getValue ( ) , <NUM_LIT:2> ) <EOL> self . assertEqual ( s . getPosition ( ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( len ( cs ) , <NUM_LIT:2> ) <EOL> s . setValue ( <NUM_LIT:3> ) <EOL> self . assertEqual ( s . getValue ( ) , <NUM_LIT:2> ) <EOL> self . assertEqual ( s . getPosition ( ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( len ( cs ) , <NUM_LIT:2> ) <EOL> def testPositionsOutsideRangeAreClamped ( self ) : <EOL> s = GafferUI . NumericSlider ( value = <NUM_LIT:0.1> , min = <NUM_LIT:0> , max = <NUM_LIT:2> ) <EOL> cs = GafferTest . CapturingSlot ( s . valueChangedSignal ( ) , s . positionChangedSignal ( ) ) <EOL> s . setPosition ( <NUM_LIT:2> ) <EOL> self . assertEqual ( s . getValue ( ) , <NUM_LIT:2> ) <EOL> self . assertEqual ( s . getPosition ( ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( len ( cs ) , <NUM_LIT:2> ) <EOL> s . setPosition ( <NUM_LIT:2> ) <EOL> self . assertEqual ( s . getValue ( ) , <NUM_LIT:2> ) <EOL> self . assertEqual ( s . getPosition ( ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( len ( cs ) , <NUM_LIT:2> ) <EOL> def testHardRange ( self ) : <EOL> s = GafferUI . NumericSlider ( value = <NUM_LIT:0.1> , min = <NUM_LIT:0> , max = <NUM_LIT:2> , hardMin = - <NUM_LIT:1> , hardMax = <NUM_LIT:3> ) <EOL> self . assertEqual ( s . getRange ( ) , ( <NUM_LIT:0> , <NUM_LIT:2> , - <NUM_LIT:1> , <NUM_LIT:3> ) ) <EOL> cs = GafferTest . CapturingSlot ( s . valueChangedSignal ( ) , s . positionChangedSignal ( ) ) <EOL> s . setValue ( <NUM_LIT:3> ) <EOL> self . assertEqual ( s . getValue ( ) , <NUM_LIT:3> ) <EOL> self . assertEqual ( s . getPosition ( ) , <NUM_LIT> ) <EOL> self . assertEqual ( len ( cs ) , <NUM_LIT:2> ) <EOL> s . setValue ( <NUM_LIT> ) <EOL> self . assertEqual ( s . getValue ( ) , <NUM_LIT:3> ) <EOL> self . assertEqual ( s . getPosition ( ) , <NUM_LIT> ) <EOL> self . assertEqual ( len ( cs ) , <NUM_LIT:2> ) <EOL> s . setValue ( - <NUM_LIT:1> ) <EOL> self . assertEqual ( s . getValue ( ) , - <NUM_LIT:1> ) <EOL> self . assertEqual ( s . getPosition ( ) , - <NUM_LIT:0.5> ) <EOL> self . assertEqual ( len ( cs ) , <NUM_LIT:4> ) <EOL> s . setValue ( - <NUM_LIT:2> ) <EOL> self . assertEqual ( s . getValue ( ) , - <NUM_LIT:1> ) <EOL> self . assertEqual ( s . getPosition ( ) , - <NUM_LIT:0.5> ) <EOL> self . assertEqual ( len ( cs ) , <NUM_LIT:4> ) <EOL> def testSetRangeClampsValue ( self ) : <EOL> s = GafferUI . NumericSlider ( value = <NUM_LIT:0.5> , min = <NUM_LIT:0> , max = <NUM_LIT:2> ) <EOL> self . assertEqual ( s . getPosition ( ) , <NUM_LIT> ) <EOL> self . assertEqual ( s . getValue ( ) , <NUM_LIT:0.5> ) <EOL> s . setRange ( <NUM_LIT:1> , <NUM_LIT:2> ) <EOL> self . assertEqual ( s . getPosition ( ) , <NUM_LIT:0> ) <EOL> self . assertEqual ( s . getValue ( ) , <NUM_LIT:1> ) <EOL> def testMultipleValues ( self ) : <EOL> self . assertRaises ( Exception , GafferUI . NumericSlider , value = <NUM_LIT:0> , values = [ <NUM_LIT:1> , <NUM_LIT:2> ] ) <EOL> s = GafferUI . NumericSlider ( values = [ <NUM_LIT:1> , <NUM_LIT> ] , min = <NUM_LIT:0> , max = <NUM_LIT:2> ) <EOL> self . assertEqual ( s . getValues ( ) , [ <NUM_LIT:1> , <NUM_LIT> ] ) <EOL> self . assertEqual ( s . getPositions ( ) , [ <NUM_LIT:0.5> , <NUM_LIT> ] ) <EOL> self . assertRaises ( ValueError , s . getValue ) <EOL> if __name__ == "<STR_LIT:__main__>" : <EOL> unittest . main ( ) </s>
<s> import unittest <EOL> import weakref <EOL> import sys <EOL> import IECore <EOL> import Gaffer <EOL> import GafferTest <EOL> import GafferUI <EOL> import GafferUITest <EOL> QtCore = GafferUI . _qtImport ( "<STR_LIT>" ) <EOL> QtGui = GafferUI . _qtImport ( "<STR_LIT>" ) <EOL> class TestWidget ( GafferUI . Widget ) : <EOL> def __init__ ( self , ** kw ) : <EOL> GafferUI . Widget . __init__ ( self , QtGui . QLabel ( "<STR_LIT:hello>" ) , ** kw ) <EOL> class TestWidget2 ( GafferUI . Widget ) : <EOL> def __init__ ( self ) : <EOL> self . topLevelGafferWidget = TestWidget ( ) <EOL> GafferUI . Widget . __init__ ( self , self . topLevelGafferWidget ) <EOL> class WidgetTest ( GafferUITest . TestCase ) : <EOL> def testOwner ( self ) : <EOL> w = TestWidget ( ) <EOL> self . assert_ ( GafferUI . Widget . _owner ( w . _qtWidget ( ) ) is w ) <EOL> def testParent ( self ) : <EOL> w = TestWidget ( ) <EOL> self . assert_ ( w . parent ( ) is None ) <EOL> def testCanDie ( self ) : <EOL> w = TestWidget ( ) <EOL> wr1 = weakref . ref ( w ) <EOL> wr2 = weakref . ref ( w . _qtWidget ( ) ) <EOL> del w <EOL> self . assert_ ( wr1 ( ) is None ) <EOL> self . assert_ ( wr2 ( ) is None ) <EOL> def testAncestor ( self ) : <EOL> w = GafferUI . Window ( "<STR_LIT:test>" ) <EOL> l = GafferUI . ListContainer ( GafferUI . ListContainer . Orientation . Vertical ) <EOL> p = GafferUI . SplitContainer ( ) <EOL> l . append ( p ) <EOL> w . setChild ( l ) <EOL> self . assert_ ( p . ancestor ( GafferUI . ListContainer ) is l ) <EOL> self . assert_ ( p . ancestor ( GafferUI . Window ) is w ) <EOL> self . assert_ ( p . ancestor ( GafferUI . Menu ) is None ) <EOL> def testIsAncestorOf ( self ) : <EOL> with GafferUI . Window ( "<STR_LIT:test>" ) as w : <EOL> with GafferUI . SplitContainer ( ) as p : <EOL> with GafferUI . ListContainer ( ) as l1 : <EOL> b1 = GafferUI . Button ( ) <EOL> with GafferUI . ListContainer ( ) as l2 : <EOL> b2 = GafferUI . Button ( ) <EOL> self . assertTrue ( l2 . isAncestorOf ( b2 ) ) <EOL> self . assertFalse ( l1 . isAncestorOf ( b2 ) ) <EOL> self . assertTrue ( p . isAncestorOf ( b2 ) ) <EOL> self . assertTrue ( w . isAncestorOf ( b2 ) ) <EOL> self . assertFalse ( b2 . isAncestorOf ( b1 ) ) <EOL> self . assertFalse ( b2 . isAncestorOf ( l1 ) ) <EOL> self . assertFalse ( b2 . isAncestorOf ( l2 ) ) <EOL> self . assertFalse ( b2 . isAncestorOf ( p ) ) <EOL> self . assertFalse ( b2 . isAncestorOf ( w ) ) <EOL> self . assertTrue ( l1 . isAncestorOf ( b1 ) ) <EOL> self . assertFalse ( l2 . isAncestorOf ( b1 ) ) <EOL> self . assertTrue ( p . isAncestorOf ( b1 ) ) <EOL> self . assertTrue ( w . isAncestorOf ( b1 ) ) <EOL> def testGafferWidgetAsTopLevel ( self ) : <EOL> w = TestWidget2 ( ) <EOL> self . assert_ ( GafferUI . Widget . _owner ( w . _qtWidget ( ) ) is w ) <EOL> self . assert_ ( w . topLevelGafferWidget . parent ( ) is w ) <EOL> self . assert_ ( GafferUI . Widget . _owner ( w . topLevelGafferWidget . _qtWidget ( ) ) is not w ) <EOL> def testToolTip ( self ) : <EOL> w = TestWidget ( ) <EOL> self . assertEqual ( w . getToolTip ( ) , "<STR_LIT>" ) <EOL> w = TestWidget ( toolTip = "<STR_LIT>" ) <EOL> self . assertEqual ( w . getToolTip ( ) , "<STR_LIT>" ) <EOL> w . setToolTip ( "<STR_LIT:a>" ) <EOL> self . assertEqual ( w . getToolTip ( ) , "<STR_LIT:a>" ) <EOL> def testEnabledState ( self ) : <EOL> w = TestWidget ( ) <EOL> self . assertEqual ( w . getEnabled ( ) , True ) <EOL> self . assertEqual ( w . enabled ( ) , True ) <EOL> w . setEnabled ( False ) <EOL> self . assertEqual ( w . getEnabled ( ) , False ) <EOL> self . assertEqual ( w . enabled ( ) , False ) <EOL> w . setEnabled ( True ) <EOL> self . assertEqual ( w . getEnabled ( ) , True ) <EOL> self . assertEqual ( w . enabled ( ) , True ) <EOL> def testDisabledWidgetsDontGetSignals ( self ) : <EOL> w = TestWidget ( ) <EOL> def f ( w , event ) : <EOL> WidgetTest . signalsEmitted += <NUM_LIT:1> <EOL> c = w . buttonPressSignal ( ) . connect ( f ) <EOL> WidgetTest . signalsEmitted = <NUM_LIT:0> <EOL> event = QtGui . QMouseEvent ( QtCore . QEvent . MouseButtonPress , QtCore . QPoint ( <NUM_LIT:0> , <NUM_LIT:0> ) , QtCore . Qt . LeftButton , QtCore . Qt . LeftButton , QtCore . Qt . NoModifier ) <EOL> QtGui . QApplication . instance ( ) . sendEvent ( w . _qtWidget ( ) , event ) <EOL> self . assertEqual ( WidgetTest . signalsEmitted , <NUM_LIT:1> ) <EOL> w . setEnabled ( False ) <EOL> QtGui . QApplication . instance ( ) . sendEvent ( w . _qtWidget ( ) , event ) <EOL> self . assertEqual ( WidgetTest . signalsEmitted , <NUM_LIT:1> ) <EOL> w . setEnabled ( True ) <EOL> QtGui . QApplication . instance ( ) . sendEvent ( w . _qtWidget ( ) , event ) <EOL> self . assertEqual ( WidgetTest . signalsEmitted , <NUM_LIT:2> ) <EOL> def testCanDieAfterUsingSignals ( self ) : <EOL> w = TestWidget ( ) <EOL> wr1 = weakref . ref ( w ) <EOL> wr2 = weakref . ref ( w . _qtWidget ( ) ) <EOL> w . buttonPressSignal ( ) <EOL> w . buttonReleaseSignal ( ) <EOL> w . mouseMoveSignal ( ) <EOL> w . wheelSignal ( ) <EOL> del w <EOL> self . assert_ ( wr1 ( ) is None ) <EOL> self . assert_ ( wr2 ( ) is None ) <EOL> def testVisibility ( self ) : <EOL> with GafferUI . Window ( ) as w : <EOL> with GafferUI . ListContainer ( ) as l : <EOL> t = TestWidget ( ) <EOL> self . assertEqual ( w . getVisible ( ) , False ) <EOL> self . assertEqual ( l . getVisible ( ) , True ) <EOL> self . assertEqual ( t . getVisible ( ) , True ) <EOL> self . assertEqual ( w . visible ( ) , False ) <EOL> self . assertEqual ( l . visible ( ) , False ) <EOL> self . assertEqual ( t . visible ( ) , False ) <EOL> w . setVisible ( True ) <EOL> self . assertEqual ( w . getVisible ( ) , True ) <EOL> self . assertEqual ( l . getVisible ( ) , True ) <EOL> self . assertEqual ( t . getVisible ( ) , True ) <EOL> self . assertEqual ( w . visible ( ) , True ) <EOL> self . assertEqual ( l . visible ( ) , True ) <EOL> self . assertEqual ( t . visible ( ) , True ) <EOL> w . setVisible ( False ) <EOL> self . assertEqual ( w . getVisible ( ) , False ) <EOL> self . assertEqual ( l . getVisible ( ) , True ) <EOL> self . assertEqual ( t . getVisible ( ) , True ) <EOL> self . assertEqual ( w . visible ( ) , False ) <EOL> self . assertEqual ( l . visible ( ) , False ) <EOL> self . assertEqual ( t . visible ( ) , False ) <EOL> self . assertEqual ( t . visible ( relativeTo = l ) , True ) <EOL> self . assertEqual ( t . visible ( relativeTo = w ) , True ) <EOL> w . setVisible ( True ) <EOL> t . setVisible ( False ) <EOL> self . assertEqual ( t . getVisible ( ) , False ) <EOL> self . assertEqual ( t . visible ( ) , False ) <EOL> self . assertEqual ( t . visible ( relativeTo = l ) , False ) <EOL> def testGetVisibleForNewWidgets ( self ) : <EOL> w = TestWidget ( ) <EOL> self . assertEqual ( w . getVisible ( ) , True ) <EOL> def testVisibilityOfParentlessWidgets ( self ) : <EOL> w = GafferUI . Window ( ) <EOL> t = TestWidget ( ) <EOL> self . assertEqual ( w . getVisible ( ) , False ) <EOL> self . assertEqual ( w . visible ( ) , False ) <EOL> self . assertEqual ( t . getVisible ( ) , True ) <EOL> self . assertEqual ( t . visible ( ) , False ) <EOL> w . setVisible ( True ) <EOL> self . assertEqual ( w . getVisible ( ) , True ) <EOL> self . assertEqual ( w . visible ( ) , True ) <EOL> w . setChild ( t ) <EOL> self . assertEqual ( t . getVisible ( ) , True ) <EOL> self . assertEqual ( t . visible ( ) , True ) <EOL> w . removeChild ( t ) <EOL> self . assertEqual ( t . parent ( ) , None ) <EOL> self . assertEqual ( t . getVisible ( ) , True ) <EOL> self . assertEqual ( t . visible ( ) , False ) <EOL> def testVisibilityWhenTransferringWidgets ( self ) : <EOL> w1 = GafferUI . Window ( ) <EOL> w1 . setVisible ( True ) <EOL> w2 = GafferUI . Window ( ) <EOL> w2 . setVisible ( True ) <EOL> v = TestWidget ( ) <EOL> self . assertEqual ( v . getVisible ( ) , True ) <EOL> self . assertEqual ( v . visible ( ) , False ) <EOL> h = TestWidget ( ) <EOL> self . assertEqual ( h . getVisible ( ) , True ) <EOL> h . setVisible ( False ) <EOL> self . assertEqual ( h . getVisible ( ) , False ) <EOL> self . assertEqual ( h . visible ( ) , False ) <EOL> w1 . setChild ( v ) <EOL> self . assertEqual ( v . getVisible ( ) , True ) <EOL> self . assertEqual ( v . visible ( ) , True ) <EOL> self . assertEqual ( h . getVisible ( ) , False ) <EOL> self . assertEqual ( h . visible ( ) , False ) <EOL> w2 . setChild ( v ) <EOL> self . assertEqual ( v . getVisible ( ) , True ) <EOL> self . assertEqual ( v . visible ( ) , True ) <EOL> self . assertEqual ( h . getVisible ( ) , False ) <EOL> self . assertEqual ( h . visible ( ) , False ) <EOL> w1 . setChild ( h ) <EOL> self . assertEqual ( v . getVisible ( ) , True ) <EOL> self . assertEqual ( v . visible ( ) , True ) <EOL> self . assertEqual ( h . getVisible ( ) , False ) <EOL> self . assertEqual ( h . visible ( ) , False ) <EOL> w2 . setChild ( h ) <EOL> self . assertEqual ( v . getVisible ( ) , True ) <EOL> self . assertEqual ( v . visible ( ) , False ) <EOL> self . assertEqual ( h . getVisible ( ) , False ) <EOL> self . assertEqual ( h . visible ( ) , False ) <EOL> def testSignals ( self ) : <EOL> w = TestWidget ( ) <EOL> for s in [ <EOL> ( "<STR_LIT>" , GafferUI . WidgetEventSignal ) , <EOL> ( "<STR_LIT>" , GafferUI . WidgetEventSignal ) , <EOL> ( "<STR_LIT>" , GafferUI . WidgetEventSignal ) , <EOL> ( "<STR_LIT>" , GafferUI . WidgetEventSignal ) , <EOL> ( "<STR_LIT>" , GafferUI . WidgetEventSignal ) , <EOL> ( "<STR_LIT>" , GafferUI . WidgetEventSignal ) , <EOL> ( "<STR_LIT>" , GafferUI . WidgetSignal ) , <EOL> ( "<STR_LIT>" , GafferUI . WidgetSignal ) , <EOL> ( "<STR_LIT>" , GafferUI . WidgetEventSignal ) , <EOL> ( "<STR_LIT>" , GafferUI . WidgetSignal ) , <EOL> ( "<STR_LIT>" , GafferUI . WidgetSignal ) , <EOL> ( "<STR_LIT>" , GafferUI . WidgetSignal ) , <EOL> ] : <EOL> self . failUnless ( isinstance ( getattr ( w , s [ <NUM_LIT:0> ] ) ( ) , s [ <NUM_LIT:1> ] ) ) <EOL> self . failUnless ( getattr ( w , s [ <NUM_LIT:0> ] ) ( ) is getattr ( w , s [ <NUM_LIT:0> ] ) ( ) ) <EOL> def testBound ( self ) : <EOL> w = GafferUI . Window ( borderWidth = <NUM_LIT:8> ) <EOL> b = GafferUI . Button ( ) <EOL> w . setChild ( b ) <EOL> w . setVisible ( True ) <EOL> w . setPosition ( IECore . V2i ( <NUM_LIT:100> ) ) <EOL> self . waitForIdle ( <NUM_LIT:1000> ) <EOL> wb = w . bound ( ) <EOL> bb = b . bound ( ) <EOL> bbw = b . bound ( relativeTo = w ) <EOL> self . failUnless ( isinstance ( wb , IECore . Box2i ) ) <EOL> self . failUnless ( isinstance ( bb , IECore . Box2i ) ) <EOL> self . failUnless ( isinstance ( bbw , IECore . Box2i ) ) <EOL> self . assertEqual ( bb . size ( ) , bbw . size ( ) ) <EOL> self . assertEqual ( bbw . min , bb . min - wb . min ) <EOL> self . assertEqual ( b . size ( ) , bb . size ( ) ) <EOL> def testParentChangedSignal ( self ) : <EOL> w = TestWidget ( ) <EOL> window = GafferUI . Window ( ) <EOL> cs = GafferTest . CapturingSlot ( w . parentChangedSignal ( ) ) <EOL> self . assertEqual ( len ( cs ) , <NUM_LIT:0> ) <EOL> window . setChild ( w ) <EOL> self . assertEqual ( len ( cs ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( cs [ <NUM_LIT:0> ] , ( w , ) ) <EOL> window . setChild ( None ) <EOL> self . assertEqual ( len ( cs ) , <NUM_LIT:2> ) <EOL> self . assertEqual ( cs [ <NUM_LIT:1> ] , ( w , ) ) <EOL> def testHighlighting ( self ) : <EOL> w = TestWidget ( ) <EOL> self . assertEqual ( w . getHighlighted ( ) , False ) <EOL> w . setHighlighted ( True ) <EOL> self . assertEqual ( w . getHighlighted ( ) , True ) <EOL> w . setHighlighted ( False ) <EOL> self . assertEqual ( w . getHighlighted ( ) , False ) <EOL> def testWidgetAt ( self ) : <EOL> with GafferUI . Window ( ) as w1 : <EOL> t1 = GafferUI . TextWidget ( "<STR_LIT:hello>" ) <EOL> with GafferUI . Window ( ) as w2 : <EOL> t2 = GafferUI . TextWidget ( "<STR_LIT:hello>" ) <EOL> w1 . setVisible ( True ) <EOL> w2 . setVisible ( True ) <EOL> w1 . setPosition ( IECore . V2i ( <NUM_LIT:100> ) ) <EOL> w2 . setPosition ( IECore . V2i ( <NUM_LIT> ) ) <EOL> self . waitForIdle ( <NUM_LIT:1000> ) <EOL> self . assertTrue ( GafferUI . Widget . widgetAt ( w1 . bound ( ) . center ( ) ) is t1 ) <EOL> self . assertTrue ( GafferUI . Widget . widgetAt ( w2 . bound ( ) . center ( ) ) is t2 ) <EOL> self . assertTrue ( GafferUI . Widget . widgetAt ( w1 . bound ( ) . center ( ) , widgetType = GafferUI . Window ) is w1 ) <EOL> self . assertTrue ( GafferUI . Widget . widgetAt ( w2 . bound ( ) . center ( ) , widgetType = GafferUI . Window ) is w2 ) <EOL> def testMousePosition ( self ) : <EOL> w = GafferUI . Window ( borderWidth = <NUM_LIT:8> ) <EOL> b = GafferUI . Button ( ) <EOL> w . setChild ( b ) <EOL> w . setVisible ( True ) <EOL> w . setPosition ( IECore . V2i ( <NUM_LIT:100> ) ) <EOL> self . waitForIdle ( <NUM_LIT:1000> ) <EOL> mouseGlobal = GafferUI . Widget . mousePosition ( ) <EOL> mouseLocal = GafferUI . Widget . mousePosition ( relativeTo = b ) <EOL> self . assertEqual ( mouseGlobal , mouseLocal + b . bound ( ) . min ) <EOL> def testAddressAndObject ( self ) : <EOL> button = GafferUI . Button ( ) <EOL> address = GafferUI . _qtAddress ( button . _qtWidget ( ) ) <EOL> self . assertTrue ( isinstance ( address , int ) ) <EOL> widget = GafferUI . _qtObject ( address , QtGui . QPushButton ) <EOL> self . assertTrue ( isinstance ( widget , QtGui . QPushButton ) ) <EOL> def testSetVisibleWithNonBool ( self ) : <EOL> w = TestWidget ( ) <EOL> self . assertTrue ( w . getVisible ( ) is True ) <EOL> w . setVisible ( <NUM_LIT:0> ) <EOL> self . assertTrue ( w . getVisible ( ) is False ) <EOL> w . setVisible ( <NUM_LIT:1> ) <EOL> self . assertTrue ( w . getVisible ( ) is True ) <EOL> if __name__ == "<STR_LIT:__main__>" : <EOL> unittest . main ( ) </s>
<s> import GafferUI <EOL> import GafferSceneUI <EOL> def __toolMenu ( nodeEditor , node , menuDefinition ) : <EOL> GafferUI . UIEditor . appendNodeEditorToolMenuDefinitions ( nodeEditor , node , menuDefinition ) <EOL> GafferUI . BoxUI . appendNodeEditorToolMenuDefinitions ( nodeEditor , node , menuDefinition ) <EOL> GafferSceneUI . FilteredSceneProcessorUI . appendNodeEditorToolMenuDefinitions ( nodeEditor , node , menuDefinition ) <EOL> __nodeEditorToolMenuConnection = GafferUI . NodeEditor . toolMenuSignal ( ) . connect ( __toolMenu ) </s>
<s> VERSION = ( <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:0> , '<STR_LIT>' , <NUM_LIT:1> ) <EOL> __version__ = '<STR_LIT:.>' . join ( map ( str , VERSION ) ) <EOL> def get_version ( ) : <EOL> version = '<STR_LIT>' % ( VERSION [ <NUM_LIT:0> ] , VERSION [ <NUM_LIT:1> ] ) <EOL> if VERSION [ <NUM_LIT:2> ] : <EOL> version = '<STR_LIT>' % ( version , VERSION [ <NUM_LIT:2> ] ) <EOL> if VERSION [ <NUM_LIT:3> : ] == ( '<STR_LIT>' , <NUM_LIT:0> ) : <EOL> version = '<STR_LIT>' % version <EOL> else : <EOL> if VERSION [ <NUM_LIT:3> ] != '<STR_LIT>' : <EOL> version = '<STR_LIT>' % ( version , VERSION [ <NUM_LIT:3> ] , VERSION [ <NUM_LIT:4> ] ) <EOL> return version </s>
<s> import yappi <EOL> import os <EOL> from totalimpact import backend <EOL> rootdir = "<STR_LIT:.>" <EOL> logfile = '<STR_LIT>' <EOL> yappi . clear_stats ( ) <EOL> yappi . start ( ) <EOL> backend . main ( logfile ) <EOL> yappi . stop ( ) <EOL> yappi . print_stats ( sort_type = yappi . SORTTYPE_TTOT , limit = <NUM_LIT:30> , thread_stats_on = False ) </s>
<s> import os , collections , simplejson <EOL> from totalimpact import db , app <EOL> from totalimpact . providers import pmc <EOL> from test . unit_tests . providers import common <EOL> from test . unit_tests . providers . common import ProviderTestCase <EOL> from totalimpact . providers . provider import Provider , ProviderContentMalformedError , ProviderFactory <EOL> from totalimpact import provider_batch_data <EOL> from test . utils import http <EOL> from test . utils import setup_postgres_for_unittests , teardown_postgres_for_unittests <EOL> from nose . tools import assert_equals , raises , nottest , assert_items_equal <EOL> datadir = os . path . join ( os . path . split ( __file__ ) [ <NUM_LIT:0> ] , "<STR_LIT>" ) <EOL> SAMPLE_EXTRACT_METRICS_PAGE = os . path . join ( datadir , "<STR_LIT>" ) <EOL> SAMPLE_EXTRACT_METRICS_PAGE_DIFFERENT_MONTH = os . path . join ( datadir , "<STR_LIT>" ) <EOL> TEST_PMID = "<STR_LIT>" <EOL> class TestPmc ( ProviderTestCase ) : <EOL> provider_name = "<STR_LIT>" <EOL> testitem_aliases = ( "<STR_LIT>" , TEST_PMID ) <EOL> testitem_metrics = ( "<STR_LIT>" , TEST_PMID ) <EOL> def setUp ( self ) : <EOL> ProviderTestCase . setUp ( self ) <EOL> self . db = setup_postgres_for_unittests ( db , app ) <EOL> sample_data_dump = open ( SAMPLE_EXTRACT_METRICS_PAGE , "<STR_LIT:r>" ) . read ( ) <EOL> sample_data_dump_different_month = open ( SAMPLE_EXTRACT_METRICS_PAGE_DIFFERENT_MONTH , "<STR_LIT:r>" ) . read ( ) <EOL> test_monthly_data = [ <EOL> { "<STR_LIT>" : "<STR_LIT:abc>" , <EOL> "<STR_LIT:type>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : sample_data_dump , <EOL> "<STR_LIT>" : <NUM_LIT:1.0> , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : { "<STR_LIT>" : [ "<STR_LIT>" , "<STR_LIT>" ] } , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" <EOL> } , <EOL> { "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT:type>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : sample_data_dump_different_month , <EOL> "<STR_LIT>" : <NUM_LIT:1.0> , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : { "<STR_LIT>" : [ "<STR_LIT>" ] } , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" <EOL> } , <EOL> { <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : { <EOL> "<STR_LIT>" : [ <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" <EOL> ] <EOL> } , <EOL> "<STR_LIT>" : <NUM_LIT:1> , <EOL> "<STR_LIT:type>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" <EOL> } <EOL> ] <EOL> for doc in test_monthly_data : <EOL> new_object = provider_batch_data . create_objects_from_doc ( doc ) <EOL> print new_object <EOL> self . provider = pmc . Pmc ( ) <EOL> print "<STR_LIT>" <EOL> def tearDown ( self ) : <EOL> teardown_postgres_for_unittests ( self . db ) <EOL> def test_has_applicable_batch_data_true ( self ) : <EOL> response = self . provider . has_applicable_batch_data ( "<STR_LIT>" , "<STR_LIT>" ) <EOL> assert_equals ( response , True ) <EOL> def test_has_applicable_batch_data_false ( self ) : <EOL> response = self . provider . has_applicable_batch_data ( "<STR_LIT>" , "<STR_LIT>" ) <EOL> assert_equals ( response , False ) <EOL> def test_build_batch_data_dict ( self ) : <EOL> response = self . provider . build_batch_data_dict ( ) <EOL> print response . keys ( ) <EOL> expected = [ ( '<STR_LIT>' , '<STR_LIT>' ) , ( '<STR_LIT>' , '<STR_LIT>' ) , ( '<STR_LIT>' , '<STR_LIT>' ) , ( '<STR_LIT>' , '<STR_LIT>' ) , ( '<STR_LIT>' , '<STR_LIT>' ) , ( '<STR_LIT>' , '<STR_LIT>' ) , ( '<STR_LIT>' , '<STR_LIT>' ) , ( '<STR_LIT>' , '<STR_LIT>' ) , ( '<STR_LIT>' , '<STR_LIT>' ) , ( '<STR_LIT>' , '<STR_LIT>' ) , ( '<STR_LIT>' , '<STR_LIT>' ) , ( '<STR_LIT>' , '<STR_LIT>' ) , ( '<STR_LIT>' , '<STR_LIT>' ) , ( '<STR_LIT>' , '<STR_LIT>' ) , ( '<STR_LIT>' , '<STR_LIT>' ) ] <EOL> assert_items_equal ( response . keys ( ) , expected ) <EOL> def test_is_relevant_alias ( self ) : <EOL> assert_equals ( self . provider . is_relevant_alias ( self . testitem_aliases ) , True ) <EOL> def test_extract_metrics_success ( self ) : <EOL> f = open ( SAMPLE_EXTRACT_METRICS_PAGE , "<STR_LIT:r>" ) <EOL> good_page = f . read ( ) <EOL> metrics_dict = self . provider . _extract_metrics ( good_page , id = "<STR_LIT>" ) <EOL> print metrics_dict <EOL> expected = { '<STR_LIT>' : <NUM_LIT> , '<STR_LIT>' : <NUM_LIT> , '<STR_LIT>' : <NUM_LIT> , '<STR_LIT>' : <NUM_LIT:9> } <EOL> assert_equals ( metrics_dict , expected ) <EOL> def test_provider_metrics_500 ( self ) : <EOL> pass <EOL> def test_provider_metrics_400 ( self ) : <EOL> pass <EOL> def test_provider_metrics_nonsense_xml ( self ) : <EOL> pass <EOL> def test_provider_metrics_nonsense_txt ( self ) : <EOL> pass <EOL> def test_provider_metrics_empty ( self ) : <EOL> pass <EOL> @ http <EOL> def test_metrics ( self ) : <EOL> metrics_dict = self . provider . metrics ( [ ( "<STR_LIT>" , "<STR_LIT>" ) ] ) <EOL> expected = { '<STR_LIT>' : ( <NUM_LIT> , '<STR_LIT>' ) , '<STR_LIT>' : ( <NUM_LIT> , '<STR_LIT>' ) , '<STR_LIT>' : ( <NUM_LIT> , '<STR_LIT>' ) , '<STR_LIT>' : ( <NUM_LIT:9> , '<STR_LIT>' ) } <EOL> print metrics_dict <EOL> for key in expected : <EOL> assert metrics_dict [ key ] [ <NUM_LIT:0> ] >= expected [ key ] [ <NUM_LIT:0> ] , [ key , metrics_dict [ key ] , expected [ key ] ] <EOL> assert metrics_dict [ key ] [ <NUM_LIT:1> ] == expected [ key ] [ <NUM_LIT:1> ] , [ key , metrics_dict [ key ] , expected [ key ] ] <EOL> @ http <EOL> def test_metrics_multiple_months ( self ) : <EOL> metrics_dict = self . provider . metrics ( [ ( "<STR_LIT>" , "<STR_LIT>" ) ] ) <EOL> expected = { '<STR_LIT>' : ( <NUM_LIT> , '<STR_LIT>' ) , '<STR_LIT>' : ( <NUM_LIT> , '<STR_LIT>' ) , '<STR_LIT>' : ( <NUM_LIT> , '<STR_LIT>' ) , '<STR_LIT>' : ( <NUM_LIT> , '<STR_LIT>' ) , '<STR_LIT>' : ( <NUM_LIT> , '<STR_LIT>' ) } <EOL> print metrics_dict <EOL> for key in expected : <EOL> assert metrics_dict [ key ] [ <NUM_LIT:0> ] >= expected [ key ] [ <NUM_LIT:0> ] , [ key , metrics_dict [ key ] , expected [ key ] ] <EOL> assert metrics_dict [ key ] [ <NUM_LIT:1> ] == expected [ key ] [ <NUM_LIT:1> ] , [ key , metrics_dict [ key ] , expected [ key ] ] <EOL> @ http <EOL> def test_metrics_real ( self ) : <EOL> metrics_dict = self . provider . metrics ( [ ( "<STR_LIT>" , "<STR_LIT>" ) ] ) <EOL> expected = { '<STR_LIT>' : ( <NUM_LIT> , '<STR_LIT>' ) , '<STR_LIT>' : ( <NUM_LIT> , '<STR_LIT>' ) , '<STR_LIT>' : ( <NUM_LIT> , '<STR_LIT>' ) , '<STR_LIT>' : ( <NUM_LIT> , '<STR_LIT>' ) , '<STR_LIT>' : ( <NUM_LIT> , '<STR_LIT>' ) } <EOL> print metrics_dict <EOL> for key in expected : <EOL> assert metrics_dict [ key ] [ <NUM_LIT:0> ] >= expected [ key ] [ <NUM_LIT:0> ] , [ key , metrics_dict [ key ] , expected [ key ] ] <EOL> assert metrics_dict [ key ] [ <NUM_LIT:1> ] == expected [ key ] [ <NUM_LIT:1> ] , [ key , metrics_dict [ key ] , expected [ key ] ] </s>
<s> import os <EOL> import sys <EOL> import hashlib <EOL> import logging <EOL> import json <EOL> from cPickle import PicklingError <EOL> import redis <EOL> from totalimpact import REDIS_CACHE_DATABASE_NUMBER <EOL> logger = logging . getLogger ( "<STR_LIT>" ) <EOL> cache_client = redis . from_url ( os . getenv ( "<STR_LIT>" ) , REDIS_CACHE_DATABASE_NUMBER ) <EOL> MAX_PAYLOAD_SIZE_BYTES = <NUM_LIT:1000> * <NUM_LIT:1000> <EOL> MAX_CACHE_SIZE_BYTES = <NUM_LIT:100> * <NUM_LIT:1000> * <NUM_LIT:1000> <EOL> class CacheException ( Exception ) : <EOL> pass <EOL> class Cache ( object ) : <EOL> """<STR_LIT>""" <EOL> def _build_hash_key ( self , key ) : <EOL> json_key = json . dumps ( key ) <EOL> hash_key = hashlib . md5 ( json_key . encode ( "<STR_LIT:utf-8>" ) ) . hexdigest ( ) <EOL> return hash_key <EOL> def _get_client ( self ) : <EOL> return cache_client <EOL> def __init__ ( self , max_cache_age = <NUM_LIT> * <NUM_LIT> ) : <EOL> self . max_cache_age = max_cache_age <EOL> self . flush_cache ( ) <EOL> def flush_cache ( self ) : <EOL> mc = self . _get_client ( ) <EOL> def get_cache_entry ( self , key ) : <EOL> """<STR_LIT>""" <EOL> mc = self . _get_client ( ) <EOL> hash_key = self . _build_hash_key ( key ) <EOL> response = mc . get ( hash_key ) <EOL> if response : <EOL> response = json . loads ( response ) <EOL> return response <EOL> def set_cache_entry ( self , key , data ) : <EOL> """<STR_LIT>""" <EOL> if sys . getsizeof ( data [ "<STR_LIT:text>" ] ) > MAX_PAYLOAD_SIZE_BYTES : <EOL> logger . debug ( u"<STR_LIT>" ) <EOL> return None <EOL> mc = self . _get_client ( ) <EOL> if mc . info ( ) [ "<STR_LIT>" ] >= MAX_CACHE_SIZE_BYTES : <EOL> logger . debug ( u"<STR_LIT>" ) <EOL> return None <EOL> hash_key = self . _build_hash_key ( key ) <EOL> set_response = mc . set ( hash_key , json . dumps ( data ) ) <EOL> mc . expire ( hash_key , self . max_cache_age ) <EOL> if not set_response : <EOL> logger . warning ( "<STR_LIT>" ) <EOL> raise CacheException ( "<STR_LIT>" ) <EOL> return set_response </s>
<s> from totalimpact . providers import provider <EOL> from totalimpact . providers . provider import Provider , ProviderContentMalformedError <EOL> import simplejson , os , re , urllib <EOL> import logging <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> class Plosalm ( Provider ) : <EOL> example_id = ( "<STR_LIT>" , "<STR_LIT>" ) <EOL> url = "<STR_LIT>" <EOL> descr = "<STR_LIT>" <EOL> metrics_url_template = "<STR_LIT>" + os . environ [ "<STR_LIT>" ] <EOL> provenance_url_template = "<STR_LIT>" <EOL> PLOS_ICON = "<STR_LIT>" <EOL> static_meta_dict = { <EOL> "<STR_LIT>" : { <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT:description>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : PLOS_ICON , <EOL> } , <EOL> "<STR_LIT>" : { <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT:description>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : PLOS_ICON , <EOL> } <EOL> } <EOL> def __init__ ( self ) : <EOL> super ( Plosalm , self ) . __init__ ( ) <EOL> def is_relevant_alias ( self , alias ) : <EOL> ( namespace , nid ) = alias <EOL> relevant = ( ( "<STR_LIT>" == namespace ) and ( "<STR_LIT>" in nid ) ) <EOL> return ( relevant ) <EOL> def _extract_metrics ( self , page , status_code = <NUM_LIT:200> , id = None ) : <EOL> if status_code != <NUM_LIT:200> : <EOL> if status_code == <NUM_LIT> : <EOL> return { } <EOL> else : <EOL> raise ( self . _get_error ( status_code ) ) <EOL> if not "<STR_LIT>" in page : <EOL> raise ProviderContentMalformedError <EOL> json_response = provider . _load_json ( page ) <EOL> this_article = json_response [ <NUM_LIT:0> ] [ "<STR_LIT>" ] [ <NUM_LIT:0> ] [ "<STR_LIT>" ] <EOL> dict_of_keylists = { <EOL> '<STR_LIT>' : [ '<STR_LIT:html>' ] , <EOL> '<STR_LIT>' : [ '<STR_LIT>' ] <EOL> } <EOL> metrics_dict = provider . _extract_from_data_dict ( this_article , dict_of_keylists ) <EOL> return metrics_dict </s>
<s> import os <EOL> import sys <EOL> import urlparse <EOL> from kombu import Exchange , Queue <EOL> sys . path . append ( '<STR_LIT:.>' ) <EOL> redis_url = os . environ . get ( '<STR_LIT>' , "<STR_LIT>" ) <EOL> if not redis_url . endswith ( "<STR_LIT:/>" ) : <EOL> redis_url += "<STR_LIT:/>" <EOL> BROKER_URL = redis_url + "<STR_LIT:1>" <EOL> CELERY_RESULT_BACKEND = redis_url + "<STR_LIT:2>" <EOL> REDIS_CONNECT_RETRY = True <EOL> BROKER_TRANSPORT_OPTIONS = { '<STR_LIT>' : True , <EOL> '<STR_LIT>' : True , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : <NUM_LIT:100> <EOL> } <EOL> CELERY_DEFAULT_QUEUE = '<STR_LIT>' <EOL> CELERY_QUEUES = [ <EOL> Queue ( '<STR_LIT>' , routing_key = '<STR_LIT>' ) , <EOL> Queue ( '<STR_LIT>' , routing_key = '<STR_LIT>' ) <EOL> ] <EOL> BROKER_POOL_LIMIT = None <EOL> CELERY_CREATE_MISSING_QUEUES = True <EOL> CELERY_ACCEPT_CONTENT = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> CELERY_ENABLE_UTC = True <EOL> CELERY_TASK_RESULT_EXPIRES = <NUM_LIT> * <NUM_LIT> * <NUM_LIT:1> <EOL> CELERY_ACKS_LATE = True <EOL> CELERYD_FORCE_EXECV = True <EOL> CELERY_TRACK_STARTED = True <EOL> CELERYD_PREFETCH_MULTIPLIER = <NUM_LIT:1> <EOL> CELERY_IMPORTS = ( "<STR_LIT>" , ) <EOL> CELERY_ANNOTATIONS = { <EOL> '<STR_LIT>' : { '<STR_LIT>' : <NUM_LIT> * <NUM_LIT:2> } <EOL> } </s>
<s> from totalimpact . providers import provider <EOL> from totalimpact . providers . provider import Provider , ProviderFactory <EOL> from totalimpactwebapp import app , db <EOL> from nose . tools import assert_equals , nottest <EOL> from xml . dom import minidom <EOL> from test . utils import setup_postgres_for_unittests , teardown_postgres_for_unittests <EOL> import simplejson , BeautifulSoup <EOL> import os <EOL> from sqlalchemy . sql import text <EOL> sampledir = os . path . join ( os . path . split ( __file__ ) [ <NUM_LIT:0> ] , "<STR_LIT>" ) <EOL> class Test_Provider ( ) : <EOL> TEST_PROVIDER_CONFIG = [ <EOL> ( "<STR_LIT>" , { "<STR_LIT>" : <NUM_LIT:1> } ) , <EOL> ( "<STR_LIT>" , { "<STR_LIT>" : <NUM_LIT:3> } ) , <EOL> ( "<STR_LIT>" , { "<STR_LIT>" : <NUM_LIT:3> } ) , <EOL> ] <EOL> TEST_JSON = """<STR_LIT>""" <EOL> TEST_XML = open ( os . path . join ( sampledir , "<STR_LIT>" , "<STR_LIT>" ) ) . read ( ) <EOL> def setUp ( self ) : <EOL> self . db = setup_postgres_for_unittests ( db , app ) <EOL> def tearDown ( self ) : <EOL> teardown_postgres_for_unittests ( self . db ) <EOL> def test_get_provider ( self ) : <EOL> provider = ProviderFactory . get_provider ( "<STR_LIT>" ) <EOL> assert_equals ( provider . __class__ . __name__ , "<STR_LIT>" ) <EOL> def test_get_providers ( self ) : <EOL> providers = ProviderFactory . get_providers ( self . TEST_PROVIDER_CONFIG ) <EOL> provider_names = [ provider . __class__ . __name__ for provider in providers ] <EOL> assert_equals ( set ( provider_names ) , set ( [ '<STR_LIT>' , '<STR_LIT>' , "<STR_LIT>" ] ) ) <EOL> def test_get_providers_filters_by_metrics ( self ) : <EOL> providers = ProviderFactory . get_providers ( self . TEST_PROVIDER_CONFIG , "<STR_LIT>" ) <EOL> provider_names = [ provider . __class__ . __name__ for provider in providers ] <EOL> assert_equals ( set ( provider_names ) , set ( [ '<STR_LIT>' , '<STR_LIT>' , "<STR_LIT>" ] ) ) <EOL> def test_get_providers_filters_by_biblio ( self ) : <EOL> providers = ProviderFactory . get_providers ( self . TEST_PROVIDER_CONFIG , "<STR_LIT>" ) <EOL> provider_names = [ provider . __class__ . __name__ for provider in providers ] <EOL> assert_equals ( set ( provider_names ) , set ( [ '<STR_LIT>' , '<STR_LIT>' ] ) ) <EOL> def test_get_providers_filters_by_aliases ( self ) : <EOL> providers = ProviderFactory . get_providers ( self . TEST_PROVIDER_CONFIG , "<STR_LIT>" ) <EOL> provider_names = [ provider . __class__ . __name__ for provider in providers ] <EOL> assert_equals ( set ( provider_names ) , set ( [ '<STR_LIT>' , '<STR_LIT>' ] ) ) <EOL> def test_lookup_json ( self ) : <EOL> page = self . TEST_JSON <EOL> data = simplejson . loads ( page ) <EOL> response = provider . _lookup_json ( data , [ '<STR_LIT>' , '<STR_LIT:name>' ] ) <EOL> assert_equals ( response , u'<STR_LIT>' ) <EOL> def test_extract_json ( self ) : <EOL> page = self . TEST_JSON <EOL> dict_of_keylists = { <EOL> '<STR_LIT:title>' : [ '<STR_LIT>' , '<STR_LIT:name>' ] , <EOL> '<STR_LIT:description>' : [ '<STR_LIT>' , '<STR_LIT:description>' ] } <EOL> response = provider . _extract_from_json ( page , dict_of_keylists ) <EOL> assert_equals ( response , { '<STR_LIT:description>' : u'<STR_LIT>' , '<STR_LIT:title>' : u'<STR_LIT>' } ) <EOL> def test_lookup_xml_from_dom ( self ) : <EOL> page = self . TEST_XML <EOL> doc = minidom . parseString ( page . strip ( ) ) <EOL> response = provider . _lookup_xml_from_dom ( doc , [ '<STR_LIT>' ] ) <EOL> assert_equals ( response , <NUM_LIT> ) <EOL> def test_lookup_xml_from_soup ( self ) : <EOL> page = self . TEST_XML <EOL> doc = BeautifulSoup . BeautifulStoneSoup ( page ) <EOL> response = provider . _lookup_xml_from_soup ( doc , [ '<STR_LIT>' ] ) <EOL> assert_equals ( response , <NUM_LIT> ) <EOL> def test_extract_xml ( self ) : <EOL> page = self . TEST_XML <EOL> dict_of_keylists = { <EOL> '<STR_LIT:count>' : [ '<STR_LIT>' ] } <EOL> response = provider . _extract_from_xml ( page , dict_of_keylists ) <EOL> assert_equals ( response , { '<STR_LIT:count>' : <NUM_LIT> } ) <EOL> def test_doi_from_url_string ( self ) : <EOL> test_url = "<STR_LIT>" <EOL> expected = "<STR_LIT>" <EOL> response = provider . doi_from_url_string ( test_url ) <EOL> assert_equals ( response , expected ) <EOL> def test_is_issn_in_doaj_false ( self ) : <EOL> response = provider . is_issn_in_doaj ( "<STR_LIT>" ) <EOL> assert_equals ( response , False ) <EOL> def test_is_issn_in_doaj_true ( self ) : <EOL> zookeys_issn = "<STR_LIT>" <EOL> response = provider . is_issn_in_doaj ( zookeys_issn ) <EOL> assert_equals ( response , True ) <EOL> def test_import_products ( self ) : <EOL> response = provider . import_products ( "<STR_LIT>" , <EOL> { "<STR_LIT>" : [ "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ] } ) <EOL> expected = [ ( '<STR_LIT>' , '<STR_LIT>' ) , ( '<STR_LIT:url>' , '<STR_LIT>' ) , ( '<STR_LIT>' , '<STR_LIT>' ) , ( '<STR_LIT>' , '<STR_LIT>' ) ] <EOL> assert_equals ( response , expected ) <EOL> def test_import_products_bad_providername ( self ) : <EOL> response = provider . import_products ( "<STR_LIT>" , { } ) <EOL> expected = [ ] <EOL> assert_equals ( response , expected ) <EOL> class TestProviderFactory ( ) : <EOL> TEST_PROVIDER_CONFIG = [ <EOL> ( "<STR_LIT>" , { "<STR_LIT>" : <NUM_LIT:1> } ) , <EOL> ( "<STR_LIT>" , { "<STR_LIT>" : <NUM_LIT:3> } ) , <EOL> ( "<STR_LIT>" , { "<STR_LIT>" : <NUM_LIT:3> } ) , <EOL> ] <EOL> def test_get_all_static_meta ( self ) : <EOL> sm = ProviderFactory . get_all_static_meta ( self . TEST_PROVIDER_CONFIG ) <EOL> expected = '<STR_LIT>' <EOL> assert_equals ( sm [ "<STR_LIT>" ] [ "<STR_LIT:description>" ] , expected ) <EOL> def test_get_all_metric_names ( self ) : <EOL> response = ProviderFactory . get_all_metric_names ( self . TEST_PROVIDER_CONFIG ) <EOL> expected = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> assert_equals ( response , expected ) <EOL> def test_get_all_metadata ( self ) : <EOL> md = ProviderFactory . get_all_metadata ( self . TEST_PROVIDER_CONFIG ) <EOL> print md [ "<STR_LIT>" ] <EOL> assert_equals ( md [ "<STR_LIT>" ] [ '<STR_LIT:url>' ] , '<STR_LIT>' ) </s>
<s> import datetime <EOL> import copy <EOL> import unicode_helpers <EOL> import json <EOL> import logging <EOL> from util import cached_property <EOL> from util import dict_from_dir <EOL> from totalimpactwebapp import db <EOL> logger = logging . getLogger ( "<STR_LIT>" ) <EOL> def clean_id ( nid ) : <EOL> try : <EOL> nid = nid . strip ( '<STR_LIT>' ) . strip ( ) <EOL> nid = unicode_helpers . remove_nonprinting_characters ( nid ) <EOL> except ( TypeError , AttributeError ) : <EOL> pass <EOL> return ( nid ) <EOL> def normalize_alias_tuple ( ns , nid ) : <EOL> ns = clean_id ( ns ) <EOL> ns = ns . lower ( ) <EOL> if ns == "<STR_LIT>" : <EOL> return ( ns , nid ) <EOL> nid = clean_id ( nid ) <EOL> from totalimpact . providers import crossref <EOL> from totalimpact . providers import pubmed <EOL> from totalimpact . providers import arxiv <EOL> from totalimpact . providers import webpage <EOL> from totalimpact import importer <EOL> clean_nid = None <EOL> if ns == "<STR_LIT>" or importer . is_doi ( nid ) : <EOL> ns = "<STR_LIT>" <EOL> clean_nid = crossref . clean_doi ( nid ) <EOL> elif ns == "<STR_LIT>" or importer . is_pmid ( nid ) : <EOL> ns = "<STR_LIT>" <EOL> clean_nid = pubmed . clean_pmid ( nid ) <EOL> elif ns == "<STR_LIT>" or importer . is_arxiv ( nid ) : <EOL> ns = "<STR_LIT>" <EOL> clean_nid = arxiv . clean_arxiv_id ( nid ) <EOL> elif ns == "<STR_LIT:url>" or importer . is_url ( nid ) : <EOL> ns = "<STR_LIT:url>" <EOL> clean_nid = webpage . clean_url ( nid ) <EOL> elif ns not in [ "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT:url>" ] : <EOL> clean_nid = nid <EOL> if not clean_nid : <EOL> return None <EOL> return ( ns , clean_nid ) <EOL> def clean_alias_tuple_for_comparing ( ns , nid ) : <EOL> alias_tuple = normalize_alias_tuple ( ns , nid ) <EOL> if not alias_tuple : <EOL> return None <EOL> try : <EOL> ( ns , nid ) = alias_tuple <EOL> cleaned_alias = ( ns . lower ( ) , nid . lower ( ) ) <EOL> except AttributeError : <EOL> logger . debug ( u"<STR_LIT>" . format ( <EOL> ns = ns , nid = nid ) ) <EOL> cleaned_alias = ( ns , nid ) <EOL> return cleaned_alias <EOL> def alias_tuples_from_dict ( aliases_dict ) : <EOL> """<STR_LIT>""" <EOL> alias_tuples = [ ] <EOL> for ns , ids in aliases_dict . iteritems ( ) : <EOL> if isinstance ( ids , basestring ) : <EOL> alias_tuples . append ( ( ns , ids ) ) <EOL> else : <EOL> for id in ids : <EOL> alias_tuples . append ( ( ns , id ) ) <EOL> return alias_tuples <EOL> def alias_dict_from_tuples ( aliases_tuples ) : <EOL> alias_dict = { } <EOL> for ( ns , ids ) in aliases_tuples : <EOL> if ns in alias_dict : <EOL> alias_dict [ ns ] += [ ids ] <EOL> else : <EOL> alias_dict [ ns ] = [ ids ] <EOL> return alias_dict <EOL> def canonical_aliases ( orig_aliases_dict ) : <EOL> lowercase_aliases_dict = { } <EOL> for orig_namespace in orig_aliases_dict : <EOL> lowercase_namespace = clean_id ( orig_namespace . lower ( ) ) <EOL> if lowercase_namespace == "<STR_LIT>" : <EOL> lowercase_aliases_dict [ lowercase_namespace ] = [ clean_id ( doi . lower ( ) ) for doi in orig_aliases_dict [ orig_namespace ] ] <EOL> else : <EOL> lowercase_aliases_dict [ lowercase_namespace ] = [ clean_id ( nid ) for nid in orig_aliases_dict [ orig_namespace ] ] <EOL> return lowercase_aliases_dict <EOL> def merge_alias_dicts ( aliases1 , aliases2 ) : <EOL> merged_aliases = copy . deepcopy ( aliases1 ) <EOL> for ns , nid_list in aliases2 . iteritems ( ) : <EOL> for nid in nid_list : <EOL> try : <EOL> if not nid in merged_aliases [ ns ] : <EOL> merged_aliases [ ns ] . append ( nid ) <EOL> except KeyError : <EOL> merged_aliases [ ns ] = [ nid ] <EOL> return merged_aliases <EOL> def matches_alias ( product1 , product2 , exclude = [ ] ) : <EOL> alias_tuple_list1 = [ alias_row . my_alias_tuple_for_comparing for alias_row in product1 . alias_rows ] <EOL> alias_tuple_list2 = [ alias_row . my_alias_tuple_for_comparing for alias_row in product2 . alias_rows ] <EOL> has_matches = False <EOL> for alias_tuple1 in alias_tuple_list1 : <EOL> if alias_tuple1 : <EOL> ( ns , nid ) = alias_tuple1 <EOL> if alias_tuple1 in alias_tuple_list2 and ns not in exclude : <EOL> has_matches = True <EOL> return has_matches <EOL> class AliasRow ( db . Model ) : <EOL> __tablename__ = '<STR_LIT>' <EOL> tiid = db . Column ( db . Text , db . ForeignKey ( '<STR_LIT>' ) , primary_key = True ) <EOL> namespace = db . Column ( db . Text , primary_key = True ) <EOL> nid = db . Column ( db . Text , primary_key = True ) <EOL> collected_date = db . Column ( db . DateTime ( ) ) <EOL> def __init__ ( self , ** kwargs ) : <EOL> if "<STR_LIT>" not in kwargs : <EOL> self . collected_date = datetime . datetime . utcnow ( ) <EOL> super ( AliasRow , self ) . __init__ ( ** kwargs ) <EOL> @ cached_property <EOL> def alias_tuple ( self ) : <EOL> return ( self . namespace , self . nid ) <EOL> @ cached_property <EOL> def my_alias_tuple_for_comparing ( self ) : <EOL> return clean_alias_tuple_for_comparing ( self . namespace , self . nid ) <EOL> def is_equivalent_alias ( self , given_namespace , given_nid ) : <EOL> if not given_nid : <EOL> return False <EOL> given_clean_alias = clean_alias_tuple_for_comparing ( given_namespace , given_nid ) <EOL> if not given_clean_alias : <EOL> return False <EOL> return given_clean_alias == self . my_alias_tuple_for_comparing <EOL> class Aliases ( object ) : <EOL> def __init__ ( self , alias_rows ) : <EOL> ignore_namepaces = [ "<STR_LIT>" ] <EOL> self . tiid = None <EOL> for alias_row in alias_rows : <EOL> if alias_row . namespace not in ignore_namepaces : <EOL> self . tiid = alias_row . tiid <EOL> try : <EOL> getattr ( self , alias_row . namespace ) . append ( alias_row . nid ) <EOL> except AttributeError : <EOL> setattr ( self , alias_row . namespace , [ alias_row . nid ] ) <EOL> @ cached_property <EOL> def best_url ( self ) : <EOL> if self . display_doi : <EOL> return u"<STR_LIT>" + self . display_doi <EOL> if self . display_pmid : <EOL> return u"<STR_LIT>" + self . display_pmid <EOL> if self . display_pmc : <EOL> return u"<STR_LIT>" + self . display_pmc <EOL> if self . resolved_url : <EOL> return self . resolved_url <EOL> try : <EOL> return self . url [ <NUM_LIT:0> ] <EOL> except AttributeError : <EOL> return None <EOL> @ cached_property <EOL> def display_best_url ( self ) : <EOL> return self . best_url <EOL> @ cached_property <EOL> def display_pmid ( self ) : <EOL> try : <EOL> return self . pmid [ <NUM_LIT:0> ] <EOL> except AttributeError : <EOL> return None <EOL> @ cached_property <EOL> def display_pmc ( self ) : <EOL> try : <EOL> return self . pmc [ <NUM_LIT:0> ] <EOL> except AttributeError : <EOL> return None <EOL> @ cached_property <EOL> def display_doi ( self ) : <EOL> try : <EOL> return self . doi [ <NUM_LIT:0> ] <EOL> except AttributeError : <EOL> return None <EOL> @ cached_property <EOL> def display_arxiv ( self ) : <EOL> try : <EOL> return self . arxiv [ <NUM_LIT:0> ] <EOL> except AttributeError : <EOL> return None <EOL> @ cached_property <EOL> def has_formal_alias ( self ) : <EOL> if self . display_arxiv or self . display_doi or self . display_pmid or self . display_pmc : <EOL> return True <EOL> else : <EOL> return False <EOL> @ cached_property <EOL> def resolved_url ( self ) : <EOL> try : <EOL> for url in self . url : <EOL> if "<STR_LIT>" in url : <EOL> continue <EOL> elif "<STR_LIT>" in url : <EOL> continue <EOL> elif "<STR_LIT>" in url : <EOL> continue <EOL> elif "<STR_LIT>" in url : <EOL> continue <EOL> elif "<STR_LIT>" in url : <EOL> continue <EOL> else : <EOL> return url <EOL> return self . url [ <NUM_LIT:0> ] <EOL> except AttributeError : <EOL> return None <EOL> def get_genre ( self ) : <EOL> return self . _guess_genre_and_host_from_aliases ( ) [ <NUM_LIT:0> ] <EOL> def get_host ( self ) : <EOL> return self . _guess_genre_and_host_from_aliases ( ) [ <NUM_LIT:1> ] <EOL> def _guess_genre_and_host_from_aliases ( self ) : <EOL> """<STR_LIT>""" <EOL> genre = "<STR_LIT>" <EOL> host = "<STR_LIT>" <EOL> if hasattr ( self , "<STR_LIT>" ) : <EOL> joined_doi_string = "<STR_LIT>" . join ( self . doi ) . lower ( ) <EOL> if "<STR_LIT>" in joined_doi_string : <EOL> genre = "<STR_LIT>" <EOL> host = "<STR_LIT>" <EOL> elif "<STR_LIT>" in joined_doi_string : <EOL> host = "<STR_LIT>" <EOL> genre = "<STR_LIT>" <EOL> else : <EOL> genre = "<STR_LIT>" <EOL> elif hasattr ( self , "<STR_LIT>" ) : <EOL> genre = "<STR_LIT>" <EOL> elif hasattr ( self , "<STR_LIT>" ) : <EOL> genre = "<STR_LIT>" <EOL> host = "<STR_LIT>" <EOL> elif hasattr ( self , "<STR_LIT>" ) : <EOL> genre = "<STR_LIT>" <EOL> host = "<STR_LIT>" <EOL> elif hasattr ( self , "<STR_LIT>" ) : <EOL> genre = "<STR_LIT>" <EOL> host = "<STR_LIT>" <EOL> elif hasattr ( self , "<STR_LIT:url>" ) : <EOL> joined_url_string = "<STR_LIT>" . join ( self . url ) . lower ( ) <EOL> if "<STR_LIT>" in joined_url_string : <EOL> genre = "<STR_LIT>" <EOL> host = "<STR_LIT>" <EOL> elif "<STR_LIT>" in joined_url_string : <EOL> genre = "<STR_LIT>" <EOL> host = "<STR_LIT>" <EOL> elif ( "<STR_LIT>" in joined_url_string ) or ( "<STR_LIT>" in joined_url_string ) : <EOL> genre = "<STR_LIT>" <EOL> host = "<STR_LIT>" <EOL> elif "<STR_LIT>" in joined_url_string : <EOL> genre = "<STR_LIT>" <EOL> host = "<STR_LIT>" <EOL> else : <EOL> genre = "<STR_LIT>" <EOL> return genre , host <EOL> def to_dict ( self ) : <EOL> ret = dict_from_dir ( self ) <EOL> return ret </s>
<s> from totalimpactwebapp import json_sqlalchemy <EOL> from util import commit <EOL> from util import cached_property <EOL> from util import dict_from_dir <EOL> from util import as_int_or_float_if_possible <EOL> from totalimpactwebapp import db <EOL> from totalimpactwebapp . tweeter import Tweeter <EOL> from birdy . twitter import AppClient , TwitterApiError , TwitterRateLimitError , TwitterClientError <EOL> from collections import defaultdict <EOL> from sqlalchemy import case <EOL> import os <EOL> import re <EOL> import datetime <EOL> import logging <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def tweets_from_tiids ( tiids ) : <EOL> if not tiids : <EOL> return [ ] <EOL> tweets = db . session . query ( Tweet ) . filter ( Tweet . tiid . in_ ( tiids ) ) . all ( ) <EOL> return tweets <EOL> def get_product_tweets_for_profile ( profile_id ) : <EOL> tweets = db . session . query ( Tweet ) . filter ( Tweet . profile_id == profile_id ) . all ( ) <EOL> response = defaultdict ( list ) <EOL> for tweet in tweets : <EOL> if tweet . tiid and tweet . tweet_text : <EOL> response [ tweet . tiid ] . append ( tweet ) <EOL> return response <EOL> def store_tweet_payload_and_tweeter_from_twitter ( payload_dicts_from_twitter , tweets ) : <EOL> tweets_by_tweet_id = defaultdict ( list ) <EOL> for tweet in tweets : <EOL> tweets_by_tweet_id [ tweet . tweet_id ] . append ( tweet ) <EOL> for payload_dict in payload_dicts_from_twitter : <EOL> tweet_id = payload_dict [ "<STR_LIT>" ] <EOL> logger . debug ( "<STR_LIT>" . format ( <EOL> tweet_id = tweet_id ) ) <EOL> for tweet in tweets_by_tweet_id [ tweet_id ] : <EOL> if not tweet . payload : <EOL> tweet . payload = payload_dict <EOL> logger . info ( u"<STR_LIT>" . format ( <EOL> tweet_id = tweet_id , tiid = tweet . tiid ) ) <EOL> if "<STR_LIT:user>" in payload_dict : <EOL> try : <EOL> tweet . tweeter . set_attributes_from_twitter_data ( payload_dict [ "<STR_LIT:user>" ] ) <EOL> except AttributeError : <EOL> tweeter = Tweeter . query . get ( tweet . screen_name ) <EOL> if not tweeter : <EOL> tweeter = Tweeter ( screen_name = tweet . screen_name ) <EOL> db . session . add ( tweeter ) <EOL> tweeter . set_attributes_from_twitter_data ( payload_dict [ "<STR_LIT:user>" ] ) <EOL> tweet . tweeter = tweeter <EOL> commit ( db ) <EOL> if tweet . tweeter : <EOL> logger . info ( u"<STR_LIT>" . format ( <EOL> screen_name = tweet . tweeter . screen_name ) ) <EOL> def flag_deleted_tweets ( tweet_ids ) : <EOL> if not tweet_ids : <EOL> return None <EOL> for tweet in Tweet . query . filter ( Tweet . tweet_id . in_ ( tweet_ids ) ) . all ( ) : <EOL> tweet . is_deleted = True <EOL> db . session . merge ( tweet ) <EOL> def handle_all_tweets ( data , tweets ) : <EOL> store_tweet_payload_and_tweeter_from_twitter ( data , tweets ) <EOL> tweet_ids = [ tweet . tweet_id for tweet in tweets ] <EOL> tweet_ids_with_response = [ tweet [ "<STR_LIT>" ] for tweet in data ] <EOL> tweet_ids_without_response = [ tweet for tweet in tweet_ids if tweet not in tweet_ids_with_response ] <EOL> flag_deleted_tweets ( tweet_ids_without_response ) <EOL> return True <EOL> class AppDictClient ( AppClient ) : <EOL> @ staticmethod <EOL> def get_json_object_hook ( data ) : <EOL> return data <EOL> def get_and_save_tweet_text_and_tweeter_followers ( tweets ) : <EOL> client = AppDictClient ( <EOL> os . getenv ( "<STR_LIT>" ) , <EOL> os . getenv ( "<STR_LIT>" ) , <EOL> access_token = os . getenv ( "<STR_LIT>" ) <EOL> ) <EOL> logger . info ( u"<STR_LIT>" . format ( <EOL> num = len ( tweets ) ) ) <EOL> group_size = <NUM_LIT:100> <EOL> list_of_groups = [ tweets [ i : i + group_size ] for i in range ( <NUM_LIT:0> , len ( tweets ) , group_size ) ] <EOL> for tweet_subset in list_of_groups : <EOL> tweet_id_string = "<STR_LIT:U+002C>" . join ( [ tweet . tweet_id for tweet in tweet_subset ] ) <EOL> try : <EOL> response = client . api . statuses . lookup . post ( id = tweet_id_string , trim_user = False ) <EOL> handle_all_tweets ( response . data , tweet_subset ) <EOL> except TwitterApiError , e : <EOL> logger . exception ( "<STR_LIT>" ) <EOL> except TwitterClientError , e : <EOL> logger . exception ( "<STR_LIT>" ) <EOL> except TwitterRateLimitError , e : <EOL> logger . exception ( "<STR_LIT>" ) <EOL> return <EOL> def hydrate_twitter_text_and_followers ( profile_id , altmetric_twitter_posts ) : <EOL> logger . info ( u"<STR_LIT>" . format ( <EOL> profile_id = profile_id ) ) <EOL> tweets_to_hydrate_from_twitter = [ ] <EOL> tweets = Tweet . query . filter ( Tweet . profile_id == profile_id ) <EOL> tweet_dict = dict ( [ ( ( tweet . tweet_id , tweet . tiid ) , tweet ) for tweet in tweets ] ) <EOL> for tiid , post_list in altmetric_twitter_posts . iteritems ( ) : <EOL> for post in post_list : <EOL> tweet_id = post [ "<STR_LIT>" ] <EOL> screen_name = post [ "<STR_LIT>" ] [ "<STR_LIT>" ] <EOL> if ( tweet_id , tiid ) in tweet_dict . keys ( ) : <EOL> tweet = tweet_dict [ ( tweet_id , tiid ) ] <EOL> if not tweet . tweet_text and not tweet . is_deleted : <EOL> tweets_to_hydrate_from_twitter . append ( tweet ) <EOL> else : <EOL> if not Tweet . query . get ( ( tweet_id , tiid ) ) : <EOL> tweet = Tweet ( tweet_id = tweet_id , tiid = tiid ) <EOL> tweet . set_attributes_from_altmetric_post ( post ) <EOL> tweet . profile_id = profile_id <EOL> tweets_to_hydrate_from_twitter . append ( tweet ) <EOL> db . session . add ( tweet ) <EOL> if not tweet . tweeter : <EOL> tweeter = Tweeter . query . get ( screen_name ) <EOL> if not tweeter : <EOL> tweeter = Tweeter ( screen_name = screen_name ) <EOL> db . session . add ( tweeter ) <EOL> tweeter . set_attributes_from_altmetric_post ( post ) <EOL> commit ( db ) <EOL> logger . info ( u"<STR_LIT>" . format ( <EOL> profile_id = profile_id ) ) <EOL> if tweets_to_hydrate_from_twitter : <EOL> commit ( db ) <EOL> tweet_ids = [ tweet . tweet_id for tweet in tweets_to_hydrate_from_twitter ] <EOL> logger . info ( u"<STR_LIT>" . format ( <EOL> profile_id = profile_id ) ) <EOL> get_and_save_tweet_text_and_tweeter_followers ( tweets_to_hydrate_from_twitter ) <EOL> commit ( db ) <EOL> else : <EOL> logger . info ( u"<STR_LIT>" . format ( <EOL> profile_id = profile_id ) ) <EOL> return <EOL> handle_workaround_join_string = "<STR_LIT>" <EOL> class Tweet ( db . Model ) : <EOL> tweet_id = db . Column ( db . Text , primary_key = True ) <EOL> tiid = db . Column ( db . Text , primary_key = True ) <EOL> profile_id = db . Column ( db . Integer , db . ForeignKey ( '<STR_LIT>' ) ) <EOL> screen_name = db . Column ( db . Text , db . ForeignKey ( '<STR_LIT>' ) ) <EOL> tweet_timestamp = db . Column ( db . DateTime ( ) ) <EOL> payload = db . Column ( json_sqlalchemy . JSONAlchemy ( db . Text ) ) <EOL> is_deleted = db . Column ( db . Boolean ) <EOL> tweet_url = db . Column ( db . Text ) <EOL> country = db . Column ( db . Text ) <EOL> followers_at_time_of_tweet = db . Column ( db . Integer ) <EOL> tweeter = db . relationship ( <EOL> '<STR_LIT>' , <EOL> lazy = '<STR_LIT>' , <EOL> cascade = '<STR_LIT:all>' , <EOL> backref = db . backref ( "<STR_LIT>" ) , <EOL> uselist = False , <EOL> primaryjoin = handle_workaround_join_string <EOL> ) <EOL> def __init__ ( self , ** kwargs ) : <EOL> if "<STR_LIT>" in kwargs : <EOL> payload_dict = kwargs [ "<STR_LIT>" ] <EOL> kwargs [ "<STR_LIT>" ] = payload_dict [ "<STR_LIT>" ] <EOL> kwargs [ "<STR_LIT>" ] = payload_dict [ "<STR_LIT:user>" ] [ "<STR_LIT>" ] <EOL> kwargs [ "<STR_LIT>" ] = payload_dict <EOL> kwargs [ "<STR_LIT>" ] = datetime . datetime . strptime ( payload_dict [ "<STR_LIT>" ] , r"<STR_LIT>" ) <EOL> if not "<STR_LIT>" in kwargs : <EOL> try : <EOL> kwargs [ "<STR_LIT>" ] = payload_dict [ "<STR_LIT>" ] [ "<STR_LIT>" ] <EOL> except ( AttributeError , TypeError ) : <EOL> pass <EOL> super ( Tweet , self ) . __init__ ( ** kwargs ) <EOL> @ classmethod <EOL> def most_recent_tweet_id ( cls , screen_name ) : <EOL> screen_name = screen_name . replace ( "<STR_LIT:@>" , "<STR_LIT>" ) <EOL> q = db . session . query ( Tweet ) . filter ( Tweet . screen_name == screen_name ) . order_by ( Tweet . tweet_timestamp . desc ( ) ) <EOL> tweet = q . first ( ) <EOL> try : <EOL> tweet_id = tweet . tweet_id <EOL> except AttributeError : <EOL> tweet_id = None <EOL> return tweet_id <EOL> @ cached_property <EOL> def tweet_text ( self ) : <EOL> try : <EOL> return self . payload [ "<STR_LIT:text>" ] <EOL> except TypeError : <EOL> return None <EOL> @ cached_property <EOL> def tweet_text_with_links ( self ) : <EOL> if self . tweet_text is None : <EOL> return None <EOL> ret = self . tweet_text <EOL> ret = re . sub ( r"<STR_LIT>" , r"<STR_LIT>" , ret ) <EOL> for url_info in self . urls : <EOL> my_link = u"<STR_LIT>" . format ( <EOL> url = url_info [ "<STR_LIT>" ] , <EOL> display_url = url_info [ "<STR_LIT>" ] <EOL> ) <EOL> ret = re . sub ( r"<STR_LIT>" , my_link , ret , <NUM_LIT:1> ) <EOL> ret = re . sub ( r"<STR_LIT>" , r"<STR_LIT>" , ret ) <EOL> ret = re . sub ( r"<STR_LIT>" , r"<STR_LIT>" , ret ) <EOL> return ret <EOL> @ cached_property <EOL> def urls ( self ) : <EOL> try : <EOL> return self . payload [ "<STR_LIT>" ] [ "<STR_LIT>" ] <EOL> except TypeError : <EOL> return None <EOL> except KeyError : <EOL> return [ ] <EOL> @ cached_property <EOL> def has_country ( self ) : <EOL> return self . country != None <EOL> def set_attributes_from_altmetric_post ( self , post ) : <EOL> self . tweet_id = post [ "<STR_LIT>" ] <EOL> self . screen_name = post [ "<STR_LIT>" ] [ "<STR_LIT>" ] <EOL> self . tweet_timestamp = post [ "<STR_LIT>" ] <EOL> if "<STR_LIT>" in post [ "<STR_LIT>" ] : <EOL> self . country = post [ "<STR_LIT>" ] [ "<STR_LIT>" ] . get ( "<STR_LIT>" , None ) <EOL> return self <EOL> def __repr__ ( self ) : <EOL> return u'<STR_LIT>' . format ( <EOL> tweet_id = self . tweet_id , <EOL> profile_id = self . profile_id , <EOL> screen_name = self . screen_name , <EOL> timestamp = self . tweet_timestamp ) <EOL> def to_dict ( self ) : <EOL> attributes_to_ignore = [ <EOL> "<STR_LIT>" <EOL> ] <EOL> ret = dict_from_dir ( self , attributes_to_ignore ) <EOL> return ret <EOL> twitter_example_contents = """<STR_LIT>""" </s>
<s> import os <EOL> import numpy as np <EOL> def load_gender_data ( ntrain = <NUM_LIT> , ntest = <NUM_LIT> ) : <EOL> import pandas as pd <EOL> file_loc = os . path . dirname ( os . path . realpath ( __file__ ) ) <EOL> relative_path = "<STR_LIT>" <EOL> fullpath = os . path . join ( file_loc , relative_path ) <EOL> data = pd . read_csv ( fullpath , nrows = ntrain + ntest ) <EOL> X = data [ '<STR_LIT:text>' ] . values <EOL> X = [ str ( x ) for x in X ] <EOL> Y = data [ '<STR_LIT>' ] . values <EOL> trX = X [ : - ntest ] <EOL> teX = X [ - ntest : ] <EOL> trY = Y [ : - ntest ] <EOL> teY = Y [ - ntest : ] <EOL> return trX , teX , trY , teY <EOL> def load_mnist ( data_dir = None ) : <EOL> if data_dir is None : <EOL> import urllib <EOL> import gzip <EOL> url = '<STR_LIT>' <EOL> fnames = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' <EOL> ] <EOL> for fname in fnames : <EOL> if not os . path . isfile ( fname ) : <EOL> print '<STR_LIT>' , fname <EOL> urllib . urlretrieve ( url + fname , fname ) <EOL> data_dir = '<STR_LIT>' <EOL> fd = gzip . open ( os . path . join ( data_dir , '<STR_LIT>' ) ) <EOL> loaded = np . fromstring ( fd . read ( ) , dtype = np . uint8 ) <EOL> trX = loaded [ <NUM_LIT:16> : ] . reshape ( ( <NUM_LIT> , - <NUM_LIT:1> ) ) <EOL> fd = gzip . open ( os . path . join ( data_dir , '<STR_LIT>' ) ) <EOL> loaded = np . fromstring ( fd . read ( ) , dtype = np . uint8 ) <EOL> trY = loaded [ <NUM_LIT:8> : ] . reshape ( ( <NUM_LIT> ) ) <EOL> fd = gzip . open ( os . path . join ( data_dir , '<STR_LIT>' ) ) <EOL> loaded = np . fromstring ( fd . read ( ) , dtype = np . uint8 ) <EOL> teX = loaded [ <NUM_LIT:16> : ] . reshape ( ( <NUM_LIT> , - <NUM_LIT:1> ) ) <EOL> fd = gzip . open ( os . path . join ( data_dir , '<STR_LIT>' ) ) <EOL> loaded = np . fromstring ( fd . read ( ) , dtype = np . uint8 ) <EOL> teY = loaded [ <NUM_LIT:8> : ] . reshape ( ( <NUM_LIT> ) ) <EOL> trX = trX / <NUM_LIT> <EOL> teX = teX / <NUM_LIT> <EOL> trX = trX . reshape ( - <NUM_LIT:1> , <NUM_LIT> , <NUM_LIT> ) <EOL> teX = teX . reshape ( - <NUM_LIT:1> , <NUM_LIT> , <NUM_LIT> ) <EOL> return trX , teX , trY , teY </s>
<s> import unittest <EOL> import os <EOL> import commands <EOL> from utils import get_temporary_location <EOL> from utils import delete_repository <EOL> from gitpy import LocalRepository <EOL> from gitpy import find_repository <EOL> from gitpy . exceptions import GitException <EOL> class EmptyRepositoryTest ( unittest . TestCase ) : <EOL> def setUp ( self ) : <EOL> self . dirname = get_temporary_location ( ) <EOL> self . repo = LocalRepository ( self . dirname ) <EOL> self . assertFalse ( os . path . exists ( self . dirname ) ) <EOL> self . assertFalse ( self . repo . isValid ( ) ) <EOL> def tearDown ( self ) : <EOL> if os . path . exists ( self . dirname ) : <EOL> delete_repository ( self . repo ) <EOL> class BasicRepositories ( EmptyRepositoryTest ) : <EOL> def testRepositoryInit ( self ) : <EOL> self . repo . init ( ) <EOL> self . assertTrue ( self . repo . isValid ( ) ) <EOL> self . failUnless ( os . path . isdir ( self . dirname ) ) <EOL> self . failUnless ( os . path . isdir ( os . path . join ( self . dirname , "<STR_LIT>" ) ) ) <EOL> def testConfiguration ( self ) : <EOL> self . repo . init ( ) <EOL> self . repo . config . setParameter ( '<STR_LIT>' , <NUM_LIT:2> ) <EOL> self . assertEquals ( self . repo . config . getParameter ( '<STR_LIT>' ) , '<STR_LIT:2>' ) <EOL> def testRepositoryInitWhenExists ( self ) : <EOL> os . mkdir ( self . dirname ) <EOL> self . repo . init ( ) <EOL> self . failUnless ( os . path . isdir ( self . dirname ) ) <EOL> self . failUnless ( os . path . isdir ( os . path . join ( self . dirname , "<STR_LIT>" ) ) ) <EOL> class ModifiedRepositoryTest ( EmptyRepositoryTest ) : <EOL> FILENAME = "<STR_LIT>" <EOL> def setUp ( self ) : <EOL> super ( ModifiedRepositoryTest , self ) . setUp ( ) <EOL> self . repo . init ( ) <EOL> with open ( os . path . join ( self . repo . path , self . FILENAME ) , "<STR_LIT:wb>" ) as f : <EOL> print >> f , "<STR_LIT>" <EOL> self . assertFalse ( self . repo . isWorkingDirectoryClean ( ) ) <EOL> class ModifiedRepositories ( ModifiedRepositoryTest ) : <EOL> def testStatus ( self ) : <EOL> untracked = self . repo . getUntrackedFiles ( ) <EOL> self . assertEquals ( untracked , [ self . FILENAME ] ) <EOL> def testAdding ( self ) : <EOL> untracked_files = self . repo . getUntrackedFiles ( ) <EOL> for u in untracked_files : <EOL> self . repo . add ( u ) <EOL> self . assertEquals ( self . repo . getStagedFiles ( ) , untracked_files ) <EOL> self . assertFalse ( self . repo . isWorkingDirectoryClean ( ) ) <EOL> def testCommitting ( self ) : <EOL> self . repo . addAll ( ) <EOL> self . assertNotEquals ( self . repo . getStagedFiles ( ) , [ ] ) <EOL> c = self . repo . commit ( message = "<STR_LIT>" ) <EOL> self . assertTrue ( self . repo . isWorkingDirectoryClean ( ) ) <EOL> self . assertEquals ( self . repo . getStagedFiles ( ) , [ ] ) <EOL> class CleaningUntrackedFiles ( ModifiedRepositoryTest ) : <EOL> def _clean ( self ) : <EOL> self . repo . cleanUntrackedFiles ( ) <EOL> self . failIf ( self . repo . getUntrackedFiles ( ) ) <EOL> def testCleaningUpUntrackedFiles ( self ) : <EOL> with open ( os . path . join ( self . repo . path , "<STR_LIT>" ) , "<STR_LIT:wb>" ) as f : <EOL> print >> f , "<STR_LIT:data>" <EOL> self . failUnless ( self . repo . getUntrackedFiles ( ) ) <EOL> self . _clean ( ) <EOL> dirpath = os . path . join ( self . repo . path , "<STR_LIT>" ) <EOL> os . mkdir ( dirpath ) <EOL> self . _clean ( ) <EOL> self . failIf ( os . path . exists ( dirpath ) ) <EOL> class TestAPI ( ModifiedRepositoryTest ) : <EOL> def test_find_repository ( self ) : <EOL> prev_path = os . path . realpath ( "<STR_LIT:.>" ) <EOL> subpath = os . path . join ( self . repo . path , "<STR_LIT:a>" , "<STR_LIT:b>" , "<STR_LIT:c>" ) <EOL> os . makedirs ( subpath ) <EOL> os . chdir ( subpath ) <EOL> try : <EOL> repo = find_repository ( ) <EOL> finally : <EOL> os . chdir ( prev_path ) <EOL> self . failUnless ( repo . path == self . repo . path ) <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL> unittest . main ( ) </s>
<s> import logging <EOL> from okcupyd . db import model , txn , with_txn <EOL> log = logging . getLogger ( __name__ ) <EOL> class UserAdapter ( object ) : <EOL> def __init__ ( self , profile ) : <EOL> self . profile = profile <EOL> def build ( self , session ) : <EOL> found = model . User . query_no_txn ( session , model . User . handle == <EOL> self . profile . username ) <EOL> if found : <EOL> return found [ <NUM_LIT:0> ] <EOL> else : <EOL> return model . User ( okc_id = self . profile . id , <EOL> handle = self . profile . username , <EOL> age = self . profile . age , <EOL> location = self . profile . location ) <EOL> def get_no_txn ( self , session ) : <EOL> return model . User . upsert_one_no_txn ( session , self . build ( session ) , <EOL> id_key = '<STR_LIT>' ) <EOL> get = with_txn ( get_no_txn ) <EOL> class ThreadAdapter ( object ) : <EOL> def __init__ ( self , thread ) : <EOL> self . thread = thread <EOL> def _get_thread ( self , session ) : <EOL> initiator = UserAdapter ( self . thread . initiator ) . get_no_txn ( session ) <EOL> respondent = UserAdapter ( self . thread . respondent ) . get_no_txn ( session ) <EOL> message_thread = model . MessageThread ( okc_id = self . thread . id , <EOL> initiator = initiator , <EOL> respondent = respondent ) <EOL> return model . MessageThread . upsert_one_no_txn ( session , message_thread , <EOL> id_key = '<STR_LIT>' ) <EOL> def _add_messages ( self , thread_model ) : <EOL> existing_message_ids = set ( [ m . okc_id for m in thread_model . messages ] ) <EOL> new_messages = [ message for message in self . thread . messages <EOL> if message . id not in existing_message_ids ] <EOL> new_message_models = [ ] <EOL> for new_message in new_messages : <EOL> from_initiator = thread_model . initiator . handle . lower ( ) == new_message . sender . username . lower ( ) <EOL> sender , recipient = ( thread_model . initiator , <EOL> thread_model . respondent ) if from_initiator else ( thread_model . respondent , <EOL> thread_model . initiator ) <EOL> new_message_model = model . Message ( okc_id = new_message . id , <EOL> text = new_message . content , <EOL> sender = sender , <EOL> recipient = recipient , <EOL> time_sent = new_message . time_sent ) <EOL> new_message_models . append ( new_message_model ) <EOL> thread_model . messages . append ( new_message_model ) <EOL> return new_message_models <EOL> def add_messages ( self ) : <EOL> with txn ( ) as session : <EOL> thread_model = model . MessageThread . find_no_txn ( session , <EOL> self . thread . id , <EOL> id_key = '<STR_LIT>' ) <EOL> return self . _add_messages ( thread_model ) <EOL> def get_thread ( self ) : <EOL> with txn ( ) as session : <EOL> thread_model = self . _get_thread ( session ) <EOL> return thread_model , self . _add_messages ( thread_model ) </s>
<s> import logging <EOL> from invoke import task <EOL> import IPython <EOL> from okcupyd import db <EOL> from okcupyd import util <EOL> from okcupyd . db import mailbox , model <EOL> from okcupyd . user import User <EOL> log = logging . getLogger ( __name__ ) <EOL> @ task ( default = True ) <EOL> def session ( ) : <EOL> with db . txn ( ) as session : <EOL> IPython . embed ( ) <EOL> @ task <EOL> def reset ( ) : <EOL> util . enable_logger ( __name__ ) <EOL> log . info ( db . Base . metadata . bind ) <EOL> db . Base . metadata . drop_all ( ) <EOL> db . Base . metadata . create_all ( ) <EOL> @ task <EOL> def sync ( ) : <EOL> user = User ( ) <EOL> mailbox . Sync ( user ) . all ( ) <EOL> log . info ( model . Message . query ( model . User . okc_id == user . profile . id ) ) <EOL> @ task <EOL> def make ( ) : <EOL> user = User ( ) <EOL> user_model = model . User . from_profile ( user . profile ) <EOL> user_model . upsert_model ( id_key = '<STR_LIT>' ) <EOL> okcupyd_user = model . OKCupydUser ( user_id = user_model . id ) <EOL> okcupyd_user . upsert_model ( id_key = '<STR_LIT>' ) <EOL> return okcupyd_user </s>
<s> from . import util <EOL> from okcupyd import User , photo <EOL> @ util . use_cassette ( path = '<STR_LIT>' , <EOL> match_on = util . match_on_no_body ) <EOL> def test_photo_upload ( ) : <EOL> uploader = photo . PhotoUploader ( ) <EOL> upload_response_dict = uploader . upload_and_confirm ( '<STR_LIT>' ) <EOL> assert int ( upload_response_dict [ '<STR_LIT:id>' ] ) > <NUM_LIT:0> <EOL> @ util . use_cassette ( path = '<STR_LIT>' , match_on = util . match_on_no_body ) <EOL> def test_photo_delete ( ) : <EOL> user = User ( ) <EOL> response_dict = user . photo . upload_and_confirm ( user . quickmatch ( ) . photo_infos [ <NUM_LIT:0> ] ) <EOL> before_delete_photos = user . profile . photo_infos <EOL> user . photo . delete ( response_dict [ '<STR_LIT:id>' ] ) <EOL> user . profile . refresh ( ) <EOL> assert len ( before_delete_photos ) - <NUM_LIT:1> == len ( user . profile . photo_infos ) <EOL> def test_make_photo_uri_from_https_link ( ) : <EOL> photo_info = photo . Info . from_cdn_uri ( <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> ) <EOL> assert photo_info . id == <NUM_LIT> <EOL> assert photo_info . thumb_nail_top == <NUM_LIT> <EOL> @ util . use_cassette <EOL> def test_photo_info_upload ( vcr_live_sleep ) : <EOL> user = User ( ) <EOL> response = user . photo . upload_and_confirm ( user . quickmatch ( ) . photo_infos [ <NUM_LIT:0> ] ) <EOL> vcr_live_sleep ( <NUM_LIT:2> ) <EOL> assert int ( response [ '<STR_LIT:id>' ] ) in [ pi . id for pi in user . profile . photo_infos ] </s>
<s> import theano <EOL> import theano . tensor as T <EOL> from theano . sandbox . rng_mrg import MRG_RandomStreams <EOL> from theano . tensor . nnet . conv import conv2d <EOL> from theano . tensor . signal . downsample import max_pool_2d <EOL> from theano . tensor . shared_randomstreams import RandomStreams <EOL> import numpy as np <EOL> from toolbox import * <EOL> from modelbase import * <EOL> class LM_gru ( ModelLMBase ) : <EOL> def __init__ ( self , data , hp ) : <EOL> super ( LM_gru , self ) . __init__ ( self . __class__ . __name__ , data , hp ) <EOL> self . n_h = <NUM_LIT> <EOL> self . dropout = <NUM_LIT:0.5> <EOL> self . params = Parameters ( ) <EOL> self . hiddenstates = Parameters ( ) <EOL> n_tokens = self . data [ '<STR_LIT>' ] <EOL> n_h = self . n_h <EOL> scale = hp . init_scale <EOL> gates = <NUM_LIT:3> <EOL> with self . hiddenstates : <EOL> b1_h = shared_zeros ( ( self . hp . batch_size , n_h ) ) <EOL> b2_h = shared_zeros ( ( self . hp . batch_size , n_h ) ) <EOL> if hp . load_model and os . path . isfile ( self . filename ) : <EOL> self . params . load ( self . filename ) <EOL> else : <EOL> with self . params : <EOL> W_emb = shared_normal ( ( n_tokens , n_h ) , scale = scale ) <EOL> W1 = shared_normal ( ( n_h , n_h * gates ) , scale = scale * <NUM_LIT> ) <EOL> V1 = shared_normal ( ( n_h , n_h * gates ) , scale = scale * <NUM_LIT> ) <EOL> b1 = shared_zeros ( ( n_h * gates ) ) <EOL> W2 = shared_normal ( ( n_h , n_h * gates ) , scale = scale * <NUM_LIT> ) <EOL> V2 = shared_normal ( ( n_h , n_h * gates ) , scale = scale * <NUM_LIT> ) <EOL> b2 = shared_zeros ( ( n_h * gates , ) ) <EOL> def lstm ( X , h , c , W , U , b ) : <EOL> g_on = T . dot ( X , W ) + T . dot ( h , U ) + b <EOL> i_on = T . nnet . sigmoid ( g_on [ : , : n_h ] ) <EOL> f_on = T . nnet . sigmoid ( g_on [ : , n_h : <NUM_LIT:2> * n_h ] ) <EOL> o_on = T . nnet . sigmoid ( g_on [ : , <NUM_LIT:2> * n_h : <NUM_LIT:3> * n_h ] ) <EOL> c = f_on * c + i_on * T . tanh ( g_on [ : , <NUM_LIT:3> * n_h : ] ) <EOL> h = o_on * T . tanh ( c ) <EOL> return h , c <EOL> def gru ( X , h , W , U , b ) : <EOL> z_t = T . nnet . sigmoid ( T . dot ( X , W [ : , : n_h ] ) + T . dot ( h , U [ : , : n_h ] ) + b [ : n_h ] ) <EOL> r_t = T . nnet . sigmoid ( T . dot ( X , W [ : , n_h : <NUM_LIT:2> * n_h ] ) + T . dot ( h , U [ : , n_h : <NUM_LIT:2> * n_h ] ) + b [ n_h : <NUM_LIT:2> * n_h ] ) <EOL> h_t = T . tanh ( T . dot ( X , W [ : , <NUM_LIT:2> * n_h : <NUM_LIT:3> * n_h ] ) + r_t * T . dot ( h , U [ : , <NUM_LIT:2> * n_h : <NUM_LIT:3> * n_h ] ) + b [ <NUM_LIT:2> * n_h : <NUM_LIT:3> * n_h ] ) <EOL> return ( <NUM_LIT:1> - z_t ) * h + z_t * h_t <EOL> def sgru ( X , h , W , U , b ) : <EOL> z_t = T . tanh ( T . dot ( X , W [ : , : n_h ] ) + T . dot ( h , U [ : , : n_h ] ) + b [ : n_h ] ) <EOL> h_t = T . tanh ( T . dot ( X , W [ : , <NUM_LIT:1> * n_h : <NUM_LIT:2> * n_h ] ) + T . dot ( h , U [ : , <NUM_LIT:1> * n_h : <NUM_LIT:2> * n_h ] ) + b [ <NUM_LIT:1> * n_h : <NUM_LIT:2> * n_h ] ) <EOL> return z_t * h_t <EOL> def model ( x , p , p_dropout ) : <EOL> input_size = x . shape [ <NUM_LIT:1> ] <EOL> h0 = p . W_emb [ x ] <EOL> h0 = dropout ( h0 , p_dropout ) <EOL> cost , h1 , h2 = [ <NUM_LIT:0.> , b1_h , b2_h ] <EOL> for t in xrange ( <NUM_LIT:0> , self . hp . seq_size ) : <EOL> if t >= self . hp . warmup_size : <EOL> pyx = softmax ( T . dot ( dropout ( h2 , p_dropout ) , T . transpose ( p . W_emb ) ) ) <EOL> cost += T . sum ( T . nnet . categorical_crossentropy ( pyx , theano_one_hot ( x [ t ] , n_tokens ) ) ) <EOL> h1 = gru ( h0 [ t ] , h1 , p . W1 , p . V1 , p . b1 ) <EOL> h2 = gru ( dropout ( h1 , p_dropout ) , h2 , p . W2 , p . V2 , p . b2 ) <EOL> h_updates = [ ( b1_h , h1 ) , ( b2_h , h2 ) ] <EOL> return cost , h_updates <EOL> cost , h_updates = model ( self . X , self . params , self . dropout ) <EOL> te_cost , te_h_updates = model ( self . X , self . params , <NUM_LIT:0.> ) <EOL> self . compile ( cost , te_cost , h_updates , te_h_updates ) </s>
<s> """<STR_LIT>""" <EOL> import csv <EOL> import sys <EOL> def csvOutput ( queryResult , separator = '<STR_LIT:U+002C>' , quote = '<STR_LIT:">' ) : <EOL> """<STR_LIT>""" <EOL> csvWriter = csv . writer ( sys . stdout , delimiter = separator , quotechar = quote , <EOL> quoting = csv . QUOTE_MINIMAL ) <EOL> for line in queryResult : <EOL> csvWriter . writerow ( line ) </s>
<s> import sys , os , stat <EOL> import pythoncom <EOL> from win32com . shell import shell , shellcon <EOL> import commctrl <EOL> import winerror <EOL> from win32com . server . util import wrap <EOL> from pywintypes import IID <EOL> IPersist_Methods = [ "<STR_LIT>" ] <EOL> IColumnProvider_Methods = IPersist_Methods + [ "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ] <EOL> class ColumnProvider : <EOL> _reg_progid_ = "<STR_LIT>" <EOL> _reg_desc_ = "<STR_LIT>" <EOL> _reg_clsid_ = IID ( "<STR_LIT>" ) <EOL> _com_interfaces_ = [ pythoncom . IID_IPersist , <EOL> shell . IID_IColumnProvider , <EOL> ] <EOL> _public_methods_ = IColumnProvider_Methods <EOL> def GetClassID ( self ) : <EOL> return self . _reg_clsid_ <EOL> def Initialize ( self , colInit ) : <EOL> flags , reserved , name = colInit <EOL> print "<STR_LIT>" , name <EOL> def GetColumnInfo ( self , index ) : <EOL> if index in [ <NUM_LIT:0> , <NUM_LIT:1> ] : <EOL> if index == <NUM_LIT:0> : <EOL> ext = "<STR_LIT>" <EOL> else : <EOL> ext = "<STR_LIT>" <EOL> title = ext + "<STR_LIT>" <EOL> description = "<STR_LIT>" % ext <EOL> col_id = ( self . _reg_clsid_ , <EOL> index ) <EOL> col_info = ( <EOL> col_id , <EOL> pythoncom . VT_I4 , <EOL> commctrl . LVCFMT_RIGHT , <EOL> <NUM_LIT:20> , <EOL> shellcon . SHCOLSTATE_TYPE_INT | shellcon . SHCOLSTATE_SECONDARYUI , <EOL> title , <EOL> description ) <EOL> return col_info <EOL> return None <EOL> def GetItemData ( self , colid , colData ) : <EOL> fmt_id , pid = colid <EOL> fmt_id == self . _reg_clsid_ <EOL> flags , attr , reserved , ext , name = colData <EOL> if ext . lower ( ) not in [ "<STR_LIT>" , "<STR_LIT>" ] : <EOL> return None <EOL> if pid == <NUM_LIT:0> : <EOL> ext = "<STR_LIT>" <EOL> else : <EOL> ext = "<STR_LIT>" <EOL> check_file = os . path . splitext ( name ) [ <NUM_LIT:0> ] + ext <EOL> try : <EOL> st = os . stat ( check_file ) <EOL> return st [ stat . ST_SIZE ] <EOL> except OSError : <EOL> return None <EOL> def DllRegisterServer ( ) : <EOL> import _winreg <EOL> key = _winreg . CreateKey ( _winreg . HKEY_CLASSES_ROOT , <EOL> "<STR_LIT>" + str ( ColumnProvider . _reg_clsid_ ) ) <EOL> _winreg . SetValueEx ( key , None , <NUM_LIT:0> , _winreg . REG_SZ , ColumnProvider . _reg_desc_ ) <EOL> print ColumnProvider . _reg_desc_ , "<STR_LIT>" <EOL> def DllUnregisterServer ( ) : <EOL> import _winreg <EOL> try : <EOL> key = _winreg . DeleteKey ( _winreg . HKEY_CLASSES_ROOT , <EOL> "<STR_LIT>" + str ( ColumnProvider . _reg_clsid_ ) ) <EOL> except WindowsError , details : <EOL> import errno <EOL> if details . errno != errno . ENOENT : <EOL> raise <EOL> print ColumnProvider . _reg_desc_ , "<STR_LIT>" <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL> from win32com . server import register <EOL> register . UseCommandLine ( ColumnProvider , <EOL> finalize_register = DllRegisterServer , <EOL> finalize_unregister = DllUnregisterServer ) </s>
<s> def __load ( ) : <EOL> import imp , os , sys <EOL> try : <EOL> dirname = os . path . dirname ( __loader__ . archive ) <EOL> except NameError : <EOL> dirname = sys . prefix <EOL> path = os . path . join ( dirname , '<STR_LIT>' ) <EOL> mod = imp . load_dynamic ( __name__ , path ) <EOL> __load ( ) <EOL> del __load </s>
<s> import logging <EOL> class LoggerFactory ( object ) : <EOL> _isSetup = False <EOL> def __init__ ( self , level = logging . DEBUG ) : <EOL> if LoggerFactory . _isSetup is False : <EOL> logger = logging . getLogger ( "<STR_LIT>" ) <EOL> logger . setLevel ( level ) <EOL> formatter = logging . Formatter ( '<STR_LIT>' ) <EOL> ch = logging . StreamHandler ( ) <EOL> ch . setLevel ( level ) <EOL> ch . setFormatter ( formatter ) <EOL> logger . addHandler ( ch ) <EOL> LoggerFactory . _isSetup = True <EOL> def getLogger ( self , name , level = logging . DEBUG ) : <EOL> logger = logging . getLogger ( "<STR_LIT>" % name ) <EOL> logger . setLevel ( level ) <EOL> return logger </s>
<s> from . functions import * </s>
<s> from __future__ import division <EOL> import numpy as np <EOL> from pysd import functions <EOL> def time ( ) : <EOL> return _t <EOL> def flowa ( ) : <EOL> """<STR_LIT>""" <EOL> return <NUM_LIT:0.1> <EOL> def stocka ( ) : <EOL> return _state [ '<STR_LIT>' ] <EOL> def _stocka_init ( ) : <EOL> return - <NUM_LIT:5> <EOL> def _dstocka_dt ( ) : <EOL> return flowa ( ) <EOL> def test_exp ( ) : <EOL> """<STR_LIT>""" <EOL> return np . exp ( stocka ( ) ) <EOL> def final_time ( ) : <EOL> """<STR_LIT>""" <EOL> return <NUM_LIT:100> <EOL> def initial_time ( ) : <EOL> """<STR_LIT>""" <EOL> return <NUM_LIT:0> <EOL> def saveper ( ) : <EOL> """<STR_LIT>""" <EOL> return time_step ( ) <EOL> def time_step ( ) : <EOL> """<STR_LIT>""" <EOL> return <NUM_LIT:1> </s>
<s> """<STR_LIT>""" <EOL> __all__ = [ <EOL> '<STR_LIT>' <EOL> ] <EOL> __version__ = '<STR_LIT>' </s>
<s> from myapp import utils <EOL> module_name = utils . getFinalName ( __name__ ) <EOL> module = utils . getModule ( __name__ , subdomain = module_name ) <EOL> import views <EOL> import views . morepages </s>
<s> """<STR_LIT>""" <EOL> import sys <EOL> import os <EOL> import subprocess <EOL> def perform_testing ( config ) : <EOL> requirements = { <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" <EOL> } <EOL> print "<STR_LIT>" <EOL> print canwrite ( config [ '<STR_LIT>' ] [ '<STR_LIT>' ] ) , "<STR_LIT>" <EOL> print "<STR_LIT>" <EOL> print "<STR_LIT>" <EOL> for req in requirements : <EOL> print checkcommand ( requirements [ req ] ) , req <EOL> sys . exit ( <NUM_LIT:0> ) <EOL> def canwrite ( path ) : <EOL> try : <EOL> ret = booltostatus ( os . access ( path , os . W_OK | os . X_OK ) ) <EOL> except : <EOL> ret = False <EOL> finally : <EOL> return ret <EOL> def booltostatus ( inbool ) : <EOL> if inbool : <EOL> return "<STR_LIT>" <EOL> else : <EOL> return "<STR_LIT>" <EOL> def checkcommand ( com ) : <EOL> proc = subprocess . Popen ( <EOL> [ <EOL> '<STR_LIT>' , <EOL> str ( com ) <EOL> ] , <EOL> stderr = subprocess . PIPE , <EOL> stdout = subprocess . PIPE <EOL> ) <EOL> return booltostatus ( len ( proc . stdout . read ( ) ) > <NUM_LIT:0> ) </s>
<s> """<STR_LIT>""" <EOL> from collections import namedtuple <EOL> from uuid import uuid4 <EOL> from django . http import HttpResponse <EOL> from django . contrib . gis . db . models . query import GeoQuerySet <EOL> from django . contrib . gis . db . models import GeometryField <EOL> from django import forms as f <EOL> import json <EOL> from django . shortcuts import render_to_response <EOL> from ga_ows . views import common <EOL> from ga_ows . utils import MultipleValueField , BBoxField , CaseInsensitiveDict <EOL> from lxml import etree <EOL> from ga_ows . views . common import RequestForm , CommonParameters , GetCapabilitiesMixin <EOL> from osgeo import ogr <EOL> from django . conf import settings <EOL> from tempfile import gettempdir <EOL> from django . db import connections <EOL> import re <EOL> from lxml import etree <EOL> import os <EOL> class InputParameters ( RequestForm ) : <EOL> """<STR_LIT:U+0020>""" <EOL> srs_name = f . CharField ( ) <EOL> input_format = f . CharField ( ) <EOL> srs_format = f . CharField ( required = False ) <EOL> @ classmethod <EOL> def from_request ( cls , request ) : <EOL> request [ '<STR_LIT>' ] = request . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> request [ '<STR_LIT>' ] = request . get ( '<STR_LIT>' , "<STR_LIT>" ) <EOL> class PresentationParameters ( RequestForm ) : <EOL> count = f . IntegerField ( ) <EOL> start_index = f . IntegerField ( ) <EOL> max_features = f . IntegerField ( ) <EOL> output_format = f . CharField ( ) <EOL> @ classmethod <EOL> def from_request ( cls , request ) : <EOL> request [ '<STR_LIT:count>' ] = int ( request . get ( '<STR_LIT:count>' , '<STR_LIT:1>' ) ) <EOL> request [ '<STR_LIT>' ] = int ( request . get ( '<STR_LIT>' , '<STR_LIT:1>' ) ) <EOL> request [ '<STR_LIT>' ] = int ( request . get ( '<STR_LIT>' , '<STR_LIT:1>' ) ) <EOL> request [ '<STR_LIT>' ] = request . get ( '<STR_LIT>' , "<STR_LIT>" ) <EOL> class AdHocQueryParameters ( RequestForm ) : <EOL> type_names = MultipleValueField ( ) <EOL> aliases = MultipleValueField ( required = False ) <EOL> filter = f . CharField ( required = False ) <EOL> filter_language = f . CharField ( required = False ) <EOL> resource_id = f . CharField ( required = False ) <EOL> bbox = BBoxField ( ) <EOL> sort_by = f . CharField ( required = False ) <EOL> @ classmethod <EOL> def from_request ( cls , request ) : <EOL> request [ '<STR_LIT>' ] = request . getlist ( '<STR_LIT>' ) <EOL> request [ '<STR_LIT>' ] = request . getlist ( '<STR_LIT>' ) <EOL> request [ '<STR_LIT>' ] = request . get ( '<STR_LIT>' ) <EOL> request [ '<STR_LIT>' ] = request . get ( '<STR_LIT>' ) <EOL> request [ '<STR_LIT>' ] = request . get ( '<STR_LIT>' ) <EOL> request [ '<STR_LIT>' ] = request . get ( '<STR_LIT>' ) <EOL> request [ '<STR_LIT>' ] = request . get ( '<STR_LIT>' ) <EOL> class StoredQueryParameters ( RequestForm ) : <EOL> stored_query_id = f . CharField ( required = False ) <EOL> @ classmethod <EOL> def from_request ( cls , request ) : <EOL> request [ '<STR_LIT>' ] = request . get ( '<STR_LIT>' ) <EOL> class GetFeatureByIdParameters ( RequestForm ) : <EOL> feature_id = f . CharField ( ) <EOL> @ classmethod <EOL> def from_request ( cls , request ) : <EOL> request [ '<STR_LIT>' ] = request . get ( '<STR_LIT:id>' ) <EOL> class ResolveParameters ( RequestForm ) : <EOL> resolve = f . CharField ( required = False ) <EOL> resolve_depth = f . IntegerField ( ) <EOL> resolve_timeout = f . FloatField ( ) <EOL> @ classmethod <EOL> def from_request ( cls , request ) : <EOL> request [ '<STR_LIT>' ] = request . get ( '<STR_LIT>' ) <EOL> request [ '<STR_LIT>' ] = int ( request . get ( '<STR_LIT>' , '<STR_LIT:0>' ) ) <EOL> request [ '<STR_LIT>' ] = float ( request . get ( '<STR_LIT>' , '<STR_LIT:0>' ) ) <EOL> class CannotLockAllFeatures ( common . OWSException ) : <EOL> """<STR_LIT>""" <EOL> class DuplicateStoredQueryIdValue ( common . OWSException ) : <EOL> """<STR_LIT>""" <EOL> class DuplicateStoredQueryParameterName ( common . OWSException ) : <EOL> """<STR_LIT>""" <EOL> class FeaturesNotLocked ( common . OWSException ) : <EOL> """<STR_LIT>""" <EOL> class InvalidLockId ( common . OWSException ) : <EOL> """<STR_LIT>""" <EOL> class InvalidValue ( common . OWSException ) : <EOL> """<STR_LIT>""" <EOL> class LockHasExpired ( common . OWSException ) : <EOL> """<STR_LIT>""" <EOL> class OperationParsingFailed ( common . OWSException ) : <EOL> """<STR_LIT>""" <EOL> class OperationProcessingFailed ( common . OWSException ) : <EOL> """<STR_LIT>""" <EOL> class ResponseCacheExpired ( common . OWSException ) : <EOL> """<STR_LIT>""" <EOL> class OperationNotSupported ( common . OWSException ) : <EOL> """<STR_LIT>""" <EOL> FeatureDescription = namedtuple ( '<STR_LIT>' , ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT:name>' , '<STR_LIT:title>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) ) <EOL> StoredQueryParameter = namedtuple ( "<STR_LIT>" , ( '<STR_LIT:type>' , '<STR_LIT:name>' , '<STR_LIT:title>' , '<STR_LIT>' , '<STR_LIT>' ) ) <EOL> StoredQueryExpression = namedtuple ( "<STR_LIT>" , ( '<STR_LIT:text>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) ) <EOL> StoredQueryDescription = namedtuple ( "<STR_LIT>" , ( '<STR_LIT:name>' , '<STR_LIT>' , '<STR_LIT:title>' , '<STR_LIT>' ) ) <EOL> class WFSAdapter ( object ) : <EOL> """<STR_LIT>""" <EOL> def get_feature_descriptions ( self , request , * types ) : <EOL> raise OperationNotSupported . at ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> def list_stored_queries ( self , request ) : <EOL> """<STR_LIT>""" <EOL> queries = dict ( [ ( q [ <NUM_LIT:3> : ] , [ ] ) for q in filter ( lambda x : x . startswith ( "<STR_LIT>" ) , <EOL> reduce ( <EOL> list . __add__ , <EOL> [ c . __dict__ . keys ( ) for c in self . __class__ . mro ( ) ] <EOL> ) <EOL> ) ] ) <EOL> return queries <EOL> def get_features ( self , request , parms ) : <EOL> raise OperationNotSupported . at ( '<STR_LIT>' , "<STR_LIT>" ) <EOL> def supports_feature_versioning ( self ) : <EOL> return False <EOL> class GeoDjangoWFSAdapter ( WFSAdapter ) : <EOL> def __init__ ( self , models ) : <EOL> self . models = { } <EOL> self . srids = { } <EOL> self . geometries = { } <EOL> for model in models : <EOL> self . models [ model . _meta . app_label + "<STR_LIT::>" + model . _meta . object_name ] = model <EOL> for field in model . _meta . fields : <EOL> if isinstance ( field , GeometryField ) : <EOL> self . geometries [ model . _meta . app_label + "<STR_LIT::>" + model . _meta . object_name ] = field <EOL> self . srids [ model . _meta . app_label + "<STR_LIT::>" + model . _meta . object_name ] = field . srid <EOL> def list_stored_queries ( self , request ) : <EOL> sq = super ( GeoDjangoWFSAdapter , self ) . list_stored_queries ( request ) <EOL> fts = list ( self . models . keys ( ) ) <EOL> for k in sq . keys ( ) : <EOL> sq [ k ] = StoredQueryDescription ( name = k , feature_types = fts , title = k , parameters = [ ] ) <EOL> return sq <EOL> def get_feature_descriptions ( self , request , * types ) : <EOL> namespace = request . build_absolute_uri ( ) . split ( '<STR_LIT:?>' ) [ <NUM_LIT:0> ] + "<STR_LIT>" <EOL> for model in self . models . values ( ) : <EOL> if model . objects . count ( ) > <NUM_LIT:0> : <EOL> extent = model . objects . extent ( ) <EOL> else : <EOL> extent = ( <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> ) <EOL> yield FeatureDescription ( <EOL> ns = namespace , <EOL> ns_name = model . _meta . app_label , <EOL> name = model . _meta . object_name , <EOL> abstract = model . __doc__ , <EOL> title = model . _meta . verbose_name , <EOL> keywords = [ ] , <EOL> srs = self . srids [ model . _meta . app_label + "<STR_LIT::>" + model . _meta . object_name ] , <EOL> bbox = extent , <EOL> schema = namespace <EOL> ) <EOL> def get_features ( self , request , parms ) : <EOL> if parms . cleaned_data [ '<STR_LIT>' ] : <EOL> squid = "<STR_LIT>" + parms . cleaned_data [ '<STR_LIT>' ] <EOL> try : <EOL> return self . __getattribute__ ( squid ) ( request , parms ) <EOL> except AttributeError : <EOL> raise OperationNotSupported . at ( '<STR_LIT>' , '<STR_LIT>' . format ( squid = squid ) ) <EOL> else : <EOL> return self . AdHocQuery ( request , parms ) <EOL> def AdHocQuery ( self , request , parms ) : <EOL> type_names = parms . cleaned_data [ '<STR_LIT>' ] <EOL> flt = parms . cleaned_data [ '<STR_LIT>' ] <EOL> flt_lang = parms . cleaned_data [ '<STR_LIT>' ] <EOL> bbox = parms . cleaned_data [ '<STR_LIT>' ] <EOL> sort_by = parms . cleaned_data [ '<STR_LIT>' ] <EOL> count = parms . cleaned_data [ '<STR_LIT:count>' ] <EOL> if not count : <EOL> count = parms . cleaned_data [ '<STR_LIT>' ] <EOL> start_index = parms . cleaned_data [ '<STR_LIT>' ] <EOL> srs_name = parms . cleaned_data [ '<STR_LIT>' ] <EOL> srs_format = parms . cleaned_data [ '<STR_LIT>' ] <EOL> model = self . models [ type_names [ <NUM_LIT:0> ] ] <EOL> geometry_field = self . geometries [ type_names [ <NUM_LIT:0> ] ] <EOL> query_set = model . objects . all ( ) <EOL> if bbox : <EOL> mnx , mny , mxx , mxy = bbox <EOL> query_set . filter ( ** { geometry_field . name + "<STR_LIT>" : <EOL> "<STR_LIT>" . format ( <EOL> mnx = mnx , <EOL> mny = mny , <EOL> mxx = mxx , <EOL> mxy = mxy ) <EOL> } ) <EOL> if flt : <EOL> flt = json . loads ( flt ) <EOL> query_set = query_set . filter ( ** flt ) <EOL> if sort_by and '<STR_LIT:U+002C>' in sort_by : <EOL> sort_by = sort_by . split ( '<STR_LIT:U+002C>' ) <EOL> query_set = query_set . order_by ( * sort_by ) <EOL> elif sort_by : <EOL> query_set = query_set . order_by ( sort_by ) <EOL> if start_index and count : <EOL> query_set = query_set [ start_index : start_index + count ] <EOL> elif start_index : <EOL> query_set = query_set [ start_index : ] <EOL> elif count : <EOL> query_set = query_set [ : count ] <EOL> if srs_name : <EOL> if ( not srs_format or srs_format == '<STR_LIT>' ) and srs_name != geometry_field . srid : <EOL> if srs_name . lower ( ) . startswith ( '<STR_LIT>' ) : <EOL> srs_name = srs_name [ <NUM_LIT:5> : ] <EOL> query_set . transform ( int ( srs_name ) ) <EOL> return query_set <EOL> def SQ_GetFeatureById ( self , request , parms ) : <EOL> my_parms = GetFeatureByIdParameters . create ( request . REQUEST ) <EOL> typename , pk = my_parms . cleaned_data [ '<STR_LIT>' ] . split ( '<STR_LIT:.>' ) <EOL> return self . models [ typename ] . objects . filter ( pk = int ( pk ) ) <EOL> class WFSBase ( object ) : <EOL> """<STR_LIT>""" <EOL> adapter = None <EOL> class DescribeFeatureTypeMixin ( WFSBase ) : <EOL> """<STR_LIT>""" <EOL> class Parameters ( <EOL> CommonParameters <EOL> ) : <EOL> type_names = MultipleValueField ( ) <EOL> output_format = f . CharField ( ) <EOL> @ classmethod <EOL> def from_request ( cls , request ) : <EOL> request [ '<STR_LIT>' ] = request . getlist ( '<STR_LIT>' ) + request . getlist ( '<STR_LIT>' ) <EOL> request [ '<STR_LIT>' ] = request . get ( '<STR_LIT>' , "<STR_LIT>" ) <EOL> def _parse_xml_DescribeFeatureType ( self , request ) : <EOL> """<STR_LIT>""" <EOL> def add_ns ( it , ns ) : <EOL> x = it . split ( '<STR_LIT::>' ) <EOL> if len ( x ) > <NUM_LIT:1> : <EOL> return ns [ x [ <NUM_LIT:0> ] ] , x [ <NUM_LIT:1> ] <EOL> else : <EOL> return '<STR_LIT>' , x <EOL> root = etree . fromstring ( request ) <EOL> xmlns = root . get ( '<STR_LIT>' ) <EOL> output_format = root . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> if xmlns is not None : <EOL> xmlns = "<STR_LIT:{>" + xmlns + "<STR_LIT:}>" <EOL> else : <EOL> xmlns = "<STR_LIT>" <EOL> namespaces = { } <EOL> for name , value in root . attrib . items ( ) : <EOL> if name . startswith ( xmlns ) : <EOL> namespaces [ value ] = name [ len ( xmlns ) : ] <EOL> type_names = root . get ( '<STR_LIT>' ) <EOL> if type_names is not None : <EOL> type_names = [ add_ns ( n , namespaces ) for n in type_names . split ( '<STR_LIT:U+002C>' ) ] <EOL> else : <EOL> type_names = [ ] <EOL> for elt in root : <EOL> if elt . tag . endswith ( "<STR_LIT>" ) : <EOL> namespace , name = elt . text . split ( "<STR_LIT::>" ) <EOL> namespace = namespaces [ namespace ] <EOL> type_names . append ( ( namespace , name ) ) <EOL> if not len ( type_names ) : <EOL> type_names = '<STR_LIT:all>' <EOL> return DescribeFeatureTypeMixin . Parameters . create ( CaseInsensitiveDict ( { "<STR_LIT>" : type_names , "<STR_LIT>" : output_format } ) ) <EOL> def _response_xml_DescribeFeatureType ( self , response ) : <EOL> return render_to_response ( "<STR_LIT>" , { "<STR_LIT>" : list ( response ) } ) <EOL> def _response_json_DescribeFeatureType ( self , response , callback = None ) : <EOL> rsp = [ ] <EOL> for feature_type in response : <EOL> rsp . append ( { <EOL> "<STR_LIT>" : feature_type . schema , <EOL> "<STR_LIT:name>" : feature_type . name , <EOL> "<STR_LIT>" : feature_type . abstract , <EOL> "<STR_LIT:title>" : feature_type . title , <EOL> "<STR_LIT>" : feature_type . ns_name <EOL> } ) <EOL> if callback is not None : <EOL> return HttpResponse ( callback + "<STR_LIT:(>" + json . dumps ( rsp ) + "<STR_LIT:)>" , mimetype = '<STR_LIT>' ) <EOL> else : <EOL> return HttpResponse ( json . dumps ( rsp ) , mimetype = '<STR_LIT:application/json>' ) <EOL> def DescribeFeatureType ( self , request , kwargs ) : <EOL> """<STR_LIT>""" <EOL> if '<STR_LIT>' in kwargs : <EOL> parms = self . _parse_xml_DescribeFeatureType ( kwargs [ '<STR_LIT>' ] ) <EOL> else : <EOL> parms = DescribeFeatureTypeMixin . Parameters . create ( kwargs ) <EOL> response = self . adapter . get_feature_descriptions ( request , * parms . cleaned_data [ '<STR_LIT>' ] ) <EOL> if parms . cleaned_data [ '<STR_LIT>' ] . endswith ( '<STR_LIT>' ) : <EOL> if '<STR_LIT>' in kwargs : <EOL> return self . _response_json_DescribeFeatureType ( response , callback = kwargs [ '<STR_LIT>' ] ) <EOL> elif '<STR_LIT>' in kwargs : <EOL> return self . _response_json_DescribeFeatureType ( response , callback = kwargs [ '<STR_LIT>' ] ) <EOL> else : <EOL> return self . _response_json_DescribeFeatureType ( response ) <EOL> else : <EOL> return self . _response_xml_DescribeFeatureType ( response ) <EOL> class GetFeatureMixin ( WFSBase ) : <EOL> """<STR_LIT>""" <EOL> class Parameters ( <EOL> CommonParameters , <EOL> InputParameters , <EOL> PresentationParameters , <EOL> AdHocQueryParameters , <EOL> StoredQueryParameters <EOL> ) : <EOL> pass <EOL> def _parse_xml_GetFeature ( self , request ) : <EOL> """<STR_LIT:U+0020>""" <EOL> raise OperationNotSupported . at ( "<STR_LIT>" , "<STR_LIT>" ) <EOL> def GetFeature ( self , request , kwargs ) : <EOL> """<STR_LIT:U+0020>""" <EOL> mimetypes = { <EOL> '<STR_LIT>' : '<STR_LIT:application/json>' <EOL> } <EOL> if '<STR_LIT>' in kwargs : <EOL> parms = self . _parse_xml_GetFeature ( kwargs [ '<STR_LIT>' ] ) <EOL> else : <EOL> parms = GetFeatureMixin . Parameters . create ( kwargs ) <EOL> response = self . adapter . get_features ( request , parms ) <EOL> if isinstance ( response , GeoQuerySet ) : <EOL> layer = None <EOL> db_params = settings . DATABASES [ response . db ] <EOL> if db_params [ '<STR_LIT>' ] . endswith ( '<STR_LIT>' ) : <EOL> from psycopg2 . extensions import adapt <EOL> query , parameters = response . query . get_compiler ( response . db ) . as_sql ( ) <EOL> parameters = tuple ( [ adapt ( p ) for p in parameters ] ) <EOL> query = query % parameters <EOL> drv = ogr . GetDriverByName ( "<STR_LIT>" ) <EOL> connection_string = "<STR_LIT>" . format ( db = db_params [ '<STR_LIT>' ] ) <EOL> if '<STR_LIT>' in db_params and db_params [ '<STR_LIT>' ] : <EOL> connection_string += "<STR_LIT>" . format ( host = db_params [ '<STR_LIT>' ] ) <EOL> if '<STR_LIT>' in db_params and db_params [ '<STR_LIT>' ] : <EOL> connection_string += "<STR_LIT>" . format ( port = db_params [ '<STR_LIT>' ] ) <EOL> if '<STR_LIT>' in db_params and db_params [ '<STR_LIT>' ] : <EOL> connection_string += "<STR_LIT>" . format ( user = db_params [ '<STR_LIT>' ] ) <EOL> if '<STR_LIT>' in db_params and db_params [ '<STR_LIT>' ] : <EOL> connection_string += "<STR_LIT>" . format ( password = db_params [ '<STR_LIT>' ] ) <EOL> conn = drv . Open ( connection_string ) <EOL> layer = conn . ExecuteSQL ( query . encode ( '<STR_LIT:ascii>' ) ) <EOL> elif db_params [ '<STR_LIT>' ] . endswith ( '<STR_LIT>' ) : <EOL> from psycopg2 . extensions import adapt <EOL> query , parameters = response . query . get_compiler ( response . db ) . as_sql ( ) <EOL> parameters = tuple ( [ adapt ( p ) for p in parameters ] ) <EOL> query = query % parameters <EOL> drv = ogr . GetDriverByName ( "<STR_LIT>" ) <EOL> conn = drv . Open ( db_params [ '<STR_LIT>' ] ) <EOL> layer = conn . ExecuteSQL ( query ) <EOL> else : <EOL> layer = response . GetLayerByIndex ( <NUM_LIT:0> ) <EOL> drivers = dict ( [ ( ogr . GetDriver ( drv ) . GetName ( ) , ogr . GetDriver ( drv ) ) for drv in range ( ogr . GetDriverCount ( ) ) if ogr . GetDriver ( drv ) . TestCapability ( ogr . ODrCCreateDataSource ) ] ) <EOL> output_format = parms . cleaned_data [ '<STR_LIT>' ] . decode ( '<STR_LIT:ascii>' ) <EOL> if '<STR_LIT>' in output_format or '<STR_LIT>' in output_format : <EOL> tmpname = "<STR_LIT>" . format ( tmpdir = gettempdir ( ) , uuid = uuid4 ( ) , output_format = '<STR_LIT>' , sep = os . path . sep ) <EOL> drv = ogr . GetDriverByName ( "<STR_LIT>" ) <EOL> ds = drv . CreateDataSource ( tmpname ) <EOL> l2 = ds . CopyLayer ( layer , '<STR_LIT>' ) <EOL> l2 . SyncToDisk ( ) <EOL> del ds <EOL> responsef = open ( tmpname ) <EOL> rdata = responsef . read ( ) <EOL> responsef . close ( ) <EOL> os . unlink ( tmpname ) <EOL> return HttpResponse ( rdata , mimetype = output_format ) <EOL> elif output_format in drivers : <EOL> tmpname = "<STR_LIT>" . format ( tmpdir = gettempdir ( ) , uuid = uuid4 ( ) , output_format = output_format , sep = os . path . sep ) <EOL> drv = drivers [ output_format ] <EOL> ds = drv . CreateDataSource ( tmpname ) <EOL> l2 = ds . CopyLayer ( layer , '<STR_LIT>' ) <EOL> l2 . SyncToDisk ( ) <EOL> del ds <EOL> responsef = open ( tmpname ) <EOL> rdata = responsef . read ( ) <EOL> responsef . close ( ) <EOL> os . unlink ( tmpname ) <EOL> return HttpResponse ( rdata , mimetype = mimetypes . get ( output_format , '<STR_LIT>' ) ) <EOL> else : <EOL> raise OperationProcessingFailed . at ( '<STR_LIT>' , '<STR_LIT>' . format ( of = output_format , formats = drivers . keys ( ) ) ) <EOL> class ListStoredQueriesMixin ( WFSBase ) : <EOL> """<STR_LIT>""" <EOL> def ListStoredQueries ( self , request , kwargs ) : <EOL> """<STR_LIT:U+0020>""" <EOL> queries = self . adapter . list_stored_queries ( request ) <EOL> response = etree . Element ( "<STR_LIT>" ) <EOL> for query , description in queries . items ( ) : <EOL> sub = etree . SubElement ( response , "<STR_LIT>" ) <EOL> etree . SubElement ( sub , "<STR_LIT>" ) . text = query <EOL> for feature_type in description . feature_types : <EOL> etree . SubElement ( sub , '<STR_LIT>' ) . text = feature_type <EOL> return HttpResponse ( etree . tostring ( response , pretty_print = True ) , mimetype = '<STR_LIT>' ) <EOL> class DescribeStoredQueriesMixin ( WFSBase ) : <EOL> class Parameters ( CommonParameters ) : <EOL> stored_query_id = MultipleValueField ( ) <EOL> @ classmethod <EOL> def from_request ( cls , request ) : <EOL> request [ '<STR_LIT>' ] = request . getlist ( '<STR_LIT>' ) <EOL> def DescribeStoredQueries ( self , request , kwargs ) : <EOL> parms = DescribeStoredQueriesMixin . Parameters . create ( kwargs ) <EOL> inspected_queries = parms . cleaned_data [ '<STR_LIT>' ] <EOL> response = etree . Element ( '<STR_LIT>' ) <EOL> for query , description in filter ( lambda ( x , y ) : x in inspected_queries , self . adapter . list_stored_queries ( request ) . items ( ) ) : <EOL> desc = etree . SubElement ( response , "<STR_LIT>" ) <EOL> etree . SubElement ( desc , '<STR_LIT>' ) . text = query <EOL> for parameter in description . parameters : <EOL> p = etree . SubElement ( desc , "<STR_LIT>" , attrib = { "<STR_LIT:name>" : parameter . name , "<STR_LIT:type>" : parameter . type } ) <EOL> etree . SubElement ( p , '<STR_LIT>' ) . text = parameter . title <EOL> etree . SubElement ( p , '<STR_LIT>' ) . text = parameter . abstractS <EOL> if parameter . query_expression : <EOL> etree . SubElement ( p , "<STR_LIT>" , attrib = { <EOL> "<STR_LIT>" : parameter . query_expression . private == True , <EOL> "<STR_LIT>" : parameter . query_expression . language , <EOL> "<STR_LIT>" : '<STR_LIT:U+0020>' . join ( parameter . query_expression . return_feature_types ) <EOL> } ) . text = parameter . query_expression . text <EOL> return HttpResponse ( etree . tostring ( response , pretty_print = True ) , mimetype = '<STR_LIT>' ) <EOL> class CreateStoredQuery ( WFSBase ) : <EOL> def CreateStoredQuery ( self , request , kwargs ) : <EOL> raise OperationNotSupported . at ( "<STR_LIT>" ) <EOL> class DropStoredQuery ( WFSBase ) : <EOL> def DropStoredQuery ( self , request , kwargs ) : <EOL> raise OperationNotSupported . at ( "<STR_LIT>" ) <EOL> class TransactionMixin ( WFSBase ) : <EOL> def Transaction ( self , request , kwargs ) : <EOL> """<STR_LIT:U+0020>""" <EOL> raise OperationNotSupported . at ( '<STR_LIT>' ) <EOL> class GetFeatureWithLockMixin ( WFSBase ) : <EOL> def GetFeatureWithLock ( self , request , kwargs ) : <EOL> raise OperationNotSupported . at ( "<STR_LIT>" ) <EOL> class LockFeatureMixin ( WFSBase ) : <EOL> def LockFeature ( self , request , kwargs ) : <EOL> raise OperationNotSupported . at ( '<STR_LIT>' ) <EOL> class GetPropertyValueMixin ( WFSBase ) : <EOL> class Parameters ( StoredQueryParameters , AdHocQueryParameters ) : <EOL> value_reference = f . CharField ( ) <EOL> resolve_path = f . CharField ( required = False ) <EOL> def from_request ( cls , request ) : <EOL> request [ '<STR_LIT>' ] = request [ '<STR_LIT>' ] <EOL> request [ '<STR_LIT>' ] = request [ '<STR_LIT>' ] <EOL> def GetPropertyValue ( self , request , kwargs ) : <EOL> raise OperationNotSupported . at ( '<STR_LIT>' ) <EOL> class WFS ( <EOL> common . OWSView , <EOL> GetCapabilitiesMixin , <EOL> DescribeFeatureTypeMixin , <EOL> DescribeStoredQueriesMixin , <EOL> GetFeatureMixin , <EOL> ListStoredQueriesMixin , <EOL> GetPropertyValueMixin <EOL> ) : <EOL> """<STR_LIT>""" <EOL> adapter = None <EOL> models = None <EOL> title = None <EOL> keywords = [ ] <EOL> fees = None <EOL> access_constraints = None <EOL> provider_name = None <EOL> addr_street = None <EOL> addr_city = None <EOL> addr_admin_area = None <EOL> addr_postcode = None <EOL> addr_country = None <EOL> addr_email = None <EOL> def __init__ ( self , ** kwargs ) : <EOL> common . OWSView . __init__ ( self , ** kwargs ) <EOL> if self . models : <EOL> self . adapter = GeoDjangoWFSAdapter ( self . models ) <EOL> def get_capabilities_response ( self , request , params ) : <EOL> return render_to_response ( '<STR_LIT>' , { <EOL> "<STR_LIT:title>" : self . title , <EOL> "<STR_LIT>" : self . keywords , <EOL> "<STR_LIT>" : self . fees , <EOL> "<STR_LIT>" : self . access_constraints , <EOL> "<STR_LIT>" : request . build_absolute_uri ( ) . split ( '<STR_LIT:?>' ) [ <NUM_LIT:0> ] , <EOL> "<STR_LIT>" : [ ogr . GetDriver ( drv ) . GetName ( ) for drv in range ( ogr . GetDriverCount ( ) ) if ogr . GetDriver ( drv ) . TestCapability ( ogr . ODrCCreateDataSource ) ] , <EOL> "<STR_LIT>" : self . addr_street , <EOL> "<STR_LIT>" : self . addr_city , <EOL> "<STR_LIT>" : self . addr_admin_area , <EOL> "<STR_LIT>" : self . addr_postcode , <EOL> "<STR_LIT>" : self . addr_country , <EOL> "<STR_LIT>" : False , <EOL> "<STR_LIT>" : False , <EOL> '<STR_LIT>' : self . adapter . get_feature_descriptions ( request ) <EOL> } ) <EOL> class WFST ( WFS , TransactionMixin , GetFeatureWithLockMixin , LockFeatureMixin ) : <EOL> """<STR_LIT>""" <EOL> def get_capabilities_response ( self , request , params ) : <EOL> return render_to_response ( '<STR_LIT>' , { <EOL> "<STR_LIT:title>" : self . title , <EOL> "<STR_LIT>" : self . keywords , <EOL> "<STR_LIT>" : self . fees , <EOL> "<STR_LIT>" : self . access_constraints , <EOL> "<STR_LIT>" : request . build_absolute_uri ( ) . split ( '<STR_LIT:?>' ) [ <NUM_LIT:0> ] , <EOL> "<STR_LIT>" : [ ogr . GetDriver ( drv ) . GetName ( ) for drv in range ( ogr . GetDriverCount ( ) ) if ogr . GetDriver ( drv ) . TestCapability ( ogr . ODrCCreateDataSource ) ] , <EOL> "<STR_LIT>" : self . addr_street , <EOL> "<STR_LIT>" : self . addr_city , <EOL> "<STR_LIT>" : self . addr_admin_area , <EOL> "<STR_LIT>" : self . addr_postcode , <EOL> "<STR_LIT>" : self . addr_country , <EOL> "<STR_LIT>" : self . adapter . supports_feature_versioning ( ) , <EOL> "<STR_LIT>" : True , <EOL> '<STR_LIT>' : self . adapter . get_feature_descriptions ( request ) <EOL> } ) </s>
<s> from sondra . document . valuehandlers import DateTime , Geometry , Now <EOL> from shapely . geometry import Point <EOL> from datetime import datetime <EOL> import rethinkdb as r <EOL> import pytest <EOL> from sondra . tests . api import * <EOL> from sondra . auth import Auth <EOL> s = ConcreteSuite ( ) <EOL> api = SimpleApp ( s ) <EOL> auth = Auth ( s ) <EOL> AuthenticatedApp ( s ) <EOL> AuthorizedApp ( s ) <EOL> s . ensure_database_objects ( ) <EOL> @ pytest . fixture ( scope = '<STR_LIT>' ) <EOL> def simple_doc ( request ) : <EOL> simple_doc = s [ '<STR_LIT>' ] [ '<STR_LIT>' ] . create ( { <EOL> '<STR_LIT:name>' : "<STR_LIT>" , <EOL> "<STR_LIT:date>" : datetime . now ( ) , <EOL> "<STR_LIT:value>" : <NUM_LIT:0> <EOL> } ) <EOL> def teardown ( ) : <EOL> simple_doc . delete ( ) <EOL> request . addfinalizer ( teardown ) <EOL> return simple_doc <EOL> @ pytest . fixture ( scope = '<STR_LIT>' ) <EOL> def fk_doc ( request , simple_doc ) : <EOL> fk_doc = s [ '<STR_LIT>' ] [ '<STR_LIT>' ] . create ( { <EOL> '<STR_LIT:name>' : "<STR_LIT>" , <EOL> '<STR_LIT>' : simple_doc , <EOL> '<STR_LIT>' : [ simple_doc ] <EOL> } ) <EOL> def teardown ( ) : <EOL> fk_doc . delete ( ) <EOL> request . addfinalizer ( teardown ) <EOL> return fk_doc <EOL> def test_foreignkey ( fk_doc , simple_doc ) : <EOL> retr_doc = s [ '<STR_LIT>' ] [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> assert isinstance ( fk_doc . obj [ '<STR_LIT>' ] , str ) <EOL> assert fk_doc . obj [ '<STR_LIT>' ] == simple_doc . url <EOL> assert isinstance ( retr_doc . obj [ '<STR_LIT>' ] , str ) <EOL> assert retr_doc . obj [ '<STR_LIT>' ] == simple_doc . url <EOL> storage_repr = fk_doc . rql_repr ( ) <EOL> assert storage_repr [ '<STR_LIT>' ] == simple_doc . id <EOL> assert isinstance ( fk_doc [ '<STR_LIT>' ] , SimpleDocument ) </s>
<s> import os <EOL> from PySide . QtGui import * <EOL> from PySide . QtCore import * <EOL> from ui_Event import Ui_Event <EOL> '''<STR_LIT>''' <EOL> class EventWindow ( QDialog , Ui_Event ) : <EOL> def __init__ ( self , parent , eventId ) : <EOL> super ( EventWindow , self ) . __init__ ( parent ) <EOL> self . rent = parent <EOL> self . data = parent . eventData [ eventId ] <EOL> self . deckAssignment = [ ] <EOL> self . setupUi ( self ) <EOL> self . assignWidgets ( ) <EOL> self . setWindowTitle ( unicode ( "<STR_LIT>" % eventId ) ) <EOL> def savePressed ( self ) : <EOL> self . data [ "<STR_LIT>" ] = self . notesText . toPlainText ( ) <EOL> self . data [ "<STR_LIT>" ] = self . deckText . text ( ) <EOL> self . data [ "<STR_LIT>" ] = self . placeText . text ( ) <EOL> self . data [ "<STR_LIT>" ] = self . eventTypeText . text ( ) <EOL> self . data [ "<STR_LIT>" ] = self . playersText . text ( ) <EOL> self . data [ "<STR_LIT>" ] = self . formatText . text ( ) <EOL> self . data [ "<STR_LIT>" ] = self . locationText . text ( ) <EOL> self . data [ "<STR_LIT>" ] = self . dateText . text ( ) <EOL> ourCounter = <NUM_LIT:0> <EOL> for ourRound in self . deckAssignment : <EOL> self . data [ "<STR_LIT>" ] [ self . deckAssignment [ ourCounter ] [ <NUM_LIT:0> ] ] [ <NUM_LIT:2> ] = self . deckAssignment [ ourCounter ] [ <NUM_LIT:1> ] <EOL> ourCounter += <NUM_LIT:1> <EOL> self . rent . updateGUI ( ) <EOL> self . rent . messageBox ( "<STR_LIT>" ) <EOL> def closePressed ( self ) : <EOL> self . hide ( ) <EOL> def roundSelected ( self , ourRound , ourColumn ) : <EOL> ourIndex = int ( ourRound . text ( <NUM_LIT:0> ) ) - <NUM_LIT:1> <EOL> deckName , ok = QInputDialog . getText ( self , "<STR_LIT>" , <EOL> "<STR_LIT>" ) <EOL> if ok and deckName : <EOL> self . data [ "<STR_LIT>" ] [ ourIndex ] [ <NUM_LIT:3> ] . setData ( <NUM_LIT:3> , <NUM_LIT:0> , deckName ) <EOL> self . deckAssignment . append ( [ ourIndex , deckName ] ) <EOL> def assignWidgets ( self ) : <EOL> self . saveChangesButton . clicked . connect ( self . savePressed ) <EOL> self . closeButton . clicked . connect ( self . closePressed ) <EOL> self . roundTree . itemDoubleClicked . connect ( self . roundSelected ) <EOL> self . notesText . setPlainText ( self . data [ "<STR_LIT>" ] ) <EOL> self . deckText . setText ( self . data [ "<STR_LIT>" ] ) <EOL> self . placeText . setText ( self . data [ "<STR_LIT>" ] ) <EOL> self . eventTypeText . setText ( self . data [ "<STR_LIT>" ] ) <EOL> self . playersText . setText ( self . data [ "<STR_LIT>" ] ) <EOL> self . formatText . setText ( self . data [ "<STR_LIT>" ] ) <EOL> self . locationText . setText ( self . data [ "<STR_LIT>" ] ) <EOL> self . dateText . setText ( self . data [ "<STR_LIT>" ] ) <EOL> matchItem = TreeWidgetItem ( self . resultsTree ) <EOL> matchItem . setText ( <NUM_LIT:0> , unicode ( self . data [ "<STR_LIT>" ] ) ) <EOL> matchItem . setText ( <NUM_LIT:1> , unicode ( self . data [ "<STR_LIT>" ] ) ) <EOL> matchItem . setText ( <NUM_LIT:2> , unicode ( self . data [ "<STR_LIT>" ] ) ) <EOL> matchItem . setText ( <NUM_LIT:3> , unicode ( self . data [ "<STR_LIT>" ] ) ) <EOL> self . resultsTree . addTopLevelItem ( matchItem ) <EOL> for i in range ( <NUM_LIT:4> ) : <EOL> self . resultsTree . resizeColumnToContents ( i ) <EOL> roundCounter = <NUM_LIT:1> <EOL> for opponent in self . data [ "<STR_LIT>" ] : <EOL> roundItem = TreeWidgetItem ( self . roundTree ) <EOL> roundItem . setText ( <NUM_LIT:0> , unicode ( roundCounter ) ) <EOL> roundItem . setText ( <NUM_LIT:1> , unicode ( opponent [ <NUM_LIT:0> ] ) ) <EOL> roundItem . setText ( <NUM_LIT:2> , unicode ( opponent [ <NUM_LIT:1> ] ) ) <EOL> roundItem . setText ( <NUM_LIT:3> , unicode ( opponent [ <NUM_LIT:2> ] ) ) <EOL> opponent [ <NUM_LIT:3> ] = roundItem <EOL> self . roundTree . addTopLevelItem ( roundItem ) <EOL> roundCounter += <NUM_LIT:1> <EOL> for i in range ( <NUM_LIT:4> ) : <EOL> self . roundTree . resizeColumnToContents ( i ) <EOL> class TreeWidgetItem ( QTreeWidgetItem ) : <EOL> def __init__ ( self , parent = None ) : <EOL> QTreeWidgetItem . __init__ ( self , parent ) <EOL> def __lt__ ( self , otherItem ) : <EOL> column = self . treeWidget ( ) . sortColumn ( ) <EOL> try : <EOL> return float ( self . text ( column ) ) > float ( otherItem . text ( column ) ) <EOL> except ValueError : <EOL> return self . text ( column ) > otherItem . text ( column ) </s>
<s> """<STR_LIT>""" <EOL> import numpy as np <EOL> from pylatex import Document , Section , Subsection , Math , Matrix , VectorName <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL> a = np . array ( [ [ <NUM_LIT:100> , <NUM_LIT:10> , <NUM_LIT:20> ] ] ) . T <EOL> doc = Document ( ) <EOL> section = Section ( '<STR_LIT>' ) <EOL> subsection = Subsection ( '<STR_LIT>' ) <EOL> vec = Matrix ( a ) <EOL> vec_name = VectorName ( '<STR_LIT:a>' ) <EOL> math = Math ( data = [ vec_name , '<STR_LIT:=>' , vec ] ) <EOL> subsection . append ( math ) <EOL> section . append ( subsection ) <EOL> subsection = Subsection ( '<STR_LIT>' ) <EOL> M = np . matrix ( [ [ <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:4> ] , <EOL> [ <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:1> ] , <EOL> [ <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:2> ] ] ) <EOL> matrix = Matrix ( M , mtype = '<STR_LIT:b>' ) <EOL> math = Math ( data = [ '<STR_LIT>' , matrix ] ) <EOL> subsection . append ( math ) <EOL> section . append ( subsection ) <EOL> subsection = Subsection ( '<STR_LIT>' ) <EOL> math = Math ( data = [ '<STR_LIT:M>' , vec_name , '<STR_LIT:=>' , Matrix ( M * a ) ] ) <EOL> subsection . append ( math ) <EOL> section . append ( subsection ) <EOL> doc . append ( section ) <EOL> doc . generate_pdf ( '<STR_LIT>' ) </s>
<s> import quantities as pq <EOL> from pylatex . quantities import _dimensionality_to_siunitx , Quantity <EOL> def test_quantity ( ) : <EOL> v = <NUM_LIT:1> * pq . m / pq . s <EOL> q1 = Quantity ( v ) <EOL> assert q1 . dumps ( ) == r'<STR_LIT>' <EOL> q2 = Quantity ( v , format_cb = lambda x : str ( int ( x ) ) ) <EOL> assert q2 . dumps ( ) == r'<STR_LIT>' <EOL> q3 = Quantity ( v , options = { '<STR_LIT>' : '<STR_LIT:true>' } ) <EOL> ref = r'<STR_LIT>' <EOL> assert q3 . dumps ( ) == ref <EOL> def test_quantity_float ( ) : <EOL> q1 = Quantity ( <NUM_LIT> ) <EOL> assert q1 . dumps ( ) == r'<STR_LIT>' <EOL> def test_quantity_uncertain ( ) : <EOL> t = pq . UncertainQuantity ( <NUM_LIT> , pq . second , <NUM_LIT:1.> ) <EOL> q1 = Quantity ( t ) <EOL> assert q1 . dumps ( ) == r'<STR_LIT>' <EOL> def test_dimensionality_to_siunitx ( ) : <EOL> assert _dimensionality_to_siunitx ( ( pq . volt / pq . kelvin ) . dimensionality ) == r'<STR_LIT>' <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL> test_quantity ( ) <EOL> test_dimensionality_to_siunitx ( ) </s>
<s> from supervisor . medusa import asyncore_25 as asyncore <EOL> from supervisor . medusa import default_handler <EOL> from supervisor . medusa import http_server <EOL> from supervisor . medusa import put_handler <EOL> from supervisor . medusa import auth_handler <EOL> from supervisor . medusa import filesys <EOL> users = { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT>' } <EOL> fs = filesys . os_filesystem ( '<STR_LIT>' ) <EOL> dh = default_handler . default_handler ( fs ) <EOL> ph = put_handler . put_handler ( fs , '<STR_LIT>' ) <EOL> ah = auth_handler . auth_handler ( users , ph ) <EOL> hs = http_server . http_server ( ip = '<STR_LIT>' , port = <NUM_LIT> ) <EOL> hs . install_handler ( dh ) <EOL> hs . install_handler ( ah ) <EOL> asyncore . loop ( ) </s>
<s> import socket <EOL> import string <EOL> from supervisor . medusa import asyncore_25 as asyncore <EOL> from supervisor . medusa import asynchat_25 as asynchat <EOL> class test_client ( asynchat . async_chat ) : <EOL> ac_in_buffer_size = <NUM_LIT> <EOL> ac_out_buffer_size = <NUM_LIT> <EOL> total_in = <NUM_LIT:0> <EOL> concurrent = <NUM_LIT:0> <EOL> max_concurrent = <NUM_LIT:0> <EOL> def __init__ ( self , addr , chain ) : <EOL> asynchat . async_chat . __init__ ( self ) <EOL> self . create_socket ( socket . AF_INET , socket . SOCK_STREAM ) <EOL> self . set_terminator ( '<STR_LIT>' ) <EOL> self . connect ( addr ) <EOL> self . push ( chain ) <EOL> def handle_connect ( self ) : <EOL> test_client . concurrent = test_client . concurrent + <NUM_LIT:1> <EOL> if ( test_client . concurrent > test_client . max_concurrent ) : <EOL> test_client . max_concurrent = test_client . concurrent <EOL> def handle_expt ( self ) : <EOL> print '<STR_LIT>' <EOL> self . close ( ) <EOL> def close ( self ) : <EOL> test_client . concurrent = test_client . concurrent - <NUM_LIT:1> <EOL> asynchat . async_chat . close ( self ) <EOL> def collect_incoming_data ( self , data ) : <EOL> test_client . total_in = test_client . total_in + len ( data ) <EOL> def found_terminator ( self ) : <EOL> pass <EOL> def log ( self , * args ) : <EOL> pass <EOL> import time <EOL> class timer : <EOL> def __init__ ( self ) : <EOL> self . start = time . time ( ) <EOL> def end ( self ) : <EOL> return time . time ( ) - self . start <EOL> def build_request_chain ( num , host , request_size ) : <EOL> s = '<STR_LIT>' % ( request_size , host ) <EOL> sl = [ s ] * ( num - <NUM_LIT:1> ) <EOL> sl . append ( <EOL> '<STR_LIT>' % ( <EOL> request_size , host <EOL> ) <EOL> ) <EOL> return string . join ( sl , '<STR_LIT>' ) <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL> import string <EOL> import sys <EOL> if len ( sys . argv ) != <NUM_LIT:6> : <EOL> print '<STR_LIT>' % sys . argv [ <NUM_LIT:0> ] <EOL> else : <EOL> host = sys . argv [ <NUM_LIT:1> ] <EOL> ip = socket . gethostbyname ( host ) <EOL> [ port , request_size , num_requests , num_conns ] = map ( <EOL> string . atoi , sys . argv [ <NUM_LIT:2> : ] <EOL> ) <EOL> chain = build_request_chain ( num_requests , host , request_size ) <EOL> t = timer ( ) <EOL> for i in range ( num_conns ) : <EOL> test_client ( ( host , port ) , chain ) <EOL> asyncore . loop ( ) <EOL> total_time = t . end ( ) <EOL> total_bytes = test_client . total_in <EOL> num_trans = num_requests * num_conns <EOL> throughput = float ( total_bytes ) / total_time <EOL> trans_per_sec = num_trans / total_time <EOL> sys . stderr . write ( '<STR_LIT>' % total_time ) <EOL> sys . stderr . write ( '<STR_LIT>' % num_trans ) <EOL> sys . stderr . write ( '<STR_LIT>' % total_bytes ) <EOL> sys . stderr . write ( '<STR_LIT>' % throughput ) <EOL> sys . stderr . write ( '<STR_LIT>' % trans_per_sec ) <EOL> sys . stderr . write ( '<STR_LIT>' % test_client . max_concurrent ) <EOL> sys . stdout . write ( <EOL> string . join ( <EOL> map ( str , ( num_conns , num_requests , request_size , throughput , trans_per_sec ) ) , <EOL> '<STR_LIT:U+002C>' <EOL> ) + '<STR_LIT:\n>' <EOL> ) </s>
<s> from os import * <EOL> from os import _exit <EOL> import os <EOL> class FakeOS : <EOL> def __init__ ( self ) : <EOL> self . orig_uid = os . getuid ( ) <EOL> self . orig_gid = os . getgid ( ) <EOL> def setgroups ( * args ) : <EOL> return <EOL> def getuid ( ) : <EOL> return <NUM_LIT:0> <EOL> def setuid ( arg ) : <EOL> self . uid = arg <EOL> self . setuid_called = <NUM_LIT:1> <EOL> def setgid ( arg ) : <EOL> self . gid = arg <EOL> self . setgid_called = <NUM_LIT:1> <EOL> def clear ( ) : <EOL> self . uid = orig_uid <EOL> self . gid = orig_gid <EOL> self . setuid_called = <NUM_LIT:0> <EOL> self . setgid_called = <NUM_LIT:0> <EOL> fake = FakeOS ( ) <EOL> setgroups = fake . setgroups <EOL> getuid = fake . getuid <EOL> setuid = fake . setuid <EOL> setgid = fake . setgid <EOL> clear = fake . clear </s>
<s> import toto <EOL> from toto . invocation import * <EOL> from tornado . ioloop import IOLoop <EOL> @ asynchronous <EOL> def invoke ( handler , params ) : <EOL> def receive_message ( message ) : <EOL> handler . respond ( result = { '<STR_LIT:message>' : message } ) <EOL> handler . register_event_handler ( '<STR_LIT:message>' , receive_message , deregister_on_finish = True ) </s>
<s> import unittest <EOL> from uuid import uuid4 <EOL> from time import time , sleep <EOL> from toto . tasks import TaskQueue , AwaitableInstance , InstancePool <EOL> from tornado . ioloop import IOLoop <EOL> from tornado . gen import coroutine <EOL> class _Instance ( object ) : <EOL> def __init__ ( self ) : <EOL> self . counter = <NUM_LIT:0> <EOL> def increment ( self ) : <EOL> self . counter += <NUM_LIT:1> <EOL> return self . counter <EOL> def value ( self ) : <EOL> return self . counter <EOL> class TestTasks ( unittest . TestCase ) : <EOL> def test_add_task ( self ) : <EOL> queue = TaskQueue ( ) <EOL> self . assertEquals ( len ( queue ) , <NUM_LIT:0> ) <EOL> task_results = [ ] <EOL> task = lambda x : task_results . append ( x ) <EOL> queue . add_task ( task , <NUM_LIT:1> ) <EOL> queue . add_task ( task , <NUM_LIT:2> ) <EOL> queue . add_task ( task , <NUM_LIT:3> ) <EOL> start = time ( ) <EOL> while <NUM_LIT:1> : <EOL> if len ( task_results ) == <NUM_LIT:3> : <EOL> break <EOL> if time ( ) - start > <NUM_LIT:5> : <EOL> break <EOL> sleep ( <NUM_LIT> ) <EOL> self . assertEquals ( len ( task_results ) , <NUM_LIT:3> ) <EOL> self . assertEquals ( task_results , [ <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> ] ) <EOL> def test_yield_task ( self ) : <EOL> queue = TaskQueue ( ) <EOL> task_results = [ ] <EOL> @ coroutine <EOL> def yield_tasks ( ) : <EOL> task = lambda x : x <EOL> futures = [ ] <EOL> futures . append ( queue . yield_task ( task , <NUM_LIT:1> ) ) <EOL> futures . append ( queue . yield_task ( task , <NUM_LIT:2> ) ) <EOL> futures . append ( queue . yield_task ( task , <NUM_LIT:3> ) ) <EOL> res = yield futures <EOL> task_results [ : ] = res <EOL> loop = IOLoop ( ) <EOL> loop . make_current ( ) <EOL> loop . run_sync ( yield_tasks ) <EOL> self . assertEquals ( len ( task_results ) , <NUM_LIT:3> ) <EOL> self . assertEquals ( task_results , [ <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> ] ) <EOL> def test_add_task_exception ( self ) : <EOL> queue = TaskQueue ( ) <EOL> self . assertEquals ( len ( queue ) , <NUM_LIT:0> ) <EOL> task_results = [ ] <EOL> def task ( x ) : <EOL> task_results . append ( x ) <EOL> raise Exception ( '<STR_LIT>' ) <EOL> queue . add_task ( task , <NUM_LIT:1> ) <EOL> queue . add_task ( task , <NUM_LIT:2> ) <EOL> queue . add_task ( task , <NUM_LIT:3> ) <EOL> start = time ( ) <EOL> while <NUM_LIT:1> : <EOL> if len ( task_results ) == <NUM_LIT:3> : <EOL> break <EOL> if time ( ) - start > <NUM_LIT:5> : <EOL> break <EOL> sleep ( <NUM_LIT> ) <EOL> self . assertEquals ( len ( task_results ) , <NUM_LIT:3> ) <EOL> self . assertEquals ( task_results , [ <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> ] ) <EOL> def test_yield_task_exception ( self ) : <EOL> queue = TaskQueue ( ) <EOL> task_results = [ ] <EOL> @ coroutine <EOL> def yield_tasks ( ) : <EOL> def task ( x ) : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> futures = [ ] <EOL> futures . append ( queue . yield_task ( task , <NUM_LIT:1> ) ) <EOL> futures . append ( queue . yield_task ( task , <NUM_LIT:2> ) ) <EOL> futures . append ( queue . yield_task ( task , <NUM_LIT:3> ) ) <EOL> for f in futures : <EOL> try : <EOL> yield f <EOL> except Exception as e : <EOL> task_results . append ( e ) <EOL> loop = IOLoop ( ) <EOL> loop . make_current ( ) <EOL> loop . run_sync ( yield_tasks ) <EOL> self . assertEquals ( len ( task_results ) , <NUM_LIT:3> ) <EOL> for e in task_results : <EOL> self . assertEquals ( e . message , '<STR_LIT>' ) <EOL> def test_awaitable ( self ) : <EOL> instance = _Instance ( ) <EOL> instance . increment ( ) <EOL> self . assertEquals ( instance . value ( ) , <NUM_LIT:1> ) <EOL> awaitable = AwaitableInstance ( instance ) <EOL> @ coroutine <EOL> def yield_tasks ( ) : <EOL> self . assertEquals ( ( yield awaitable . increment ( ) ) , <NUM_LIT:2> ) <EOL> self . assertEquals ( ( yield awaitable . increment ( ) ) , <NUM_LIT:3> ) <EOL> self . assertEquals ( ( yield awaitable . increment ( ) ) , <NUM_LIT:4> ) <EOL> self . assertEquals ( ( yield awaitable . value ( ) ) , <NUM_LIT:4> ) <EOL> loop = IOLoop ( ) <EOL> loop . make_current ( ) <EOL> loop . run_sync ( yield_tasks ) <EOL> self . assertEquals ( instance . value ( ) , <NUM_LIT:4> ) <EOL> def test_instance_pool ( self ) : <EOL> instance1 = _Instance ( ) <EOL> instance2 = _Instance ( ) <EOL> pool = InstancePool ( [ instance1 , instance2 ] ) <EOL> pool . increment ( ) <EOL> pool . increment ( ) <EOL> self . assertEquals ( instance1 . value ( ) , <NUM_LIT:1> ) <EOL> self . assertEquals ( instance2 . value ( ) , <NUM_LIT:1> ) <EOL> pool . transaction ( lambda i : i . increment ( ) ) <EOL> pool . transaction ( lambda i : i . increment ( ) ) <EOL> self . assertEquals ( instance1 . value ( ) , <NUM_LIT:2> ) <EOL> self . assertEquals ( instance2 . value ( ) , <NUM_LIT:2> ) <EOL> @ coroutine <EOL> def yield_tasks ( ) : <EOL> self . assertEquals ( ( yield pool . await ( ) . increment ( ) ) , <NUM_LIT:3> ) <EOL> self . assertEquals ( ( yield pool . await ( ) . increment ( ) ) , <NUM_LIT:3> ) <EOL> self . assertEquals ( instance1 . value ( ) , <NUM_LIT:3> ) <EOL> self . assertEquals ( instance2 . value ( ) , <NUM_LIT:3> ) <EOL> self . assertEquals ( ( yield pool . await_transaction ( lambda i : i . increment ( ) ) ) , <NUM_LIT:4> ) <EOL> self . assertEquals ( ( yield pool . await_transaction ( lambda i : i . increment ( ) ) ) , <NUM_LIT:4> ) <EOL> loop = IOLoop ( ) <EOL> loop . make_current ( ) <EOL> loop . run_sync ( yield_tasks ) <EOL> self . assertEquals ( instance1 . value ( ) , <NUM_LIT:4> ) <EOL> self . assertEquals ( instance2 . value ( ) , <NUM_LIT:4> ) </s>
<s> '''<STR_LIT>''' <EOL> import cPickle as pickle <EOL> from threading import Thread <EOL> from collections import deque <EOL> from tornado . web import * <EOL> from tornado . ioloop import IOLoop <EOL> from traceback import format_exc <EOL> from tornado . options import options <EOL> import zmq <EOL> import logging <EOL> import zlib <EOL> from random import choice , shuffle <EOL> class EventManager ( ) : <EOL> '''<STR_LIT>''' <EOL> def __init__ ( self , address = None ) : <EOL> self . __handlers = { } <EOL> self . address = address <EOL> self . __zmq_context = zmq . Context ( ) <EOL> self . __remote_servers = { } <EOL> self . __thread = None <EOL> self . __queued_servers = deque ( ) <EOL> def register_server ( self , address ) : <EOL> '''<STR_LIT>''' <EOL> if address in self . __remote_servers : <EOL> raise Exception ( '<STR_LIT>' , address ) <EOL> socket = self . __zmq_context . socket ( zmq . PUSH ) <EOL> socket . connect ( address ) <EOL> self . __remote_servers [ address ] = socket <EOL> self . refresh_server_queue ( ) <EOL> def remove_server ( self , address ) : <EOL> '''<STR_LIT>''' <EOL> del self . __remote_servers [ address ] <EOL> self . refresh_server_queue ( ) <EOL> def remove_all_servers ( self ) : <EOL> '''<STR_LIT>''' <EOL> self . __remote_servers . clear ( ) <EOL> self . refresh_server_queue ( ) <EOL> def refresh_server_queue ( self ) : <EOL> '''<STR_LIT>''' <EOL> self . __queued_servers . clear ( ) <EOL> self . __queued_servers . extend ( self . __remote_servers . itervalues ( ) ) <EOL> shuffle ( self . __queued_servers ) <EOL> def register_handler ( self , event_name , event_handler , run_on_main_loop = False , request_handler = None , persist = False ) : <EOL> '''<STR_LIT>''' <EOL> if not event_name in self . __handlers : <EOL> self . __handlers [ event_name ] = set ( ) <EOL> handler_tuple = ( event_handler , run_on_main_loop , request_handler , persist ) <EOL> self . __handlers [ event_name ] . add ( handler_tuple ) <EOL> return ( event_name , handler_tuple ) <EOL> def remove_handler ( self , handler_sig ) : <EOL> '''<STR_LIT>''' <EOL> self . __handlers [ handler_sig [ <NUM_LIT:0> ] ] . discard ( handler_sig [ <NUM_LIT:1> ] ) <EOL> def start_listening ( self ) : <EOL> '''<STR_LIT>''' <EOL> if self . __thread : <EOL> return <EOL> def receive ( ) : <EOL> context = zmq . Context ( ) <EOL> socket = context . socket ( zmq . PULL ) <EOL> socket . bind ( self . address ) <EOL> while True : <EOL> event = pickle . loads ( zlib . decompress ( socket . recv ( ) ) ) <EOL> event_name = event [ '<STR_LIT:name>' ] <EOL> event_args = event [ '<STR_LIT:args>' ] <EOL> if event_name in self . __handlers : <EOL> handlers = self . __handlers [ event_name ] <EOL> for handler in list ( handlers ) : <EOL> if not handler [ <NUM_LIT:3> ] : <EOL> handlers . remove ( handler ) <EOL> try : <EOL> if handler [ <NUM_LIT:2> ] and handler [ <NUM_LIT:2> ] . _finished : <EOL> continue <EOL> if handler [ <NUM_LIT:1> ] : <EOL> ( lambda h : IOLoop . instance ( ) . add_callback ( lambda : h [ <NUM_LIT:0> ] ( event_args ) ) ) ( handler ) <EOL> else : <EOL> handler [ <NUM_LIT:0> ] ( event_args ) <EOL> except Exception as e : <EOL> logging . error ( format_exc ( ) ) <EOL> self . __thread = Thread ( target = receive ) <EOL> self . __thread . daemon = True <EOL> self . __thread . start ( ) <EOL> def send_to_server ( self , address , event_name , event_args ) : <EOL> '''<STR_LIT>''' <EOL> event = { '<STR_LIT:name>' : event_name , '<STR_LIT:args>' : event_args } <EOL> event_data = zlib . compress ( pickle . dumps ( event ) ) <EOL> self . __remote_servers [ address ] . send ( event_data ) <EOL> def send ( self , event_name , event_args , broadcast = True ) : <EOL> '''<STR_LIT>''' <EOL> if not self . __remote_servers : <EOL> return <EOL> event = { '<STR_LIT:name>' : event_name , '<STR_LIT:args>' : event_args } <EOL> event_data = zlib . compress ( pickle . dumps ( event ) ) <EOL> if not broadcast : <EOL> self . __queued_servers [ <NUM_LIT:0> ] . send ( event_data ) <EOL> self . __queued_servers . rotate ( - <NUM_LIT:1> ) <EOL> return <EOL> for socket in self . __queued_servers : <EOL> socket . send ( event_data ) <EOL> @ classmethod <EOL> def instance ( cls ) : <EOL> '''<STR_LIT>''' <EOL> if not hasattr ( cls , '<STR_LIT>' ) : <EOL> cls . _instance = cls ( ) <EOL> return cls . _instance </s>
<s> import toto <EOL> import cPickle as pickle <EOL> import zlib <EOL> import logging <EOL> from threading import Thread <EOL> from tornado . options import options <EOL> from tornado . gen import Task <EOL> from collections import deque <EOL> from time import time <EOL> from uuid import uuid4 <EOL> from traceback import format_exc <EOL> from toto . options import safe_define <EOL> safe_define ( "<STR_LIT>" , type = str , help = "<STR_LIT>" ) <EOL> safe_define ( "<STR_LIT>" , type = str , help = "<STR_LIT>" ) <EOL> safe_define ( "<STR_LIT>" , type = str , default = '<STR_LIT>' , help = "<STR_LIT>" ) <EOL> safe_define ( "<STR_LIT>" , default = <NUM_LIT> , help = "<STR_LIT>" ) <EOL> safe_define ( "<STR_LIT>" , default = False , help = "<STR_LIT>" ) <EOL> safe_define ( "<STR_LIT>" , default = <NUM_LIT:0> , help = "<STR_LIT>" ) <EOL> safe_define ( "<STR_LIT>" , default = '<STR_LIT>' , help = "<STR_LIT>" ) <EOL> safe_define ( "<STR_LIT>" , default = '<STR_LIT>' , help = "<STR_LIT>" ) <EOL> WORKER_SOCKET_CONNECT = '<STR_LIT>' <EOL> WORKER_SOCKET_DISCONNECT = '<STR_LIT>' <EOL> class WorkerConnection ( object ) : <EOL> '''<STR_LIT>''' <EOL> def __getattr__ ( self , path ) : <EOL> return WorkerInvocation ( path , self ) <EOL> def log_error ( self , error ) : <EOL> logging . error ( repr ( error ) ) <EOL> def enable_traceback_logging ( self ) : <EOL> from new import instancemethod <EOL> from traceback import format_exc <EOL> def log_error ( self , e ) : <EOL> logging . error ( format_exc ( ) ) <EOL> self . log_error = instancemethod ( log_error , self ) <EOL> @ classmethod <EOL> def instance ( cls ) : <EOL> '''<STR_LIT>''' <EOL> if not hasattr ( cls , '<STR_LIT>' ) : <EOL> if options . worker_transport == '<STR_LIT:http>' : <EOL> from toto . httpworkerconnection import HTTPWorkerConnection <EOL> cls . _instance = HTTPWorkerConnection . instance ( ) <EOL> else : <EOL> from toto . zmqworkerconnection import ZMQWorkerConnection <EOL> cls . _instance = ZMQWorkerConnection . instance ( ) <EOL> return cls . _instance <EOL> class WorkerInvocation ( object ) : <EOL> def __init__ ( self , path , connection ) : <EOL> self . _path = path <EOL> self . _connection = connection <EOL> def __call__ ( self , * args , ** kwargs ) : <EOL> return self . _connection . invoke ( self . _path , * args , ** kwargs ) <EOL> def __getattr__ ( self , path ) : <EOL> return getattr ( self . _connection , self . _path + '<STR_LIT:.>' + path ) </s>
<s> from . import multiarray <EOL> __all__ = [ ] </s>
<s> """<STR_LIT>""" <EOL> __author__ = '<STR_LIT>' <EOL> import urllib <EOL> from pyactiveresource import connection <EOL> from pyactiveresource import formats <EOL> class Error ( Exception ) : <EOL> """<STR_LIT>""" <EOL> class FakeConnection ( object ) : <EOL> """<STR_LIT>""" <EOL> def __init__ ( self , format = formats . XMLFormat ) : <EOL> """<STR_LIT>""" <EOL> self . format = format <EOL> self . _request_map = { } <EOL> self . _debug_only = False <EOL> def _split_path ( self , path ) : <EOL> """<STR_LIT>""" <EOL> path_only , query_string = urllib . splitquery ( path ) <EOL> if query_string : <EOL> query_dict = dict ( [ i . split ( '<STR_LIT:=>' ) for i in query_string . split ( '<STR_LIT:&>' ) ] ) <EOL> else : <EOL> query_dict = { } <EOL> return path_only , query_dict <EOL> def debug_only ( self , debug = True ) : <EOL> self . _debug_only = debug <EOL> def respond_to ( self , method , path , headers , data , body , <EOL> response_headers = None ) : <EOL> """<STR_LIT>""" <EOL> path_only , query = self . _split_path ( path ) <EOL> if response_headers is None : <EOL> response_headers = { } <EOL> self . _request_map . setdefault ( method , [ ] ) . append ( <EOL> ( ( path_only , query , headers , data ) , ( body , response_headers ) ) ) <EOL> def _lookup_response ( self , method , path , headers , data ) : <EOL> path_only , query = self . _split_path ( path ) <EOL> for key , value in self . _request_map . get ( method , { } ) : <EOL> if key == ( path_only , query , headers , data ) : <EOL> response_body , response_headers = value <EOL> return connection . Response ( <NUM_LIT:200> , response_body , response_headers ) <EOL> raise Error ( '<STR_LIT>' % <EOL> ( path , headers , data ) ) <EOL> def get ( self , path , headers = None ) : <EOL> """<STR_LIT>""" <EOL> return self . format . decode ( <EOL> self . _lookup_response ( '<STR_LIT>' , path , headers , None ) . body ) <EOL> def post ( self , path , headers = None , data = None ) : <EOL> """<STR_LIT>""" <EOL> return self . _lookup_response ( '<STR_LIT>' , path , headers , data ) <EOL> def put ( self , path , headers = None , data = None ) : <EOL> """<STR_LIT>""" <EOL> return self . _lookup_response ( '<STR_LIT>' , path , headers , data ) <EOL> def delete ( self , path , headers = None ) : <EOL> """<STR_LIT>""" <EOL> return self . _lookup_response ( '<STR_LIT>' , path , headers , None ) </s>
<s> from trac . env import Environment <EOL> from trac . attachment import Attachment <EOL> from tracLib import * <EOL> from ConfigParser import ConfigParser <EOL> import tracLib <EOL> import tracLib . timetracking <EOL> class Client ( object ) : <EOL> def __init__ ( self , env_path ) : <EOL> self . env_path = env_path <EOL> self . env = Environment ( env_path ) <EOL> self . db_cnx = self . env . get_db_cnx ( ) <EOL> self . _registered_users_logins = [ ] <EOL> self . _timetracking_plugins = self . _get_timetracking_plugins ( ) <EOL> def _get_timetracking_plugins ( self ) : <EOL> plugins = { } <EOL> if tracLib . SUPPORT_TIME_TRACKING == '<STR_LIT>' : <EOL> for plugin in tracLib . timetracking . plugins : <EOL> plugin_name = plugin . get_name ( ) <EOL> for com_name , com_enabled in self . env . _component_rules . items ( ) : <EOL> if com_name . startswith ( plugin_name ) and com_enabled and plugin_name not in plugins : <EOL> plugins [ plugin_name ] = plugin ( self . env ) <EOL> else : <EOL> for plugin in tracLib . timetracking . plugins : <EOL> plugin_name = plugin . get_name ( ) <EOL> if plugin_name == tracLib . SUPPORT_TIME_TRACKING : <EOL> plugins [ plugin_name ] = plugin ( self . env ) <EOL> break ; <EOL> for plugin_name in plugins . keys ( ) : <EOL> print "<STR_LIT>" % plugin_name <EOL> return plugins . values ( ) <EOL> def get_project_description ( self ) : <EOL> return self . env . project_description <EOL> def get_users ( self ) : <EOL> result = self . env . get_known_users ( ) <EOL> trac_users = list ( [ ] ) <EOL> for user in result : <EOL> user_login = user [ <NUM_LIT:0> ] . lower ( ) <EOL> if user_login in self . _registered_users_logins : <EOL> continue <EOL> u = TracUser ( user_login ) <EOL> u . email = user [ <NUM_LIT:2> ] <EOL> trac_users . append ( u ) <EOL> self . _registered_users_logins . append ( user_login ) <EOL> if not tracLib . ACCEPT_NON_AUTHORISED_USERS : <EOL> return trac_users <EOL> user_fields = [ ( "<STR_LIT>" , "<STR_LIT>" ) , ( "<STR_LIT>" , "<STR_LIT>" ) , ( "<STR_LIT>" , "<STR_LIT>" ) , ( "<STR_LIT>" , "<STR_LIT>" ) ] <EOL> first = True <EOL> request = "<STR_LIT>" <EOL> for column_name , table_name in user_fields : <EOL> if first : <EOL> first = False <EOL> else : <EOL> request += "<STR_LIT>" <EOL> request += "<STR_LIT>" % ( column_name , table_name ) <EOL> cursor = self . db_cnx . cursor ( ) <EOL> cursor . execute ( request ) <EOL> for row in cursor : <EOL> if row [ <NUM_LIT:0> ] not in self . _registered_users_logins : <EOL> trac_user = self . _get_non_authorised_user ( row [ <NUM_LIT:0> ] ) <EOL> if trac_user is not None : <EOL> trac_users . append ( trac_user ) <EOL> self . _registered_users_logins . append ( trac_user . name ) <EOL> return trac_users <EOL> def _get_non_authorised_user ( self , user_name ) : <EOL> if user_name is None : <EOL> return None <EOL> start = user_name . find ( "<STR_LIT:<>" ) <EOL> end = user_name . rfind ( "<STR_LIT:>>" ) <EOL> if ( start > - <NUM_LIT:1> ) and ( end > start + <NUM_LIT:1> ) : <EOL> if user_name . find ( "<STR_LIT:@>" , start , end ) > <NUM_LIT:0> : <EOL> user = TracUser ( user_name [ start + <NUM_LIT:1> : end ] . replace ( "<STR_LIT:U+0020>" , "<STR_LIT:_>" ) ) <EOL> user . email = user_name [ start + <NUM_LIT:1> : end ] . replace ( "<STR_LIT:U+0020>" , "<STR_LIT:_>" ) <EOL> return user <EOL> return None <EOL> def _get_user_login ( self , user_name ) : <EOL> if user_name is None : <EOL> return None <EOL> if user_name in self . _registered_users_logins : <EOL> return user_name <EOL> if not tracLib . ACCEPT_NON_AUTHORISED_USERS : <EOL> return None <EOL> user = self . _get_non_authorised_user ( user_name ) <EOL> if ( user is None ) or ( user . name not in self . _registered_users_logins ) : <EOL> return None <EOL> return user . name <EOL> def get_severities ( self ) : <EOL> return self . _get_data_from_enum ( "<STR_LIT>" ) <EOL> def get_issue_types ( self ) : <EOL> return self . _get_data_from_enum ( "<STR_LIT>" ) <EOL> def get_issue_priorities ( self ) : <EOL> return self . _get_data_from_enum ( "<STR_LIT>" ) <EOL> def get_issue_resolutions ( self ) : <EOL> return [ TracResolution ( name ) for name in self . _get_data_from_enum ( "<STR_LIT>" ) ] <EOL> def get_components ( self ) : <EOL> cursor = self . db_cnx . cursor ( ) <EOL> cursor . execute ( "<STR_LIT>" ) <EOL> trac_components = list ( [ ] ) <EOL> for row in cursor : <EOL> component = TracComponent ( row [ <NUM_LIT:0> ] ) <EOL> component . owner = self . _get_user_login ( component . owner ) <EOL> if row [ <NUM_LIT:2> ] is not None : <EOL> component . description = row [ <NUM_LIT:2> ] <EOL> trac_components . append ( component ) <EOL> return trac_components <EOL> def get_versions ( self ) : <EOL> cursor = self . db_cnx . cursor ( ) <EOL> cursor . execute ( "<STR_LIT>" ) <EOL> trac_versions = list ( [ ] ) <EOL> for row in cursor : <EOL> version = TracVersion ( row [ <NUM_LIT:0> ] ) <EOL> if row [ <NUM_LIT:1> ] : <EOL> version . time = to_unix_time ( row [ <NUM_LIT:1> ] ) <EOL> if row [ <NUM_LIT:2> ] is not None : <EOL> version . description = row [ <NUM_LIT:2> ] <EOL> trac_versions . append ( version ) <EOL> return trac_versions <EOL> def get_issues ( self ) : <EOL> cursor = self . db_cnx . cursor ( ) <EOL> cursor . execute ( "<STR_LIT>" <EOL> "<STR_LIT>" ) <EOL> trac_issues = list ( [ ] ) <EOL> for row in cursor : <EOL> issue = TracIssue ( row [ <NUM_LIT:0> ] ) <EOL> issue . time = to_unix_time ( row [ <NUM_LIT:2> ] ) <EOL> issue . changetime = to_unix_time ( row [ <NUM_LIT:3> ] ) <EOL> issue . reporter = self . _get_user_login ( row [ <NUM_LIT:8> ] ) <EOL> if row [ <NUM_LIT:9> ] is not None : <EOL> cc = row [ <NUM_LIT:9> ] . split ( "<STR_LIT:U+002C>" ) <EOL> for c in cc : <EOL> if len ( c ) > <NUM_LIT:0> : <EOL> cc_name = self . _get_user_login ( c . strip ( ) ) <EOL> if cc_name is not None : <EOL> issue . cc . add ( cc_name ) <EOL> issue . summary = row [ <NUM_LIT> ] <EOL> issue . description = row [ <NUM_LIT> ] <EOL> issue . custom_fields [ "<STR_LIT>" ] = row [ <NUM_LIT:1> ] <EOL> issue . custom_fields [ "<STR_LIT>" ] = row [ <NUM_LIT:4> ] <EOL> issue . custom_fields [ "<STR_LIT>" ] = row [ <NUM_LIT:5> ] <EOL> issue . custom_fields [ "<STR_LIT>" ] = row [ <NUM_LIT:6> ] <EOL> issue . custom_fields [ "<STR_LIT>" ] = self . _get_user_login ( row [ <NUM_LIT:7> ] ) <EOL> issue . custom_fields [ "<STR_LIT>" ] = row [ <NUM_LIT:10> ] <EOL> issue . custom_fields [ "<STR_LIT>" ] = row [ <NUM_LIT:11> ] <EOL> issue . custom_fields [ "<STR_LIT>" ] = row [ <NUM_LIT:12> ] <EOL> if row [ <NUM_LIT:15> ] is not None : <EOL> keywords = row [ <NUM_LIT:15> ] . rsplit ( "<STR_LIT:U+002C>" ) <EOL> for kw in keywords : <EOL> if len ( kw ) > <NUM_LIT:0> : <EOL> issue . keywords . add ( kw . strip ( ) ) <EOL> custom_field_cursor = self . db_cnx . cursor ( ) <EOL> custom_field_cursor . execute ( "<STR_LIT>" , ( str ( row [ <NUM_LIT:0> ] ) , ) ) <EOL> for cf in custom_field_cursor : <EOL> issue . custom_fields [ cf [ <NUM_LIT:0> ] . capitalize ( ) ] = cf [ <NUM_LIT:1> ] <EOL> attachment_cursor = self . db_cnx . cursor ( ) <EOL> attachment_cursor . execute ( "<STR_LIT>" <EOL> "<STR_LIT>" , ( "<STR_LIT>" , str ( issue . id ) ) ) <EOL> for elem in attachment_cursor : <EOL> at = TracAttachment ( Attachment . _get_path ( self . env . path , '<STR_LIT>' , str ( issue . id ) , elem [ <NUM_LIT:0> ] ) ) <EOL> at . name = elem [ <NUM_LIT:0> ] <EOL> at . size = elem [ <NUM_LIT:1> ] <EOL> at . time = to_unix_time ( elem [ <NUM_LIT:2> ] ) <EOL> at . description = elem [ <NUM_LIT:3> ] <EOL> at . author_name = elem [ <NUM_LIT:4> ] <EOL> issue . attachment . add ( at ) <EOL> trac_issues . append ( issue ) <EOL> change_cursor = self . db_cnx . cursor ( ) <EOL> change_cursor . execute ( "<STR_LIT>" , ( str ( row [ <NUM_LIT:0> ] ) , "<STR_LIT>" , ) ) <EOL> for elem in change_cursor : <EOL> if ( elem [ <NUM_LIT:2> ] is None ) or ( not len ( elem [ <NUM_LIT:2> ] . lstrip ( ) ) ) : <EOL> continue <EOL> comment = TracComment ( to_unix_time ( elem [ <NUM_LIT:0> ] ) ) <EOL> comment . author = str ( elem [ <NUM_LIT:1> ] ) <EOL> comment . content = unicode ( elem [ <NUM_LIT:2> ] ) <EOL> comment . id = elem [ <NUM_LIT:3> ] <EOL> issue . comments . add ( comment ) <EOL> for ttp in self . _timetracking_plugins : <EOL> issue . workitems . update ( set ( ttp [ row [ <NUM_LIT:0> ] ] ) ) <EOL> return trac_issues <EOL> def get_custom_fields_declared ( self ) : <EOL> ini_file_path = self . env_path + "<STR_LIT>" <EOL> parser = ConfigParser ( ) <EOL> parser . read ( ini_file_path ) <EOL> if not ( "<STR_LIT>" in parser . sections ( ) ) : <EOL> return set ( [ ] ) <EOL> result = parser . items ( "<STR_LIT>" ) <EOL> items = dict ( [ ] ) <EOL> for elem in result : <EOL> items [ elem [ <NUM_LIT:0> ] ] = elem [ <NUM_LIT:1> ] <EOL> keys = items . keys ( ) <EOL> custom_fields = list ( [ ] ) <EOL> for k in keys : <EOL> if not ( "<STR_LIT:.>" in k ) : <EOL> field = TracCustomFieldDeclaration ( k . capitalize ( ) ) <EOL> field . type = items [ k ] <EOL> options_key = k + "<STR_LIT>" <EOL> if options_key in items : <EOL> opts_str = items [ options_key ] <EOL> opts = opts_str . rsplit ( "<STR_LIT:|>" ) <EOL> for o in opts : <EOL> field . options . append ( o ) <EOL> value_key = k + "<STR_LIT>" <EOL> if value_key in items : <EOL> field . value = items [ value_key ] <EOL> label_key = k + "<STR_LIT>" <EOL> if label_key in items : <EOL> field . label = items [ label_key ] <EOL> custom_fields . append ( field ) <EOL> return custom_fields <EOL> def _get_data_from_enum ( self , type_name ) : <EOL> cursor = self . db_cnx . cursor ( ) <EOL> cursor . execute ( "<STR_LIT>" , ( type_name , ) ) <EOL> return [ row [ <NUM_LIT:0> ] for row in cursor ] </s>
<s> """<STR_LIT>""" </s>
<s> import os <EOL> os . system ( "<STR_LIT>" ) </s>
<s> """<STR_LIT>""" <EOL> import sys <EOL> from collections import defaultdict <EOL> from bacpypes . debugging import Logging , function_debugging , ModuleLogger <EOL> from bacpypes . consolelogging import ConsoleLogHandler <EOL> from bacpypes . pdu import Address <EOL> from bacpypes . analysis import trace , strftimestamp , Tracer <EOL> from bacpypes . npdu import WhoIsRouterToNetwork <EOL> _debug = <NUM_LIT:0> <EOL> _log = ModuleLogger ( globals ( ) ) <EOL> filterSource = None <EOL> filterDestination = None <EOL> filterHost = None <EOL> requests = defaultdict ( int ) <EOL> networks = defaultdict ( list ) <EOL> @ function_debugging <EOL> def Match ( addr1 , addr2 ) : <EOL> """<STR_LIT>""" <EOL> if _debug : Match . _debug ( "<STR_LIT>" , addr1 , addr2 ) <EOL> if ( addr2 . addrType == Address . localBroadcastAddr ) : <EOL> return ( addr1 . addrType == Address . localStationAddr ) or ( addr1 . addrType == Address . localBroadcastAddr ) <EOL> elif ( addr2 . addrType == Address . localStationAddr ) : <EOL> return ( addr1 . addrType == Address . localStationAddr ) and ( addr1 . addrAddr == addr2 . addrAddr ) <EOL> elif ( addr2 . addrType == Address . remoteBroadcastAddr ) : <EOL> return ( ( addr1 . addrType == Address . remoteStationAddr ) or ( addr1 . addrType == Address . remoteBroadcastAddr ) ) and ( addr1 . addrNet == addr2 . addrNet ) <EOL> elif ( addr2 . addrType == Address . remoteStationAddr ) : <EOL> return ( addr1 . addrType == Address . remoteStationAddr ) and ( addr1 . addrNet == addr2 . addrNet ) and ( addr1 . addrAddr == addr2 . addrAddr ) <EOL> elif ( addr2 . addrType == Address . globalBroadcastAddr ) : <EOL> return ( addr1 . addrType == Address . globalBroadcastAddr ) <EOL> else : <EOL> raise RuntimeError , "<STR_LIT>" <EOL> class WhoIsRouterToNetworkSummary ( Tracer , Logging ) : <EOL> def __init__ ( self ) : <EOL> if _debug : IAmRouterToNetworkSummary . _debug ( "<STR_LIT>" ) <EOL> Tracer . __init__ ( self , self . Filter ) <EOL> def Filter ( self , pkt ) : <EOL> if _debug : WhoIsRouterToNetworkSummary . _debug ( "<STR_LIT>" , pkt ) <EOL> global requests , networks <EOL> if not isinstance ( pkt , WhoIsRouterToNetwork ) : <EOL> return <EOL> if filterSource : <EOL> if not Match ( pkt . pduSource , filterSource ) : <EOL> if _debug : WhoIsRouterToNetworkSummary . _debug ( "<STR_LIT>" ) <EOL> return <EOL> if filterDestination : <EOL> if not Match ( pkt . pduDestination , filterDestination ) : <EOL> if _debug : WhoIsRouterToNetworkSummary . _debug ( "<STR_LIT>" ) <EOL> return <EOL> if filterHost : <EOL> if ( not Match ( pkt . pduSource , filterHost ) ) and ( not Match ( pkt . pduDestination , filterHost ) ) : <EOL> if _debug : WhoIsRouterToNetworkSummary . _debug ( "<STR_LIT>" ) <EOL> return <EOL> requests [ pkt . pduSource ] += <NUM_LIT:1> <EOL> networks [ pkt . pduSource ] . append ( pkt . wirtnNetwork ) <EOL> try : <EOL> if ( '<STR_LIT>' in sys . argv ) : <EOL> indx = sys . argv . index ( '<STR_LIT>' ) <EOL> for i in range ( indx + <NUM_LIT:1> , len ( sys . argv ) ) : <EOL> ConsoleLogHandler ( sys . argv [ i ] ) <EOL> del sys . argv [ indx : ] <EOL> if _debug : _log . debug ( "<STR_LIT>" ) <EOL> if ( '<STR_LIT>' in sys . argv ) : <EOL> i = sys . argv . index ( '<STR_LIT>' ) <EOL> filterSource = Address ( sys . argv [ i + <NUM_LIT:1> ] ) <EOL> if _debug : _log . debug ( "<STR_LIT>" , filterSource ) <EOL> del sys . argv [ i : i + <NUM_LIT:2> ] <EOL> if ( '<STR_LIT>' in sys . argv ) : <EOL> i = sys . argv . index ( '<STR_LIT>' ) <EOL> filterDestination = Address ( sys . argv [ i + <NUM_LIT:1> ] ) <EOL> if _debug : _log . debug ( "<STR_LIT>" , filterDestination ) <EOL> del sys . argv [ i : i + <NUM_LIT:2> ] <EOL> if ( '<STR_LIT>' in sys . argv ) : <EOL> i = sys . argv . index ( '<STR_LIT>' ) <EOL> filterHost = Address ( sys . argv [ i + <NUM_LIT:1> ] ) <EOL> if _debug : _log . debug ( "<STR_LIT>" , filterHost ) <EOL> del sys . argv [ i : i + <NUM_LIT:2> ] <EOL> for fname in sys . argv [ <NUM_LIT:1> : ] : <EOL> trace ( fname , [ WhoIsRouterToNetworkSummary ] ) <EOL> items = requests . items ( ) <EOL> items . sort ( lambda x , y : cmp ( y [ <NUM_LIT:1> ] , x [ <NUM_LIT:1> ] ) ) <EOL> print "<STR_LIT>" % ( "<STR_LIT>" , "<STR_LIT>" ) <EOL> for key , count in items : <EOL> print "<STR_LIT>" % ( key , count ) <EOL> net_count = defaultdict ( int ) <EOL> for net in networks [ key ] : <EOL> net_count [ net ] += <NUM_LIT:1> <EOL> net_count = net_count . items ( ) <EOL> net_count . sort ( lambda x , y : cmp ( y [ <NUM_LIT:1> ] , x [ <NUM_LIT:1> ] ) ) <EOL> for net , count in net_count : <EOL> print "<STR_LIT>" % ( net , count ) <EOL> except KeyboardInterrupt : <EOL> pass <EOL> except Exception , e : <EOL> _log . exception ( "<STR_LIT>" , e ) <EOL> finally : <EOL> if _debug : _log . debug ( "<STR_LIT>" ) </s>
<s> """<STR_LIT>""" <EOL> import asyncore <EOL> import socket <EOL> import cPickle as pickle <EOL> from time import time as _time , sleep as _sleep <EOL> from StringIO import StringIO <EOL> from . debugging import ModuleLogger , DebugContents , bacpypes_debugging <EOL> from . core import deferred <EOL> from . task import FunctionTask , OneShotFunction <EOL> from . comm import PDU , Client , Server <EOL> from . comm import ServiceAccessPoint , ApplicationServiceElement <EOL> _debug = <NUM_LIT:0> <EOL> _log = ModuleLogger ( globals ( ) ) <EOL> REBIND_SLEEP_INTERVAL = <NUM_LIT> <EOL> class PickleActorMixIn : <EOL> def __init__ ( self , * args ) : <EOL> if _debug : PickleActorMixIn . _debug ( "<STR_LIT>" , args ) <EOL> super ( PickleActorMixIn , self ) . __init__ ( * args ) <EOL> self . pickleBuffer = '<STR_LIT>' <EOL> def indication ( self , pdu ) : <EOL> if _debug : PickleActorMixIn . _debug ( "<STR_LIT>" , pdu ) <EOL> pdu . pduData = pickle . dumps ( pdu . pduData ) <EOL> super ( PickleActorMixIn , self ) . indication ( pdu ) <EOL> def response ( self , pdu ) : <EOL> if _debug : PickleActorMixIn . _debug ( "<STR_LIT>" , pdu ) <EOL> self . pickleBuffer += pdu . pduData <EOL> strm = StringIO ( self . pickleBuffer ) <EOL> pos = <NUM_LIT:0> <EOL> while ( pos < strm . len ) : <EOL> try : <EOL> msg = pickle . load ( strm ) <EOL> except : <EOL> break <EOL> rpdu = PDU ( msg ) <EOL> rpdu . update ( pdu ) <EOL> super ( PickleActorMixIn , self ) . response ( rpdu ) <EOL> pos = strm . tell ( ) <EOL> if ( pos < strm . len ) : <EOL> self . pickleBuffer = self . pickleBuffer [ pos : ] <EOL> else : <EOL> self . pickleBuffer = '<STR_LIT>' <EOL> bacpypes_debugging ( PickleActorMixIn ) <EOL> class TCPClient ( asyncore . dispatcher ) : <EOL> def __init__ ( self , peer ) : <EOL> if _debug : TCPClient . _debug ( "<STR_LIT>" , peer ) <EOL> asyncore . dispatcher . __init__ ( self ) <EOL> self . create_socket ( socket . AF_INET , socket . SOCK_STREAM ) <EOL> self . peer = peer <EOL> self . request = '<STR_LIT>' <EOL> self . socketError = None <EOL> if _debug : TCPClient . _debug ( "<STR_LIT>" ) <EOL> self . connect ( peer ) <EOL> if _debug : TCPClient . _debug ( "<STR_LIT>" ) <EOL> def handle_connect ( self ) : <EOL> if _debug : deferred ( TCPClient . _debug , "<STR_LIT>" ) <EOL> def handle_expt ( self ) : <EOL> pass <EOL> def readable ( self ) : <EOL> return <NUM_LIT:1> <EOL> def handle_read ( self ) : <EOL> if _debug : deferred ( TCPClient . _debug , "<STR_LIT>" ) <EOL> try : <EOL> msg = self . recv ( <NUM_LIT> ) <EOL> if _debug : deferred ( TCPClient . _debug , "<STR_LIT>" , len ( msg ) ) <EOL> self . socketError = None <EOL> if not self . socket : <EOL> if _debug : deferred ( TCPClient . _debug , "<STR_LIT>" ) <EOL> else : <EOL> deferred ( self . response , PDU ( msg ) ) <EOL> except socket . error , err : <EOL> if ( err . args [ <NUM_LIT:0> ] == <NUM_LIT> ) : <EOL> deferred ( TCPClient . _error , "<STR_LIT>" , self . peer ) <EOL> else : <EOL> deferred ( TCPClient . _error , "<STR_LIT>" , err ) <EOL> self . socketError = err <EOL> def writable ( self ) : <EOL> return ( len ( self . request ) != <NUM_LIT:0> ) <EOL> def handle_write ( self ) : <EOL> if _debug : deferred ( TCPClient . _debug , "<STR_LIT>" ) <EOL> try : <EOL> sent = self . send ( self . request ) <EOL> if _debug : deferred ( TCPClient . _debug , "<STR_LIT>" , sent , len ( self . request ) - sent ) <EOL> self . socketError = None <EOL> self . request = self . request [ sent : ] <EOL> except socket . error , err : <EOL> if ( err . args [ <NUM_LIT:0> ] == <NUM_LIT> ) : <EOL> deferred ( TCPClient . _error , "<STR_LIT>" , self . peer ) <EOL> else : <EOL> deferred ( TCPClient . _error , "<STR_LIT>" , err ) <EOL> self . socketError = err <EOL> def handle_close ( self ) : <EOL> if _debug : deferred ( TCPClient . _debug , "<STR_LIT>" ) <EOL> self . close ( ) <EOL> self . socket = None <EOL> def indication ( self , pdu ) : <EOL> """<STR_LIT>""" <EOL> if _debug : TCPClient . _debug ( "<STR_LIT>" , pdu ) <EOL> self . request += pdu . pduData <EOL> bacpypes_debugging ( TCPClient ) <EOL> class TCPClientActor ( TCPClient ) : <EOL> def __init__ ( self , director , peer ) : <EOL> if _debug : TCPClientActor . _debug ( "<STR_LIT>" , director , peer ) <EOL> TCPClient . __init__ ( self , peer ) <EOL> self . director = director <EOL> self . timeout = director . timeout <EOL> if self . timeout > <NUM_LIT:0> : <EOL> self . timer = FunctionTask ( self . idle_timeout ) <EOL> self . timer . install_task ( _time ( ) + self . timeout ) <EOL> else : <EOL> self . timer = None <EOL> self . flushTask = None <EOL> self . director . add_actor ( self ) <EOL> def handle_close ( self ) : <EOL> if _debug : TCPClientActor . _debug ( "<STR_LIT>" ) <EOL> if self . flushTask : <EOL> self . flushTask . suspend_task ( ) <EOL> if self . timer : <EOL> self . timer . suspend_task ( ) <EOL> self . director . remove_actor ( self ) <EOL> TCPClient . handle_close ( self ) <EOL> def idle_timeout ( self ) : <EOL> if _debug : TCPClientActor . _debug ( "<STR_LIT>" ) <EOL> self . handle_close ( ) <EOL> def indication ( self , pdu ) : <EOL> if _debug : TCPClientActor . _debug ( "<STR_LIT>" , pdu ) <EOL> if self . flushTask : <EOL> if _debug : TCPServerActor . _debug ( "<STR_LIT>" ) <EOL> return <EOL> if self . timer : <EOL> self . timer . install_task ( _time ( ) + self . timeout ) <EOL> TCPClient . indication ( self , pdu ) <EOL> def response ( self , pdu ) : <EOL> if _debug : TCPClientActor . _debug ( "<STR_LIT>" , pdu ) <EOL> pdu . pduSource = self . peer <EOL> if self . timer : <EOL> self . timer . install_task ( _time ( ) + self . timeout ) <EOL> self . director . response ( pdu ) <EOL> def flush ( self ) : <EOL> if _debug : TCPClientActor . _debug ( "<STR_LIT>" ) <EOL> self . flushTask = None <EOL> if self . request : <EOL> self . flushTask = OneShotFunction ( self . flush ) <EOL> return <EOL> self . handle_close ( ) <EOL> bacpypes_debugging ( TCPClientActor ) <EOL> class TCPPickleClientActor ( PickleActorMixIn , TCPClientActor ) : <EOL> pass <EOL> class TCPClientDirector ( Server , ServiceAccessPoint , DebugContents ) : <EOL> _debug_contents = ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def __init__ ( self , timeout = <NUM_LIT:0> , actorClass = TCPClientActor , sid = None , sapID = None ) : <EOL> if _debug : TCPClientDirector . _debug ( "<STR_LIT>" , timeout , actorClass , sid , sapID ) <EOL> Server . __init__ ( self , sid ) <EOL> ServiceAccessPoint . __init__ ( self , sapID ) <EOL> if not issubclass ( actorClass , TCPClientActor ) : <EOL> raise TypeError ( "<STR_LIT>" ) <EOL> self . actorClass = actorClass <EOL> self . timeout = timeout <EOL> self . clients = { } <EOL> self . reconnect = { } <EOL> def add_actor ( self , actor ) : <EOL> """<STR_LIT>""" <EOL> if _debug : TCPClientDirector . _debug ( "<STR_LIT>" , actor ) <EOL> self . clients [ actor . peer ] = actor <EOL> if self . serviceElement : <EOL> self . sap_request ( addPeer = actor . peer ) <EOL> def remove_actor ( self , actor ) : <EOL> """<STR_LIT>""" <EOL> if _debug : TCPClientDirector . _debug ( "<STR_LIT>" , actor ) <EOL> del self . clients [ actor . peer ] <EOL> if self . serviceElement : <EOL> self . sap_request ( delPeer = actor . peer ) <EOL> if actor . peer in self . reconnect : <EOL> connect_task = FunctionTask ( self . connect , actor . peer ) <EOL> connect_task . install_task ( _time ( ) + self . reconnect [ actor . peer ] ) <EOL> def get_actor ( self , address ) : <EOL> """<STR_LIT>""" <EOL> return self . clients . get ( address , None ) <EOL> def connect ( self , address , reconnect = <NUM_LIT:0> ) : <EOL> if _debug : TCPClientDirector . _debug ( "<STR_LIT>" , address , reconnect ) <EOL> if address in self . clients : <EOL> return <EOL> client = self . actorClass ( self , address ) <EOL> if _debug : TCPClientDirector . _debug ( "<STR_LIT>" , client ) <EOL> if reconnect : <EOL> self . reconnect [ address ] = reconnect <EOL> def disconnect ( self , address ) : <EOL> if _debug : TCPClientDirector . _debug ( "<STR_LIT>" , address ) <EOL> if address not in self . clients : <EOL> return <EOL> if address in self . reconnect : <EOL> del self . reconnect [ address ] <EOL> self . clients [ address ] . handle_close ( ) <EOL> def indication ( self , pdu ) : <EOL> """<STR_LIT>""" <EOL> if _debug : TCPClientDirector . _debug ( "<STR_LIT>" , pdu ) <EOL> addr = pdu . pduDestination <EOL> client = self . clients . get ( addr , None ) <EOL> if not client : <EOL> client = self . actorClass ( self , addr ) <EOL> client . indication ( pdu ) <EOL> bacpypes_debugging ( TCPClientDirector ) <EOL> class TCPServer ( asyncore . dispatcher ) : <EOL> def __init__ ( self , sock , peer ) : <EOL> if _debug : TCPServer . _debug ( "<STR_LIT>" , sock , peer ) <EOL> asyncore . dispatcher . __init__ ( self , sock ) <EOL> self . peer = peer <EOL> self . request = '<STR_LIT>' <EOL> self . socketError = None <EOL> def handle_connect ( self ) : <EOL> if _debug : deferred ( TCPServer . _debug , "<STR_LIT>" ) <EOL> def readable ( self ) : <EOL> return <NUM_LIT:1> <EOL> def handle_read ( self ) : <EOL> if _debug : deferred ( TCPServer . _debug , "<STR_LIT>" ) <EOL> try : <EOL> msg = self . recv ( <NUM_LIT> ) <EOL> if _debug : deferred ( TCPServer . _debug , "<STR_LIT>" , len ( msg ) ) <EOL> self . socketError = None <EOL> if not self . socket : <EOL> if _debug : deferred ( TCPServer . _debug , "<STR_LIT>" ) <EOL> else : <EOL> deferred ( self . response , PDU ( msg ) ) <EOL> except socket . error , err : <EOL> if ( err . args [ <NUM_LIT:0> ] == <NUM_LIT> ) : <EOL> deferred ( TCPServer . _error , "<STR_LIT>" , self . peer ) <EOL> else : <EOL> deferred ( TCPServer . _error , "<STR_LIT>" , err ) <EOL> self . socketError = err <EOL> def writable ( self ) : <EOL> return ( len ( self . request ) != <NUM_LIT:0> ) <EOL> def handle_write ( self ) : <EOL> if _debug : deferred ( TCPServer . _debug , "<STR_LIT>" ) <EOL> try : <EOL> sent = self . send ( self . request ) <EOL> if _debug : deferred ( TCPServer . _debug , "<STR_LIT>" , sent , len ( self . request ) - sent ) <EOL> self . socketError = None <EOL> self . request = self . request [ sent : ] <EOL> except socket . error , why : <EOL> if ( why . args [ <NUM_LIT:0> ] == <NUM_LIT> ) : <EOL> deferred ( TCPServer . _error , "<STR_LIT>" , self . peer ) <EOL> else : <EOL> deferred ( TCPServer . _error , "<STR_LIT>" , why ) <EOL> self . socketError = why <EOL> def handle_close ( self ) : <EOL> if _debug : deferred ( TCPServer . _debug , "<STR_LIT>" ) <EOL> if not self : <EOL> deferred ( TCPServer . _warning , "<STR_LIT>" ) <EOL> return <EOL> if not self . socket : <EOL> deferred ( TCPServer . _warning , "<STR_LIT>" ) <EOL> return <EOL> self . close ( ) <EOL> self . socket = None <EOL> def indication ( self , pdu ) : <EOL> """<STR_LIT>""" <EOL> if _debug : TCPServer . _debug ( "<STR_LIT>" , pdu ) <EOL> self . request += pdu . pduData <EOL> bacpypes_debugging ( TCPServer ) <EOL> class TCPServerActor ( TCPServer ) : <EOL> def __init__ ( self , director , sock , peer ) : <EOL> if _debug : TCPServerActor . _debug ( "<STR_LIT>" , director , sock , peer ) <EOL> TCPServer . __init__ ( self , sock , peer ) <EOL> self . director = director <EOL> self . timeout = director . timeout <EOL> if self . timeout > <NUM_LIT:0> : <EOL> self . timer = FunctionTask ( self . idle_timeout ) <EOL> self . timer . install_task ( _time ( ) + self . timeout ) <EOL> else : <EOL> self . timer = None <EOL> self . flushTask = None <EOL> self . director . add_actor ( self ) <EOL> def handle_close ( self ) : <EOL> if _debug : TCPServerActor . _debug ( "<STR_LIT>" ) <EOL> if self . flushTask : <EOL> self . flushTask . suspend_task ( ) <EOL> self . director . remove_actor ( self ) <EOL> TCPServer . handle_close ( self ) <EOL> def idle_timeout ( self ) : <EOL> if _debug : TCPServerActor . _debug ( "<STR_LIT>" ) <EOL> self . handle_close ( ) <EOL> def indication ( self , pdu ) : <EOL> if _debug : TCPServerActor . _debug ( "<STR_LIT>" , pdu ) <EOL> if self . flushTask : <EOL> if _debug : TCPServerActor . _debug ( "<STR_LIT>" ) <EOL> return <EOL> if self . timer : <EOL> self . timer . install_task ( _time ( ) + self . timeout ) <EOL> TCPServer . indication ( self , pdu ) <EOL> def response ( self , pdu ) : <EOL> if _debug : TCPServerActor . _debug ( "<STR_LIT>" , pdu ) <EOL> if self . flushTask : <EOL> if _debug : TCPServerActor . _debug ( "<STR_LIT>" ) <EOL> return <EOL> pdu . pduSource = self . peer <EOL> if self . timer : <EOL> self . timer . install_task ( _time ( ) + self . timeout ) <EOL> self . director . response ( pdu ) <EOL> def flush ( self ) : <EOL> if _debug : TCPServerActor . _debug ( "<STR_LIT>" ) <EOL> self . flushTask = None <EOL> if self . request : <EOL> self . flushTask = OneShotFunction ( self . flush ) <EOL> return <EOL> self . handle_close ( ) <EOL> bacpypes_debugging ( TCPServerActor ) <EOL> class TCPPickleServerActor ( PickleActorMixIn , TCPServerActor ) : <EOL> pass <EOL> class TCPServerDirector ( asyncore . dispatcher , Server , ServiceAccessPoint , DebugContents ) : <EOL> _debug_contents = ( '<STR_LIT:port>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def __init__ ( self , address , listeners = <NUM_LIT:5> , timeout = <NUM_LIT:0> , reuse = False , actorClass = TCPServerActor , cid = None , sapID = None ) : <EOL> if _debug : <EOL> TCPServerDirector . _debug ( "<STR_LIT>" <EOL> , address , listeners , timeout , reuse , actorClass , cid , sapID <EOL> ) <EOL> Server . __init__ ( self , cid ) <EOL> ServiceAccessPoint . __init__ ( self , sapID ) <EOL> self . port = address <EOL> self . timeout = timeout <EOL> if not issubclass ( actorClass , TCPServerActor ) : <EOL> raise TypeError ( "<STR_LIT>" ) <EOL> self . actorClass = actorClass <EOL> self . servers = { } <EOL> asyncore . dispatcher . __init__ ( self ) <EOL> self . create_socket ( socket . AF_INET , socket . SOCK_STREAM ) <EOL> if reuse : <EOL> self . set_reuse_addr ( ) <EOL> hadBindErrors = False <EOL> for i in range ( <NUM_LIT:30> ) : <EOL> try : <EOL> self . bind ( address ) <EOL> break <EOL> except socket . error , err : <EOL> hadBindErrors = True <EOL> TCPServerDirector . _warning ( '<STR_LIT>' , err ) <EOL> _sleep ( REBIND_SLEEP_INTERVAL ) <EOL> else : <EOL> TCPServerDirector . _error ( '<STR_LIT>' ) <EOL> raise RuntimeError ( "<STR_LIT>" ) <EOL> if hadBindErrors : <EOL> TCPServerDirector . _info ( '<STR_LIT>' ) <EOL> self . listen ( listeners ) <EOL> def handle_accept ( self ) : <EOL> if _debug : TCPServerDirector . _debug ( "<STR_LIT>" ) <EOL> try : <EOL> client , addr = self . accept ( ) <EOL> except socket . error : <EOL> TCPServerDirector . _warning ( '<STR_LIT>' ) <EOL> return <EOL> except TypeError : <EOL> TCPServerDirector . _warning ( '<STR_LIT>' ) <EOL> return <EOL> if _debug : TCPServerDirector . _debug ( "<STR_LIT>" , client , addr ) <EOL> server = self . actorClass ( self , client , addr ) <EOL> self . servers [ addr ] = server <EOL> return server <EOL> def handle_close ( self ) : <EOL> if _debug : TCPServerDirector . _debug ( "<STR_LIT>" ) <EOL> self . close ( ) <EOL> def add_actor ( self , actor ) : <EOL> if _debug : TCPServerDirector . _debug ( "<STR_LIT>" , actor ) <EOL> self . servers [ actor . peer ] = actor <EOL> if self . serviceElement : <EOL> self . sap_request ( addPeer = actor . peer ) <EOL> def remove_actor ( self , actor ) : <EOL> if _debug : TCPServerDirector . _debug ( "<STR_LIT>" , actor ) <EOL> try : <EOL> del self . servers [ actor . peer ] <EOL> except KeyError : <EOL> TCPServerDirector . _warning ( "<STR_LIT>" , actor ) <EOL> if self . serviceElement : <EOL> self . sap_request ( delPeer = actor . peer ) <EOL> def get_actor ( self , address ) : <EOL> """<STR_LIT>""" <EOL> return self . servers . get ( address , None ) <EOL> def indication ( self , pdu ) : <EOL> """<STR_LIT>""" <EOL> if _debug : TCPServerDirector . _debug ( "<STR_LIT>" , pdu ) <EOL> addr = pdu . pduDestination <EOL> server = self . servers . get ( addr , None ) <EOL> if not server : <EOL> raise RuntimeError ( "<STR_LIT>" ) <EOL> server . indication ( pdu ) <EOL> bacpypes_debugging ( TCPServerDirector ) <EOL> class StreamToPacket ( Client , Server ) : <EOL> def __init__ ( self , fn , cid = None , sid = None ) : <EOL> if _debug : StreamToPacket . _debug ( "<STR_LIT>" , fn , cid , sid ) <EOL> Client . __init__ ( self , cid ) <EOL> Server . __init__ ( self , sid ) <EOL> self . packetFn = fn <EOL> self . upstreamBuffer = { } <EOL> self . downstreamBuffer = { } <EOL> def packetize ( self , pdu , streamBuffer ) : <EOL> if _debug : StreamToPacket . _debug ( "<STR_LIT>" , pdu ) <EOL> def chop ( addr ) : <EOL> if _debug : StreamToPacket . _debug ( "<STR_LIT>" , addr ) <EOL> buff = streamBuffer . get ( addr , '<STR_LIT>' ) + pdu . pduData <EOL> if _debug : StreamToPacket . _debug ( "<STR_LIT>" , buff ) <EOL> while <NUM_LIT:1> : <EOL> packet = self . packetFn ( buff ) <EOL> if packet is None : <EOL> break <EOL> yield PDU ( packet [ <NUM_LIT:0> ] , <EOL> source = pdu . pduSource , <EOL> destination = pdu . pduDestination , <EOL> user_data = pdu . pduUserData , <EOL> ) <EOL> buff = packet [ <NUM_LIT:1> ] <EOL> streamBuffer [ addr ] = buff <EOL> if pdu . pduSource : <EOL> for pdu in chop ( pdu . pduSource ) : <EOL> yield pdu <EOL> if pdu . pduDestination : <EOL> for pdu in chop ( pdu . pduDestination ) : <EOL> yield pdu <EOL> def indication ( self , pdu ) : <EOL> """<STR_LIT>""" <EOL> if _debug : StreamToPacket . _debug ( "<STR_LIT>" , pdu ) <EOL> for packet in self . packetize ( pdu , self . downstreamBuffer ) : <EOL> self . request ( packet ) <EOL> def confirmation ( self , pdu ) : <EOL> """<STR_LIT>""" <EOL> if _debug : StreamToPacket . _debug ( "<STR_LIT>" , pdu ) <EOL> for packet in self . packetize ( pdu , self . upstreamBuffer ) : <EOL> self . response ( packet ) <EOL> bacpypes_debugging ( StreamToPacket ) <EOL> class StreamToPacketSAP ( ApplicationServiceElement , ServiceAccessPoint ) : <EOL> def __init__ ( self , stp , aseID = None , sapID = None ) : <EOL> if _debug : StreamToPacketSAP . _debug ( "<STR_LIT>" , stp , aseID , sapID ) <EOL> ApplicationServiceElement . __init__ ( self , aseID ) <EOL> ServiceAccessPoint . __init__ ( self , sapID ) <EOL> self . stp = stp <EOL> def indication ( self , addPeer = None , delPeer = None ) : <EOL> if _debug : StreamToPacketSAP . _debug ( "<STR_LIT>" , addPeer , delPeer ) <EOL> if addPeer : <EOL> self . stp . upstreamBuffer [ addPeer ] = '<STR_LIT>' <EOL> self . stp . downstreamBuffer [ addPeer ] = '<STR_LIT>' <EOL> if delPeer : <EOL> del self . stp . upstreamBuffer [ delPeer ] <EOL> del self . stp . downstreamBuffer [ delPeer ] <EOL> if self . serviceElement : <EOL> self . sap_request ( addPeer = addPeer , delPeer = delPeer ) <EOL> bacpypes_debugging ( StreamToPacketSAP ) </s>
<s> """<STR_LIT>""" <EOL> import random <EOL> from copy import deepcopy <EOL> from . errors import ConfigurationError <EOL> from . debugging import ModuleLogger , bacpypes_debugging <EOL> from . core import deferred <EOL> from . pdu import Address <EOL> from . comm import Server <EOL> _debug = <NUM_LIT:0> <EOL> _log = ModuleLogger ( globals ( ) ) <EOL> @ bacpypes_debugging <EOL> class Network : <EOL> def __init__ ( self , dropPercent = <NUM_LIT:0.0> ) : <EOL> if _debug : Network . _debug ( "<STR_LIT>" , dropPercent ) <EOL> self . nodes = [ ] <EOL> self . dropPercent = dropPercent <EOL> def add_node ( self , node ) : <EOL> """<STR_LIT>""" <EOL> if _debug : Network . _debug ( "<STR_LIT>" , node ) <EOL> self . nodes . append ( node ) <EOL> node . lan = self <EOL> def remove_node ( self , node ) : <EOL> """<STR_LIT>""" <EOL> if _debug : Network . _debug ( "<STR_LIT>" , node ) <EOL> self . nodes . remove ( node ) <EOL> node . lan = None <EOL> def process_pdu ( self , pdu ) : <EOL> """<STR_LIT>""" <EOL> if _debug : Network . _debug ( "<STR_LIT>" , pdu ) <EOL> if self . dropPercent != <NUM_LIT:0.0> : <EOL> if ( random . random ( ) * <NUM_LIT> ) < self . dropPercent : <EOL> if _debug : Network . _debug ( "<STR_LIT>" ) <EOL> return <EOL> if not pdu . pduDestination or not isinstance ( pdu . pduDestination , Address ) : <EOL> raise RuntimeError ( "<STR_LIT>" ) <EOL> elif pdu . pduDestination . addrType == Address . localBroadcastAddr : <EOL> for n in self . nodes : <EOL> if ( pdu . pduSource != n . address ) : <EOL> n . response ( deepcopy ( pdu ) ) <EOL> elif pdu . pduDestination . addrType == Address . localStationAddr : <EOL> for n in self . nodes : <EOL> if n . promiscuous or ( pdu . pduDestination == n . address ) : <EOL> n . response ( deepcopy ( pdu ) ) <EOL> else : <EOL> raise RuntimeError ( "<STR_LIT>" ) <EOL> def __len__ ( self ) : <EOL> """<STR_LIT>""" <EOL> if _debug : Network . _debug ( "<STR_LIT>" ) <EOL> return len ( self . nodes ) <EOL> @ bacpypes_debugging <EOL> class Node ( Server ) : <EOL> def __init__ ( self , addr , lan = None , promiscuous = False , spoofing = False , sid = None ) : <EOL> if _debug : <EOL> Node . _debug ( "<STR_LIT>" , <EOL> addr , lan , promiscuous , spoofing , sid <EOL> ) <EOL> Server . __init__ ( self , sid ) <EOL> if not isinstance ( addr , Address ) : <EOL> raise TypeError ( "<STR_LIT>" ) <EOL> self . lan = None <EOL> self . address = addr <EOL> if lan : <EOL> self . bind ( lan ) <EOL> self . promiscuous = promiscuous <EOL> self . spoofing = spoofing <EOL> def bind ( self , lan ) : <EOL> """<STR_LIT>""" <EOL> if _debug : Node . _debug ( "<STR_LIT>" , lan ) <EOL> lan . add_node ( self ) <EOL> def indication ( self , pdu ) : <EOL> """<STR_LIT>""" <EOL> if _debug : Node . _debug ( "<STR_LIT>" , pdu ) <EOL> if not self . lan : <EOL> raise ConfigurationError ( "<STR_LIT>" ) <EOL> if pdu . pduSource is None : <EOL> pdu . pduSource = self . address <EOL> elif ( not self . spoofing ) and ( pdu . pduSource != self . address ) : <EOL> raise RuntimeError ( "<STR_LIT>" ) <EOL> deferred ( self . lan . process_pdu , pdu ) </s>
<s> """<STR_LIT>""" <EOL> import sys <EOL> from bacpypes . debugging import bacpypes_debugging , ModuleLogger <EOL> from bacpypes . consolelogging import ConfigArgumentParser <EOL> from bacpypes . consolecmd import ConsoleCmd <EOL> from bacpypes . core import run <EOL> from bacpypes . pdu import Address <EOL> from bacpypes . app import LocalDeviceObject , BIPSimpleApplication <EOL> from bacpypes . apdu import Error , AbortPDU , AtomicReadFileRequest , AtomicReadFileRequestAccessMethodChoice , AtomicReadFileRequestAccessMethodChoiceRecordAccess , AtomicReadFileRequestAccessMethodChoiceStreamAccess , AtomicReadFileACK , AtomicWriteFileRequest , AtomicWriteFileRequestAccessMethodChoice , AtomicWriteFileRequestAccessMethodChoiceRecordAccess , AtomicWriteFileRequestAccessMethodChoiceStreamAccess , AtomicWriteFileACK <EOL> from bacpypes . basetypes import ServicesSupported <EOL> _debug = <NUM_LIT:0> <EOL> _log = ModuleLogger ( globals ( ) ) <EOL> this_application = None <EOL> @ bacpypes_debugging <EOL> class TestApplication ( BIPSimpleApplication ) : <EOL> def request ( self , apdu ) : <EOL> if _debug : TestApplication . _debug ( "<STR_LIT>" , apdu ) <EOL> self . _request = apdu <EOL> BIPSimpleApplication . request ( self , apdu ) <EOL> def confirmation ( self , apdu ) : <EOL> if _debug : TestApplication . _debug ( "<STR_LIT>" , apdu ) <EOL> if isinstance ( apdu , Error ) : <EOL> sys . stdout . write ( "<STR_LIT>" % ( apdu . errorCode , ) ) <EOL> sys . stdout . flush ( ) <EOL> elif isinstance ( apdu , AbortPDU ) : <EOL> apdu . debug_contents ( ) <EOL> elif ( isinstance ( self . _request , AtomicReadFileRequest ) ) and ( isinstance ( apdu , AtomicReadFileACK ) ) : <EOL> if apdu . accessMethod . recordAccess : <EOL> value = apdu . accessMethod . recordAccess . fileRecordData <EOL> elif apdu . accessMethod . streamAccess : <EOL> value = apdu . accessMethod . streamAccess . fileData <EOL> TestApplication . _debug ( "<STR_LIT>" , value ) <EOL> sys . stdout . write ( repr ( value ) + '<STR_LIT:\n>' ) <EOL> sys . stdout . flush ( ) <EOL> elif ( isinstance ( self . _request , AtomicWriteFileRequest ) ) and ( isinstance ( apdu , AtomicWriteFileACK ) ) : <EOL> if apdu . fileStartPosition is not None : <EOL> value = apdu . fileStartPosition <EOL> elif apdu . fileStartRecord is not None : <EOL> value = apdu . fileStartRecord <EOL> TestApplication . _debug ( "<STR_LIT>" , value ) <EOL> sys . stdout . write ( repr ( value ) + '<STR_LIT:\n>' ) <EOL> sys . stdout . flush ( ) <EOL> @ bacpypes_debugging <EOL> class TestConsoleCmd ( ConsoleCmd ) : <EOL> def do_readrecord ( self , args ) : <EOL> """<STR_LIT>""" <EOL> args = args . split ( ) <EOL> if _debug : TestConsoleCmd . _debug ( "<STR_LIT>" , args ) <EOL> try : <EOL> addr , obj_inst , start_record , record_count = args <EOL> obj_type = '<STR_LIT:file>' <EOL> obj_inst = int ( obj_inst ) <EOL> start_record = int ( start_record ) <EOL> record_count = int ( record_count ) <EOL> request = AtomicReadFileRequest ( <EOL> fileIdentifier = ( obj_type , obj_inst ) , <EOL> accessMethod = AtomicReadFileRequestAccessMethodChoice ( <EOL> recordAccess = AtomicReadFileRequestAccessMethodChoiceRecordAccess ( <EOL> fileStartRecord = start_record , <EOL> requestedRecordCount = record_count , <EOL> ) , <EOL> ) , <EOL> ) <EOL> request . pduDestination = Address ( addr ) <EOL> if _debug : TestConsoleCmd . _debug ( "<STR_LIT>" , request ) <EOL> this_application . request ( request ) <EOL> except Exception , e : <EOL> TestConsoleCmd . _exception ( "<STR_LIT>" , e ) <EOL> def do_readstream ( self , args ) : <EOL> """<STR_LIT>""" <EOL> args = args . split ( ) <EOL> if _debug : TestConsoleCmd . _debug ( "<STR_LIT>" , args ) <EOL> try : <EOL> addr , obj_inst , start_position , octet_count = args <EOL> obj_type = '<STR_LIT:file>' <EOL> obj_inst = int ( obj_inst ) <EOL> start_position = int ( start_position ) <EOL> octet_count = int ( octet_count ) <EOL> request = AtomicReadFileRequest ( <EOL> fileIdentifier = ( obj_type , obj_inst ) , <EOL> accessMethod = AtomicReadFileRequestAccessMethodChoice ( <EOL> streamAccess = AtomicReadFileRequestAccessMethodChoiceStreamAccess ( <EOL> fileStartPosition = start_position , <EOL> requestedOctetCount = octet_count , <EOL> ) , <EOL> ) , <EOL> ) <EOL> request . pduDestination = Address ( addr ) <EOL> if _debug : TestConsoleCmd . _debug ( "<STR_LIT>" , request ) <EOL> this_application . request ( request ) <EOL> except Exception , e : <EOL> TestConsoleCmd . _exception ( "<STR_LIT>" , e ) <EOL> def do_writerecord ( self , args ) : <EOL> """<STR_LIT>""" <EOL> args = args . split ( ) <EOL> if _debug : TestConsoleCmd . _debug ( "<STR_LIT>" , args ) <EOL> try : <EOL> addr , obj_inst , start_record , record_count = args [ <NUM_LIT:0> : <NUM_LIT:4> ] <EOL> obj_type = '<STR_LIT:file>' <EOL> obj_inst = int ( obj_inst ) <EOL> start_record = int ( start_record ) <EOL> record_count = int ( record_count ) <EOL> record_data = list ( args [ <NUM_LIT:4> : ] ) <EOL> request = AtomicWriteFileRequest ( <EOL> fileIdentifier = ( obj_type , obj_inst ) , <EOL> accessMethod = AtomicWriteFileRequestAccessMethodChoice ( <EOL> recordAccess = AtomicWriteFileRequestAccessMethodChoiceRecordAccess ( <EOL> fileStartRecord = start_record , <EOL> recordCount = record_count , <EOL> fileRecordData = record_data , <EOL> ) , <EOL> ) , <EOL> ) <EOL> request . pduDestination = Address ( addr ) <EOL> if _debug : TestConsoleCmd . _debug ( "<STR_LIT>" , request ) <EOL> this_application . request ( request ) <EOL> except Exception , e : <EOL> TestConsoleCmd . _exception ( "<STR_LIT>" , e ) <EOL> def do_writestream ( self , args ) : <EOL> """<STR_LIT>""" <EOL> args = args . split ( ) <EOL> if _debug : TestConsoleCmd . _debug ( "<STR_LIT>" , args ) <EOL> try : <EOL> addr , obj_inst , start_position , data = args <EOL> obj_type = '<STR_LIT:file>' <EOL> obj_inst = int ( obj_inst ) <EOL> start_position = int ( start_position ) <EOL> request = AtomicWriteFileRequest ( <EOL> fileIdentifier = ( obj_type , obj_inst ) , <EOL> accessMethod = AtomicWriteFileRequestAccessMethodChoice ( <EOL> streamAccess = AtomicWriteFileRequestAccessMethodChoiceStreamAccess ( <EOL> fileStartPosition = start_position , <EOL> fileData = data , <EOL> ) , <EOL> ) , <EOL> ) <EOL> request . pduDestination = Address ( addr ) <EOL> if _debug : TestConsoleCmd . _debug ( "<STR_LIT>" , request ) <EOL> this_application . request ( request ) <EOL> except Exception , e : <EOL> TestConsoleCmd . _exception ( "<STR_LIT>" , e ) <EOL> try : <EOL> args = ConfigArgumentParser ( description = __doc__ ) . parse_args ( ) <EOL> if _debug : _log . debug ( "<STR_LIT>" ) <EOL> if _debug : _log . debug ( "<STR_LIT>" , args ) <EOL> this_device = LocalDeviceObject ( <EOL> objectName = args . ini . objectname , <EOL> objectIdentifier = int ( args . ini . objectidentifier ) , <EOL> maxApduLengthAccepted = int ( args . ini . maxapdulengthaccepted ) , <EOL> segmentationSupported = args . ini . segmentationsupported , <EOL> vendorIdentifier = int ( args . ini . vendoridentifier ) , <EOL> ) <EOL> this_application = TestApplication ( this_device , args . ini . address ) <EOL> services_supported = this_application . get_services_supported ( ) <EOL> if _debug : _log . debug ( "<STR_LIT>" , services_supported ) <EOL> this_device . protocolServicesSupported = services_supported . value <EOL> this_console = TestConsoleCmd ( ) <EOL> _log . debug ( "<STR_LIT>" ) <EOL> run ( ) <EOL> except Exception , e : <EOL> _log . exception ( "<STR_LIT>" , e ) <EOL> finally : <EOL> _log . debug ( "<STR_LIT>" ) </s>
<s> """<STR_LIT>""" <EOL> from . import test_address </s>
<s> from __future__ import division , unicode_literals <EOL> import os <EOL> import hashlib <EOL> import logging <EOL> from collections import defaultdict <EOL> from . bencode import bencode , bdecode <EOL> from . humanize import humanize_bytes <EOL> from . utils import is_unsplitable , get_root_of_unsplitable , Pieces <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> class Color : <EOL> BLACK = '<STR_LIT>' <EOL> RED = '<STR_LIT>' <EOL> GREEN = '<STR_LIT>' <EOL> YELLOW = '<STR_LIT>' <EOL> BLUE = '<STR_LIT>' <EOL> PINK = '<STR_LIT>' <EOL> CYAN = '<STR_LIT>' <EOL> WHITE = '<STR_LIT>' <EOL> ENDC = '<STR_LIT>' <EOL> COLOR_OK = Color . GREEN <EOL> COLOR_MISSING_FILES = Color . RED <EOL> COLOR_ALREADY_SEEDING = Color . BLUE <EOL> COLOR_FOLDER_EXIST_NOT_SEEDING = Color . YELLOW <EOL> COLOR_FAILED_TO_ADD_TO_CLIENT = Color . PINK <EOL> class Status : <EOL> OK = <NUM_LIT:0> <EOL> MISSING_FILES = <NUM_LIT:1> <EOL> ALREADY_SEEDING = <NUM_LIT:2> <EOL> FOLDER_EXIST_NOT_SEEDING = <NUM_LIT:3> <EOL> FAILED_TO_ADD_TO_CLIENT = <NUM_LIT:4> <EOL> status_messages = { <EOL> Status . OK : '<STR_LIT>' % ( COLOR_OK , Color . ENDC ) , <EOL> Status . MISSING_FILES : '<STR_LIT>' % ( COLOR_MISSING_FILES , Color . ENDC ) , <EOL> Status . ALREADY_SEEDING : '<STR_LIT>' % ( COLOR_ALREADY_SEEDING , Color . ENDC ) , <EOL> Status . FOLDER_EXIST_NOT_SEEDING : '<STR_LIT>' % ( COLOR_FOLDER_EXIST_NOT_SEEDING , Color . ENDC ) , <EOL> Status . FAILED_TO_ADD_TO_CLIENT : '<STR_LIT>' % ( COLOR_FAILED_TO_ADD_TO_CLIENT , Color . ENDC ) , <EOL> } <EOL> CHUNK_SIZE = <NUM_LIT> <EOL> class UnknownLinkTypeException ( Exception ) : <EOL> pass <EOL> class IllegalPathException ( Exception ) : <EOL> pass <EOL> class AutoTorrent ( object ) : <EOL> def __init__ ( self , db , client , store_path , add_limit_size , add_limit_percent , delete_torrents , link_type = '<STR_LIT>' ) : <EOL> self . db = db <EOL> self . client = client <EOL> self . store_path = store_path <EOL> self . add_limit_size = add_limit_size <EOL> self . add_limit_percent = add_limit_percent <EOL> self . delete_torrents = delete_torrents <EOL> self . link_type = link_type <EOL> self . torrents_seeded = set ( ) <EOL> def try_decode ( self , value ) : <EOL> try : <EOL> return value . decode ( '<STR_LIT:utf-8>' ) <EOL> except UnicodeDecodeError : <EOL> logger . debug ( '<STR_LIT>' % value ) <EOL> return value . decode ( '<STR_LIT>' ) <EOL> def is_legal_path ( self , path ) : <EOL> for p in path : <EOL> if p in [ '<STR_LIT:.>' , '<STR_LIT:..>' ] or '<STR_LIT:/>' in p : <EOL> return False <EOL> return True <EOL> def populate_torrents_seeded ( self ) : <EOL> """<STR_LIT>""" <EOL> self . torrents_seeded = set ( x . lower ( ) for x in self . client . get_torrents ( ) ) <EOL> def get_info_hash ( self , torrent ) : <EOL> """<STR_LIT>""" <EOL> return hashlib . sha1 ( bencode ( torrent [ b'<STR_LIT:info>' ] ) ) . hexdigest ( ) <EOL> def find_hash_checks ( self , torrent , result ) : <EOL> """<STR_LIT>""" <EOL> modified_result = False <EOL> pieces = Pieces ( torrent ) <EOL> if self . db . hash_slow_mode : <EOL> logger . info ( '<STR_LIT>' ) <EOL> self . db . build_hash_size_table ( ) <EOL> start_size = <NUM_LIT:0> <EOL> end_size = <NUM_LIT:0> <EOL> logger . info ( '<STR_LIT>' ) <EOL> for f in result : <EOL> start_size = end_size <EOL> end_size += f [ '<STR_LIT>' ] <EOL> if f [ '<STR_LIT>' ] : <EOL> continue <EOL> files_to_check = [ ] <EOL> logger . debug ( '<STR_LIT>' ) <EOL> if self . db . hash_size_mode : <EOL> logger . debug ( '<STR_LIT>' ) <EOL> files_to_check += self . db . find_hash_size ( f [ '<STR_LIT>' ] ) <EOL> if self . db . hash_name_mode : <EOL> logger . debug ( '<STR_LIT>' ) <EOL> name = f [ '<STR_LIT:path>' ] [ - <NUM_LIT:1> ] <EOL> files_to_check += self . db . find_hash_name ( name ) <EOL> if self . db . hash_slow_mode : <EOL> logger . debug ( '<STR_LIT>' ) <EOL> files_to_check += self . db . find_hash_varying_size ( f [ '<STR_LIT>' ] ) <EOL> logger . debug ( '<STR_LIT>' % len ( files_to_check ) ) <EOL> checked_files = set ( ) <EOL> for db_file in files_to_check : <EOL> if db_file in checked_files : <EOL> logger . debug ( '<STR_LIT>' % db_file ) <EOL> checked_files . add ( db_file ) <EOL> logger . info ( '<STR_LIT>' % db_file ) <EOL> match_start , match_end = pieces . match_file ( db_file , start_size , end_size ) <EOL> logger . info ( '<STR_LIT>' % ( db_file , match_start , match_end ) ) <EOL> if match_start or match_end : <EOL> size = os . path . getsize ( db_file ) <EOL> if size != f [ '<STR_LIT>' ] : <EOL> logger . debug ( '<STR_LIT>' ) <EOL> if match_start and match_end : <EOL> logger . debug ( '<STR_LIT>' ) <EOL> modification_point = pieces . find_piece_breakpoint ( db_file , start_size , end_size ) <EOL> elif match_start : <EOL> logger . debug ( '<STR_LIT>' ) <EOL> modification_point = min ( f [ '<STR_LIT>' ] , size ) <EOL> elif match_end : <EOL> logger . debug ( '<STR_LIT>' ) <EOL> modification_point = <NUM_LIT:0> <EOL> if size > f [ '<STR_LIT>' ] : <EOL> modification_action = '<STR_LIT>' <EOL> else : <EOL> modification_action = '<STR_LIT>' <EOL> f [ '<STR_LIT>' ] = False <EOL> f [ '<STR_LIT>' ] = ( '<STR_LIT>' , modification_action , modification_point ) <EOL> modified_result = True <EOL> else : <EOL> logger . debug ( '<STR_LIT>' ) <EOL> f [ '<STR_LIT>' ] = True <EOL> f [ '<STR_LIT>' ] = db_file <EOL> break <EOL> return modified_result , result <EOL> def index_torrent ( self , torrent ) : <EOL> """<STR_LIT>""" <EOL> torrent_name = torrent [ b'<STR_LIT:info>' ] [ b'<STR_LIT:name>' ] <EOL> logger . debug ( '<STR_LIT>' % ( torrent_name , ) ) <EOL> torrent_name = self . try_decode ( torrent_name ) <EOL> if not self . is_legal_path ( [ torrent_name ] ) : <EOL> raise IllegalPathException ( '<STR_LIT>' % torrent_name ) <EOL> logger . info ( '<STR_LIT>' % torrent_name ) <EOL> if self . db . exact_mode : <EOL> prefix = '<STR_LIT:d>' if b'<STR_LIT>' in torrent [ b'<STR_LIT:info>' ] else '<STR_LIT:f>' <EOL> paths = self . db . find_exact_file_path ( prefix , torrent_name ) <EOL> if paths : <EOL> for path in paths : <EOL> logger . debug ( '<STR_LIT>' % path ) <EOL> if prefix == '<STR_LIT:f>' : <EOL> logger . info ( '<STR_LIT>' ) <EOL> size = os . path . getsize ( path ) <EOL> if torrent [ b'<STR_LIT:info>' ] [ b'<STR_LIT>' ] != size : <EOL> continue <EOL> return { '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : os . path . dirname ( path ) , <EOL> '<STR_LIT>' : [ { <EOL> '<STR_LIT>' : path , <EOL> '<STR_LIT>' : size , <EOL> '<STR_LIT:path>' : [ torrent_name ] , <EOL> '<STR_LIT>' : True , <EOL> } ] } <EOL> else : <EOL> result = [ ] <EOL> for f in torrent [ b'<STR_LIT:info>' ] [ b'<STR_LIT>' ] : <EOL> orig_path = [ self . try_decode ( x ) for x in f [ b'<STR_LIT:path>' ] ] <EOL> p = os . path . join ( path , * orig_path ) <EOL> if not os . path . isfile ( p ) : <EOL> logger . debug ( '<STR_LIT>' % p ) <EOL> break <EOL> size = os . path . getsize ( p ) <EOL> if size != f [ b'<STR_LIT>' ] : <EOL> logger . debug ( '<STR_LIT>' % ( p , size , f [ b'<STR_LIT>' ] ) ) <EOL> break <EOL> result . append ( { <EOL> '<STR_LIT>' : p , <EOL> '<STR_LIT>' : f [ b'<STR_LIT>' ] , <EOL> '<STR_LIT:path>' : orig_path , <EOL> '<STR_LIT>' : True , <EOL> } ) <EOL> else : <EOL> logger . info ( '<STR_LIT>' ) <EOL> return { '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : path , <EOL> '<STR_LIT>' : result } <EOL> result = [ ] <EOL> if b'<STR_LIT>' in torrent [ b'<STR_LIT:info>' ] : <EOL> files_sorted = { } <EOL> files = { } <EOL> if b'<STR_LIT>' in torrent [ b'<STR_LIT:info>' ] : <EOL> i = <NUM_LIT:0> <EOL> path_files = defaultdict ( list ) <EOL> for f in torrent [ b'<STR_LIT:info>' ] [ b'<STR_LIT>' ] : <EOL> logger . debug ( '<STR_LIT>' % ( f , ) ) <EOL> orig_path = [ self . try_decode ( x ) for x in f [ b'<STR_LIT:path>' ] if x ] <EOL> if not self . is_legal_path ( orig_path ) : <EOL> raise IllegalPathException ( '<STR_LIT>' % orig_path ) <EOL> path = [ torrent_name ] + orig_path <EOL> name = path . pop ( ) <EOL> path_files [ os . path . join ( * path ) ] . append ( { <EOL> '<STR_LIT:path>' : orig_path , <EOL> '<STR_LIT>' : f [ b'<STR_LIT>' ] , <EOL> } ) <EOL> files_sorted [ '<STR_LIT:/>' . join ( orig_path ) ] = i <EOL> i += <NUM_LIT:1> <EOL> if self . db . unsplitable_mode : <EOL> unsplitable_paths = set ( ) <EOL> for path , files in path_files . items ( ) : <EOL> if is_unsplitable ( f [ '<STR_LIT:path>' ] [ - <NUM_LIT:1> ] for f in files ) : <EOL> path = path . split ( os . sep ) <EOL> name = get_root_of_unsplitable ( path ) <EOL> if not name : <EOL> continue <EOL> while path [ - <NUM_LIT:1> ] != name : <EOL> path . pop ( ) <EOL> unsplitable_paths . add ( os . path . join ( * path ) ) <EOL> for path , files in path_files . items ( ) : <EOL> if self . db . unsplitable_mode : <EOL> path = path . split ( os . sep ) <EOL> while path and os . path . join ( * path ) not in unsplitable_paths : <EOL> path . pop ( ) <EOL> else : <EOL> path = None <EOL> if path : <EOL> name = path [ - <NUM_LIT:1> ] <EOL> for f in files : <EOL> actual_path = self . db . find_unsplitable_file_path ( name , f [ '<STR_LIT:path>' ] , f [ '<STR_LIT>' ] ) <EOL> f [ '<STR_LIT>' ] = actual_path <EOL> f [ '<STR_LIT>' ] = actual_path is not None <EOL> result += files <EOL> else : <EOL> for f in files : <EOL> actual_path = self . db . find_file_path ( f [ '<STR_LIT:path>' ] [ - <NUM_LIT:1> ] , f [ '<STR_LIT>' ] ) <EOL> f [ '<STR_LIT>' ] = actual_path <EOL> f [ '<STR_LIT>' ] = actual_path is not None <EOL> result += files <EOL> result = sorted ( result , key = lambda x : files_sorted [ '<STR_LIT:/>' . join ( x [ '<STR_LIT:path>' ] ) ] ) <EOL> else : <EOL> length = torrent [ b'<STR_LIT:info>' ] [ b'<STR_LIT>' ] <EOL> actual_path = self . db . find_file_path ( torrent_name , length ) <EOL> result . append ( { <EOL> '<STR_LIT>' : actual_path , <EOL> '<STR_LIT>' : length , <EOL> '<STR_LIT:path>' : [ torrent_name ] , <EOL> '<STR_LIT>' : actual_path is not None , <EOL> } ) <EOL> mode = '<STR_LIT>' <EOL> if self . db . hash_mode : <EOL> modified_result , result = self . find_hash_checks ( torrent , result ) <EOL> if modified_result : <EOL> mode = '<STR_LIT>' <EOL> return { '<STR_LIT>' : mode , '<STR_LIT>' : result } <EOL> def parse_torrent ( self , torrent ) : <EOL> """<STR_LIT>""" <EOL> files = self . index_torrent ( torrent ) <EOL> found_size , missing_size = <NUM_LIT:0> , <NUM_LIT:0> <EOL> for f in files [ '<STR_LIT>' ] : <EOL> if f [ '<STR_LIT>' ] or f . get ( '<STR_LIT>' ) : <EOL> found_size += f [ '<STR_LIT>' ] <EOL> else : <EOL> missing_size += f [ '<STR_LIT>' ] <EOL> return found_size , missing_size , files <EOL> def link_files ( self , destination_path , files ) : <EOL> """<STR_LIT>""" <EOL> if not os . path . isdir ( destination_path ) : <EOL> os . makedirs ( destination_path ) <EOL> for f in files : <EOL> if f [ '<STR_LIT>' ] : <EOL> destination = os . path . join ( destination_path , * f [ '<STR_LIT:path>' ] ) <EOL> file_path = os . path . dirname ( destination ) <EOL> if not os . path . isdir ( file_path ) : <EOL> logger . debug ( '<STR_LIT>' % file_path ) <EOL> os . makedirs ( file_path ) <EOL> logger . debug ( '<STR_LIT>' % ( self . link_type , f [ '<STR_LIT>' ] , destination ) ) <EOL> if self . link_type == '<STR_LIT>' : <EOL> os . symlink ( f [ '<STR_LIT>' ] , destination ) <EOL> elif self . link_type == '<STR_LIT>' : <EOL> os . link ( f [ '<STR_LIT>' ] , destination ) <EOL> else : <EOL> raise UnknownLinkTypeException ( '<STR_LIT>' % self . link_type ) <EOL> def rewrite_hashed_files ( self , destination_path , files ) : <EOL> """<STR_LIT>""" <EOL> if not os . path . isdir ( destination_path ) : <EOL> os . makedirs ( destination_path ) <EOL> for f in files : <EOL> if not f [ '<STR_LIT>' ] and '<STR_LIT>' in f : <EOL> destination = os . path . join ( destination_path , * f [ '<STR_LIT:path>' ] ) <EOL> file_path = os . path . dirname ( destination ) <EOL> if not os . path . isdir ( file_path ) : <EOL> logger . debug ( '<STR_LIT>' % file_path ) <EOL> os . makedirs ( file_path ) <EOL> logger . debug ( '<STR_LIT>' % ( f [ '<STR_LIT>' ] , destination ) ) <EOL> _ , modification_action , modification_point = f [ '<STR_LIT>' ] <EOL> current_size = os . path . getsize ( f [ '<STR_LIT>' ] ) <EOL> expected_size = f [ '<STR_LIT>' ] <EOL> diff = abs ( current_size - expected_size ) <EOL> modified = False <EOL> bytes_written = <NUM_LIT:0> <EOL> with open ( destination , '<STR_LIT:wb>' ) as output_fp : <EOL> with open ( f [ '<STR_LIT>' ] , '<STR_LIT:rb>' ) as input_fp : <EOL> logger . debug ( '<STR_LIT>' % ( f [ '<STR_LIT>' ] , destination , modification_point ) ) <EOL> while True : <EOL> if not modified and bytes_written == modification_point : <EOL> logger . debug ( '<STR_LIT>' % ( modification_action , diff ) ) <EOL> modified = True <EOL> if modification_action == '<STR_LIT>' : <EOL> seek_point = bytes_written + diff <EOL> logger . debug ( '<STR_LIT>' % ( seek_point , ) ) <EOL> input_fp . seek ( seek_point ) <EOL> elif modification_action == '<STR_LIT>' : <EOL> logger . debug ( '<STR_LIT>' % diff ) <EOL> while diff > <NUM_LIT:0> : <EOL> write_bytes = min ( CHUNK_SIZE , diff ) <EOL> output_fp . write ( b'<STR_LIT:\x00>' * write_bytes ) <EOL> diff -= write_bytes <EOL> read_bytes = CHUNK_SIZE <EOL> if not modified : <EOL> read_bytes = min ( read_bytes , modification_point - bytes_written ) <EOL> logger . debug ( '<STR_LIT>' % ( read_bytes , ) ) <EOL> data = input_fp . read ( read_bytes ) <EOL> if not data : <EOL> break <EOL> output_fp . write ( data ) <EOL> bytes_written += read_bytes <EOL> logger . debug ( '<STR_LIT>' ) <EOL> def handle_torrentfile ( self , path , dry_run = False ) : <EOL> """<STR_LIT>""" <EOL> logger . info ( '<STR_LIT>' % path ) <EOL> torrent = self . open_torrentfile ( path ) <EOL> if self . check_torrent_in_client ( torrent ) : <EOL> self . print_status ( Status . ALREADY_SEEDING , path , '<STR_LIT>' ) <EOL> if self . delete_torrents : <EOL> logger . info ( '<STR_LIT>' % path ) <EOL> os . remove ( path ) <EOL> return Status . ALREADY_SEEDING <EOL> found_size , missing_size , files = self . parse_torrent ( torrent ) <EOL> missing_percent = ( missing_size / ( found_size + missing_size ) ) * <NUM_LIT:100> <EOL> found_percent = <NUM_LIT:100> - missing_percent <EOL> would_not_add = missing_size and missing_percent > self . add_limit_percent or missing_size > self . add_limit_size <EOL> if dry_run : <EOL> return found_size , missing_size , would_not_add , [ f [ '<STR_LIT>' ] for f in files [ '<STR_LIT>' ] if f . get ( '<STR_LIT>' ) ] <EOL> if would_not_add : <EOL> logger . info ( '<STR_LIT>' % ( path , found_percent , humanize_bytes ( missing_size ) ) ) <EOL> self . print_status ( Status . MISSING_FILES , path , '<STR_LIT>' % ( found_percent , humanize_bytes ( missing_size ) ) ) <EOL> return Status . MISSING_FILES <EOL> if files [ '<STR_LIT>' ] == '<STR_LIT>' or files [ '<STR_LIT>' ] == '<STR_LIT>' : <EOL> logger . info ( '<STR_LIT>' ) <EOL> destination_path = os . path . join ( self . store_path , os . path . splitext ( os . path . basename ( path ) ) [ <NUM_LIT:0> ] ) <EOL> if os . path . isdir ( destination_path ) : <EOL> logger . info ( '<STR_LIT>' % destination_path ) <EOL> self . print_status ( Status . FOLDER_EXIST_NOT_SEEDING , path , '<STR_LIT>' ) <EOL> return Status . FOLDER_EXIST_NOT_SEEDING <EOL> self . link_files ( destination_path , files [ '<STR_LIT>' ] ) <EOL> elif files [ '<STR_LIT>' ] == '<STR_LIT>' : <EOL> logger . info ( '<STR_LIT>' ) <EOL> destination_path = files [ '<STR_LIT>' ] <EOL> fast_resume = True <EOL> if files [ '<STR_LIT>' ] == '<STR_LIT>' : <EOL> fast_resume = False <EOL> logger . info ( '<STR_LIT>' ) <EOL> self . rewrite_hashed_files ( destination_path , files [ '<STR_LIT>' ] ) <EOL> if self . delete_torrents : <EOL> logger . info ( '<STR_LIT>' % path ) <EOL> os . remove ( path ) <EOL> if self . client . add_torrent ( torrent , destination_path , files [ '<STR_LIT>' ] , fast_resume ) : <EOL> self . print_status ( Status . OK , path , '<STR_LIT>' ) <EOL> return Status . OK <EOL> else : <EOL> self . print_status ( Status . FAILED_TO_ADD_TO_CLIENT , path , '<STR_LIT>' ) <EOL> return Status . FAILED_TO_ADD_TO_CLIENT <EOL> def check_torrent_in_client ( self , torrent ) : <EOL> """<STR_LIT>""" <EOL> info_hash = self . get_info_hash ( torrent ) <EOL> return info_hash in self . torrents_seeded <EOL> def open_torrentfile ( self , path ) : <EOL> """<STR_LIT>""" <EOL> with open ( path , '<STR_LIT:rb>' ) as f : <EOL> return bdecode ( f . read ( ) ) <EOL> def print_status ( self , status , torrentfile , message ) : <EOL> print ( '<STR_LIT>' % ( '<STR_LIT>' % status_messages [ status ] , os . path . splitext ( os . path . basename ( torrentfile ) ) [ <NUM_LIT:0> ] , message ) ) </s>
<s> import pytest <EOL> import exceptions <EOL> def test_exceptions ( ) : <EOL> with pytest . raises ( Exception ) : <EOL> raise exceptions . CardinalException <EOL> with pytest . raises ( exceptions . CardinalException ) : <EOL> raise exceptions . InternalError <EOL> with pytest . raises ( exceptions . CardinalException ) : <EOL> raise exceptions . PluginError <EOL> with pytest . raises ( exceptions . CardinalException ) : <EOL> raise exceptions . CommandNotFoundError <EOL> with pytest . raises ( exceptions . CardinalException ) : <EOL> raise exceptions . ConfigNotFoundError <EOL> with pytest . raises ( exceptions . CardinalException ) : <EOL> raise exceptions . AmbiguousConfigError <EOL> with pytest . raises ( exceptions . CardinalException ) : <EOL> raise exceptions . EventAlreadyExistsError <EOL> with pytest . raises ( exceptions . CardinalException ) : <EOL> raise exceptions . EventDoesNotExistError <EOL> with pytest . raises ( exceptions . CardinalException ) : <EOL> raise exceptions . EventCallbackError <EOL> with pytest . raises ( exceptions . CardinalException ) : <EOL> raise exceptions . EventRejectedMessage </s>
<s> import os <EOL> import legofy <EOL> import tkinter as tk <EOL> import tkinter . ttk as ttk <EOL> from tkinter import filedialog <EOL> import tkinter . messagebox as tkmsg <EOL> LEGO_PALETTE = ( '<STR_LIT:none>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT:all>' , ) <EOL> class LegofyGui ( tk . Tk ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( ) . __init__ ( * args , ** kwargs ) <EOL> self . wm_title ( "<STR_LIT>" ) <EOL> self . iconbitmap ( os . path . dirname ( os . path . realpath ( __file__ ) ) + '<STR_LIT>' ) <EOL> self . resizable ( False , False ) <EOL> self . body = LegofyGuiMainFrame ( self ) <EOL> self . body . grid ( row = <NUM_LIT:0> , column = <NUM_LIT:0> , padx = <NUM_LIT:10> , pady = <NUM_LIT:10> ) <EOL> class LegofyGuiMainFrame ( tk . Frame ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( ) . __init__ ( * args , ** kwargs ) <EOL> self . chosenFile = None <EOL> self . chosenFilePath = tk . StringVar ( ) <EOL> self . pathField = tk . Entry ( self , width = <NUM_LIT> , textvariable = self . chosenFilePath , state = tk . DISABLED ) <EOL> self . pathField . grid ( row = <NUM_LIT:0> , column = <NUM_LIT:0> , padx = <NUM_LIT:10> ) <EOL> self . selectFile = tk . Button ( self , text = "<STR_LIT>" , command = self . choose_a_file ) <EOL> self . selectFile . grid ( row = <NUM_LIT:0> , column = <NUM_LIT:1> ) <EOL> self . groupFrame = tk . LabelFrame ( self , text = "<STR_LIT>" , padx = <NUM_LIT:5> , pady = <NUM_LIT:5> ) <EOL> self . groupFrame . grid ( row = <NUM_LIT:1> , column = <NUM_LIT:0> , columnspan = <NUM_LIT:2> , ) <EOL> self . colorPaletteLabel = tk . Label ( self . groupFrame , text = '<STR_LIT>' ) <EOL> self . colorPaletteLabel . grid ( row = <NUM_LIT:0> , column = <NUM_LIT:0> ) <EOL> self . colorPalette = ttk . Combobox ( self . groupFrame ) <EOL> self . colorPalette [ '<STR_LIT>' ] = LEGO_PALETTE <EOL> self . colorPalette . current ( <NUM_LIT:0> ) <EOL> self . colorPalette . grid ( row = <NUM_LIT:0> , column = <NUM_LIT:1> ) <EOL> self . brickNumberScale = tk . Scale ( self . groupFrame , from_ = <NUM_LIT:1> , to = <NUM_LIT:200> , orient = tk . HORIZONTAL , label = "<STR_LIT>" , length = <NUM_LIT> ) <EOL> self . brickNumberScale . set ( <NUM_LIT:30> ) <EOL> self . brickNumberScale . grid ( row = <NUM_LIT:1> , column = <NUM_LIT:0> , columnspan = <NUM_LIT:2> , ) <EOL> self . convertFile = tk . Button ( text = "<STR_LIT>" , command = self . convert_file ) <EOL> self . convertFile . grid ( row = <NUM_LIT:2> , column = <NUM_LIT:0> , columnspan = <NUM_LIT:2> ) <EOL> def choose_a_file ( self ) : <EOL> options = { } <EOL> options [ '<STR_LIT>' ] = '<STR_LIT>' <EOL> options [ '<STR_LIT>' ] = [ ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> ( '<STR_LIT>' , '<STR_LIT>' ) , ] <EOL> options [ '<STR_LIT>' ] = os . path . realpath ( "<STR_LIT:\\>" ) <EOL> options [ '<STR_LIT>' ] = '<STR_LIT>' <EOL> options [ '<STR_LIT>' ] = self <EOL> options [ '<STR_LIT:title>' ] = '<STR_LIT>' <EOL> self . chosenFile = filedialog . askopenfile ( mode = '<STR_LIT:r>' , ** options ) <EOL> if self . chosenFile : <EOL> self . chosenFilePath . set ( self . chosenFile . name ) <EOL> def convert_file ( self ) : <EOL> try : <EOL> if self . chosenFile is not None : <EOL> palette = self . colorPalette . get ( ) <EOL> if palette in LEGO_PALETTE and palette != '<STR_LIT:none>' : <EOL> legofy . main ( self . chosenFile . name , size = self . brickNumberScale . get ( ) , palette_mode = palette ) <EOL> else : <EOL> legofy . main ( self . chosenFile . name , size = self . brickNumberScale . get ( ) ) <EOL> tkmsg . showinfo ( "<STR_LIT>" , "<STR_LIT>" ) <EOL> else : <EOL> tkmsg . showerror ( "<STR_LIT>" , "<STR_LIT>" ) <EOL> except Exception as e : <EOL> tkmsg . showerror ( "<STR_LIT>" , str ( e ) ) <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL> app = LegofyGui ( ) <EOL> app . mainloop ( ) </s>
<s> from distutils . core import setup <EOL> from condent import __version__ <EOL> with open ( "<STR_LIT>" ) as readme : <EOL> long_description = readme . read ( ) <EOL> classifiers = [ <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> ] <EOL> setup ( <EOL> name = "<STR_LIT>" , <EOL> version = __version__ , <EOL> py_modules = [ "<STR_LIT>" ] , <EOL> scripts = [ "<STR_LIT>" ] , <EOL> author = "<STR_LIT>" , <EOL> author_email = "<STR_LIT>" , <EOL> classifiers = classifiers , <EOL> description = "<STR_LIT>" , <EOL> license = "<STR_LIT>" , <EOL> long_description = long_description , <EOL> url = "<STR_LIT>" , <EOL> ) </s>
<s> from pyvi import window <EOL> from pyvi . modes import normal <EOL> class Editor ( object ) : <EOL> _command = None <EOL> active_tab = None <EOL> def __init__ ( self , tabs = None , config = None , normal = normal ) : <EOL> self . config = config <EOL> self . mode = self . normal = normal <EOL> self . count = None <EOL> if tabs is None : <EOL> tabs = self . tabs = [ window . Tab ( self ) ] <EOL> else : <EOL> tabs = self . tabs = list ( tabs ) <EOL> if tabs : <EOL> self . active_tab = tabs [ <NUM_LIT:0> ] <EOL> @ property <EOL> def active_window ( self ) : <EOL> return self . active_tab . active_window <EOL> def keypress ( self , keys ) : <EOL> return self . mode . keypress ( self , keys ) </s>
<s> from collections import deque <EOL> from contextlib import contextmanager <EOL> import json <EOL> from jsonschema import FormatChecker , ValidationError <EOL> from jsonschema . tests . compat import mock , unittest <EOL> from jsonschema . validators import ( <EOL> RefResolutionError , UnknownType , Draft3Validator , <EOL> Draft4Validator , RefResolver , create , extend , validator_for , validate , <EOL> ) <EOL> class TestCreateAndExtend ( unittest . TestCase ) : <EOL> def setUp ( self ) : <EOL> self . meta_schema = { u"<STR_LIT>" : { u"<STR_LIT>" : { } } } <EOL> self . smelly = mock . MagicMock ( ) <EOL> self . validators = { u"<STR_LIT>" : self . smelly } <EOL> self . types = { u"<STR_LIT>" : dict } <EOL> self . Validator = create ( <EOL> meta_schema = self . meta_schema , <EOL> validators = self . validators , <EOL> default_types = self . types , <EOL> ) <EOL> self . validator_value = <NUM_LIT:12> <EOL> self . schema = { u"<STR_LIT>" : self . validator_value } <EOL> self . validator = self . Validator ( self . schema ) <EOL> def test_attrs ( self ) : <EOL> self . assertEqual ( self . Validator . VALIDATORS , self . validators ) <EOL> self . assertEqual ( self . Validator . META_SCHEMA , self . meta_schema ) <EOL> self . assertEqual ( self . Validator . DEFAULT_TYPES , self . types ) <EOL> def test_init ( self ) : <EOL> self . assertEqual ( self . validator . schema , self . schema ) <EOL> def test_iter_errors ( self ) : <EOL> instance = "<STR_LIT:hello>" <EOL> self . smelly . return_value = [ ] <EOL> self . assertEqual ( list ( self . validator . iter_errors ( instance ) ) , [ ] ) <EOL> error = mock . Mock ( ) <EOL> self . smelly . return_value = [ error ] <EOL> self . assertEqual ( list ( self . validator . iter_errors ( instance ) ) , [ error ] ) <EOL> self . smelly . assert_called_with ( <EOL> self . validator , self . validator_value , instance , self . schema , <EOL> ) <EOL> def test_if_a_version_is_provided_it_is_registered ( self ) : <EOL> with mock . patch ( "<STR_LIT>" ) as validates : <EOL> validates . side_effect = lambda version : lambda cls : cls <EOL> Validator = create ( meta_schema = { u"<STR_LIT:id>" : "<STR_LIT>" } , version = "<STR_LIT>" ) <EOL> validates . assert_called_once_with ( "<STR_LIT>" ) <EOL> self . assertEqual ( Validator . __name__ , "<STR_LIT>" ) <EOL> def test_if_a_version_is_not_provided_it_is_not_registered ( self ) : <EOL> with mock . patch ( "<STR_LIT>" ) as validates : <EOL> create ( meta_schema = { u"<STR_LIT:id>" : "<STR_LIT:id>" } ) <EOL> self . assertFalse ( validates . called ) <EOL> def test_extend ( self ) : <EOL> validators = dict ( self . Validator . VALIDATORS ) <EOL> new = mock . Mock ( ) <EOL> Extended = extend ( self . Validator , validators = { u"<STR_LIT>" : new } ) <EOL> validators . update ( [ ( u"<STR_LIT>" , new ) ] ) <EOL> self . assertEqual ( Extended . VALIDATORS , validators ) <EOL> self . assertNotIn ( u"<STR_LIT>" , self . Validator . VALIDATORS ) <EOL> self . assertEqual ( Extended . META_SCHEMA , self . Validator . META_SCHEMA ) <EOL> self . assertEqual ( Extended . DEFAULT_TYPES , self . Validator . DEFAULT_TYPES ) <EOL> class TestIterErrors ( unittest . TestCase ) : <EOL> def setUp ( self ) : <EOL> self . validator = Draft3Validator ( { } ) <EOL> def test_iter_errors ( self ) : <EOL> instance = [ <NUM_LIT:1> , <NUM_LIT:2> ] <EOL> schema = { <EOL> u"<STR_LIT>" : u"<STR_LIT>" , <EOL> u"<STR_LIT>" : [ [ "<STR_LIT:a>" , "<STR_LIT:b>" , "<STR_LIT:c>" ] , [ "<STR_LIT:d>" , "<STR_LIT:e>" , "<STR_LIT:f>" ] ] , <EOL> u"<STR_LIT>" : <NUM_LIT:3> <EOL> } <EOL> got = ( e . message for e in self . validator . iter_errors ( instance , schema ) ) <EOL> expected = [ <EOL> "<STR_LIT>" % ( schema [ "<STR_LIT>" ] , ) , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" % ( schema [ "<STR_LIT>" ] , ) , <EOL> ] <EOL> self . assertEqual ( sorted ( got ) , sorted ( expected ) ) <EOL> def test_iter_errors_multiple_failures_one_validator ( self ) : <EOL> instance = { "<STR_LIT:foo>" : <NUM_LIT:2> , "<STR_LIT:bar>" : [ <NUM_LIT:1> ] , "<STR_LIT>" : <NUM_LIT:15> , "<STR_LIT>" : "<STR_LIT>" } <EOL> schema = { <EOL> u"<STR_LIT>" : { <EOL> "<STR_LIT:foo>" : { u"<STR_LIT:type>" : "<STR_LIT:string>" } , <EOL> "<STR_LIT:bar>" : { u"<STR_LIT>" : <NUM_LIT:2> } , <EOL> "<STR_LIT>" : { u"<STR_LIT>" : <NUM_LIT:10> , u"<STR_LIT>" : [ <NUM_LIT:2> , <NUM_LIT:4> , <NUM_LIT:6> , <NUM_LIT:8> ] } , <EOL> } <EOL> } <EOL> errors = list ( self . validator . iter_errors ( instance , schema ) ) <EOL> self . assertEqual ( len ( errors ) , <NUM_LIT:4> ) <EOL> class TestValidationErrorMessages ( unittest . TestCase ) : <EOL> def message_for ( self , instance , schema , * args , ** kwargs ) : <EOL> kwargs . setdefault ( "<STR_LIT>" , Draft3Validator ) <EOL> with self . assertRaises ( ValidationError ) as e : <EOL> validate ( instance , schema , * args , ** kwargs ) <EOL> return e . exception . message <EOL> def test_single_type_failure ( self ) : <EOL> message = self . message_for ( instance = <NUM_LIT:1> , schema = { u"<STR_LIT:type>" : u"<STR_LIT:string>" } ) <EOL> self . assertEqual ( message , "<STR_LIT>" % u"<STR_LIT:string>" ) <EOL> def test_single_type_list_failure ( self ) : <EOL> message = self . message_for ( instance = <NUM_LIT:1> , schema = { u"<STR_LIT:type>" : [ u"<STR_LIT:string>" ] } ) <EOL> self . assertEqual ( message , "<STR_LIT>" % u"<STR_LIT:string>" ) <EOL> def test_multiple_type_failure ( self ) : <EOL> types = u"<STR_LIT:string>" , u"<STR_LIT:object>" <EOL> message = self . message_for ( instance = <NUM_LIT:1> , schema = { u"<STR_LIT:type>" : list ( types ) } ) <EOL> self . assertEqual ( message , "<STR_LIT>" % types ) <EOL> def test_object_without_title_type_failure ( self ) : <EOL> type = { u"<STR_LIT:type>" : [ { u"<STR_LIT>" : <NUM_LIT:3> } ] } <EOL> message = self . message_for ( instance = <NUM_LIT:1> , schema = { u"<STR_LIT:type>" : [ type ] } ) <EOL> self . assertEqual ( message , "<STR_LIT>" % ( type , ) ) <EOL> def test_object_with_name_type_failure ( self ) : <EOL> name = "<STR_LIT>" <EOL> schema = { u"<STR_LIT:type>" : [ { u"<STR_LIT:name>" : name , u"<STR_LIT>" : <NUM_LIT:3> } ] } <EOL> message = self . message_for ( instance = <NUM_LIT:1> , schema = schema ) <EOL> self . assertEqual ( message , "<STR_LIT>" % ( name , ) ) <EOL> def test_minimum ( self ) : <EOL> message = self . message_for ( instance = <NUM_LIT:1> , schema = { "<STR_LIT>" : <NUM_LIT:2> } ) <EOL> self . assertEqual ( message , "<STR_LIT>" ) <EOL> def test_maximum ( self ) : <EOL> message = self . message_for ( instance = <NUM_LIT:1> , schema = { "<STR_LIT>" : <NUM_LIT:0> } ) <EOL> self . assertEqual ( message , "<STR_LIT>" ) <EOL> def test_dependencies_failure_has_single_element_not_list ( self ) : <EOL> depend , on = "<STR_LIT:bar>" , "<STR_LIT:foo>" <EOL> schema = { u"<STR_LIT>" : { depend : on } } <EOL> message = self . message_for ( { "<STR_LIT:bar>" : <NUM_LIT:2> } , schema ) <EOL> self . assertEqual ( message , "<STR_LIT>" % ( on , depend ) ) <EOL> def test_additionalItems_single_failure ( self ) : <EOL> message = self . message_for ( <EOL> [ <NUM_LIT:2> ] , { u"<STR_LIT>" : [ ] , u"<STR_LIT>" : False } , <EOL> ) <EOL> self . assertIn ( "<STR_LIT>" , message ) <EOL> def test_additionalItems_multiple_failures ( self ) : <EOL> message = self . message_for ( <EOL> [ <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> ] , { u"<STR_LIT>" : [ ] , u"<STR_LIT>" : False } <EOL> ) <EOL> self . assertIn ( "<STR_LIT>" , message ) <EOL> def test_additionalProperties_single_failure ( self ) : <EOL> additional = "<STR_LIT:foo>" <EOL> schema = { u"<STR_LIT>" : False } <EOL> message = self . message_for ( { additional : <NUM_LIT:2> } , schema ) <EOL> self . assertIn ( "<STR_LIT>" % ( additional , ) , message ) <EOL> def test_additionalProperties_multiple_failures ( self ) : <EOL> schema = { u"<STR_LIT>" : False } <EOL> message = self . message_for ( dict . fromkeys ( [ "<STR_LIT:foo>" , "<STR_LIT:bar>" ] ) , schema ) <EOL> self . assertIn ( repr ( "<STR_LIT:foo>" ) , message ) <EOL> self . assertIn ( repr ( "<STR_LIT:bar>" ) , message ) <EOL> self . assertIn ( "<STR_LIT>" , message ) <EOL> def test_invalid_format_default_message ( self ) : <EOL> checker = FormatChecker ( formats = ( ) ) <EOL> check_fn = mock . Mock ( return_value = False ) <EOL> checker . checks ( u"<STR_LIT>" ) ( check_fn ) <EOL> schema = { u"<STR_LIT>" : u"<STR_LIT>" } <EOL> message = self . message_for ( "<STR_LIT>" , schema , format_checker = checker ) <EOL> self . assertIn ( repr ( "<STR_LIT>" ) , message ) <EOL> self . assertIn ( repr ( "<STR_LIT>" ) , message ) <EOL> self . assertIn ( "<STR_LIT>" , message ) <EOL> class TestValidationErrorDetails ( unittest . TestCase ) : <EOL> def test_anyOf ( self ) : <EOL> instance = <NUM_LIT:5> <EOL> schema = { <EOL> "<STR_LIT>" : [ <EOL> { "<STR_LIT>" : <NUM_LIT:20> } , <EOL> { "<STR_LIT:type>" : "<STR_LIT:string>" } <EOL> ] <EOL> } <EOL> validator = Draft4Validator ( schema ) <EOL> errors = list ( validator . iter_errors ( instance ) ) <EOL> self . assertEqual ( len ( errors ) , <NUM_LIT:1> ) <EOL> e = errors [ <NUM_LIT:0> ] <EOL> self . assertEqual ( e . validator , "<STR_LIT>" ) <EOL> self . assertEqual ( e . validator_value , schema [ "<STR_LIT>" ] ) <EOL> self . assertEqual ( e . instance , instance ) <EOL> self . assertEqual ( e . schema , schema ) <EOL> self . assertIsNone ( e . parent ) <EOL> self . assertEqual ( e . path , deque ( [ ] ) ) <EOL> self . assertEqual ( e . relative_path , deque ( [ ] ) ) <EOL> self . assertEqual ( e . absolute_path , deque ( [ ] ) ) <EOL> self . assertEqual ( e . schema_path , deque ( [ "<STR_LIT>" ] ) ) <EOL> self . assertEqual ( e . relative_schema_path , deque ( [ "<STR_LIT>" ] ) ) <EOL> self . assertEqual ( e . absolute_schema_path , deque ( [ "<STR_LIT>" ] ) ) <EOL> self . assertEqual ( len ( e . context ) , <NUM_LIT:2> ) <EOL> e1 , e2 = sorted_errors ( e . context ) <EOL> self . assertEqual ( e1 . validator , "<STR_LIT>" ) <EOL> self . assertEqual ( e1 . validator_value , schema [ "<STR_LIT>" ] [ <NUM_LIT:0> ] [ "<STR_LIT>" ] ) <EOL> self . assertEqual ( e1 . instance , instance ) <EOL> self . assertEqual ( e1 . schema , schema [ "<STR_LIT>" ] [ <NUM_LIT:0> ] ) <EOL> self . assertIs ( e1 . parent , e ) <EOL> self . assertEqual ( e1 . path , deque ( [ ] ) ) <EOL> self . assertEqual ( e1 . absolute_path , deque ( [ ] ) ) <EOL> self . assertEqual ( e1 . relative_path , deque ( [ ] ) ) <EOL> self . assertEqual ( e1 . schema_path , deque ( [ <NUM_LIT:0> , "<STR_LIT>" ] ) ) <EOL> self . assertEqual ( e1 . relative_schema_path , deque ( [ <NUM_LIT:0> , "<STR_LIT>" ] ) ) <EOL> self . assertEqual ( <EOL> e1 . absolute_schema_path , deque ( [ "<STR_LIT>" , <NUM_LIT:0> , "<STR_LIT>" ] ) , <EOL> ) <EOL> self . assertFalse ( e1 . context ) <EOL> self . assertEqual ( e2 . validator , "<STR_LIT:type>" ) <EOL> self . assertEqual ( e2 . validator_value , schema [ "<STR_LIT>" ] [ <NUM_LIT:1> ] [ "<STR_LIT:type>" ] ) <EOL> self . assertEqual ( e2 . instance , instance ) <EOL> self . assertEqual ( e2 . schema , schema [ "<STR_LIT>" ] [ <NUM_LIT:1> ] ) <EOL> self . assertIs ( e2 . parent , e ) <EOL> self . assertEqual ( e2 . path , deque ( [ ] ) ) <EOL> self . assertEqual ( e2 . relative_path , deque ( [ ] ) ) <EOL> self . assertEqual ( e2 . absolute_path , deque ( [ ] ) ) <EOL> self . assertEqual ( e2 . schema_path , deque ( [ <NUM_LIT:1> , "<STR_LIT:type>" ] ) ) <EOL> self . assertEqual ( e2 . relative_schema_path , deque ( [ <NUM_LIT:1> , "<STR_LIT:type>" ] ) ) <EOL> self . assertEqual ( e2 . absolute_schema_path , deque ( [ "<STR_LIT>" , <NUM_LIT:1> , "<STR_LIT:type>" ] ) ) <EOL> self . assertEqual ( len ( e2 . context ) , <NUM_LIT:0> ) <EOL> def test_type ( self ) : <EOL> instance = { "<STR_LIT:foo>" : <NUM_LIT:1> } <EOL> schema = { <EOL> "<STR_LIT:type>" : [ <EOL> { "<STR_LIT:type>" : "<STR_LIT>" } , <EOL> { <EOL> "<STR_LIT:type>" : "<STR_LIT:object>" , <EOL> "<STR_LIT>" : { <EOL> "<STR_LIT:foo>" : { "<STR_LIT>" : [ <NUM_LIT:2> ] } <EOL> } <EOL> } <EOL> ] <EOL> } <EOL> validator = Draft3Validator ( schema ) <EOL> errors = list ( validator . iter_errors ( instance ) ) <EOL> self . assertEqual ( len ( errors ) , <NUM_LIT:1> ) <EOL> e = errors [ <NUM_LIT:0> ] <EOL> self . assertEqual ( e . validator , "<STR_LIT:type>" ) <EOL> self . assertEqual ( e . validator_value , schema [ "<STR_LIT:type>" ] ) <EOL> self . assertEqual ( e . instance , instance ) <EOL> self . assertEqual ( e . schema , schema ) <EOL> self . assertIsNone ( e . parent ) <EOL> self . assertEqual ( e . path , deque ( [ ] ) ) <EOL> self . assertEqual ( e . relative_path , deque ( [ ] ) ) <EOL> self . assertEqual ( e . absolute_path , deque ( [ ] ) ) <EOL> self . assertEqual ( e . schema_path , deque ( [ "<STR_LIT:type>" ] ) ) <EOL> self . assertEqual ( e . relative_schema_path , deque ( [ "<STR_LIT:type>" ] ) ) <EOL> self . assertEqual ( e . absolute_schema_path , deque ( [ "<STR_LIT:type>" ] ) ) <EOL> self . assertEqual ( len ( e . context ) , <NUM_LIT:2> ) <EOL> e1 , e2 = sorted_errors ( e . context ) <EOL> self . assertEqual ( e1 . validator , "<STR_LIT:type>" ) <EOL> self . assertEqual ( e1 . validator_value , schema [ "<STR_LIT:type>" ] [ <NUM_LIT:0> ] [ "<STR_LIT:type>" ] ) <EOL> self . assertEqual ( e1 . instance , instance ) <EOL> self . assertEqual ( e1 . schema , schema [ "<STR_LIT:type>" ] [ <NUM_LIT:0> ] ) <EOL> self . assertIs ( e1 . parent , e ) <EOL> self . assertEqual ( e1 . path , deque ( [ ] ) ) <EOL> self . assertEqual ( e1 . relative_path , deque ( [ ] ) ) <EOL> self . assertEqual ( e1 . absolute_path , deque ( [ ] ) ) <EOL> self . assertEqual ( e1 . schema_path , deque ( [ <NUM_LIT:0> , "<STR_LIT:type>" ] ) ) <EOL> self . assertEqual ( e1 . relative_schema_path , deque ( [ <NUM_LIT:0> , "<STR_LIT:type>" ] ) ) <EOL> self . assertEqual ( e1 . absolute_schema_path , deque ( [ "<STR_LIT:type>" , <NUM_LIT:0> , "<STR_LIT:type>" ] ) ) <EOL> self . assertFalse ( e1 . context ) <EOL> self . assertEqual ( e2 . validator , "<STR_LIT>" ) <EOL> self . assertEqual ( e2 . validator_value , [ <NUM_LIT:2> ] ) <EOL> self . assertEqual ( e2 . instance , <NUM_LIT:1> ) <EOL> self . assertEqual ( e2 . schema , { u"<STR_LIT>" : [ <NUM_LIT:2> ] } ) <EOL> self . assertIs ( e2 . parent , e ) <EOL> self . assertEqual ( e2 . path , deque ( [ "<STR_LIT:foo>" ] ) ) <EOL> self . assertEqual ( e2 . relative_path , deque ( [ "<STR_LIT:foo>" ] ) ) <EOL> self . assertEqual ( e2 . absolute_path , deque ( [ "<STR_LIT:foo>" ] ) ) <EOL> self . assertEqual ( <EOL> e2 . schema_path , deque ( [ <NUM_LIT:1> , "<STR_LIT>" , "<STR_LIT:foo>" , "<STR_LIT>" ] ) , <EOL> ) <EOL> self . assertEqual ( <EOL> e2 . relative_schema_path , deque ( [ <NUM_LIT:1> , "<STR_LIT>" , "<STR_LIT:foo>" , "<STR_LIT>" ] ) , <EOL> ) <EOL> self . assertEqual ( <EOL> e2 . absolute_schema_path , <EOL> deque ( [ "<STR_LIT:type>" , <NUM_LIT:1> , "<STR_LIT>" , "<STR_LIT:foo>" , "<STR_LIT>" ] ) , <EOL> ) <EOL> self . assertFalse ( e2 . context ) <EOL> def test_single_nesting ( self ) : <EOL> instance = { "<STR_LIT:foo>" : <NUM_LIT:2> , "<STR_LIT:bar>" : [ <NUM_LIT:1> ] , "<STR_LIT>" : <NUM_LIT:15> , "<STR_LIT>" : "<STR_LIT>" } <EOL> schema = { <EOL> "<STR_LIT>" : { <EOL> "<STR_LIT:foo>" : { "<STR_LIT:type>" : "<STR_LIT:string>" } , <EOL> "<STR_LIT:bar>" : { "<STR_LIT>" : <NUM_LIT:2> } , <EOL> "<STR_LIT>" : { "<STR_LIT>" : <NUM_LIT:10> , "<STR_LIT>" : [ <NUM_LIT:2> , <NUM_LIT:4> , <NUM_LIT:6> , <NUM_LIT:8> ] } , <EOL> } <EOL> } <EOL> validator = Draft3Validator ( schema ) <EOL> errors = validator . iter_errors ( instance ) <EOL> e1 , e2 , e3 , e4 = sorted_errors ( errors ) <EOL> self . assertEqual ( e1 . path , deque ( [ "<STR_LIT:bar>" ] ) ) <EOL> self . assertEqual ( e2 . path , deque ( [ "<STR_LIT>" ] ) ) <EOL> self . assertEqual ( e3 . path , deque ( [ "<STR_LIT>" ] ) ) <EOL> self . assertEqual ( e4 . path , deque ( [ "<STR_LIT:foo>" ] ) ) <EOL> self . assertEqual ( e1 . relative_path , deque ( [ "<STR_LIT:bar>" ] ) ) <EOL> self . assertEqual ( e2 . relative_path , deque ( [ "<STR_LIT>" ] ) ) <EOL> self . assertEqual ( e3 . relative_path , deque ( [ "<STR_LIT>" ] ) ) <EOL> self . assertEqual ( e4 . relative_path , deque ( [ "<STR_LIT:foo>" ] ) ) <EOL> self . assertEqual ( e1 . absolute_path , deque ( [ "<STR_LIT:bar>" ] ) ) <EOL> self . assertEqual ( e2 . absolute_path , deque ( [ "<STR_LIT>" ] ) ) <EOL> self . assertEqual ( e3 . absolute_path , deque ( [ "<STR_LIT>" ] ) ) <EOL> self . assertEqual ( e4 . absolute_path , deque ( [ "<STR_LIT:foo>" ] ) ) <EOL> self . assertEqual ( e1 . validator , "<STR_LIT>" ) <EOL> self . assertEqual ( e2 . validator , "<STR_LIT>" ) <EOL> self . assertEqual ( e3 . validator , "<STR_LIT>" ) <EOL> self . assertEqual ( e4 . validator , "<STR_LIT:type>" ) <EOL> def test_multiple_nesting ( self ) : <EOL> instance = [ <NUM_LIT:1> , { "<STR_LIT:foo>" : <NUM_LIT:2> , "<STR_LIT:bar>" : { "<STR_LIT>" : [ <NUM_LIT:1> ] } } , "<STR_LIT>" ] <EOL> schema = { <EOL> "<STR_LIT:type>" : "<STR_LIT:string>" , <EOL> "<STR_LIT>" : { <EOL> "<STR_LIT:type>" : [ "<STR_LIT:string>" , "<STR_LIT:object>" ] , <EOL> "<STR_LIT>" : { <EOL> "<STR_LIT:foo>" : { "<STR_LIT>" : [ <NUM_LIT:1> , <NUM_LIT:3> ] } , <EOL> "<STR_LIT:bar>" : { <EOL> "<STR_LIT:type>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : { <EOL> "<STR_LIT:bar>" : { "<STR_LIT>" : True } , <EOL> "<STR_LIT>" : { "<STR_LIT>" : <NUM_LIT:2> } , <EOL> } <EOL> } <EOL> } <EOL> } <EOL> } <EOL> validator = Draft3Validator ( schema ) <EOL> errors = validator . iter_errors ( instance ) <EOL> e1 , e2 , e3 , e4 , e5 , e6 = sorted_errors ( errors ) <EOL> self . assertEqual ( e1 . path , deque ( [ ] ) ) <EOL> self . assertEqual ( e2 . path , deque ( [ <NUM_LIT:0> ] ) ) <EOL> self . assertEqual ( e3 . path , deque ( [ <NUM_LIT:1> , "<STR_LIT:bar>" ] ) ) <EOL> self . assertEqual ( e4 . path , deque ( [ <NUM_LIT:1> , "<STR_LIT:bar>" , "<STR_LIT:bar>" ] ) ) <EOL> self . assertEqual ( e5 . path , deque ( [ <NUM_LIT:1> , "<STR_LIT:bar>" , "<STR_LIT>" ] ) ) <EOL> self . assertEqual ( e6 . path , deque ( [ <NUM_LIT:1> , "<STR_LIT:foo>" ] ) ) <EOL> self . assertEqual ( e1 . schema_path , deque ( [ "<STR_LIT:type>" ] ) ) <EOL> self . assertEqual ( e2 . schema_path , deque ( [ "<STR_LIT>" , "<STR_LIT:type>" ] ) ) <EOL> self . assertEqual ( <EOL> list ( e3 . schema_path ) , [ "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT:bar>" , "<STR_LIT:type>" ] , <EOL> ) <EOL> self . assertEqual ( <EOL> list ( e4 . schema_path ) , <EOL> [ "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT:bar>" , "<STR_LIT>" , "<STR_LIT:bar>" , "<STR_LIT>" ] , <EOL> ) <EOL> self . assertEqual ( <EOL> list ( e5 . schema_path ) , <EOL> [ "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT:bar>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ] <EOL> ) <EOL> self . assertEqual ( <EOL> list ( e6 . schema_path ) , [ "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT:foo>" , "<STR_LIT>" ] , <EOL> ) <EOL> self . assertEqual ( e1 . validator , "<STR_LIT:type>" ) <EOL> self . assertEqual ( e2 . validator , "<STR_LIT:type>" ) <EOL> self . assertEqual ( e3 . validator , "<STR_LIT:type>" ) <EOL> self . assertEqual ( e4 . validator , "<STR_LIT>" ) <EOL> self . assertEqual ( e5 . validator , "<STR_LIT>" ) <EOL> self . assertEqual ( e6 . validator , "<STR_LIT>" ) <EOL> def test_recursive ( self ) : <EOL> schema = { <EOL> "<STR_LIT>" : { <EOL> "<STR_LIT>" : { <EOL> "<STR_LIT>" : [ { <EOL> "<STR_LIT:type>" : "<STR_LIT:object>" , <EOL> "<STR_LIT>" : [ "<STR_LIT:name>" , "<STR_LIT>" ] , <EOL> "<STR_LIT>" : { <EOL> "<STR_LIT:name>" : { <EOL> "<STR_LIT:type>" : "<STR_LIT:string>" , <EOL> } , <EOL> "<STR_LIT>" : { <EOL> "<STR_LIT:type>" : "<STR_LIT:object>" , <EOL> "<STR_LIT>" : { <EOL> "<STR_LIT>" : { <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> } , <EOL> } , <EOL> } , <EOL> } , <EOL> } ] , <EOL> } , <EOL> } , <EOL> "<STR_LIT:type>" : "<STR_LIT:object>" , <EOL> "<STR_LIT>" : [ "<STR_LIT:root>" ] , <EOL> "<STR_LIT>" : { <EOL> "<STR_LIT:root>" : { "<STR_LIT>" : "<STR_LIT>" } , <EOL> } <EOL> } <EOL> instance = { <EOL> "<STR_LIT:root>" : { <EOL> "<STR_LIT:name>" : "<STR_LIT:root>" , <EOL> "<STR_LIT>" : { <EOL> "<STR_LIT:a>" : { <EOL> "<STR_LIT:name>" : "<STR_LIT:a>" , <EOL> "<STR_LIT>" : { <EOL> "<STR_LIT>" : { <EOL> "<STR_LIT:name>" : "<STR_LIT>" , <EOL> } <EOL> } <EOL> } , <EOL> } , <EOL> } , <EOL> } <EOL> validator = Draft4Validator ( schema ) <EOL> e , = validator . iter_errors ( instance ) <EOL> self . assertEqual ( e . absolute_path , deque ( [ "<STR_LIT:root>" ] ) ) <EOL> self . assertEqual ( <EOL> e . absolute_schema_path , deque ( [ "<STR_LIT>" , "<STR_LIT:root>" , "<STR_LIT>" ] ) , <EOL> ) <EOL> e1 , = e . context <EOL> self . assertEqual ( e1 . absolute_path , deque ( [ "<STR_LIT:root>" , "<STR_LIT>" , "<STR_LIT:a>" ] ) ) <EOL> self . assertEqual ( <EOL> e1 . absolute_schema_path , deque ( <EOL> [ <EOL> "<STR_LIT>" , <EOL> "<STR_LIT:root>" , <EOL> "<STR_LIT>" , <EOL> <NUM_LIT:0> , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> ] , <EOL> ) , <EOL> ) <EOL> e2 , = e1 . context <EOL> self . assertEqual ( <EOL> e2 . absolute_path , deque ( <EOL> [ "<STR_LIT:root>" , "<STR_LIT>" , "<STR_LIT:a>" , "<STR_LIT>" , "<STR_LIT>" ] , <EOL> ) , <EOL> ) <EOL> self . assertEqual ( <EOL> e2 . absolute_schema_path , deque ( <EOL> [ <EOL> "<STR_LIT>" , <EOL> "<STR_LIT:root>" , <EOL> "<STR_LIT>" , <EOL> <NUM_LIT:0> , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> <NUM_LIT:0> , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" <EOL> ] , <EOL> ) , <EOL> ) <EOL> def test_additionalProperties ( self ) : <EOL> instance = { "<STR_LIT:bar>" : "<STR_LIT:bar>" , "<STR_LIT:foo>" : <NUM_LIT:2> } <EOL> schema = { <EOL> "<STR_LIT>" : { "<STR_LIT:type>" : "<STR_LIT>" , "<STR_LIT>" : <NUM_LIT:5> } <EOL> } <EOL> validator = Draft3Validator ( schema ) <EOL> errors = validator . iter_errors ( instance ) <EOL> e1 , e2 = sorted_errors ( errors ) <EOL> self . assertEqual ( e1 . path , deque ( [ "<STR_LIT:bar>" ] ) ) <EOL> self . assertEqual ( e2 . path , deque ( [ "<STR_LIT:foo>" ] ) ) <EOL> self . assertEqual ( e1 . validator , "<STR_LIT:type>" ) <EOL> self . assertEqual ( e2 . validator , "<STR_LIT>" ) <EOL> def test_patternProperties ( self ) : <EOL> instance = { "<STR_LIT:bar>" : <NUM_LIT:1> , "<STR_LIT:foo>" : <NUM_LIT:2> } <EOL> schema = { <EOL> "<STR_LIT>" : { <EOL> "<STR_LIT:bar>" : { "<STR_LIT:type>" : "<STR_LIT:string>" } , <EOL> "<STR_LIT:foo>" : { "<STR_LIT>" : <NUM_LIT:5> } <EOL> } <EOL> } <EOL> validator = Draft3Validator ( schema ) <EOL> errors = validator . iter_errors ( instance ) <EOL> e1 , e2 = sorted_errors ( errors ) <EOL> self . assertEqual ( e1 . path , deque ( [ "<STR_LIT:bar>" ] ) ) <EOL> self . assertEqual ( e2 . path , deque ( [ "<STR_LIT:foo>" ] ) ) <EOL> self . assertEqual ( e1 . validator , "<STR_LIT:type>" ) <EOL> self . assertEqual ( e2 . validator , "<STR_LIT>" ) <EOL> def test_additionalItems ( self ) : <EOL> instance = [ "<STR_LIT:foo>" , <NUM_LIT:1> ] <EOL> schema = { <EOL> "<STR_LIT>" : [ ] , <EOL> "<STR_LIT>" : { "<STR_LIT:type>" : "<STR_LIT>" , "<STR_LIT>" : <NUM_LIT:5> } <EOL> } <EOL> validator = Draft3Validator ( schema ) <EOL> errors = validator . iter_errors ( instance ) <EOL> e1 , e2 = sorted_errors ( errors ) <EOL> self . assertEqual ( e1 . path , deque ( [ <NUM_LIT:0> ] ) ) <EOL> self . assertEqual ( e2 . path , deque ( [ <NUM_LIT:1> ] ) ) <EOL> self . assertEqual ( e1 . validator , "<STR_LIT:type>" ) <EOL> self . assertEqual ( e2 . validator , "<STR_LIT>" ) <EOL> def test_additionalItems_with_items ( self ) : <EOL> instance = [ "<STR_LIT:foo>" , "<STR_LIT:bar>" , <NUM_LIT:1> ] <EOL> schema = { <EOL> "<STR_LIT>" : [ { } ] , <EOL> "<STR_LIT>" : { "<STR_LIT:type>" : "<STR_LIT>" , "<STR_LIT>" : <NUM_LIT:5> } <EOL> } <EOL> validator = Draft3Validator ( schema ) <EOL> errors = validator . iter_errors ( instance ) <EOL> e1 , e2 = sorted_errors ( errors ) <EOL> self . assertEqual ( e1 . path , deque ( [ <NUM_LIT:1> ] ) ) <EOL> self . assertEqual ( e2 . path , deque ( [ <NUM_LIT:2> ] ) ) <EOL> self . assertEqual ( e1 . validator , "<STR_LIT:type>" ) <EOL> self . assertEqual ( e2 . validator , "<STR_LIT>" ) <EOL> class ValidatorTestMixin ( object ) : <EOL> def setUp ( self ) : <EOL> self . instance = mock . Mock ( ) <EOL> self . schema = { } <EOL> self . resolver = mock . Mock ( ) <EOL> self . validator = self . validator_class ( self . schema ) <EOL> def test_valid_instances_are_valid ( self ) : <EOL> errors = iter ( [ ] ) <EOL> with mock . patch . object ( <EOL> self . validator , "<STR_LIT>" , return_value = errors , <EOL> ) : <EOL> self . assertTrue ( <EOL> self . validator . is_valid ( self . instance , self . schema ) <EOL> ) <EOL> def test_invalid_instances_are_not_valid ( self ) : <EOL> errors = iter ( [ mock . Mock ( ) ] ) <EOL> with mock . patch . object ( <EOL> self . validator , "<STR_LIT>" , return_value = errors , <EOL> ) : <EOL> self . assertFalse ( <EOL> self . validator . is_valid ( self . instance , self . schema ) <EOL> ) <EOL> def test_non_existent_properties_are_ignored ( self ) : <EOL> instance , my_property , my_value = mock . Mock ( ) , mock . Mock ( ) , mock . Mock ( ) <EOL> validate ( instance = instance , schema = { my_property : my_value } ) <EOL> def test_it_creates_a_ref_resolver_if_not_provided ( self ) : <EOL> self . assertIsInstance ( self . validator . resolver , RefResolver ) <EOL> def test_it_delegates_to_a_ref_resolver ( self ) : <EOL> resolver = RefResolver ( "<STR_LIT>" , { } ) <EOL> schema = { "<STR_LIT>" : mock . Mock ( ) } <EOL> with mock . patch . object ( resolver , "<STR_LIT>" ) as resolve : <EOL> resolve . return_value = "<STR_LIT:url>" , { "<STR_LIT:type>" : "<STR_LIT>" } <EOL> with self . assertRaises ( ValidationError ) : <EOL> self . validator_class ( schema , resolver = resolver ) . validate ( None ) <EOL> resolve . assert_called_once_with ( schema [ "<STR_LIT>" ] ) <EOL> def test_it_delegates_to_a_legacy_ref_resolver ( self ) : <EOL> """<STR_LIT>""" <EOL> class LegacyRefResolver ( object ) : <EOL> @ contextmanager <EOL> def resolving ( this , ref ) : <EOL> self . assertEqual ( ref , "<STR_LIT>" ) <EOL> yield { "<STR_LIT:type>" : "<STR_LIT>" } <EOL> resolver = LegacyRefResolver ( ) <EOL> schema = { "<STR_LIT>" : "<STR_LIT>" } <EOL> with self . assertRaises ( ValidationError ) : <EOL> self . validator_class ( schema , resolver = resolver ) . validate ( None ) <EOL> def test_is_type_is_true_for_valid_type ( self ) : <EOL> self . assertTrue ( self . validator . is_type ( "<STR_LIT:foo>" , "<STR_LIT:string>" ) ) <EOL> def test_is_type_is_false_for_invalid_type ( self ) : <EOL> self . assertFalse ( self . validator . is_type ( "<STR_LIT:foo>" , "<STR_LIT>" ) ) <EOL> def test_is_type_evades_bool_inheriting_from_int ( self ) : <EOL> self . assertFalse ( self . validator . is_type ( True , "<STR_LIT>" ) ) <EOL> self . assertFalse ( self . validator . is_type ( True , "<STR_LIT>" ) ) <EOL> def test_is_type_raises_exception_for_unknown_type ( self ) : <EOL> with self . assertRaises ( UnknownType ) : <EOL> self . validator . is_type ( "<STR_LIT:foo>" , object ( ) ) <EOL> class TestDraft3Validator ( ValidatorTestMixin , unittest . TestCase ) : <EOL> validator_class = Draft3Validator <EOL> def test_is_type_is_true_for_any_type ( self ) : <EOL> self . assertTrue ( self . validator . is_valid ( mock . Mock ( ) , { "<STR_LIT:type>" : "<STR_LIT>" } ) ) <EOL> def test_is_type_does_not_evade_bool_if_it_is_being_tested ( self ) : <EOL> self . assertTrue ( self . validator . is_type ( True , "<STR_LIT>" ) ) <EOL> self . assertTrue ( self . validator . is_valid ( True , { "<STR_LIT:type>" : "<STR_LIT>" } ) ) <EOL> def test_non_string_custom_types ( self ) : <EOL> schema = { '<STR_LIT:type>' : [ None ] } <EOL> cls = self . validator_class ( schema , types = { None : type ( None ) } ) <EOL> cls . validate ( None , schema ) <EOL> class TestDraft4Validator ( ValidatorTestMixin , unittest . TestCase ) : <EOL> validator_class = Draft4Validator <EOL> class TestBuiltinFormats ( unittest . TestCase ) : <EOL> """<STR_LIT>""" <EOL> for format in FormatChecker . checkers : <EOL> def test ( self , format = format ) : <EOL> v = Draft4Validator ( { "<STR_LIT>" : format } , format_checker = FormatChecker ( ) ) <EOL> v . validate ( <NUM_LIT> ) <EOL> name = "<STR_LIT>" . format ( format ) <EOL> test . __name__ = name <EOL> setattr ( TestBuiltinFormats , name , test ) <EOL> del test <EOL> class TestValidatorFor ( unittest . TestCase ) : <EOL> def test_draft_3 ( self ) : <EOL> schema = { "<STR_LIT>" : "<STR_LIT>" } <EOL> self . assertIs ( validator_for ( schema ) , Draft3Validator ) <EOL> schema = { "<STR_LIT>" : "<STR_LIT>" } <EOL> self . assertIs ( validator_for ( schema ) , Draft3Validator ) <EOL> def test_draft_4 ( self ) : <EOL> schema = { "<STR_LIT>" : "<STR_LIT>" } <EOL> self . assertIs ( validator_for ( schema ) , Draft4Validator ) <EOL> schema = { "<STR_LIT>" : "<STR_LIT>" } <EOL> self . assertIs ( validator_for ( schema ) , Draft4Validator ) <EOL> def test_custom_validator ( self ) : <EOL> Validator = create ( meta_schema = { "<STR_LIT:id>" : "<STR_LIT>" } , version = "<STR_LIT>" ) <EOL> schema = { "<STR_LIT>" : "<STR_LIT>" } <EOL> self . assertIs ( validator_for ( schema ) , Validator ) <EOL> def test_validator_for_jsonschema_default ( self ) : <EOL> self . assertIs ( validator_for ( { } ) , Draft4Validator ) <EOL> def test_validator_for_custom_default ( self ) : <EOL> self . assertIs ( validator_for ( { } , default = None ) , None ) <EOL> class TestValidate ( unittest . TestCase ) : <EOL> def test_draft3_validator_is_chosen ( self ) : <EOL> schema = { "<STR_LIT>" : "<STR_LIT>" } <EOL> with mock . patch . object ( Draft3Validator , "<STR_LIT>" ) as chk_schema : <EOL> validate ( { } , schema ) <EOL> chk_schema . assert_called_once_with ( schema ) <EOL> schema = { "<STR_LIT>" : "<STR_LIT>" } <EOL> with mock . patch . object ( Draft3Validator , "<STR_LIT>" ) as chk_schema : <EOL> validate ( { } , schema ) <EOL> chk_schema . assert_called_once_with ( schema ) <EOL> def test_draft4_validator_is_chosen ( self ) : <EOL> schema = { "<STR_LIT>" : "<STR_LIT>" } <EOL> with mock . patch . object ( Draft4Validator , "<STR_LIT>" ) as chk_schema : <EOL> validate ( { } , schema ) <EOL> chk_schema . assert_called_once_with ( schema ) <EOL> def test_draft4_validator_is_the_default ( self ) : <EOL> with mock . patch . object ( Draft4Validator , "<STR_LIT>" ) as chk_schema : <EOL> validate ( { } , { } ) <EOL> chk_schema . assert_called_once_with ( { } ) <EOL> class TestRefResolver ( unittest . TestCase ) : <EOL> base_uri = "<STR_LIT>" <EOL> stored_uri = "<STR_LIT>" <EOL> stored_schema = { "<STR_LIT>" : "<STR_LIT>" } <EOL> def setUp ( self ) : <EOL> self . referrer = { } <EOL> self . store = { self . stored_uri : self . stored_schema } <EOL> self . resolver = RefResolver ( self . base_uri , self . referrer , self . store ) <EOL> def test_it_does_not_retrieve_schema_urls_from_the_network ( self ) : <EOL> ref = Draft3Validator . META_SCHEMA [ "<STR_LIT:id>" ] <EOL> with mock . patch . object ( self . resolver , "<STR_LIT>" ) as remote : <EOL> with self . resolver . resolving ( ref ) as resolved : <EOL> self . assertEqual ( resolved , Draft3Validator . META_SCHEMA ) <EOL> self . assertFalse ( remote . called ) <EOL> def test_it_resolves_local_refs ( self ) : <EOL> ref = "<STR_LIT>" <EOL> self . referrer [ "<STR_LIT>" ] = { "<STR_LIT:foo>" : object ( ) } <EOL> with self . resolver . resolving ( ref ) as resolved : <EOL> self . assertEqual ( resolved , self . referrer [ "<STR_LIT>" ] [ "<STR_LIT:foo>" ] ) <EOL> def test_it_resolves_local_refs_with_id ( self ) : <EOL> schema = { "<STR_LIT:id>" : "<STR_LIT>" , "<STR_LIT:a>" : { "<STR_LIT:foo>" : "<STR_LIT:bar>" } } <EOL> resolver = RefResolver . from_schema ( schema ) <EOL> with resolver . resolving ( "<STR_LIT>" ) as resolved : <EOL> self . assertEqual ( resolved , schema [ "<STR_LIT:a>" ] ) <EOL> with resolver . resolving ( "<STR_LIT>" ) as resolved : <EOL> self . assertEqual ( resolved , schema [ "<STR_LIT:a>" ] ) <EOL> def test_it_retrieves_stored_refs ( self ) : <EOL> with self . resolver . resolving ( self . stored_uri ) as resolved : <EOL> self . assertIs ( resolved , self . stored_schema ) <EOL> self . resolver . store [ "<STR_LIT>" ] = { "<STR_LIT:foo>" : <NUM_LIT:12> } <EOL> with self . resolver . resolving ( "<STR_LIT>" ) as resolved : <EOL> self . assertEqual ( resolved , <NUM_LIT:12> ) <EOL> def test_it_retrieves_unstored_refs_via_requests ( self ) : <EOL> ref = "<STR_LIT>" <EOL> schema = { "<STR_LIT>" : <NUM_LIT:12> } <EOL> with mock . patch ( "<STR_LIT>" ) as requests : <EOL> requests . get . return_value . json . return_value = schema <EOL> with self . resolver . resolving ( ref ) as resolved : <EOL> self . assertEqual ( resolved , <NUM_LIT:12> ) <EOL> requests . get . assert_called_once_with ( "<STR_LIT>" ) <EOL> def test_it_retrieves_unstored_refs_via_urlopen ( self ) : <EOL> ref = "<STR_LIT>" <EOL> schema = { "<STR_LIT>" : <NUM_LIT:12> } <EOL> with mock . patch ( "<STR_LIT>" , None ) : <EOL> with mock . patch ( "<STR_LIT>" ) as urlopen : <EOL> urlopen . return_value . read . return_value = ( <EOL> json . dumps ( schema ) . encode ( "<STR_LIT:utf8>" ) ) <EOL> with self . resolver . resolving ( ref ) as resolved : <EOL> self . assertEqual ( resolved , <NUM_LIT:12> ) <EOL> urlopen . assert_called_once_with ( "<STR_LIT>" ) <EOL> def test_it_can_construct_a_base_uri_from_a_schema ( self ) : <EOL> schema = { "<STR_LIT:id>" : "<STR_LIT:foo>" } <EOL> resolver = RefResolver . from_schema ( schema ) <EOL> self . assertEqual ( resolver . base_uri , "<STR_LIT:foo>" ) <EOL> self . assertEqual ( resolver . resolution_scope , "<STR_LIT:foo>" ) <EOL> with resolver . resolving ( "<STR_LIT>" ) as resolved : <EOL> self . assertEqual ( resolved , schema ) <EOL> with resolver . resolving ( "<STR_LIT:#>" ) as resolved : <EOL> self . assertEqual ( resolved , schema ) <EOL> with resolver . resolving ( "<STR_LIT:foo>" ) as resolved : <EOL> self . assertEqual ( resolved , schema ) <EOL> with resolver . resolving ( "<STR_LIT>" ) as resolved : <EOL> self . assertEqual ( resolved , schema ) <EOL> def test_it_can_construct_a_base_uri_from_a_schema_without_id ( self ) : <EOL> schema = { } <EOL> resolver = RefResolver . from_schema ( schema ) <EOL> self . assertEqual ( resolver . base_uri , "<STR_LIT>" ) <EOL> self . assertEqual ( resolver . resolution_scope , "<STR_LIT>" ) <EOL> with resolver . resolving ( "<STR_LIT>" ) as resolved : <EOL> self . assertEqual ( resolved , schema ) <EOL> with resolver . resolving ( "<STR_LIT:#>" ) as resolved : <EOL> self . assertEqual ( resolved , schema ) <EOL> def test_custom_uri_scheme_handlers ( self ) : <EOL> schema = { "<STR_LIT:foo>" : "<STR_LIT:bar>" } <EOL> ref = "<STR_LIT>" <EOL> foo_handler = mock . Mock ( return_value = schema ) <EOL> resolver = RefResolver ( "<STR_LIT>" , { } , handlers = { "<STR_LIT:foo>" : foo_handler } ) <EOL> with resolver . resolving ( ref ) as resolved : <EOL> self . assertEqual ( resolved , schema ) <EOL> foo_handler . assert_called_once_with ( ref ) <EOL> def test_cache_remote_on ( self ) : <EOL> ref = "<STR_LIT>" <EOL> foo_handler = mock . Mock ( ) <EOL> resolver = RefResolver ( <EOL> "<STR_LIT>" , { } , cache_remote = True , handlers = { "<STR_LIT:foo>" : foo_handler } , <EOL> ) <EOL> with resolver . resolving ( ref ) : <EOL> pass <EOL> with resolver . resolving ( ref ) : <EOL> pass <EOL> foo_handler . assert_called_once_with ( ref ) <EOL> def test_cache_remote_off ( self ) : <EOL> ref = "<STR_LIT>" <EOL> foo_handler = mock . Mock ( ) <EOL> resolver = RefResolver ( <EOL> "<STR_LIT>" , { } , cache_remote = False , handlers = { "<STR_LIT:foo>" : foo_handler } , <EOL> ) <EOL> with resolver . resolving ( ref ) : <EOL> pass <EOL> self . assertEqual ( foo_handler . call_count , <NUM_LIT:1> ) <EOL> def test_if_you_give_it_junk_you_get_a_resolution_error ( self ) : <EOL> ref = "<STR_LIT>" <EOL> foo_handler = mock . Mock ( side_effect = ValueError ( "<STR_LIT>" ) ) <EOL> resolver = RefResolver ( "<STR_LIT>" , { } , handlers = { "<STR_LIT:foo>" : foo_handler } ) <EOL> with self . assertRaises ( RefResolutionError ) as err : <EOL> with resolver . resolving ( ref ) : <EOL> pass <EOL> self . assertEqual ( str ( err . exception ) , "<STR_LIT>" ) <EOL> def test_helpful_error_message_on_failed_pop_scope ( self ) : <EOL> resolver = RefResolver ( "<STR_LIT>" , { } ) <EOL> resolver . pop_scope ( ) <EOL> with self . assertRaises ( RefResolutionError ) as exc : <EOL> resolver . pop_scope ( ) <EOL> self . assertIn ( "<STR_LIT>" , str ( exc . exception ) ) <EOL> class UniqueTupleItemsMixin ( object ) : <EOL> """<STR_LIT>""" <EOL> def test_it_properly_formats_an_error_message ( self ) : <EOL> validator = self . validator_class ( <EOL> schema = { "<STR_LIT>" : True } , <EOL> types = { "<STR_LIT>" : ( tuple , ) } , <EOL> ) <EOL> with self . assertRaises ( ValidationError ) as e : <EOL> validator . validate ( ( <NUM_LIT:1> , <NUM_LIT:1> ) ) <EOL> self . assertIn ( "<STR_LIT>" , str ( e . exception ) ) <EOL> class TestDraft4UniqueTupleItems ( UniqueTupleItemsMixin , unittest . TestCase ) : <EOL> validator_class = Draft4Validator <EOL> class TestDraft3UniqueTupleItems ( UniqueTupleItemsMixin , unittest . TestCase ) : <EOL> validator_class = Draft3Validator <EOL> def sorted_errors ( errors ) : <EOL> def key ( error ) : <EOL> return ( <EOL> [ str ( e ) for e in error . path ] , <EOL> [ str ( e ) for e in error . schema_path ] <EOL> ) <EOL> return sorted ( errors , key = key ) </s>
<s> '''<STR_LIT>''' <EOL> import unittest <EOL> import os <EOL> from jnpr . openclos . report import ResourceAllocationReport , L2Report , L3Report <EOL> from test_dao import InMemoryDao <EOL> class Test ( unittest . TestCase ) : <EOL> def setUp ( self ) : <EOL> '''<STR_LIT>''' <EOL> self . __conf = { } <EOL> self . __conf [ '<STR_LIT>' ] = os . path . join ( os . path . dirname ( os . path . abspath ( __file__ ) ) , '<STR_LIT>' ) <EOL> self . __conf [ '<STR_LIT>' ] = '<STR_LIT>' <EOL> self . __conf [ '<STR_LIT>' ] = '<STR_LIT:false>' <EOL> self . __conf [ '<STR_LIT>' ] = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> self . __conf [ '<STR_LIT>' ] = { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] } <EOL> self . __conf [ '<STR_LIT>' ] = { <EOL> "<STR_LIT>" : { <EOL> "<STR_LIT>" : '<STR_LIT>' <EOL> } , <EOL> "<STR_LIT>" : { <EOL> "<STR_LIT>" : '<STR_LIT>' , <EOL> "<STR_LIT>" : '<STR_LIT>' <EOL> } <EOL> } <EOL> self . _dao = InMemoryDao . getInstance ( ) <EOL> def tearDown ( self ) : <EOL> self . _dao = None <EOL> InMemoryDao . _destroy ( ) <EOL> '''<STR_LIT>''' <EOL> def testGenerateL2Report ( self ) : <EOL> l2Report = L2Report ( self . __conf , self . _dao ) <EOL> from test_model import createPod <EOL> with self . _dao . getReadSession ( ) as session : <EOL> pod = createPod ( "<STR_LIT:test>" , session ) <EOL> l2Report . generateReport ( pod . id , True , False ) <EOL> def testGenerateL3Report ( self ) : <EOL> l3Report = L3Report ( self . __conf , self . _dao ) <EOL> from test_model import createPod <EOL> with self . _dao . getReadSession ( ) as session : <EOL> pod = createPod ( "<STR_LIT:test>" , session ) <EOL> l3Report . generateReport ( pod . id , True , False ) <EOL> if __name__ == "<STR_LIT:__main__>" : <EOL> unittest . main ( ) </s>
<s> import yaml <EOL> import os . path <EOL> from jnpr . junos . factory . factory_loader import FactoryLoader <EOL> __all__ = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> def loadyaml ( path ) : <EOL> """<STR_LIT>""" <EOL> if os . path . splitext ( path ) [ <NUM_LIT:1> ] == '<STR_LIT>' : <EOL> path += '<STR_LIT>' <EOL> return FactoryLoader ( ) . load ( yaml . load ( open ( path , '<STR_LIT:r>' ) ) ) </s>
<s> """<STR_LIT>""" <EOL> from jnpr . junos . factory import loadyaml <EOL> from os . path import splitext <EOL> _YAML_ = splitext ( __file__ ) [ <NUM_LIT:0> ] + '<STR_LIT>' <EOL> globals ( ) . update ( loadyaml ( _YAML_ ) ) </s>
<s> '''<STR_LIT>''' <EOL> import unittest <EOL> from nose . plugins . attrib import attr <EOL> from jnpr . junos import Device <EOL> @ attr ( '<STR_LIT>' ) <EOL> class TestDeviceSsh ( unittest . TestCase ) : <EOL> def tearDown ( self ) : <EOL> self . dev . close ( ) <EOL> def test_device_open_default_key ( self ) : <EOL> self . dev = Device ( '<STR_LIT>' ) <EOL> self . dev . open ( ) <EOL> self . assertEqual ( self . dev . connected , True ) <EOL> def test_device_open_key_pass ( self ) : <EOL> self . dev = Device ( host = '<STR_LIT>' , ssh_private_key_file = '<STR_LIT>' , passwd = '<STR_LIT:password>' ) <EOL> self . dev . open ( ) <EOL> self . assertEqual ( self . dev . connected , True ) </s>
<s> __author__ = "<STR_LIT>" <EOL> __credits__ = "<STR_LIT>" <EOL> import unittest <EOL> from nose . plugins . attrib import attr <EOL> from jnpr . junos import Device <EOL> from jnpr . junos . utils . util import Util <EOL> from mock import patch <EOL> @ attr ( '<STR_LIT>' ) <EOL> class TestUtil ( unittest . TestCase ) : <EOL> @ patch ( '<STR_LIT>' ) <EOL> def setUp ( self , mock_connect ) : <EOL> self . dev = Device ( host = '<STR_LIT>' , user = '<STR_LIT>' , password = '<STR_LIT>' , <EOL> gather_facts = False ) <EOL> self . dev . open ( ) <EOL> self . util = Util ( self . dev ) <EOL> def test_repr ( self ) : <EOL> self . assertEqual ( repr ( self . util ) , '<STR_LIT>' ) <EOL> def test_dev_setter_exception ( self ) : <EOL> def mod_dev ( ) : <EOL> self . util . dev = '<STR_LIT:abc>' <EOL> self . assertRaises ( RuntimeError , mod_dev ) <EOL> def test_rpc_setter_exception ( self ) : <EOL> def mod_rpc ( ) : <EOL> self . util . rpc = '<STR_LIT:abc>' <EOL> self . assertRaises ( RuntimeError , mod_rpc ) </s>
<s> import unittest <EOL> from openmdao . main . api import set_as_top , Assembly <EOL> from openmdao . util . testutil import assert_rel_error <EOL> from openmdao . lib . drivers . api import BroydenSolver <EOL> from hyperloop . tube_wall_temp import TubeWallTemp <EOL> class TubeHeatBalance ( Assembly ) : <EOL> def configure ( self ) : <EOL> tm = self . add ( '<STR_LIT>' , TubeWallTemp ( ) ) <EOL> driver = self . add ( '<STR_LIT>' , BroydenSolver ( ) ) <EOL> driver . add_parameter ( '<STR_LIT>' , low = <NUM_LIT:0.> , high = <NUM_LIT> ) <EOL> driver . add_constraint ( '<STR_LIT>' ) <EOL> driver . workflow . add ( [ '<STR_LIT>' ] ) <EOL> class TubeWallTestCase ( unittest . TestCase ) : <EOL> def test_tube_temp ( self ) : <EOL> test = set_as_top ( TubeHeatBalance ( ) ) <EOL> test . tm . nozzle_air . setTotalTP ( <NUM_LIT> , <NUM_LIT> ) <EOL> test . tm . nozzle_air . W = <NUM_LIT> <EOL> test . tm . bearing_air . W = <NUM_LIT:0.> <EOL> test . tm . diameter_outer_tube = <NUM_LIT> <EOL> test . tm . length_tube = <NUM_LIT> <EOL> test . tm . num_pods = <NUM_LIT> <EOL> test . tm . temp_boundary = <NUM_LIT> <EOL> test . tm . temp_outside_ambient = <NUM_LIT> <EOL> test . run ( ) <EOL> assert_rel_error ( self , test . tm . heat_rate_pod , <NUM_LIT> , <NUM_LIT> ) <EOL> assert_rel_error ( self , test . tm . total_heat_rate_pods , <NUM_LIT> , <NUM_LIT> ) <EOL> assert_rel_error ( self , test . tm . GrDelTL3 , <NUM_LIT> , <NUM_LIT> ) <EOL> assert_rel_error ( self , test . tm . Pr , <NUM_LIT> , <NUM_LIT> ) <EOL> assert_rel_error ( self , test . tm . Gr , <NUM_LIT> , <NUM_LIT> ) <EOL> assert_rel_error ( self , test . tm . Ra , <NUM_LIT> , <NUM_LIT> ) <EOL> assert_rel_error ( self , test . tm . Nu , <NUM_LIT> , <NUM_LIT> ) <EOL> assert_rel_error ( self , test . tm . k , <NUM_LIT> , <NUM_LIT> ) <EOL> assert_rel_error ( self , test . tm . h , <NUM_LIT> , <NUM_LIT> ) <EOL> assert_rel_error ( self , test . tm . area_convection , <NUM_LIT> , <NUM_LIT> ) <EOL> assert_rel_error ( self , test . tm . q_per_area_nat_conv , <NUM_LIT> , <NUM_LIT> ) <EOL> assert_rel_error ( self , test . tm . total_q_nat_conv , <NUM_LIT> , <NUM_LIT> ) <EOL> assert_rel_error ( self , test . tm . area_viewing , <NUM_LIT> , <NUM_LIT> ) <EOL> assert_rel_error ( self , test . tm . q_per_area_solar , <NUM_LIT> , <NUM_LIT> ) <EOL> assert_rel_error ( self , test . tm . q_total_solar , <NUM_LIT> , <NUM_LIT> ) <EOL> assert_rel_error ( self , test . tm . area_rad , <NUM_LIT> , <NUM_LIT> ) <EOL> assert_rel_error ( self , test . tm . q_rad_per_area , <NUM_LIT> , <NUM_LIT> ) <EOL> assert_rel_error ( self , test . tm . q_rad_tot , <NUM_LIT> , <NUM_LIT> ) <EOL> assert_rel_error ( self , test . tm . q_total_out , <NUM_LIT> , <NUM_LIT> ) <EOL> if __name__ == "<STR_LIT:__main__>" : <EOL> unittest . main ( ) </s>
<s> import os <EOL> from setuptools import setup , find_packages <EOL> with open ( os . path . join ( os . path . dirname ( __file__ ) , '<STR_LIT>' ) ) as f : <EOL> required = f . read ( ) . splitlines ( ) <EOL> setup ( <EOL> name = '<STR_LIT>' , <EOL> version = '<STR_LIT>' , <EOL> description = '<STR_LIT>' , <EOL> author = '<STR_LIT>' , <EOL> author_email = '<STR_LIT>' , <EOL> packages = find_packages ( exclude = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) , <EOL> include_package_data = True , <EOL> setup_requires = [ <EOL> '<STR_LIT>' , <EOL> ] , <EOL> install_requires = required , <EOL> entry_points = { <EOL> '<STR_LIT>' : [ <EOL> '<STR_LIT>' , <EOL> ] , <EOL> } , <EOL> ) <EOL> del required </s>
<s> import re <EOL> import os <EOL> import sys <EOL> import time <EOL> import hmac <EOL> import base64 <EOL> import hashlib <EOL> import threading <EOL> import logging <EOL> import requests <EOL> from yubico_client . otp import OTP <EOL> from yubico_client . yubico_exceptions import ( StatusCodeError , <EOL> InvalidClientIdError , <EOL> InvalidValidationResponse , <EOL> SignatureVerificationError ) <EOL> from yubico_client . py3 import b <EOL> from yubico_client . py3 import urlencode <EOL> from yubico_client . py3 import unquote <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> COMMON_CA_LOCATIONS = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' <EOL> ] <EOL> DEFAULT_API_URLS = ( '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' ) <EOL> DEFAULT_TIMEOUT = <NUM_LIT:10> <EOL> DEFAULT_MAX_TIME_WINDOW = <NUM_LIT:5> <EOL> BAD_STATUS_CODES = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' ] <EOL> class Yubico ( object ) : <EOL> def __init__ ( self , client_id , key = None , verify_cert = True , <EOL> translate_otp = True , api_urls = DEFAULT_API_URLS , <EOL> ca_certs_bundle_path = None ) : <EOL> if ca_certs_bundle_path and not self . _is_valid_ca_bundle_file ( ca_certs_bundle_path ) : <EOL> raise ValueError ( ( '<STR_LIT>' <EOL> '<STR_LIT>' ) ) <EOL> self . client_id = client_id <EOL> if key is not None : <EOL> key = base64 . b64decode ( key . encode ( '<STR_LIT:ascii>' ) ) <EOL> self . key = key <EOL> self . verify_cert = verify_cert <EOL> self . translate_otp = translate_otp <EOL> self . api_urls = self . _init_request_urls ( api_urls = api_urls ) <EOL> self . ca_certs_bundle_path = ca_certs_bundle_path <EOL> def verify ( self , otp , timestamp = False , sl = None , timeout = None , <EOL> return_response = False ) : <EOL> """<STR_LIT>""" <EOL> ca_bundle_path = self . _get_ca_bundle_path ( ) <EOL> otp = OTP ( otp , self . translate_otp ) <EOL> rand_str = b ( os . urandom ( <NUM_LIT:30> ) ) <EOL> nonce = base64 . b64encode ( rand_str , b ( '<STR_LIT>' ) ) [ : <NUM_LIT> ] . decode ( '<STR_LIT:utf-8>' ) <EOL> query_string = self . generate_query_string ( otp . otp , nonce , timestamp , <EOL> sl , timeout ) <EOL> threads = [ ] <EOL> timeout = timeout or DEFAULT_TIMEOUT <EOL> for url in self . api_urls : <EOL> thread = URLThread ( '<STR_LIT>' % ( url , query_string ) , timeout , <EOL> self . verify_cert , ca_bundle_path ) <EOL> thread . start ( ) <EOL> threads . append ( thread ) <EOL> start_time = time . time ( ) <EOL> while threads and ( start_time + timeout ) > time . time ( ) : <EOL> for thread in threads : <EOL> if not thread . is_alive ( ) : <EOL> if thread . exception : <EOL> raise thread . exception <EOL> elif thread . response : <EOL> status = self . verify_response ( thread . response , <EOL> otp . otp , nonce , <EOL> return_response ) <EOL> if status : <EOL> if return_response : <EOL> return status <EOL> else : <EOL> return True <EOL> threads . remove ( thread ) <EOL> time . sleep ( <NUM_LIT:0.1> ) <EOL> raise Exception ( '<STR_LIT>' ) <EOL> def verify_multi ( self , otp_list , max_time_window = DEFAULT_MAX_TIME_WINDOW , <EOL> sl = None , timeout = None ) : <EOL> """<STR_LIT>""" <EOL> otps = [ ] <EOL> for otp in otp_list : <EOL> otps . append ( OTP ( otp , self . translate_otp ) ) <EOL> if len ( otp_list ) < <NUM_LIT:2> : <EOL> raise ValueError ( '<STR_LIT>' ) <EOL> device_ids = set ( ) <EOL> for otp in otps : <EOL> device_ids . add ( otp . device_id ) <EOL> if len ( device_ids ) != <NUM_LIT:1> : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> for otp in otps : <EOL> response = self . verify ( otp . otp , True , sl , timeout , <EOL> return_response = True ) <EOL> if not response : <EOL> return False <EOL> otp . timestamp = int ( response [ '<STR_LIT>' ] ) <EOL> count = len ( otps ) <EOL> delta = otps [ count - <NUM_LIT:1> ] . timestamp - otps [ <NUM_LIT:0> ] . timestamp <EOL> delta = delta / <NUM_LIT:8> <EOL> if delta < <NUM_LIT:0> : <EOL> raise Exception ( '<STR_LIT>' <EOL> '<STR_LIT>' ) <EOL> if delta > max_time_window : <EOL> raise Exception ( ( '<STR_LIT>' <EOL> '<STR_LIT>' ) % <EOL> ( max_time_window ) ) <EOL> return True <EOL> def verify_response ( self , response , otp , nonce , return_response = False ) : <EOL> """<STR_LIT>""" <EOL> try : <EOL> status = re . search ( r'<STR_LIT>' , response ) . groups ( ) <EOL> if len ( status ) > <NUM_LIT:1> : <EOL> message = '<STR_LIT>' <EOL> raise InvalidValidationResponse ( message , response ) <EOL> status = status [ <NUM_LIT:0> ] <EOL> except ( AttributeError , IndexError ) : <EOL> return False <EOL> signature , parameters = self . parse_parameters_from_response ( response ) <EOL> if self . key : <EOL> generated_signature = self . generate_message_signature ( parameters ) <EOL> if signature != generated_signature : <EOL> logger . warn ( "<STR_LIT>" , parameters ) <EOL> raise SignatureVerificationError ( generated_signature , <EOL> signature ) <EOL> param_dict = self . get_parameters_as_dictionary ( parameters ) <EOL> if '<STR_LIT>' in param_dict and param_dict [ '<STR_LIT>' ] != otp : <EOL> message = '<STR_LIT>' <EOL> raise InvalidValidationResponse ( message , response , param_dict ) <EOL> if '<STR_LIT>' in param_dict and param_dict [ '<STR_LIT>' ] != nonce : <EOL> message = '<STR_LIT>' <EOL> raise InvalidValidationResponse ( message , response , param_dict ) <EOL> if status == '<STR_LIT:OK>' : <EOL> if return_response : <EOL> return param_dict <EOL> else : <EOL> return True <EOL> elif status == '<STR_LIT>' : <EOL> raise InvalidClientIdError ( self . client_id ) <EOL> elif status == '<STR_LIT>' : <EOL> raise StatusCodeError ( status ) <EOL> return False <EOL> def generate_query_string ( self , otp , nonce , timestamp = False , sl = None , <EOL> timeout = None ) : <EOL> """<STR_LIT>""" <EOL> data = [ ( '<STR_LIT:id>' , self . client_id ) , <EOL> ( '<STR_LIT>' , otp ) , <EOL> ( '<STR_LIT>' , nonce ) ] <EOL> if timestamp : <EOL> data . append ( ( '<STR_LIT>' , '<STR_LIT:1>' ) ) <EOL> if sl is not None : <EOL> if sl not in range ( <NUM_LIT:0> , <NUM_LIT> ) and sl not in [ '<STR_LIT>' , '<STR_LIT>' ] : <EOL> raise Exception ( '<STR_LIT>' <EOL> '<STR_LIT>' ) <EOL> data . append ( ( '<STR_LIT>' , sl ) ) <EOL> if timeout : <EOL> data . append ( ( '<STR_LIT>' , timeout ) ) <EOL> query_string = urlencode ( data ) <EOL> if self . key : <EOL> hmac_signature = self . generate_message_signature ( query_string ) <EOL> hmac_signature = hmac_signature <EOL> query_string += '<STR_LIT>' % ( hmac_signature . replace ( '<STR_LIT:+>' , '<STR_LIT>' ) ) <EOL> return query_string <EOL> def generate_message_signature ( self , query_string ) : <EOL> """<STR_LIT>""" <EOL> pairs = query_string . split ( '<STR_LIT:&>' ) <EOL> pairs = [ pair . split ( '<STR_LIT:=>' , <NUM_LIT:1> ) for pair in pairs ] <EOL> pairs_sorted = sorted ( pairs ) <EOL> pairs_string = '<STR_LIT:&>' . join ( [ '<STR_LIT:=>' . join ( pair ) for pair in pairs_sorted ] ) <EOL> digest = hmac . new ( self . key , b ( pairs_string ) , hashlib . sha1 ) . digest ( ) <EOL> signature = base64 . b64encode ( digest ) . decode ( '<STR_LIT:utf-8>' ) <EOL> return signature <EOL> def parse_parameters_from_response ( self , response ) : <EOL> """<STR_LIT>""" <EOL> lines = response . splitlines ( ) <EOL> pairs = [ line . strip ( ) . split ( '<STR_LIT:=>' , <NUM_LIT:1> ) for line in lines if '<STR_LIT:=>' in line ] <EOL> pairs = sorted ( pairs ) <EOL> signature = ( [ unquote ( v ) for k , v in pairs if k == '<STR_LIT:h>' ] or [ None ] ) [ <NUM_LIT:0> ] <EOL> query_string = '<STR_LIT:&>' . join ( [ k + '<STR_LIT:=>' + v for k , v in pairs if k != '<STR_LIT:h>' ] ) <EOL> return ( signature , query_string ) <EOL> def get_parameters_as_dictionary ( self , query_string ) : <EOL> """<STR_LIT>""" <EOL> pairs = ( x . split ( '<STR_LIT:=>' , <NUM_LIT:1> ) for x in query_string . split ( '<STR_LIT:&>' ) ) <EOL> return dict ( ( k , unquote ( v ) ) for k , v in pairs ) <EOL> def _init_request_urls ( self , api_urls ) : <EOL> """<STR_LIT>""" <EOL> if not isinstance ( api_urls , ( str , list , tuple ) ) : <EOL> raise TypeError ( '<STR_LIT>' ) <EOL> if isinstance ( api_urls , str ) : <EOL> api_urls = ( api_urls , ) <EOL> api_urls = list ( api_urls ) <EOL> for url in api_urls : <EOL> if not url . startswith ( '<STR_LIT>' ) and not url . startswith ( '<STR_LIT>' ) : <EOL> raise ValueError ( ( '<STR_LIT>' <EOL> '<STR_LIT>' % ( url ) ) ) <EOL> return list ( api_urls ) <EOL> def _get_ca_bundle_path ( self ) : <EOL> """<STR_LIT>""" <EOL> if self . ca_certs_bundle_path : <EOL> return self . ca_certs_bundle_path <EOL> for file_path in COMMON_CA_LOCATIONS : <EOL> if self . _is_valid_ca_bundle_file ( file_path = file_path ) : <EOL> return file_path <EOL> return None <EOL> def _is_valid_ca_bundle_file ( self , file_path ) : <EOL> return os . path . exists ( file_path ) and os . path . isfile ( file_path ) <EOL> class URLThread ( threading . Thread ) : <EOL> def __init__ ( self , url , timeout , verify_cert , ca_bundle_path = None ) : <EOL> super ( URLThread , self ) . __init__ ( ) <EOL> self . url = url <EOL> self . timeout = timeout <EOL> self . verify_cert = verify_cert <EOL> self . ca_bundle_path = ca_bundle_path <EOL> self . exception = None <EOL> self . request = None <EOL> self . response = None <EOL> def run ( self ) : <EOL> logger . debug ( '<STR_LIT>' % ( self . url , <EOL> self . name ) ) <EOL> verify = self . verify_cert <EOL> if self . ca_bundle_path is not None : <EOL> verify = self . ca_bundle_path <EOL> logger . debug ( '<STR_LIT>' % ( self . ca_bundle_path ) ) <EOL> try : <EOL> self . request = requests . get ( url = self . url , timeout = self . timeout , <EOL> verify = verify ) <EOL> self . response = self . request . content . decode ( '<STR_LIT:utf-8>' ) <EOL> except requests . exceptions . SSLError : <EOL> e = sys . exc_info ( ) [ <NUM_LIT:1> ] <EOL> self . exception = e <EOL> self . response = None <EOL> except Exception : <EOL> e = sys . exc_info ( ) [ <NUM_LIT:1> ] <EOL> logger . error ( '<STR_LIT>' + str ( e ) ) <EOL> self . response = None <EOL> args = ( self . url , self . name , self . response ) <EOL> logger . debug ( '<STR_LIT>' % args ) </s>
<s> import logging <EOL> from app import app , logger <EOL> root = logging . getLogger ( ) <EOL> root . setLevel ( logging . DEBUG ) <EOL> logging . getLogger ( "<STR_LIT>" ) . setLevel ( logging . INFO ) <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL> logger . warn ( "<STR_LIT>" ) <EOL> app . run ( host = '<STR_LIT>' , debug = True ) </s>
<s> from setuptools import setup <EOL> setup ( <EOL> name = '<STR_LIT>' , <EOL> version = '<STR_LIT>' , <EOL> py_modules = [ '<STR_LIT>' ] , <EOL> install_requires = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] , <EOL> entry_points = '''<STR_LIT>''' , <EOL> ) </s>
<s> from nose . tools import ok_ , raises <EOL> from linot import config <EOL> from linot . interfaces . line_interface import LineClientP , LineInterface <EOL> class TestLineClientP : <EOL> def setUp ( self ) : <EOL> self . line_cfg = config [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> self . lineclient = LineClientP ( self . line_cfg [ '<STR_LIT>' ] , <EOL> self . line_cfg [ '<STR_LIT:password>' ] ) <EOL> def test_find_contact_by_id ( self ) : <EOL> contact = self . lineclient . find_contact_by_id ( self . line_cfg [ '<STR_LIT>' ] ) <EOL> ok_ ( contact . id == self . line_cfg [ '<STR_LIT>' ] ) <EOL> @ raises ( ValueError ) <EOL> def test_find_contact_by_id_exception ( self ) : <EOL> self . lineclient . find_contact_by_id ( self . line_cfg [ '<STR_LIT>' ] [ : - <NUM_LIT:2> ] ) <EOL> class TestLineInterface : <EOL> def setUp ( self ) : <EOL> self . line_interface = LineInterface ( ) <EOL> def test_polling_command ( self ) : <EOL> test_str = '<STR_LIT>' <EOL> me = self . line_interface . _client . getProfile ( ) <EOL> me . sendMessage ( test_str ) <EOL> result = self . line_interface . polling_command ( ) <EOL> ok_ ( len ( result ) == <NUM_LIT:1> , result ) <EOL> submitter , msg = result [ <NUM_LIT:0> ] <EOL> ok_ ( submitter . code == me . id , submitter ) <EOL> ok_ ( msg == test_str , <EOL> '<STR_LIT>' . format ( msg , test_str ) ) <EOL> def test_get_contact_by_id ( self ) : <EOL> me = self . line_interface . _client . getProfile ( ) <EOL> contact = self . line_interface . _get_contact_by_id ( me . id ) <EOL> ok_ ( me . id == contact . id , '<STR_LIT>' . format ( me . id , contact . id ) ) <EOL> def test_send_message ( self ) : <EOL> test_str = '<STR_LIT>' <EOL> me = self . line_interface . _client . getProfile ( ) <EOL> me . sendMessage ( test_str ) <EOL> result = self . line_interface . polling_command ( ) <EOL> me , msg = result [ <NUM_LIT:0> ] <EOL> self . line_interface . send_message ( me , test_str ) <EOL> result = self . line_interface . polling_command ( ) <EOL> me , msg = result [ <NUM_LIT:0> ] <EOL> ok_ ( msg == test_str , '<STR_LIT>' . format ( msg , test_str ) ) <EOL> def test_send_message_to_id ( self ) : <EOL> test_str = '<STR_LIT>' <EOL> me = self . line_interface . _client . getProfile ( ) <EOL> me . sendMessage ( test_str ) <EOL> result = self . line_interface . polling_command ( ) <EOL> me , msg = result [ <NUM_LIT:0> ] <EOL> self . line_interface . _send_message_to_id ( me . code , test_str ) <EOL> result = self . line_interface . polling_command ( ) <EOL> me , msg = result [ <NUM_LIT:0> ] <EOL> ok_ ( msg == test_str , '<STR_LIT>' . format ( msg , test_str ) ) <EOL> def test_get_display_name ( self ) : <EOL> test_str = '<STR_LIT>' <EOL> me = self . line_interface . _client . getProfile ( ) <EOL> me . sendMessage ( test_str ) <EOL> result = self . line_interface . polling_command ( ) <EOL> me_submitter , msg = result [ <NUM_LIT:0> ] <EOL> me_display_name = self . line_interface . get_display_name ( me_submitter ) <EOL> ok_ ( me_display_name == me . name ) </s>
<s> import pytest <EOL> import socket <EOL> from aiohttp . parsers import StreamWriter , CORK <EOL> from unittest import mock <EOL> def test_nodelay_default ( loop ) : <EOL> transport = mock . Mock ( ) <EOL> s = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) <EOL> transport . get_extra_info . return_value = s <EOL> proto = mock . Mock ( ) <EOL> reader = mock . Mock ( ) <EOL> writer = StreamWriter ( transport , proto , reader , loop ) <EOL> assert not writer . tcp_nodelay <EOL> assert not s . getsockopt ( socket . IPPROTO_TCP , socket . TCP_NODELAY ) <EOL> def test_set_nodelay_no_change ( loop ) : <EOL> transport = mock . Mock ( ) <EOL> s = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) <EOL> transport . get_extra_info . return_value = s <EOL> proto = mock . Mock ( ) <EOL> reader = mock . Mock ( ) <EOL> writer = StreamWriter ( transport , proto , reader , loop ) <EOL> writer . set_tcp_nodelay ( False ) <EOL> assert not writer . tcp_nodelay <EOL> assert not s . getsockopt ( socket . IPPROTO_TCP , socket . TCP_NODELAY ) <EOL> def test_set_nodelay_enable ( loop ) : <EOL> transport = mock . Mock ( ) <EOL> s = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) <EOL> transport . get_extra_info . return_value = s <EOL> proto = mock . Mock ( ) <EOL> reader = mock . Mock ( ) <EOL> writer = StreamWriter ( transport , proto , reader , loop ) <EOL> writer . set_tcp_nodelay ( True ) <EOL> assert writer . tcp_nodelay <EOL> assert s . getsockopt ( socket . IPPROTO_TCP , socket . TCP_NODELAY ) <EOL> def test_set_nodelay_enable_and_disable ( loop ) : <EOL> transport = mock . Mock ( ) <EOL> s = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) <EOL> transport . get_extra_info . return_value = s <EOL> proto = mock . Mock ( ) <EOL> reader = mock . Mock ( ) <EOL> writer = StreamWriter ( transport , proto , reader , loop ) <EOL> writer . set_tcp_nodelay ( True ) <EOL> writer . set_tcp_nodelay ( False ) <EOL> assert not writer . tcp_nodelay <EOL> assert not s . getsockopt ( socket . IPPROTO_TCP , socket . TCP_NODELAY ) <EOL> def test_set_nodelay_enable_ipv6 ( loop ) : <EOL> transport = mock . Mock ( ) <EOL> s = socket . socket ( socket . AF_INET6 , socket . SOCK_STREAM ) <EOL> transport . get_extra_info . return_value = s <EOL> proto = mock . Mock ( ) <EOL> reader = mock . Mock ( ) <EOL> writer = StreamWriter ( transport , proto , reader , loop ) <EOL> writer . set_tcp_nodelay ( True ) <EOL> assert writer . tcp_nodelay <EOL> assert s . getsockopt ( socket . IPPROTO_TCP , socket . TCP_NODELAY ) <EOL> @ pytest . mark . skipif ( not hasattr ( socket , '<STR_LIT>' ) , <EOL> reason = "<STR_LIT>" ) <EOL> def test_set_nodelay_enable_unix ( loop ) : <EOL> transport = mock . Mock ( ) <EOL> s = socket . socket ( socket . AF_UNIX , socket . SOCK_STREAM ) <EOL> transport . get_extra_info . return_value = s <EOL> proto = mock . Mock ( ) <EOL> reader = mock . Mock ( ) <EOL> writer = StreamWriter ( transport , proto , reader , loop ) <EOL> writer . set_tcp_nodelay ( True ) <EOL> assert writer . tcp_nodelay <EOL> def test_set_nodelay_enable_no_socket ( loop ) : <EOL> transport = mock . Mock ( ) <EOL> transport . get_extra_info . return_value = None <EOL> proto = mock . Mock ( ) <EOL> reader = mock . Mock ( ) <EOL> writer = StreamWriter ( transport , proto , reader , loop ) <EOL> writer . set_tcp_nodelay ( True ) <EOL> assert writer . tcp_nodelay <EOL> assert writer . _socket is None <EOL> @ pytest . mark . skipif ( CORK is None , reason = "<STR_LIT>" ) <EOL> def test_cork_default ( loop ) : <EOL> transport = mock . Mock ( ) <EOL> s = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) <EOL> transport . get_extra_info . return_value = s <EOL> proto = mock . Mock ( ) <EOL> reader = mock . Mock ( ) <EOL> writer = StreamWriter ( transport , proto , reader , loop ) <EOL> assert not writer . tcp_cork <EOL> assert not s . getsockopt ( socket . IPPROTO_TCP , CORK ) <EOL> @ pytest . mark . skipif ( CORK is None , reason = "<STR_LIT>" ) <EOL> def test_set_cork_no_change ( loop ) : <EOL> transport = mock . Mock ( ) <EOL> s = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) <EOL> transport . get_extra_info . return_value = s <EOL> proto = mock . Mock ( ) <EOL> reader = mock . Mock ( ) <EOL> writer = StreamWriter ( transport , proto , reader , loop ) <EOL> writer . set_tcp_cork ( False ) <EOL> assert not writer . tcp_cork <EOL> assert not s . getsockopt ( socket . IPPROTO_TCP , CORK ) <EOL> @ pytest . mark . skipif ( CORK is None , reason = "<STR_LIT>" ) <EOL> def test_set_cork_enable ( loop ) : <EOL> transport = mock . Mock ( ) <EOL> s = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) <EOL> transport . get_extra_info . return_value = s <EOL> proto = mock . Mock ( ) <EOL> reader = mock . Mock ( ) <EOL> writer = StreamWriter ( transport , proto , reader , loop ) <EOL> writer . set_tcp_cork ( True ) <EOL> assert writer . tcp_cork <EOL> assert s . getsockopt ( socket . IPPROTO_TCP , CORK ) <EOL> @ pytest . mark . skipif ( CORK is None , reason = "<STR_LIT>" ) <EOL> def test_set_cork_enable_and_disable ( loop ) : <EOL> transport = mock . Mock ( ) <EOL> s = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) <EOL> transport . get_extra_info . return_value = s <EOL> proto = mock . Mock ( ) <EOL> reader = mock . Mock ( ) <EOL> writer = StreamWriter ( transport , proto , reader , loop ) <EOL> writer . set_tcp_cork ( True ) <EOL> writer . set_tcp_cork ( False ) <EOL> assert not writer . tcp_cork <EOL> assert not s . getsockopt ( socket . IPPROTO_TCP , CORK ) <EOL> @ pytest . mark . skipif ( CORK is None , reason = "<STR_LIT>" ) <EOL> def test_set_cork_enable_ipv6 ( loop ) : <EOL> transport = mock . Mock ( ) <EOL> s = socket . socket ( socket . AF_INET6 , socket . SOCK_STREAM ) <EOL> transport . get_extra_info . return_value = s <EOL> proto = mock . Mock ( ) <EOL> reader = mock . Mock ( ) <EOL> writer = StreamWriter ( transport , proto , reader , loop ) <EOL> writer . set_tcp_cork ( True ) <EOL> assert writer . tcp_cork <EOL> assert s . getsockopt ( socket . IPPROTO_TCP , CORK ) <EOL> @ pytest . mark . skipif ( not hasattr ( socket , '<STR_LIT>' ) , <EOL> reason = "<STR_LIT>" ) <EOL> @ pytest . mark . skipif ( CORK is None , reason = "<STR_LIT>" ) <EOL> def test_set_cork_enable_unix ( loop ) : <EOL> transport = mock . Mock ( ) <EOL> s = socket . socket ( socket . AF_UNIX , socket . SOCK_STREAM ) <EOL> transport . get_extra_info . return_value = s <EOL> proto = mock . Mock ( ) <EOL> reader = mock . Mock ( ) <EOL> writer = StreamWriter ( transport , proto , reader , loop ) <EOL> writer . set_tcp_cork ( True ) <EOL> assert writer . tcp_cork <EOL> @ pytest . mark . skipif ( CORK is None , reason = "<STR_LIT>" ) <EOL> def test_set_cork_enable_no_socket ( loop ) : <EOL> transport = mock . Mock ( ) <EOL> transport . get_extra_info . return_value = None <EOL> proto = mock . Mock ( ) <EOL> reader = mock . Mock ( ) <EOL> writer = StreamWriter ( transport , proto , reader , loop ) <EOL> writer . set_tcp_cork ( True ) <EOL> assert writer . tcp_cork <EOL> assert writer . _socket is None <EOL> @ pytest . mark . skipif ( CORK is None , reason = "<STR_LIT>" ) <EOL> def test_set_enabling_cork_disables_nodelay ( loop ) : <EOL> transport = mock . Mock ( ) <EOL> s = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) <EOL> transport . get_extra_info . return_value = s <EOL> proto = mock . Mock ( ) <EOL> reader = mock . Mock ( ) <EOL> writer = StreamWriter ( transport , proto , reader , loop ) <EOL> writer . set_tcp_nodelay ( True ) <EOL> writer . set_tcp_cork ( True ) <EOL> assert not writer . tcp_nodelay <EOL> assert not s . getsockopt ( socket . IPPROTO_TCP , socket . TCP_NODELAY ) <EOL> assert writer . tcp_cork <EOL> assert s . getsockopt ( socket . IPPROTO_TCP , CORK ) <EOL> @ pytest . mark . skipif ( CORK is None , reason = "<STR_LIT>" ) <EOL> def test_set_enabling_nodelay_disables_cork ( loop ) : <EOL> transport = mock . Mock ( ) <EOL> s = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) <EOL> transport . get_extra_info . return_value = s <EOL> proto = mock . Mock ( ) <EOL> reader = mock . Mock ( ) <EOL> writer = StreamWriter ( transport , proto , reader , loop ) <EOL> writer . set_tcp_cork ( True ) <EOL> writer . set_tcp_nodelay ( True ) <EOL> assert writer . tcp_nodelay <EOL> assert s . getsockopt ( socket . IPPROTO_TCP , socket . TCP_NODELAY ) <EOL> assert not writer . tcp_cork <EOL> assert not s . getsockopt ( socket . IPPROTO_TCP , CORK ) </s>
<s> """<STR_LIT>""" <EOL> import argparse <EOL> import logging <EOL> from collections import namedtuple <EOL> from . import placeholder <EOL> logger = logging . getLogger ( ) <EOL> ShortenerSettings = namedtuple ( '<STR_LIT>' , [ <EOL> '<STR_LIT:name>' , <EOL> '<STR_LIT>' <EOL> ] ) <EOL> Settings = namedtuple ( '<STR_LIT>' , [ <EOL> '<STR_LIT:source>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT:strict>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' <EOL> ] ) <EOL> def default_settings ( ) : <EOL> return Settings ( <EOL> verbose = False , <EOL> strict = True , <EOL> force = False , <EOL> source = '<STR_LIT:src>' , <EOL> destination = '<STR_LIT:target>' , <EOL> templates = '<STR_LIT>' , <EOL> images = '<STR_LIT>' , <EOL> right_to_left = [ '<STR_LIT>' , '<STR_LIT>' ] , <EOL> pattern = '<STR_LIT>' , <EOL> shortener = { } , <EOL> exclusive = None , <EOL> default_locale = '<STR_LIT>' , <EOL> workers_pool = <NUM_LIT:10> , <EOL> local_images = '<STR_LIT>' , <EOL> save = None , <EOL> cms_service_host = "<STR_LIT>" <EOL> ) <EOL> def read_args ( argsargs = argparse . ArgumentParser ) : <EOL> settings = default_settings ( ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> args = argsargs ( epilog = '<STR_LIT>' ) <EOL> args . add_argument ( '<STR_LIT>' , '<STR_LIT>' , help = '<STR_LIT>' % settings . source ) <EOL> args . add_argument ( <EOL> '<STR_LIT>' , '<STR_LIT>' , help = '<STR_LIT>' % settings . exclusive ) <EOL> args . add_argument ( '<STR_LIT>' , '<STR_LIT>' , <EOL> help = '<STR_LIT>' % settings . destination ) <EOL> args . add_argument ( '<STR_LIT>' , '<STR_LIT>' , help = '<STR_LIT>' % settings . templates ) <EOL> args . add_argument ( '<STR_LIT>' , '<STR_LIT>' , <EOL> help = '<STR_LIT>' % settings . right_to_left ) <EOL> args . add_argument ( '<STR_LIT>' , '<STR_LIT>' , help = '<STR_LIT>' % settings . images ) <EOL> args . add_argument ( '<STR_LIT>' , '<STR_LIT>' , help = '<STR_LIT>' % settings . pattern ) <EOL> args . add_argument ( '<STR_LIT>' , '<STR_LIT>' , <EOL> help = '<STR_LIT>' , <EOL> action = '<STR_LIT>' ) <EOL> args . add_argument ( '<STR_LIT>' , '<STR_LIT>' , help = '<STR_LIT>' , action = '<STR_LIT:store_true>' ) <EOL> args . add_argument ( '<STR_LIT>' , '<STR_LIT>' , <EOL> help = '<STR_LIT>' % settings . workers_pool , type = int ) <EOL> args . add_argument ( '<STR_LIT>' , '<STR_LIT>' , help = '<STR_LIT>' , action = '<STR_LIT:store_true>' ) <EOL> args . add_argument ( '<STR_LIT>' , '<STR_LIT>' , help = '<STR_LIT>' , action = '<STR_LIT:store_true>' ) <EOL> subparsers = args . add_subparsers ( help = '<STR_LIT>' , dest = '<STR_LIT>' ) <EOL> template_parser = subparsers . add_parser ( '<STR_LIT>' ) <EOL> template_parser . add_argument ( '<STR_LIT>' , help = '<STR_LIT>' ) <EOL> template_parser . add_argument ( '<STR_LIT>' , <EOL> help = '<STR_LIT>' ) <EOL> config_parser = subparsers . add_parser ( '<STR_LIT>' ) <EOL> config_parser . add_argument ( '<STR_LIT>' , help = '<STR_LIT>' ) <EOL> gui_parser = subparsers . add_parser ( '<STR_LIT>' ) <EOL> gui_parser . add_argument ( '<STR_LIT>' , '<STR_LIT>' , type = int , help = '<STR_LIT>' , default = <NUM_LIT> ) <EOL> gui_parser . add_argument ( '<STR_LIT>' , '<STR_LIT>' , type = str , help = '<STR_LIT>' , <EOL> default = '<STR_LIT>' ) <EOL> gui_parser . add_argument ( '<STR_LIT>' , type = str , help = '<STR_LIT>' ) <EOL> gui_parser . add_argument ( '<STR_LIT>' , '<STR_LIT>' , type = str , help = '<STR_LIT>' ) <EOL> return args . parse_args ( ) <EOL> def read_settings ( args ) : <EOL> args = vars ( args ) <EOL> settings = default_settings ( ) . _asdict ( ) <EOL> for k in settings : <EOL> if k in args and args [ k ] is not None : <EOL> settings [ k ] = args [ k ] <EOL> return Settings ( ** settings ) <EOL> def print_version ( ) : <EOL> import pkg_resources <EOL> version = pkg_resources . require ( '<STR_LIT>' ) [ <NUM_LIT:0> ] . version <EOL> print ( version ) <EOL> return True <EOL> def generate_config ( args ) : <EOL> if args . config_name == '<STR_LIT>' : <EOL> logger . info ( '<STR_LIT>' ) <EOL> settings = read_settings ( args ) <EOL> placeholder . generate_config ( settings ) <EOL> return True <EOL> return False <EOL> def execute_command ( args ) : <EOL> if args . command == '<STR_LIT>' : <EOL> return generate_config ( args ) <EOL> elif args . command == '<STR_LIT>' : <EOL> from . gui . gui import serve <EOL> serve ( args ) <EOL> return True <EOL> return False </s>
<s> from ldap3 import Server , Connection , ALL <EOL> """<STR_LIT>""" <EOL> def rotate ( record , newpassword ) : <EOL> result = False <EOL> host = record . get ( '<STR_LIT>' ) <EOL> user_dn = record . get ( '<STR_LIT>' ) <EOL> try : <EOL> server = Server ( <EOL> host = host , <EOL> use_ssl = True , <EOL> get_info = ALL ) <EOL> conn = Connection ( <EOL> server = server , <EOL> user = user_dn , <EOL> password = record . password , <EOL> auto_bind = True ) <EOL> changePwdResult = conn . extend . microsoft . modify_password ( user_dn , newpassword ) <EOL> if ( changePwdResult == True ) : <EOL> print ( '<STR_LIT>' ) <EOL> record . password = newpassword <EOL> result = True <EOL> else : <EOL> print ( "<STR_LIT>" % ( changePwdResult ) ) <EOL> conn . unbind ( ) <EOL> except : <EOL> print ( "<STR_LIT>" ) <EOL> return result </s>
<s> from keepercommander . record import Record <EOL> def sample_record ( ) : <EOL> record = Record ( ) <EOL> record . folder = '<STR_LIT>' <EOL> record . title = '<STR_LIT:title>' <EOL> record . login = '<STR_LIT>' <EOL> record . password = '<STR_LIT:password>' <EOL> record . login_url = '<STR_LIT>' <EOL> record . notes = '<STR_LIT>' <EOL> record . custom_fields = [ <EOL> { '<STR_LIT:name>' : '<STR_LIT>' , '<STR_LIT:value>' : '<STR_LIT>' , '<STR_LIT:type>' : '<STR_LIT:text>' } , <EOL> { '<STR_LIT:name>' : '<STR_LIT>' , '<STR_LIT:value>' : '<STR_LIT>' , '<STR_LIT:type>' : '<STR_LIT:text>' } ] <EOL> return record <EOL> class TestRecord : <EOL> def test_to_tab_delimited ( self ) : <EOL> assert sample_record ( ) . to_tab_delimited ( ) == '<STR_LIT>' <EOL> def test_to_tab_dictionary ( self ) : <EOL> assert sample_record ( ) . to_dictionary ( ) == { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:title>' : '<STR_LIT:title>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT:password>' : '<STR_LIT:password>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : [ <EOL> { '<STR_LIT:name>' : '<STR_LIT>' , '<STR_LIT:value>' : '<STR_LIT>' , '<STR_LIT:type>' : '<STR_LIT:text>' } , <EOL> { '<STR_LIT:name>' : '<STR_LIT>' , '<STR_LIT:value>' : '<STR_LIT>' , '<STR_LIT:type>' : '<STR_LIT:text>' } ] , <EOL> } </s>
<s> from filesize import size <EOL> from filesize import traditional , alternative , verbose , iec , si </s>
<s> import os <EOL> import logbook <EOL> import pytest <EOL> import pyshark <EOL> @ pytest . fixture <EOL> def caps_directory ( ) : <EOL> return os . path . join ( os . path . dirname ( __file__ ) , '<STR_LIT>' ) <EOL> @ pytest . fixture <EOL> def lazy_simple_capture ( request , caps_directory ) : <EOL> """<STR_LIT>""" <EOL> cap_path = os . path . join ( caps_directory , '<STR_LIT>' ) <EOL> cap = pyshark . FileCapture ( cap_path ) <EOL> cap . log . level = logbook . DEBUG <EOL> def finalizer ( ) : <EOL> cap . close ( ) <EOL> cap . eventloop . stop ( ) <EOL> request . addfinalizer ( finalizer ) <EOL> return cap <EOL> @ pytest . fixture <EOL> def simple_capture ( lazy_simple_capture ) : <EOL> """<STR_LIT>""" <EOL> lazy_simple_capture . load_packets ( ) <EOL> return lazy_simple_capture </s>
<s> from cornice import Service <EOL> from pyramid import httpexceptions <EOL> from pyramid . security import NO_PERMISSION_REQUIRED <EOL> from kinto . events import ServerFlushed <EOL> flush = Service ( name = '<STR_LIT>' , <EOL> description = '<STR_LIT>' , <EOL> path = '<STR_LIT>' ) <EOL> @ flush . post ( permission = NO_PERMISSION_REQUIRED ) <EOL> def flush_post ( request ) : <EOL> request . registry . storage . flush ( ) <EOL> request . registry . permission . flush ( ) <EOL> request . registry . cache . flush ( ) <EOL> event = ServerFlushed ( request ) <EOL> request . registry . notify ( event ) <EOL> return httpexceptions . HTTPAccepted ( ) </s>
<s> import os <EOL> os . environ [ '<STR_LIT>' ] = os . environ . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> from tests import base <EOL> def setUpModule ( ) : <EOL> """<STR_LIT>""" <EOL> base . enabledPlugins . append ( '<STR_LIT>' ) <EOL> base . enabledPlugins . append ( '<STR_LIT>' ) <EOL> base . enabledPlugins . append ( '<STR_LIT>' ) <EOL> base . enabledPlugins . append ( '<STR_LIT>' ) <EOL> base . startServer ( False ) <EOL> def tearDownModule ( ) : <EOL> """<STR_LIT>""" <EOL> base . stopServer ( ) <EOL> class SourceTestCase ( base . TestCase ) : <EOL> """<STR_LIT>""" <EOL> def setUp ( self ) : <EOL> """<STR_LIT>""" <EOL> super ( SourceTestCase , self ) . setUp ( ) <EOL> self . _user = self . model ( '<STR_LIT:user>' ) . createUser ( <EOL> '<STR_LIT>' , '<STR_LIT:password>' , '<STR_LIT>' , '<STR_LIT:user>' , <EOL> '<STR_LIT>' ) <EOL> def testSource ( self ) : <EOL> """<STR_LIT>""" <EOL> path = '<STR_LIT>' <EOL> params = { <EOL> '<STR_LIT>' : self . _user [ '<STR_LIT>' ] , <EOL> } <EOL> response = self . request ( path = path , method = '<STR_LIT:GET>' , params = params ) <EOL> self . assertStatusOk ( response ) <EOL> folder = response . json [ '<STR_LIT>' ] <EOL> self . assertEquals ( folder , None ) <EOL> response = self . request ( path = path , method = '<STR_LIT:POST>' , params = params ) <EOL> self . assertStatus ( response , <NUM_LIT> ) <EOL> response = self . request ( path = path , method = '<STR_LIT:POST>' , params = params , user = self . _user ) <EOL> self . assertStatusOk ( response ) <EOL> folder = response . json [ '<STR_LIT>' ] <EOL> self . assertNotEquals ( folder , None ) <EOL> self . assertEquals ( folder [ '<STR_LIT>' ] , '<STR_LIT:user>' ) <EOL> self . assertEquals ( folder [ '<STR_LIT>' ] , str ( self . _user [ '<STR_LIT>' ] ) ) <EOL> response = self . request ( path = path , method = '<STR_LIT:GET>' , params = params ) <EOL> self . assertStatusOk ( response ) <EOL> folder = response . json [ '<STR_LIT>' ] <EOL> self . assertEquals ( folder , None ) <EOL> response = self . request ( path = path , method = '<STR_LIT:GET>' , params = params , user = self . _user ) <EOL> self . assertStatusOk ( response ) <EOL> folder = response . json [ '<STR_LIT>' ] <EOL> self . assertNotEquals ( folder , None ) <EOL> self . assertEquals ( folder [ '<STR_LIT>' ] , '<STR_LIT:user>' ) <EOL> self . assertEquals ( folder [ '<STR_LIT>' ] , str ( self . _user [ '<STR_LIT>' ] ) ) <EOL> params = { <EOL> '<STR_LIT:name>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : folder [ '<STR_LIT>' ] <EOL> } <EOL> response = self . request ( path = '<STR_LIT>' , method = '<STR_LIT:POST>' , params = params , <EOL> user = self . _user ) <EOL> item1Id = response . json [ '<STR_LIT>' ] <EOL> params = { <EOL> '<STR_LIT:name>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : folder [ '<STR_LIT>' ] <EOL> } <EOL> response = self . request ( path = '<STR_LIT>' , method = '<STR_LIT:POST>' , params = params , <EOL> user = self . _user ) <EOL> item2Id = response . json [ '<STR_LIT>' ] <EOL> path = '<STR_LIT>' <EOL> params = { <EOL> '<STR_LIT>' : self . _user [ '<STR_LIT>' ] , <EOL> } <EOL> response = self . request ( path = path , method = '<STR_LIT:GET>' , params = params ) <EOL> self . assertStatusOk ( response ) <EOL> self . assertEquals ( len ( response . json ) , <NUM_LIT:0> ) <EOL> response = self . request ( path = path , method = '<STR_LIT:GET>' , params = params , user = self . _user ) <EOL> self . assertStatusOk ( response ) <EOL> self . assertEquals ( len ( response . json ) , <NUM_LIT:2> ) <EOL> sourceIds = [ d [ '<STR_LIT>' ] for d in response . json ] <EOL> self . assertTrue ( item1Id in sourceIds , "<STR_LIT>" ) <EOL> self . assertTrue ( item2Id in sourceIds , "<STR_LIT>" ) </s>
<s> from girder . api import access <EOL> from girder . api . describe import Description <EOL> from girder . api . rest import loadmodel , RestException <EOL> from girder . constants import AccessType <EOL> from girder . plugins . minerva . rest . dataset import Dataset <EOL> from girder . plugins . minerva . utility . minerva_utility import findDatasetFolder , updateMinervaMetadata <EOL> class GeojsonDataset ( Dataset ) : <EOL> def __init__ ( self ) : <EOL> self . resourceName = '<STR_LIT>' <EOL> self . route ( '<STR_LIT:POST>' , ( ) , self . createGeojsonDataset ) <EOL> @ access . user <EOL> @ loadmodel ( map = { '<STR_LIT>' : '<STR_LIT>' } , model = '<STR_LIT>' , <EOL> level = AccessType . WRITE ) <EOL> def createGeojsonDataset ( self , item , params ) : <EOL> user = self . getCurrentUser ( ) <EOL> folder = findDatasetFolder ( user , user , create = True ) <EOL> if folder is None : <EOL> raise RestException ( '<STR_LIT>' ) <EOL> if folder [ '<STR_LIT>' ] != item [ '<STR_LIT>' ] : <EOL> raise RestException ( "<STR_LIT>" + <EOL> "<STR_LIT>" ) <EOL> minerva_metadata = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } <EOL> for file in self . model ( '<STR_LIT>' ) . childFiles ( item = item , limit = <NUM_LIT:0> ) : <EOL> if '<STR_LIT>' in file [ '<STR_LIT>' ] or '<STR_LIT>' in file [ '<STR_LIT>' ] : <EOL> minerva_metadata [ '<STR_LIT>' ] = [ { <EOL> '<STR_LIT:name>' : file [ '<STR_LIT:name>' ] , '<STR_LIT>' : file [ '<STR_LIT>' ] } ] <EOL> minerva_metadata [ '<STR_LIT>' ] = { <EOL> '<STR_LIT:name>' : file [ '<STR_LIT:name>' ] , '<STR_LIT>' : file [ '<STR_LIT>' ] } <EOL> break <EOL> if '<STR_LIT>' not in minerva_metadata : <EOL> raise RestException ( '<STR_LIT>' ) <EOL> updateMinervaMetadata ( item , minerva_metadata ) <EOL> return item <EOL> createGeojsonDataset . description = ( <EOL> Description ( '<STR_LIT>' ) <EOL> . responseClass ( '<STR_LIT>' ) <EOL> . param ( '<STR_LIT>' , '<STR_LIT>' , required = True ) <EOL> . errorResponse ( '<STR_LIT>' ) <EOL> . errorResponse ( '<STR_LIT>' , <NUM_LIT> ) ) </s>
<s> from setuptools import setup , find_packages <EOL> import re <EOL> import os <EOL> from os . path import join as opj <EOL> curdir = os . path . dirname ( os . path . realpath ( __file__ ) ) <EOL> def read ( fname ) : <EOL> contents = '<STR_LIT>' <EOL> with open ( fname ) as f : <EOL> contents = f . read ( ) <EOL> return contents <EOL> package_name = '<STR_LIT>' <EOL> def version ( ) : <EOL> text = read ( opj ( curdir , package_name , '<STR_LIT>' ) ) <EOL> matches = re . findall ( "<STR_LIT>" , text ) <EOL> return matches [ <NUM_LIT:0> ] [ <NUM_LIT:1> ] <EOL> install_requires = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] <EOL> test_requires = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL> setup ( <EOL> name = package_name , <EOL> packages = [ package_name ] , <EOL> include_package_data = True , <EOL> author = '<STR_LIT>' , <EOL> author_email = '<STR_LIT>' , <EOL> version = version ( ) , <EOL> description = "<STR_LIT>" , <EOL> long_description = read ( opj ( curdir , '<STR_LIT>' ) ) , <EOL> url = '<STR_LIT>' , <EOL> install_requires = install_requires , <EOL> license = '<STR_LIT>' , <EOL> classifiers = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> ] , <EOL> package_data = { '<STR_LIT>' : [ '<STR_LIT>' ] } , <EOL> zip_safe = False , <EOL> tests_require = test_requires , <EOL> ) </s>
<s> import unittest <EOL> import utils <EOL> import sdk <EOL> change_file_permissions = [ '<STR_LIT>' ] <EOL> change_folder_permissions = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> list_permissions = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> readonly_permissions = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> class Permissions ( unittest . TestCase ) : <EOL> new_roles = { } <EOL> @ utils . allow ( services = list_permissions ) <EOL> def setUp ( self ) : <EOL> acc = self . account <EOL> if acc . service in list_permissions : <EOL> self . test_folder = utils . create_or_get_test_folder ( acc ) <EOL> self . test_file = utils . create_test_file ( acc ) <EOL> new_roles = { <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" <EOL> } <EOL> if acc . service in change_folder_permissions : <EOL> self . new_roles = new_roles <EOL> self . test_folder . permissions . create ( data = self . new_roles ) <EOL> if acc . service in change_file_permissions : <EOL> self . new_roles = new_roles <EOL> self . test_file . permissions . create ( data = self . new_roles ) <EOL> def list_helper ( self , data ) : <EOL> result = data . permissions . all ( ) <EOL> self . assertIsInstance ( result , sdk . resources . AnnotatedList ) <EOL> owner_exists = False <EOL> for perm in result : <EOL> self . assertIsInstance ( perm , sdk . resources . Permission ) <EOL> if self . account . service not in readonly_permissions : <EOL> if perm . role == "<STR_LIT>" : <EOL> owner_exists = True <EOL> else : <EOL> self . assertIn ( perm . email , self . new_roles ) <EOL> self . assertEqual ( perm . role , self . new_roles . get ( perm . email ) ) <EOL> self . assertTrue ( owner_exists ) <EOL> def test_folder_permissions_list ( self ) : <EOL> if self . account . service in list_permissions : <EOL> self . list_helper ( self . test_folder ) <EOL> def test_folder_permissions_set ( self ) : <EOL> if self . account . service in change_folder_permissions : <EOL> self . new_roles = { <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" <EOL> } <EOL> result = self . test_folder . permissions . create ( data = self . new_roles ) <EOL> self . assertIsInstance ( result . permissions , list ) <EOL> self . list_helper ( self . test_folder ) <EOL> def test_folder_permissions_update ( self ) : <EOL> if self . account . service in change_folder_permissions : <EOL> self . new_roles . update ( { <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" <EOL> } ) <EOL> result = self . test_folder . permissions . update ( data = self . new_roles ) <EOL> self . assertIsInstance ( result . permissions , list ) <EOL> self . list_helper ( self . test_folder ) <EOL> def test_file_permissions_list ( self ) : <EOL> if self . account . service in list_permissions : <EOL> self . list_helper ( self . test_file ) <EOL> def test_file_permissions_set ( self ) : <EOL> if self . account . service in change_file_permissions : <EOL> self . new_roles = { <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" <EOL> } <EOL> result = self . test_file . permissions . create ( data = self . new_roles ) <EOL> self . assertIsInstance ( result . permissions , list ) <EOL> self . list_helper ( self . test_file ) <EOL> def test_file_permissions_update ( self ) : <EOL> if self . account . service in change_file_permissions : <EOL> self . new_roles . update ( { <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" <EOL> } ) <EOL> result = self . test_file . permissions . update ( data = self . new_roles ) <EOL> self . assertIsInstance ( result . permissions , list ) <EOL> self . list_helper ( self . test_file ) <EOL> def test_cases ( ) : <EOL> return [ utils . create_test_case ( acc , Permissions ) for acc in utils . accounts ] <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL> suite = utils . create_suite ( test_cases ( ) ) <EOL> unittest . TextTestRunner ( verbosity = <NUM_LIT:2> ) . run ( suite ) </s>
<s> try : <EOL> basestring = basestring <EOL> except NameError : <EOL> basestring = str <EOL> from . nmea import NMEASentence <EOL> class NMEAFile ( object ) : <EOL> """<STR_LIT>""" <EOL> def __init__ ( self , f , * args , ** kwargs ) : <EOL> super ( NMEAFile , self ) . __init__ ( ) <EOL> if isinstance ( f , basestring ) or args or kwargs : <EOL> self . _file = self . open ( f , * args , ** kwargs ) <EOL> else : <EOL> self . _file = f <EOL> self . _context = None <EOL> def open ( self , fp , mode = '<STR_LIT:r>' ) : <EOL> """<STR_LIT>""" <EOL> self . _file = open ( fp , mode = mode ) <EOL> return self . _file <EOL> def close ( self ) : <EOL> """<STR_LIT>""" <EOL> self . _file . close ( ) <EOL> def __iter__ ( self ) : <EOL> """<STR_LIT>""" <EOL> for line in self . _file : <EOL> yield self . parse ( line ) <EOL> def __enter__ ( self ) : <EOL> if hasattr ( self . _file , '<STR_LIT>' ) : <EOL> self . _context = self . _file . __enter__ ( ) <EOL> return self <EOL> def __exit__ ( self , exc_type , exc_val , exc_tb ) : <EOL> if self . _context : <EOL> ctx = self . _context <EOL> self . _context = None <EOL> ctx . __exit__ ( exc_type , exc_val , exc_tb ) <EOL> def next ( self ) : <EOL> """<STR_LIT>""" <EOL> data = self . _file . readline ( ) <EOL> return self . parse ( data ) <EOL> def parse ( self , s ) : <EOL> return NMEASentence . parse ( s ) <EOL> def readline ( self ) : <EOL> """<STR_LIT>""" <EOL> data = self . _file . readline ( ) <EOL> s = self . parse ( data ) <EOL> return s <EOL> def read ( self ) : <EOL> """<STR_LIT>""" <EOL> return [ s for s in self ] </s>
<s> from optparse import make_option <EOL> from django . core . management . base import BaseCommand <EOL> from django . utils . translation import ugettext as _ <EOL> from django_q . cluster import Cluster <EOL> class Command ( BaseCommand ) : <EOL> help = _ ( "<STR_LIT>" ) <EOL> option_list = BaseCommand . option_list + ( <EOL> make_option ( '<STR_LIT>' , <EOL> action = '<STR_LIT:store_true>' , <EOL> dest = '<STR_LIT>' , <EOL> default = False , <EOL> help = '<STR_LIT>' ) , <EOL> ) <EOL> def handle ( self , * args , ** options ) : <EOL> q = Cluster ( ) <EOL> q . start ( ) <EOL> if options . get ( '<STR_LIT>' , False ) : <EOL> q . stop ( ) </s>
<s> sources = """<STR_LIT>""" <EOL> import sys <EOL> import base64 <EOL> import zlib <EOL> class DictImporter ( object ) : <EOL> def __init__ ( self , sources ) : <EOL> self . sources = sources <EOL> def find_module ( self , fullname , path = None ) : <EOL> if fullname == "<STR_LIT>" and sys . version_info >= ( <NUM_LIT:2> , <NUM_LIT:7> ) : <EOL> return None <EOL> if fullname in self . sources : <EOL> return self <EOL> if fullname + '<STR_LIT>' in self . sources : <EOL> return self <EOL> return None <EOL> def load_module ( self , fullname ) : <EOL> from types import ModuleType <EOL> try : <EOL> s = self . sources [ fullname ] <EOL> is_pkg = False <EOL> except KeyError : <EOL> s = self . sources [ fullname + '<STR_LIT>' ] <EOL> is_pkg = True <EOL> co = compile ( s , fullname , '<STR_LIT>' ) <EOL> module = sys . modules . setdefault ( fullname , ModuleType ( fullname ) ) <EOL> module . __file__ = "<STR_LIT>" % ( __file__ , fullname ) <EOL> module . __loader__ = self <EOL> if is_pkg : <EOL> module . __path__ = [ fullname ] <EOL> do_exec ( co , module . __dict__ ) <EOL> return sys . modules [ fullname ] <EOL> def get_source ( self , name ) : <EOL> res = self . sources . get ( name ) <EOL> if res is None : <EOL> res = self . sources . get ( name + '<STR_LIT>' ) <EOL> return res <EOL> if __name__ == "<STR_LIT:__main__>" : <EOL> try : <EOL> import pkg_resources <EOL> except ImportError : <EOL> sys . stderr . write ( "<STR_LIT>" ) <EOL> sys . exit ( <NUM_LIT:2> ) <EOL> if sys . version_info >= ( <NUM_LIT:3> , <NUM_LIT:0> ) : <EOL> exec ( "<STR_LIT>" ) <EOL> import pickle <EOL> sources = sources . encode ( "<STR_LIT:ascii>" ) <EOL> sources = pickle . loads ( zlib . decompress ( base64 . decodebytes ( sources ) ) ) <EOL> else : <EOL> import cPickle as pickle <EOL> exec ( "<STR_LIT>" ) <EOL> sources = pickle . loads ( zlib . decompress ( base64 . decodestring ( sources ) ) ) <EOL> importer = DictImporter ( sources ) <EOL> sys . meta_path . insert ( <NUM_LIT:0> , importer ) <EOL> entry = "<STR_LIT>" <EOL> do_exec ( entry , locals ( ) ) </s>
<s> from __future__ import with_statement <EOL> from contextlib import contextmanager <EOL> from datetime import datetime <EOL> from UserDict import DictMixin <EOL> import bcrypt <EOL> from pyramid . location import lineage <EOL> from pyramid . security import view_execution_permitted <EOL> from six import string_types <EOL> from sqlalchemy import Boolean , bindparam <EOL> from sqlalchemy import Column <EOL> from sqlalchemy import DateTime <EOL> from sqlalchemy import func <EOL> from sqlalchemy import Integer <EOL> from sqlalchemy import Unicode <EOL> from sqlalchemy . orm . exc import NoResultFound <EOL> from sqlalchemy . sql . expression import and_ <EOL> from sqlalchemy . sql . expression import or_ <EOL> from zope . deprecation . deprecation import deprecated <EOL> from kotti import Base <EOL> from kotti import DBSession <EOL> from kotti import get_settings <EOL> from kotti . sqla import bakery <EOL> from kotti . sqla import JsonType <EOL> from kotti . sqla import MutationList <EOL> from kotti . util import _ <EOL> from kotti . util import request_cache <EOL> from kotti . util import DontCache <EOL> def get_principals ( ) : <EOL> return get_settings ( ) [ '<STR_LIT>' ] [ <NUM_LIT:0> ] ( ) <EOL> @ request_cache ( lambda request : None ) <EOL> def get_user ( request ) : <EOL> userid = request . unauthenticated_userid <EOL> return get_principals ( ) . get ( userid ) <EOL> def has_permission ( permission , context , request ) : <EOL> """<STR_LIT>""" <EOL> return request . has_permission ( permission , context ) <EOL> deprecated ( u'<STR_LIT>' , <EOL> u"<STR_LIT>" <EOL> u"<STR_LIT>" <EOL> u"<STR_LIT>" ) <EOL> class Principal ( Base ) : <EOL> """<STR_LIT>""" <EOL> id = Column ( Integer , primary_key = True ) <EOL> name = Column ( Unicode ( <NUM_LIT:100> ) , unique = True ) <EOL> password = Column ( Unicode ( <NUM_LIT:100> ) ) <EOL> active = Column ( Boolean ) <EOL> confirm_token = Column ( Unicode ( <NUM_LIT:100> ) ) <EOL> title = Column ( Unicode ( <NUM_LIT:100> ) , nullable = False ) <EOL> email = Column ( Unicode ( <NUM_LIT:100> ) , unique = True ) <EOL> groups = Column ( MutationList . as_mutable ( JsonType ) , nullable = False ) <EOL> creation_date = Column ( DateTime ( ) , nullable = False ) <EOL> last_login_date = Column ( DateTime ( ) ) <EOL> __tablename__ = '<STR_LIT>' <EOL> __mapper_args__ = dict ( <EOL> order_by = name , <EOL> ) <EOL> def __init__ ( self , name , password = None , active = True , confirm_token = None , <EOL> title = u"<STR_LIT>" , email = None , groups = None ) : <EOL> self . name = name <EOL> if password is not None : <EOL> password = get_principals ( ) . hash_password ( password ) <EOL> self . password = password <EOL> self . active = active <EOL> self . confirm_token = confirm_token <EOL> self . title = title <EOL> self . email = email <EOL> if groups is None : <EOL> groups = [ ] <EOL> self . groups = groups <EOL> self . creation_date = datetime . now ( ) <EOL> self . last_login_date = None <EOL> def __repr__ ( self ) : <EOL> return u'<STR_LIT>' . format ( self . name ) <EOL> class AbstractPrincipals ( object ) : <EOL> """<STR_LIT>""" <EOL> def __getitem__ ( self , name ) : <EOL> """<STR_LIT>""" <EOL> def __setitem__ ( self , name , principal ) : <EOL> """<STR_LIT>""" <EOL> def __delitem__ ( self , name ) : <EOL> """<STR_LIT>""" <EOL> def keys ( self ) : <EOL> """<STR_LIT>""" <EOL> def search ( self , ** kwargs ) : <EOL> """<STR_LIT>""" <EOL> def hash_password ( self , password ) : <EOL> """<STR_LIT>""" <EOL> def validate_password ( self , clear , hashed ) : <EOL> """<STR_LIT>""" <EOL> ROLES = { <EOL> u'<STR_LIT>' : Principal ( u'<STR_LIT>' , title = _ ( u'<STR_LIT>' ) ) , <EOL> u'<STR_LIT>' : Principal ( u'<STR_LIT>' , title = _ ( u'<STR_LIT>' ) ) , <EOL> u'<STR_LIT>' : Principal ( u'<STR_LIT>' , title = _ ( u'<STR_LIT>' ) ) , <EOL> u'<STR_LIT>' : Principal ( u'<STR_LIT>' , title = _ ( u'<STR_LIT>' ) ) , <EOL> } <EOL> _DEFAULT_ROLES = ROLES . copy ( ) <EOL> SHARING_ROLES = [ u'<STR_LIT>' , u'<STR_LIT>' , u'<STR_LIT>' ] <EOL> USER_MANAGEMENT_ROLES = SHARING_ROLES + [ '<STR_LIT>' ] <EOL> _DEFAULT_SHARING_ROLES = SHARING_ROLES [ : ] <EOL> _DEFAULT_USER_MANAGEMENT_ROLES = USER_MANAGEMENT_ROLES [ : ] <EOL> SITE_ACL = [ <EOL> [ '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' ] ] , <EOL> [ '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' ] ] , <EOL> [ '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ] , <EOL> [ '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ] , <EOL> ] <EOL> def set_roles ( roles_dict ) : <EOL> ROLES . clear ( ) <EOL> ROLES . update ( roles_dict ) <EOL> def set_sharing_roles ( role_names ) : <EOL> SHARING_ROLES [ : ] = role_names <EOL> def set_user_management_roles ( role_names ) : <EOL> USER_MANAGEMENT_ROLES [ : ] = role_names <EOL> def reset_roles ( ) : <EOL> ROLES . clear ( ) <EOL> ROLES . update ( _DEFAULT_ROLES ) <EOL> def reset_sharing_roles ( ) : <EOL> SHARING_ROLES [ : ] = _DEFAULT_SHARING_ROLES <EOL> def reset_user_management_roles ( ) : <EOL> USER_MANAGEMENT_ROLES [ : ] = _DEFAULT_USER_MANAGEMENT_ROLES <EOL> def reset ( ) : <EOL> reset_roles ( ) <EOL> reset_sharing_roles ( ) <EOL> reset_user_management_roles ( ) <EOL> class PersistentACLMixin ( object ) : <EOL> def _get_acl ( self ) : <EOL> if self . _acl is None : <EOL> raise AttributeError ( '<STR_LIT>' ) <EOL> return self . _acl <EOL> def _set_acl ( self , value ) : <EOL> self . _acl = value <EOL> def _del_acl ( self ) : <EOL> self . _acl = None <EOL> __acl__ = property ( _get_acl , _set_acl , _del_acl ) <EOL> def _cachekey_list_groups_raw ( name , context ) : <EOL> context_id = context is not None and getattr ( context , '<STR_LIT:id>' , id ( context ) ) <EOL> return name , context_id <EOL> @ request_cache ( _cachekey_list_groups_raw ) <EOL> def list_groups_raw ( name , context ) : <EOL> """<STR_LIT>""" <EOL> from kotti . resources import Node <EOL> if isinstance ( context , Node ) : <EOL> return set ( <EOL> r . group_name for r in context . local_groups <EOL> if r . principal_name == name <EOL> ) <EOL> return set ( ) <EOL> def list_groups ( name , context = None ) : <EOL> """<STR_LIT>""" <EOL> return list_groups_ext ( name , context ) [ <NUM_LIT:0> ] <EOL> def _cachekey_list_groups_ext ( name , context = None , _seen = None , _inherited = None ) : <EOL> if _seen is not None or _inherited is not None : <EOL> raise DontCache <EOL> else : <EOL> context_id = getattr ( context , '<STR_LIT:id>' , id ( context ) ) <EOL> return unicode ( name ) , context_id <EOL> @ request_cache ( _cachekey_list_groups_ext ) <EOL> def list_groups_ext ( name , context = None , _seen = None , _inherited = None ) : <EOL> name = unicode ( name ) <EOL> groups = set ( ) <EOL> recursing = _inherited is not None <EOL> _inherited = _inherited or set ( ) <EOL> principal = get_principals ( ) . get ( name ) <EOL> if principal is not None : <EOL> groups . update ( principal . groups ) <EOL> if context is not None or ( context is None and _seen is not None ) : <EOL> _inherited . update ( principal . groups ) <EOL> if _seen is None : <EOL> _seen = { name } <EOL> if context is not None : <EOL> items = lineage ( context ) <EOL> for idx , item in enumerate ( items ) : <EOL> group_names = [ i for i in list_groups_raw ( name , item ) <EOL> if i not in _seen ] <EOL> groups . update ( group_names ) <EOL> if recursing or idx != <NUM_LIT:0> : <EOL> _inherited . update ( group_names ) <EOL> new_groups = groups - _seen <EOL> _seen . update ( new_groups ) <EOL> for group_name in new_groups : <EOL> g , i = list_groups_ext ( <EOL> group_name , context , _seen = _seen , _inherited = _inherited ) <EOL> groups . update ( g ) <EOL> _inherited . update ( i ) <EOL> return list ( groups ) , list ( _inherited ) <EOL> def set_groups ( name , context , groups_to_set = ( ) ) : <EOL> """<STR_LIT>""" <EOL> from kotti . resources import LocalGroup <EOL> name = unicode ( name ) <EOL> context . local_groups = [ <EOL> lg for lg in context . local_groups <EOL> if lg . principal_name != name <EOL> ] + [ <EOL> LocalGroup ( context , name , unicode ( group_name ) ) <EOL> for group_name in groups_to_set <EOL> ] <EOL> def list_groups_callback ( name , request ) : <EOL> """<STR_LIT>""" <EOL> if not is_user ( name ) : <EOL> return None <EOL> if name in get_principals ( ) : <EOL> context = request . environ . get ( <EOL> '<STR_LIT>' , getattr ( request , '<STR_LIT>' , None ) ) <EOL> if context is None : <EOL> from kotti . resources import get_root <EOL> context = get_root ( request ) <EOL> return list_groups ( name , context ) <EOL> @ contextmanager <EOL> def authz_context ( context , request ) : <EOL> before = request . environ . pop ( '<STR_LIT>' , None ) <EOL> request . environ [ '<STR_LIT>' ] = context <EOL> try : <EOL> yield <EOL> finally : <EOL> del request . environ [ '<STR_LIT>' ] <EOL> if before is not None : <EOL> request . environ [ '<STR_LIT>' ] = before <EOL> @ contextmanager <EOL> def request_method ( request , method ) : <EOL> before = request . method <EOL> request . method = method <EOL> try : <EOL> yield <EOL> finally : <EOL> request . method = before <EOL> def view_permitted ( context , request , name = '<STR_LIT>' , method = '<STR_LIT:GET>' ) : <EOL> with authz_context ( context , request ) : <EOL> with request_method ( request , method ) : <EOL> return view_execution_permitted ( context , request , name ) <EOL> def principals_with_local_roles ( context , inherit = True ) : <EOL> """<STR_LIT>""" <EOL> principals = set ( ) <EOL> items = [ context ] <EOL> if inherit : <EOL> items = lineage ( context ) <EOL> for item in items : <EOL> principals . update ( <EOL> r . principal_name for r in item . local_groups <EOL> if not r . principal_name . startswith ( '<STR_LIT>' ) <EOL> ) <EOL> return list ( principals ) <EOL> def map_principals_with_local_roles ( context ) : <EOL> principals = get_principals ( ) <EOL> value = [ ] <EOL> for principal_name in principals_with_local_roles ( context ) : <EOL> try : <EOL> principal = principals [ principal_name ] <EOL> except KeyError : <EOL> continue <EOL> else : <EOL> all , inherited = list_groups_ext ( principal_name , context ) <EOL> value . append ( ( principal , ( all , inherited ) ) ) <EOL> return sorted ( value , key = lambda t : t [ <NUM_LIT:0> ] . name ) <EOL> def is_user ( principal ) : <EOL> if not isinstance ( principal , string_types ) : <EOL> principal = principal . name <EOL> return '<STR_LIT::>' not in principal <EOL> class Principals ( DictMixin ) : <EOL> """<STR_LIT>""" <EOL> factory = Principal <EOL> @ classmethod <EOL> def _principal_by_name ( cls , name ) : <EOL> query = bakery ( lambda session : session . query ( cls . factory ) . filter ( <EOL> cls . factory . name == bindparam ( '<STR_LIT:name>' ) ) ) <EOL> return query ( DBSession ( ) ) . params ( name = name ) . one ( ) <EOL> @ request_cache ( lambda self , name : unicode ( name ) ) <EOL> def __getitem__ ( self , name ) : <EOL> name = unicode ( name ) <EOL> if name . startswith ( '<STR_LIT>' ) : <EOL> raise KeyError ( name ) <EOL> try : <EOL> return self . _principal_by_name ( name ) <EOL> except NoResultFound : <EOL> raise KeyError ( name ) <EOL> def __setitem__ ( self , name , principal ) : <EOL> name = unicode ( name ) <EOL> if isinstance ( principal , dict ) : <EOL> principal = self . factory ( ** principal ) <EOL> DBSession . add ( principal ) <EOL> def __delitem__ ( self , name ) : <EOL> name = unicode ( name ) <EOL> try : <EOL> principal = self . _principal_by_name ( name ) <EOL> DBSession . delete ( principal ) <EOL> except NoResultFound : <EOL> raise KeyError ( name ) <EOL> def iterkeys ( self ) : <EOL> for ( principal_name , ) in DBSession . query ( self . factory . name ) : <EOL> yield principal_name <EOL> def keys ( self ) : <EOL> return list ( self . iterkeys ( ) ) <EOL> def search ( self , match = '<STR_LIT>' , ** kwargs ) : <EOL> """<STR_LIT>""" <EOL> if not kwargs : <EOL> return [ ] <EOL> filters = [ ] <EOL> for key , value in kwargs . items ( ) : <EOL> col = getattr ( self . factory , key ) <EOL> if isinstance ( value , string_types ) and '<STR_LIT:*>' in value : <EOL> value = value . replace ( '<STR_LIT:*>' , '<STR_LIT:%>' ) . lower ( ) <EOL> filters . append ( func . lower ( col ) . like ( value ) ) <EOL> else : <EOL> filters . append ( col == value ) <EOL> query = DBSession . query ( self . factory ) <EOL> if match == '<STR_LIT>' : <EOL> query = query . filter ( or_ ( * filters ) ) <EOL> elif match == '<STR_LIT:all>' : <EOL> query = query . filter ( and_ ( * filters ) ) <EOL> else : <EOL> raise ValueError ( '<STR_LIT>' ) <EOL> return query <EOL> log_rounds = <NUM_LIT:10> <EOL> def hash_password ( self , password , hashed = None ) : <EOL> if hashed is None : <EOL> hashed = bcrypt . gensalt ( self . log_rounds ) <EOL> return unicode ( <EOL> bcrypt . hashpw ( password . encode ( '<STR_LIT:utf-8>' ) , hashed . encode ( '<STR_LIT:utf-8>' ) ) ) <EOL> def validate_password ( self , clear , hashed ) : <EOL> try : <EOL> return self . hash_password ( clear , hashed ) == hashed <EOL> except ValueError : <EOL> return False <EOL> def principals_factory ( ) : <EOL> return Principals ( ) </s>
<s> import json <EOL> from mechanize . _mechanize import LinkNotFoundError <EOL> from pytest import raises <EOL> from kotti . testing import BASE_URL <EOL> from kotti . testing import user <EOL> from kotti . views . edit . upload import UploadView <EOL> def test_upload_anonymous ( root , dummy_request , browser ) : <EOL> view = UploadView ( root , dummy_request ) <EOL> assert view . factories == [ ] <EOL> link = browser . getLink <EOL> browser . open ( u'<STR_LIT>' . format ( BASE_URL ) ) <EOL> with raises ( LinkNotFoundError ) : <EOL> link ( '<STR_LIT>' ) . click ( ) <EOL> browser . open ( u'<STR_LIT>' . format ( BASE_URL ) ) <EOL> assert browser . url . startswith ( u'<STR_LIT>' . format ( BASE_URL ) ) <EOL> browser . open ( u'<STR_LIT>' . format ( BASE_URL ) ) <EOL> assert browser . url . startswith ( u'<STR_LIT>' . format ( BASE_URL ) ) <EOL> @ user ( '<STR_LIT>' ) <EOL> def test_upload_authenticated_wo_mimetype ( root , dummy_request , browser ) : <EOL> with raises ( KeyError ) : <EOL> browser . open ( u'<STR_LIT>' . format ( BASE_URL ) ) <EOL> @ user ( '<STR_LIT>' ) <EOL> def test_upload_authenticated_text ( root , dummy_request , browser ) : <EOL> browser . open ( u'<STR_LIT>' . format ( BASE_URL ) ) <EOL> j = json . loads ( browser . contents ) <EOL> assert '<STR_LIT>' in j <EOL> types = j [ '<STR_LIT>' ] <EOL> assert len ( types ) == <NUM_LIT:1> <EOL> assert types [ <NUM_LIT:0> ] [ '<STR_LIT:name>' ] == u'<STR_LIT>' </s>
<s> import os <EOL> import sys <EOL> from setuptools import setup <EOL> from setuptools import find_packages <EOL> here = os . path . abspath ( os . path . dirname ( __file__ ) ) <EOL> try : <EOL> README = open ( os . path . join ( here , '<STR_LIT>' ) ) . read ( ) <EOL> AUTHORS = open ( os . path . join ( here , '<STR_LIT>' ) ) . read ( ) <EOL> CHANGES = open ( os . path . join ( here , '<STR_LIT>' ) ) . read ( ) <EOL> except IOError : <EOL> README = AUTHORS = CHANGES = '<STR_LIT>' <EOL> install_requires = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] <EOL> tests_require = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] <EOL> development_requires = [ ] <EOL> docs_require = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] <EOL> if sys . version_info [ : <NUM_LIT:3> ] < ( <NUM_LIT:2> , <NUM_LIT:7> , <NUM_LIT:0> ) : <EOL> install_requires . append ( '<STR_LIT>' ) <EOL> setup ( name = '<STR_LIT>' , <EOL> version = '<STR_LIT>' , <EOL> description = "<STR_LIT>" , <EOL> long_description = '<STR_LIT>' . join ( [ README , AUTHORS , CHANGES ] ) , <EOL> classifiers = [ <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> ] , <EOL> author = '<STR_LIT>' , <EOL> author_email = '<STR_LIT>' , <EOL> url = '<STR_LIT>' , <EOL> keywords = '<STR_LIT>' , <EOL> license = "<STR_LIT>" , <EOL> packages = find_packages ( ) , <EOL> include_package_data = True , <EOL> zip_safe = False , <EOL> install_requires = install_requires , <EOL> tests_require = tests_require , <EOL> dependency_links = [ ] , <EOL> entry_points = """<STR_LIT>""" , <EOL> extras_require = { <EOL> '<STR_LIT>' : tests_require , <EOL> '<STR_LIT>' : development_requires , <EOL> '<STR_LIT>' : docs_require , <EOL> } , <EOL> ) </s>
<s> """<STR_LIT>""" <EOL> from __future__ import division , unicode_literals <EOL> from . markers import list_marker_layout <EOL> from . min_max import handle_min_max_width <EOL> from . percentages import resolve_percentages , resolve_position_percentages <EOL> from . preferred import shrink_to_fit <EOL> from . tables import table_wrapper_width <EOL> from . . formatting_structure import boxes <EOL> @ handle_min_max_width <EOL> def float_width ( box , context , containing_block ) : <EOL> if box . width == '<STR_LIT>' : <EOL> box . width = shrink_to_fit ( context , box , containing_block . width ) <EOL> def float_layout ( context , box , containing_block , device_size , absolute_boxes , <EOL> fixed_boxes ) : <EOL> """<STR_LIT>""" <EOL> from . blocks import block_container_layout <EOL> from . inlines import inline_replaced_box_width_height <EOL> resolve_percentages ( box , ( containing_block . width , containing_block . height ) ) <EOL> resolve_position_percentages ( <EOL> box , ( containing_block . width , containing_block . height ) ) <EOL> if box . margin_left == '<STR_LIT>' : <EOL> box . margin_left = <NUM_LIT:0> <EOL> if box . margin_right == '<STR_LIT>' : <EOL> box . margin_right = <NUM_LIT:0> <EOL> if box . margin_top == '<STR_LIT>' : <EOL> box . margin_top = <NUM_LIT:0> <EOL> if box . margin_bottom == '<STR_LIT>' : <EOL> box . margin_bottom = <NUM_LIT:0> <EOL> clearance = get_clearance ( context , box ) <EOL> if clearance is not None : <EOL> box . position_y += clearance <EOL> if isinstance ( box , boxes . BlockReplacedBox ) : <EOL> inline_replaced_box_width_height ( box , device_size = None ) <EOL> elif box . width == '<STR_LIT>' : <EOL> float_width ( box , context , containing_block ) <EOL> if box . is_table_wrapper : <EOL> table_wrapper_width ( <EOL> context , box , ( containing_block . width , containing_block . height ) ) <EOL> if isinstance ( box , boxes . BlockBox ) : <EOL> context . create_block_formatting_context ( ) <EOL> box , _ , _ , _ , _ = block_container_layout ( <EOL> context , box , max_position_y = float ( '<STR_LIT>' ) , <EOL> skip_stack = None , device_size = device_size , page_is_empty = False , <EOL> absolute_boxes = absolute_boxes , fixed_boxes = fixed_boxes , <EOL> adjoining_margins = None ) <EOL> list_marker_layout ( context , box ) <EOL> context . finish_block_formatting_context ( box ) <EOL> else : <EOL> assert isinstance ( box , boxes . BlockReplacedBox ) <EOL> box = find_float_position ( context , box , containing_block ) <EOL> context . excluded_shapes . append ( box ) <EOL> return box <EOL> def find_float_position ( context , box , containing_block ) : <EOL> """<STR_LIT>""" <EOL> if context . excluded_shapes : <EOL> highest_y = context . excluded_shapes [ - <NUM_LIT:1> ] . position_y <EOL> if box . position_y < highest_y : <EOL> box . translate ( <NUM_LIT:0> , highest_y - box . position_y ) <EOL> position_x , position_y , available_width = avoid_collisions ( <EOL> context , box , containing_block ) <EOL> if box . style . float == '<STR_LIT:right>' : <EOL> position_x += available_width - box . margin_width ( ) <EOL> box . translate ( position_x - box . position_x , position_y - box . position_y ) <EOL> return box <EOL> def get_clearance ( context , box , collapsed_margin = <NUM_LIT:0> ) : <EOL> """<STR_LIT>""" <EOL> clearance = None <EOL> hypothetical_position = box . position_y + collapsed_margin <EOL> for excluded_shape in context . excluded_shapes : <EOL> if box . style . clear in ( excluded_shape . style . float , '<STR_LIT>' ) : <EOL> y , h = excluded_shape . position_y , excluded_shape . margin_height ( ) <EOL> if hypothetical_position < y + h : <EOL> clearance = max ( <EOL> ( clearance or <NUM_LIT:0> ) , y + h - hypothetical_position ) <EOL> return clearance <EOL> def avoid_collisions ( context , box , containing_block , outer = True ) : <EOL> excluded_shapes = context . excluded_shapes <EOL> position_y = box . position_y if outer else box . border_box_y ( ) <EOL> box_width = box . margin_width ( ) if outer else box . border_width ( ) <EOL> box_height = box . margin_height ( ) if outer else box . border_height ( ) <EOL> if box . border_height ( ) == <NUM_LIT:0> and box . is_floated ( ) : <EOL> return <NUM_LIT:0> , <NUM_LIT:0> , containing_block . width <EOL> while True : <EOL> colliding_shapes = [ <EOL> shape for shape in excluded_shapes <EOL> if ( shape . position_y < position_y < <EOL> shape . position_y + shape . margin_height ( ) ) or <EOL> ( shape . position_y < position_y + box_height < <EOL> shape . position_y + shape . margin_height ( ) ) or <EOL> ( shape . position_y >= position_y and <EOL> shape . position_y + shape . margin_height ( ) <= <EOL> position_y + box_height ) <EOL> ] <EOL> left_bounds = [ <EOL> shape . position_x + shape . margin_width ( ) <EOL> for shape in colliding_shapes <EOL> if shape . style . float == '<STR_LIT:left>' ] <EOL> right_bounds = [ <EOL> shape . position_x <EOL> for shape in colliding_shapes <EOL> if shape . style . float == '<STR_LIT:right>' ] <EOL> max_left_bound = containing_block . content_box_x ( ) <EOL> max_right_bound = containing_block . content_box_x ( ) + containing_block . width <EOL> if not outer : <EOL> max_left_bound += box . margin_left <EOL> max_right_bound -= box . margin_right <EOL> if left_bounds or right_bounds : <EOL> if left_bounds : <EOL> max_left_bound = max ( max ( left_bounds ) , max_left_bound ) <EOL> if right_bounds : <EOL> max_right_bound = min ( min ( right_bounds ) , max_right_bound ) <EOL> if box_width > max_right_bound - max_left_bound : <EOL> new_positon_y = min ( <EOL> shape . position_y + shape . margin_height ( ) <EOL> for shape in colliding_shapes ) <EOL> if new_positon_y > position_y : <EOL> position_y = new_positon_y <EOL> continue <EOL> break <EOL> position_x = max_left_bound <EOL> available_width = max_right_bound - max_left_bound <EOL> if not outer : <EOL> position_x -= box . margin_left <EOL> position_y -= box . margin_top <EOL> return position_x , position_y , available_width </s>
<s> """<STR_LIT>""" <EOL> from setuptools import setup , find_packages <EOL> VERSION = '<STR_LIT>' <EOL> options = dict ( <EOL> name = "<STR_LIT>" , <EOL> version = VERSION , <EOL> description = "<STR_LIT>" , <EOL> long_description = __doc__ , <EOL> author = "<STR_LIT>" , <EOL> author_email = "<STR_LIT>" , <EOL> license = "<STR_LIT>" , <EOL> platforms = "<STR_LIT>" , <EOL> install_requires = [ '<STR_LIT>' ] , <EOL> provides = [ '<STR_LIT>' ] , <EOL> packages = find_packages ( ) , <EOL> use_2to3 = True , <EOL> classifiers = [ <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" ] ) <EOL> setup ( ** options ) </s>
<s> from django . conf . urls import patterns , include , url <EOL> import health_check <EOL> health_check . autodiscover ( ) <EOL> urlpatterns = patterns ( '<STR_LIT>' , <EOL> url ( r'<STR_LIT>' , '<STR_LIT>' , name = '<STR_LIT>' ) , <EOL> ) </s>
<s> import django <EOL> from django . db import connection <EOL> from django . db . models import Count <EOL> from django . db . models . query_utils import Q <EOL> from django . utils import translation <EOL> from hvad . test_utils . data import NORMAL , STANDARD <EOL> from hvad . test_utils . testcase import HvadTestCase , minimumDjangoVersion <EOL> from hvad . test_utils . project . app . models import Normal , AggregateModel , Standard , SimpleRelated <EOL> from hvad . test_utils . fixtures import NormalFixture , StandardFixture <EOL> class FilterTests ( HvadTestCase , NormalFixture ) : <EOL> normal_count = <NUM_LIT:2> <EOL> def test_simple_filter ( self ) : <EOL> qs = Normal . objects . language ( '<STR_LIT>' ) . filter ( shared_field__contains = '<STR_LIT:2>' ) <EOL> self . assertEqual ( qs . count ( ) , <NUM_LIT:1> ) <EOL> obj = qs [ <NUM_LIT:0> ] <EOL> self . assertEqual ( obj . shared_field , NORMAL [ <NUM_LIT:2> ] . shared_field ) <EOL> self . assertEqual ( obj . translated_field , NORMAL [ <NUM_LIT:2> ] . translated_field [ '<STR_LIT>' ] ) <EOL> qs = Normal . objects . language ( '<STR_LIT>' ) . filter ( shared_field__contains = '<STR_LIT:1>' ) <EOL> self . assertEqual ( qs . count ( ) , <NUM_LIT:1> ) <EOL> obj = qs [ <NUM_LIT:0> ] <EOL> self . assertEqual ( obj . shared_field , NORMAL [ <NUM_LIT:1> ] . shared_field ) <EOL> self . assertEqual ( obj . translated_field , NORMAL [ <NUM_LIT:1> ] . translated_field [ '<STR_LIT>' ] ) <EOL> def test_translated_filter ( self ) : <EOL> qs = Normal . objects . language ( '<STR_LIT>' ) . filter ( translated_field__contains = '<STR_LIT>' ) <EOL> self . assertEqual ( qs . count ( ) , self . normal_count ) <EOL> obj1 , obj2 = qs <EOL> self . assertEqual ( obj1 . shared_field , NORMAL [ <NUM_LIT:1> ] . shared_field ) <EOL> self . assertEqual ( obj1 . translated_field , NORMAL [ <NUM_LIT:1> ] . translated_field [ '<STR_LIT>' ] ) <EOL> self . assertEqual ( obj2 . shared_field , NORMAL [ <NUM_LIT:2> ] . shared_field ) <EOL> self . assertEqual ( obj2 . translated_field , NORMAL [ <NUM_LIT:2> ] . translated_field [ '<STR_LIT>' ] ) <EOL> def test_fallbacks_filter ( self ) : <EOL> ( Normal . objects . language ( '<STR_LIT>' ) <EOL> . filter ( shared_field = NORMAL [ <NUM_LIT:1> ] . shared_field ) <EOL> . delete_translations ( ) ) <EOL> with translation . override ( '<STR_LIT>' ) : <EOL> qs = Normal . objects . language ( ) . fallbacks ( ) <EOL> with self . assertNumQueries ( <NUM_LIT:2> ) : <EOL> self . assertEqual ( qs . count ( ) , self . normal_count ) <EOL> self . assertEqual ( len ( qs ) , self . normal_count ) <EOL> with self . assertNumQueries ( <NUM_LIT:0> ) : <EOL> self . assertCountEqual ( ( obj . pk for obj in qs ) , tuple ( self . normal_id . values ( ) ) ) <EOL> self . assertCountEqual ( ( obj . language_code for obj in qs ) , self . translations ) <EOL> def test_all_languages_filter ( self ) : <EOL> with self . assertNumQueries ( <NUM_LIT:2> ) : <EOL> qs = Normal . objects . language ( '<STR_LIT:all>' ) . filter ( shared_field__contains = '<STR_LIT>' ) <EOL> self . assertEqual ( qs . count ( ) , self . normal_count * len ( self . translations ) ) <EOL> self . assertCountEqual ( ( obj . shared_field for obj in qs ) , <EOL> ( NORMAL [ <NUM_LIT:1> ] . shared_field , <EOL> NORMAL [ <NUM_LIT:2> ] . shared_field ) * <NUM_LIT:2> ) <EOL> self . assertCountEqual ( ( obj . translated_field for obj in qs ) , <EOL> ( NORMAL [ <NUM_LIT:1> ] . translated_field [ '<STR_LIT>' ] , <EOL> NORMAL [ <NUM_LIT:1> ] . translated_field [ '<STR_LIT>' ] , <EOL> NORMAL [ <NUM_LIT:2> ] . translated_field [ '<STR_LIT>' ] , <EOL> NORMAL [ <NUM_LIT:2> ] . translated_field [ '<STR_LIT>' ] ) ) <EOL> with self . assertNumQueries ( <NUM_LIT:2> ) : <EOL> qs = Normal . objects . language ( '<STR_LIT:all>' ) . filter ( translated_field__contains = '<STR_LIT>' ) <EOL> self . assertEqual ( qs . count ( ) , self . normal_count ) <EOL> self . assertCountEqual ( ( obj . shared_field for obj in qs ) , <EOL> ( NORMAL [ <NUM_LIT:1> ] . shared_field , <EOL> NORMAL [ <NUM_LIT:2> ] . shared_field ) ) <EOL> self . assertCountEqual ( ( obj . translated_field for obj in qs ) , <EOL> ( NORMAL [ <NUM_LIT:1> ] . translated_field [ '<STR_LIT>' ] , <EOL> NORMAL [ <NUM_LIT:2> ] . translated_field [ '<STR_LIT>' ] ) ) <EOL> with self . assertNumQueries ( <NUM_LIT:2> ) : <EOL> qs = Normal . objects . language ( '<STR_LIT:all>' ) . filter ( translated_field__contains = '<STR_LIT:1>' ) <EOL> self . assertEqual ( qs . count ( ) , <NUM_LIT:1> ) <EOL> obj = qs [ <NUM_LIT:0> ] <EOL> self . assertEqual ( obj . shared_field , NORMAL [ <NUM_LIT:1> ] . shared_field ) <EOL> self . assertEqual ( obj . translated_field , NORMAL [ <NUM_LIT:1> ] . translated_field [ '<STR_LIT>' ] ) <EOL> def test_deferred_language_filter ( self ) : <EOL> with translation . override ( '<STR_LIT>' ) : <EOL> qs = Normal . objects . language ( ) . filter ( translated_field__contains = '<STR_LIT>' ) <EOL> with translation . override ( '<STR_LIT>' ) : <EOL> self . assertEqual ( qs . count ( ) , self . normal_count ) <EOL> obj1 , obj2 = qs <EOL> self . assertEqual ( obj1 . shared_field , NORMAL [ <NUM_LIT:1> ] . shared_field ) <EOL> self . assertEqual ( obj1 . translated_field , NORMAL [ <NUM_LIT:1> ] . translated_field [ '<STR_LIT>' ] ) <EOL> self . assertEqual ( obj2 . shared_field , NORMAL [ <NUM_LIT:2> ] . shared_field ) <EOL> self . assertEqual ( obj2 . translated_field , NORMAL [ <NUM_LIT:2> ] . translated_field [ '<STR_LIT>' ] ) <EOL> class ExtraTests ( HvadTestCase , NormalFixture ) : <EOL> normal_count = <NUM_LIT:2> <EOL> def test_simple_extra ( self ) : <EOL> qs = Normal . objects . language ( '<STR_LIT>' ) . extra ( select = { '<STR_LIT>' : '<STR_LIT>' } ) <EOL> self . assertEqual ( qs . count ( ) , self . normal_count ) <EOL> self . assertEqual ( int ( qs [ <NUM_LIT:0> ] . test_extra ) , <NUM_LIT:4> ) <EOL> class QueryCachingTests ( HvadTestCase , NormalFixture ) : <EOL> normal_count = <NUM_LIT:2> <EOL> def _try_all_cache_using_methods ( self , qs , length ) : <EOL> with self . assertNumQueries ( <NUM_LIT:0> ) : <EOL> x = <NUM_LIT:0> <EOL> for obj in qs : x += <NUM_LIT:1> <EOL> self . assertEqual ( x , length ) <EOL> with self . assertNumQueries ( <NUM_LIT:0> ) : <EOL> qs [ <NUM_LIT:0> ] <EOL> with self . assertNumQueries ( <NUM_LIT:0> ) : <EOL> self . assertEqual ( qs . exists ( ) , length != <NUM_LIT:0> ) <EOL> with self . assertNumQueries ( <NUM_LIT:0> ) : <EOL> self . assertEqual ( qs . count ( ) , length ) <EOL> with self . assertNumQueries ( <NUM_LIT:0> ) : <EOL> self . assertEqual ( len ( qs ) , length ) <EOL> with self . assertNumQueries ( <NUM_LIT:0> ) : <EOL> self . assertEqual ( bool ( qs ) , length != <NUM_LIT:0> ) <EOL> def test_iter_caches ( self ) : <EOL> with translation . override ( '<STR_LIT>' ) : <EOL> index = <NUM_LIT:0> <EOL> qs = Normal . objects . language ( ) . filter ( pk = self . normal_id [ <NUM_LIT:1> ] ) <EOL> for obj in qs : <EOL> index += <NUM_LIT:1> <EOL> self . assertEqual ( index , <NUM_LIT:1> ) <EOL> self . _try_all_cache_using_methods ( qs , <NUM_LIT:1> ) <EOL> def test_pickling_caches ( self ) : <EOL> import pickle <EOL> with translation . override ( '<STR_LIT>' ) : <EOL> qs = Normal . objects . language ( ) . filter ( pk = self . normal_id [ <NUM_LIT:1> ] ) <EOL> pickle . dumps ( qs ) <EOL> self . _try_all_cache_using_methods ( qs , <NUM_LIT:1> ) <EOL> def test_len_caches ( self ) : <EOL> with translation . override ( '<STR_LIT>' ) : <EOL> qs = Normal . objects . language ( ) . filter ( pk = self . normal_id [ <NUM_LIT:1> ] ) <EOL> self . assertEqual ( len ( qs ) , <NUM_LIT:1> ) <EOL> self . _try_all_cache_using_methods ( qs , <NUM_LIT:1> ) <EOL> def test_bool_caches ( self ) : <EOL> with translation . override ( '<STR_LIT>' ) : <EOL> qs = Normal . objects . language ( ) . filter ( pk = self . normal_id [ <NUM_LIT:1> ] ) <EOL> self . assertTrue ( qs ) <EOL> self . _try_all_cache_using_methods ( qs , <NUM_LIT:1> ) <EOL> class IterTests ( HvadTestCase , NormalFixture ) : <EOL> normal_count = <NUM_LIT:2> <EOL> def test_simple_iter ( self ) : <EOL> with translation . override ( '<STR_LIT>' ) : <EOL> with self . assertNumQueries ( <NUM_LIT:1> ) : <EOL> for index , obj in enumerate ( Normal . objects . language ( ) , <NUM_LIT:1> ) : <EOL> self . assertEqual ( obj . shared_field , NORMAL [ index ] . shared_field ) <EOL> self . assertEqual ( obj . translated_field , NORMAL [ index ] . translated_field [ '<STR_LIT>' ] ) <EOL> with translation . override ( '<STR_LIT>' ) : <EOL> with self . assertNumQueries ( <NUM_LIT:1> ) : <EOL> for index , obj in enumerate ( Normal . objects . language ( ) , <NUM_LIT:1> ) : <EOL> self . assertEqual ( obj . shared_field , NORMAL [ index ] . shared_field ) <EOL> self . assertEqual ( obj . translated_field , NORMAL [ index ] . translated_field [ '<STR_LIT>' ] ) <EOL> def test_iter_unique_reply ( self ) : <EOL> with translation . override ( '<STR_LIT>' ) : <EOL> self . assertEqual ( len ( Normal . objects . all ( ) ) , len ( Normal . objects . untranslated ( ) ) ) <EOL> def test_iter_deferred_language ( self ) : <EOL> with translation . override ( '<STR_LIT>' ) : <EOL> qs = Normal . objects . language ( ) <EOL> with translation . override ( '<STR_LIT>' ) : <EOL> for index , obj in enumerate ( qs , <NUM_LIT:1> ) : <EOL> self . assertEqual ( obj . shared_field , NORMAL [ index ] . shared_field ) <EOL> self . assertEqual ( obj . translated_field , NORMAL [ index ] . translated_field [ '<STR_LIT>' ] ) <EOL> class UpdateTests ( HvadTestCase , NormalFixture ) : <EOL> normal_count = <NUM_LIT:2> <EOL> def test_update_shared ( self ) : <EOL> NEW_SHARED = '<STR_LIT>' <EOL> n1 = Normal . objects . language ( '<STR_LIT>' ) . get ( pk = self . normal_id [ <NUM_LIT:1> ] ) <EOL> n2 = Normal . objects . language ( '<STR_LIT>' ) . get ( pk = self . normal_id [ <NUM_LIT:2> ] ) <EOL> ja1 = Normal . objects . language ( '<STR_LIT>' ) . get ( pk = self . normal_id [ <NUM_LIT:1> ] ) <EOL> ja2 = Normal . objects . language ( '<STR_LIT>' ) . get ( pk = self . normal_id [ <NUM_LIT:2> ] ) <EOL> with self . assertNumQueries ( <NUM_LIT:1> if connection . features . update_can_self_select else <NUM_LIT:2> ) : <EOL> Normal . objects . language ( '<STR_LIT>' ) . update ( shared_field = NEW_SHARED ) <EOL> new1 = Normal . objects . language ( '<STR_LIT>' ) . get ( pk = self . normal_id [ <NUM_LIT:1> ] ) <EOL> new2 = Normal . objects . language ( '<STR_LIT>' ) . get ( pk = self . normal_id [ <NUM_LIT:2> ] ) <EOL> self . assertEqual ( new1 . shared_field , NEW_SHARED ) <EOL> self . assertEqual ( new1 . translated_field , n1 . translated_field ) <EOL> self . assertEqual ( new2 . shared_field , NEW_SHARED ) <EOL> self . assertEqual ( new2 . translated_field , n2 . translated_field ) <EOL> newja1 = Normal . objects . language ( '<STR_LIT>' ) . get ( pk = self . normal_id [ <NUM_LIT:1> ] ) <EOL> newja2 = Normal . objects . language ( '<STR_LIT>' ) . get ( pk = self . normal_id [ <NUM_LIT:2> ] ) <EOL> self . assertEqual ( newja1 . shared_field , NEW_SHARED ) <EOL> self . assertEqual ( newja2 . shared_field , NEW_SHARED ) <EOL> self . assertEqual ( newja1 . translated_field , ja1 . translated_field ) <EOL> self . assertEqual ( newja2 . translated_field , ja2 . translated_field ) <EOL> def test_update_translated ( self ) : <EOL> NEW_TRANSLATED = '<STR_LIT>' <EOL> n1 = Normal . objects . language ( '<STR_LIT>' ) . get ( pk = self . normal_id [ <NUM_LIT:1> ] ) <EOL> n2 = Normal . objects . language ( '<STR_LIT>' ) . get ( pk = self . normal_id [ <NUM_LIT:2> ] ) <EOL> ja1 = Normal . objects . language ( '<STR_LIT>' ) . get ( pk = self . normal_id [ <NUM_LIT:1> ] ) <EOL> ja2 = Normal . objects . language ( '<STR_LIT>' ) . get ( pk = self . normal_id [ <NUM_LIT:2> ] ) <EOL> with self . assertNumQueries ( <NUM_LIT:1> ) : <EOL> Normal . objects . language ( '<STR_LIT>' ) . update ( translated_field = NEW_TRANSLATED ) <EOL> new1 = Normal . objects . language ( '<STR_LIT>' ) . get ( pk = self . normal_id [ <NUM_LIT:1> ] ) <EOL> new2 = Normal . objects . language ( '<STR_LIT>' ) . get ( pk = self . normal_id [ <NUM_LIT:2> ] ) <EOL> self . assertEqual ( new1 . shared_field , n1 . shared_field ) <EOL> self . assertEqual ( new2 . shared_field , n2 . shared_field ) <EOL> self . assertEqual ( new1 . translated_field , NEW_TRANSLATED ) <EOL> self . assertEqual ( new2 . translated_field , NEW_TRANSLATED ) <EOL> newja1 = Normal . objects . language ( '<STR_LIT>' ) . get ( pk = self . normal_id [ <NUM_LIT:1> ] ) <EOL> newja2 = Normal . objects . language ( '<STR_LIT>' ) . get ( pk = self . normal_id [ <NUM_LIT:2> ] ) <EOL> self . assertEqual ( newja1 . shared_field , ja1 . shared_field ) <EOL> self . assertEqual ( newja2 . shared_field , ja2 . shared_field ) <EOL> self . assertEqual ( newja1 . translated_field , ja1 . translated_field ) <EOL> self . assertEqual ( newja2 . translated_field , ja2 . translated_field ) <EOL> def test_update_mixed ( self ) : <EOL> NEW_SHARED = '<STR_LIT>' <EOL> NEW_TRANSLATED = '<STR_LIT>' <EOL> ja1 = Normal . objects . language ( '<STR_LIT>' ) . get ( pk = self . normal_id [ <NUM_LIT:1> ] ) <EOL> ja2 = Normal . objects . language ( '<STR_LIT>' ) . get ( pk = self . normal_id [ <NUM_LIT:2> ] ) <EOL> with self . assertNumQueries ( <NUM_LIT:2> if connection . features . update_can_self_select else <NUM_LIT:3> ) : <EOL> Normal . objects . language ( '<STR_LIT>' ) . update ( <EOL> shared_field = NEW_SHARED , translated_field = NEW_TRANSLATED <EOL> ) <EOL> new1 = Normal . objects . language ( '<STR_LIT>' ) . get ( pk = self . normal_id [ <NUM_LIT:1> ] ) <EOL> new2 = Normal . objects . language ( '<STR_LIT>' ) . get ( pk = self . normal_id [ <NUM_LIT:2> ] ) <EOL> self . assertEqual ( new1 . shared_field , NEW_SHARED ) <EOL> self . assertEqual ( new1 . translated_field , NEW_TRANSLATED ) <EOL> self . assertEqual ( new2 . shared_field , NEW_SHARED ) <EOL> self . assertEqual ( new2 . translated_field , NEW_TRANSLATED ) <EOL> newja1 = Normal . objects . language ( '<STR_LIT>' ) . get ( pk = self . normal_id [ <NUM_LIT:1> ] ) <EOL> newja2 = Normal . objects . language ( '<STR_LIT>' ) . get ( pk = self . normal_id [ <NUM_LIT:2> ] ) <EOL> self . assertEqual ( newja1 . shared_field , NEW_SHARED ) <EOL> self . assertEqual ( newja2 . shared_field , NEW_SHARED ) <EOL> self . assertEqual ( newja1 . translated_field , ja1 . translated_field ) <EOL> self . assertEqual ( newja2 . translated_field , ja2 . translated_field ) <EOL> def test_update_deferred_language ( self ) : <EOL> NEW_TRANSLATED = '<STR_LIT>' <EOL> n1 = Normal . objects . language ( '<STR_LIT>' ) . get ( pk = self . normal_id [ <NUM_LIT:1> ] ) <EOL> n2 = Normal . objects . language ( '<STR_LIT>' ) . get ( pk = self . normal_id [ <NUM_LIT:2> ] ) <EOL> ja1 = Normal . objects . language ( '<STR_LIT>' ) . get ( pk = self . normal_id [ <NUM_LIT:1> ] ) <EOL> ja2 = Normal . objects . language ( '<STR_LIT>' ) . get ( pk = self . normal_id [ <NUM_LIT:2> ] ) <EOL> with translation . override ( '<STR_LIT>' ) : <EOL> qs = Normal . objects . language ( ) <EOL> with translation . override ( '<STR_LIT>' ) : <EOL> with self . assertNumQueries ( <NUM_LIT:1> ) : <EOL> qs . update ( translated_field = NEW_TRANSLATED ) <EOL> new1 = Normal . objects . language ( '<STR_LIT>' ) . get ( pk = self . normal_id [ <NUM_LIT:1> ] ) <EOL> new2 = Normal . objects . language ( '<STR_LIT>' ) . get ( pk = self . normal_id [ <NUM_LIT:2> ] ) <EOL> self . assertEqual ( new1 . shared_field , n1 . shared_field ) <EOL> self . assertEqual ( new2 . shared_field , n2 . shared_field ) <EOL> self . assertEqual ( new1 . translated_field , NEW_TRANSLATED ) <EOL> self . assertEqual ( new2 . translated_field , NEW_TRANSLATED ) <EOL> newja1 = Normal . objects . language ( '<STR_LIT>' ) . get ( pk = self . normal_id [ <NUM_LIT:1> ] ) <EOL> newja2 = Normal . objects . language ( '<STR_LIT>' ) . get ( pk = self . normal_id [ <NUM_LIT:2> ] ) <EOL> self . assertEqual ( newja1 . shared_field , ja1 . shared_field ) <EOL> self . assertEqual ( newja2 . shared_field , ja2 . shared_field ) <EOL> self . assertEqual ( newja1 . translated_field , ja1 . translated_field ) <EOL> self . assertEqual ( newja2 . translated_field , ja2 . translated_field ) <EOL> def test_update_fallbacks ( self ) : <EOL> qs = Normal . objects . language ( ) . fallbacks ( ) <EOL> with self . assertNumQueries ( <NUM_LIT:1> if connection . features . update_can_self_select else <NUM_LIT:2> ) : <EOL> qs . filter ( shared_field = NORMAL [ <NUM_LIT:1> ] . shared_field ) . update ( shared_field = '<STR_LIT>' ) <EOL> self . assertEqual ( Normal . objects . language ( '<STR_LIT>' ) . get ( shared_field = '<STR_LIT>' ) . pk , self . normal_id [ <NUM_LIT:1> ] ) <EOL> self . assertEqual ( Normal . objects . language ( '<STR_LIT>' ) . get ( shared_field = '<STR_LIT>' ) . pk , self . normal_id [ <NUM_LIT:1> ] ) <EOL> class ValuesListTests ( HvadTestCase , NormalFixture ) : <EOL> normal_count = <NUM_LIT:2> <EOL> def test_values_list_translated ( self ) : <EOL> values = Normal . objects . language ( '<STR_LIT>' ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> values_list = list ( values ) <EOL> self . assertCountEqual ( values_list , [ NORMAL [ <NUM_LIT:1> ] . translated_field [ '<STR_LIT>' ] , <EOL> NORMAL [ <NUM_LIT:2> ] . translated_field [ '<STR_LIT>' ] ] ) <EOL> def test_values_list_shared ( self ) : <EOL> values = Normal . objects . language ( '<STR_LIT>' ) . values_list ( '<STR_LIT>' , flat = True ) <EOL> values_list = list ( values ) <EOL> self . assertCountEqual ( values_list , [ NORMAL [ <NUM_LIT:1> ] . shared_field , <EOL> NORMAL [ <NUM_LIT:2> ] . shared_field ] ) <EOL> def test_values_list_mixed ( self ) : <EOL> values = Normal . objects . language ( '<STR_LIT>' ) . values_list ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> values_list = list ( values ) <EOL> check = [ <EOL> ( NORMAL [ <NUM_LIT:1> ] . shared_field , NORMAL [ <NUM_LIT:1> ] . translated_field [ '<STR_LIT>' ] ) , <EOL> ( NORMAL [ <NUM_LIT:2> ] . shared_field , NORMAL [ <NUM_LIT:2> ] . translated_field [ '<STR_LIT>' ] ) , <EOL> ] <EOL> self . assertCountEqual ( values_list , check ) <EOL> def test_values_list_deferred_language ( self ) : <EOL> with translation . override ( '<STR_LIT>' ) : <EOL> qs = Normal . objects . language ( ) <EOL> with translation . override ( '<STR_LIT>' ) : <EOL> values = qs . values_list ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> values_list = list ( values ) <EOL> check = [ <EOL> ( NORMAL [ <NUM_LIT:1> ] . shared_field , NORMAL [ <NUM_LIT:1> ] . translated_field [ '<STR_LIT>' ] ) , <EOL> ( NORMAL [ <NUM_LIT:2> ] . shared_field , NORMAL [ <NUM_LIT:2> ] . translated_field [ '<STR_LIT>' ] ) , <EOL> ] <EOL> self . assertCountEqual ( values_list , check ) <EOL> def test_values_list_language_all ( self ) : <EOL> values = ( Normal . objects . language ( '<STR_LIT:all>' ) . filter ( shared_field = NORMAL [ <NUM_LIT:1> ] . shared_field ) <EOL> . values_list ( '<STR_LIT>' , '<STR_LIT>' ) ) <EOL> values_list = list ( values ) <EOL> check = [ <EOL> ( NORMAL [ <NUM_LIT:1> ] . shared_field , NORMAL [ <NUM_LIT:1> ] . translated_field [ '<STR_LIT>' ] ) , <EOL> ( NORMAL [ <NUM_LIT:1> ] . shared_field , NORMAL [ <NUM_LIT:1> ] . translated_field [ '<STR_LIT>' ] ) , <EOL> ] <EOL> self . assertCountEqual ( values_list , check ) <EOL> class ValuesTests ( HvadTestCase , NormalFixture ) : <EOL> normal_count = <NUM_LIT:2> <EOL> def test_values_shared ( self ) : <EOL> values = Normal . objects . language ( '<STR_LIT>' ) . values ( '<STR_LIT>' ) <EOL> values_list = list ( values ) <EOL> check = [ <EOL> { '<STR_LIT>' : NORMAL [ <NUM_LIT:1> ] . shared_field } , <EOL> { '<STR_LIT>' : NORMAL [ <NUM_LIT:2> ] . shared_field } , <EOL> ] <EOL> self . assertCountEqual ( values_list , check ) <EOL> def test_values_translated ( self ) : <EOL> values = Normal . objects . language ( '<STR_LIT>' ) . values ( '<STR_LIT>' ) <EOL> values_list = list ( values ) <EOL> check = [ <EOL> { '<STR_LIT>' : NORMAL [ <NUM_LIT:1> ] . translated_field [ '<STR_LIT>' ] } , <EOL> { '<STR_LIT>' : NORMAL [ <NUM_LIT:2> ] . translated_field [ '<STR_LIT>' ] } , <EOL> ] <EOL> self . assertCountEqual ( values_list , check ) <EOL> def test_values_mixed ( self ) : <EOL> values = Normal . objects . language ( '<STR_LIT>' ) . values ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> values_list = list ( values ) <EOL> check = [ <EOL> { '<STR_LIT>' : NORMAL [ <NUM_LIT:1> ] . translated_field [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : NORMAL [ <NUM_LIT:1> ] . shared_field } , <EOL> { '<STR_LIT>' : NORMAL [ <NUM_LIT:2> ] . translated_field [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : NORMAL [ <NUM_LIT:2> ] . shared_field } , <EOL> ] <EOL> self . assertCountEqual ( values_list , check ) <EOL> def test_values_post_language ( self ) : <EOL> values = Normal . objects . language ( ) . values ( '<STR_LIT>' ) . language ( '<STR_LIT>' ) <EOL> values_list = list ( values ) <EOL> check = [ <EOL> { '<STR_LIT>' : NORMAL [ <NUM_LIT:1> ] . shared_field } , <EOL> { '<STR_LIT>' : NORMAL [ <NUM_LIT:2> ] . shared_field } , <EOL> ] <EOL> self . assertCountEqual ( values_list , check ) <EOL> def test_values_post_filter ( self ) : <EOL> qs = Normal . objects . language ( '<STR_LIT>' ) . values ( '<STR_LIT>' ) <EOL> values = qs . filter ( shared_field = NORMAL [ <NUM_LIT:1> ] . shared_field ) <EOL> values_list = list ( values ) <EOL> check = [ <EOL> { '<STR_LIT>' : NORMAL [ <NUM_LIT:1> ] . shared_field } , <EOL> ] <EOL> self . assertCountEqual ( values_list , check ) <EOL> def test_values_deferred_language ( self ) : <EOL> with translation . override ( '<STR_LIT>' ) : <EOL> qs = Normal . objects . language ( ) <EOL> with translation . override ( '<STR_LIT>' ) : <EOL> values = qs . values ( '<STR_LIT>' ) <EOL> values_list = list ( values ) <EOL> check = [ <EOL> { '<STR_LIT>' : NORMAL [ <NUM_LIT:1> ] . translated_field [ '<STR_LIT>' ] } , <EOL> { '<STR_LIT>' : NORMAL [ <NUM_LIT:2> ] . translated_field [ '<STR_LIT>' ] } , <EOL> ] <EOL> self . assertCountEqual ( values_list , check ) <EOL> def test_values_language_all ( self ) : <EOL> values = ( Normal . objects . language ( '<STR_LIT:all>' ) . filter ( shared_field = NORMAL [ <NUM_LIT:1> ] . shared_field ) <EOL> . values ( '<STR_LIT>' , '<STR_LIT>' ) ) <EOL> values_list = list ( values ) <EOL> check = [ <EOL> { '<STR_LIT>' : NORMAL [ <NUM_LIT:1> ] . shared_field , <EOL> '<STR_LIT>' : NORMAL [ <NUM_LIT:1> ] . translated_field [ '<STR_LIT>' ] } , <EOL> { '<STR_LIT>' : NORMAL [ <NUM_LIT:1> ] . shared_field , <EOL> '<STR_LIT>' : NORMAL [ <NUM_LIT:1> ] . translated_field [ '<STR_LIT>' ] } , <EOL> ] <EOL> self . assertCountEqual ( values_list , check ) <EOL> class InBulkTests ( HvadTestCase , NormalFixture ) : <EOL> normal_count = <NUM_LIT:2> <EOL> def test_empty_in_bulk ( self ) : <EOL> with self . assertNumQueries ( <NUM_LIT:0> ) : <EOL> result = Normal . objects . language ( '<STR_LIT>' ) . in_bulk ( [ ] ) <EOL> self . assertEqual ( len ( result ) , <NUM_LIT:0> ) <EOL> def test_in_bulk ( self ) : <EOL> pk1 , pk2 = self . normal_id [ <NUM_LIT:1> ] , self . normal_id [ <NUM_LIT:2> ] <EOL> with self . assertNumQueries ( <NUM_LIT:1> ) : <EOL> result = Normal . objects . language ( '<STR_LIT>' ) . in_bulk ( [ pk1 , pk2 ] ) <EOL> self . assertCountEqual ( ( pk1 , pk2 ) , result ) <EOL> self . assertEqual ( result [ pk1 ] . shared_field , NORMAL [ <NUM_LIT:1> ] . shared_field ) <EOL> self . assertEqual ( result [ pk1 ] . translated_field , NORMAL [ <NUM_LIT:1> ] . translated_field [ '<STR_LIT>' ] ) <EOL> self . assertEqual ( result [ pk1 ] . language_code , '<STR_LIT>' ) <EOL> self . assertEqual ( result [ pk2 ] . shared_field , NORMAL [ <NUM_LIT:2> ] . shared_field ) <EOL> self . assertEqual ( result [ pk2 ] . translated_field , NORMAL [ <NUM_LIT:2> ] . translated_field [ '<STR_LIT>' ] ) <EOL> self . assertEqual ( result [ pk2 ] . language_code , '<STR_LIT>' ) <EOL> def test_untranslated_in_bulk ( self ) : <EOL> pk1 = self . normal_id [ <NUM_LIT:1> ] <EOL> with translation . override ( '<STR_LIT>' ) : <EOL> with self . assertNumQueries ( <NUM_LIT:2> ) : <EOL> result = Normal . objects . untranslated ( ) . in_bulk ( [ pk1 ] ) <EOL> self . assertCountEqual ( ( pk1 , ) , result ) <EOL> self . assertEqual ( result [ pk1 ] . shared_field , NORMAL [ <NUM_LIT:1> ] . shared_field ) <EOL> self . assertEqual ( result [ pk1 ] . translated_field , NORMAL [ <NUM_LIT:1> ] . translated_field [ '<STR_LIT>' ] ) <EOL> self . assertEqual ( result [ pk1 ] . language_code , '<STR_LIT>' ) <EOL> def test_fallbacks_in_bulk ( self ) : <EOL> ( Normal . objects . language ( '<STR_LIT>' ) <EOL> . filter ( shared_field = NORMAL [ <NUM_LIT:2> ] . shared_field ) <EOL> . delete_translations ( ) ) <EOL> with self . assertNumQueries ( <NUM_LIT:1> ) : <EOL> pk1 , pk2 = self . normal_id [ <NUM_LIT:1> ] , self . normal_id [ <NUM_LIT:2> ] <EOL> result = Normal . objects . language ( '<STR_LIT>' ) . fallbacks ( '<STR_LIT>' , '<STR_LIT>' ) . in_bulk ( [ pk1 , pk2 ] ) <EOL> self . assertCountEqual ( ( pk1 , pk2 ) , result ) <EOL> self . assertEqual ( result [ pk1 ] . shared_field , NORMAL [ <NUM_LIT:1> ] . shared_field ) <EOL> self . assertEqual ( result [ pk1 ] . translated_field , NORMAL [ <NUM_LIT:1> ] . translated_field [ '<STR_LIT>' ] ) <EOL> self . assertEqual ( result [ pk1 ] . language_code , '<STR_LIT>' ) <EOL> self . assertEqual ( result [ pk2 ] . shared_field , NORMAL [ <NUM_LIT:2> ] . shared_field ) <EOL> self . assertEqual ( result [ pk2 ] . translated_field , NORMAL [ <NUM_LIT:2> ] . translated_field [ '<STR_LIT>' ] ) <EOL> self . assertEqual ( result [ pk2 ] . language_code , '<STR_LIT>' ) <EOL> def test_all_languages_in_bulk ( self ) : <EOL> with self . assertRaises ( ValueError ) : <EOL> Normal . objects . language ( '<STR_LIT:all>' ) . in_bulk ( [ self . normal_id [ <NUM_LIT:1> ] ] ) <EOL> def test_in_bulk_deferred_language ( self ) : <EOL> pk1 = self . normal_id [ <NUM_LIT:1> ] <EOL> with translation . override ( '<STR_LIT>' ) : <EOL> qs = Normal . objects . language ( ) <EOL> with translation . override ( '<STR_LIT>' ) : <EOL> result = qs . in_bulk ( [ pk1 ] ) <EOL> self . assertCountEqual ( ( pk1 , ) , result ) <EOL> self . assertEqual ( result [ pk1 ] . shared_field , NORMAL [ <NUM_LIT:1> ] . shared_field ) <EOL> self . assertEqual ( result [ pk1 ] . translated_field , NORMAL [ <NUM_LIT:1> ] . translated_field [ '<STR_LIT>' ] ) <EOL> self . assertEqual ( result [ pk1 ] . language_code , '<STR_LIT>' ) <EOL> class DeleteTests ( HvadTestCase , NormalFixture ) : <EOL> normal_count = <NUM_LIT:2> <EOL> def test_delete_all ( self ) : <EOL> Normal . objects . all ( ) . delete ( ) <EOL> self . assertEqual ( Normal . objects . count ( ) , <NUM_LIT:0> ) <EOL> self . assertEqual ( Normal . _meta . translations_model . objects . count ( ) , <NUM_LIT:0> ) <EOL> def test_delete_translation ( self ) : <EOL> self . assertEqual ( Normal . _meta . translations_model . objects . count ( ) , <NUM_LIT:4> ) <EOL> Normal . objects . language ( '<STR_LIT>' ) . delete_translations ( ) <EOL> self . assertEqual ( Normal . objects . untranslated ( ) . count ( ) , <NUM_LIT:2> ) <EOL> self . assertEqual ( Normal . _meta . translations_model . objects . count ( ) , <NUM_LIT:2> ) <EOL> Normal . objects . language ( '<STR_LIT>' ) . delete_translations ( ) <EOL> self . assertEqual ( Normal . objects . untranslated ( ) . count ( ) , <NUM_LIT:2> ) <EOL> self . assertEqual ( Normal . _meta . translations_model . objects . count ( ) , <NUM_LIT:0> ) <EOL> def test_filtered_delete_translation ( self ) : <EOL> self . assertEqual ( Normal . _meta . translations_model . objects . count ( ) , <NUM_LIT:4> ) <EOL> ( Normal . objects . language ( '<STR_LIT>' ) <EOL> . filter ( shared_field = NORMAL [ <NUM_LIT:1> ] . shared_field ) <EOL> . delete_translations ( ) ) <EOL> self . assertEqual ( Normal . objects . untranslated ( ) . count ( ) , <NUM_LIT:2> ) <EOL> self . assertEqual ( Normal . _meta . translations_model . objects . count ( ) , <NUM_LIT:3> ) <EOL> ( Normal . objects . language ( '<STR_LIT>' ) <EOL> . filter ( translated_field = NORMAL [ <NUM_LIT:2> ] . translated_field [ '<STR_LIT>' ] ) <EOL> . delete_translations ( ) ) <EOL> self . assertEqual ( Normal . objects . untranslated ( ) . count ( ) , <NUM_LIT:2> ) <EOL> self . assertEqual ( Normal . _meta . translations_model . objects . count ( ) , <NUM_LIT:2> ) <EOL> def test_delete_translation_deferred_language ( self ) : <EOL> self . assertEqual ( Normal . _meta . translations_model . objects . count ( ) , <NUM_LIT:4> ) <EOL> with translation . override ( '<STR_LIT>' ) : <EOL> qs = Normal . objects . language ( ) <EOL> with translation . override ( '<STR_LIT>' ) : <EOL> qs . delete_translations ( ) <EOL> self . assertEqual ( Normal . objects . language ( '<STR_LIT>' ) . count ( ) , <NUM_LIT:2> ) <EOL> self . assertEqual ( Normal . objects . language ( '<STR_LIT>' ) . count ( ) , <NUM_LIT:0> ) <EOL> def test_delete_fallbacks ( self ) : <EOL> qs = Normal . objects . language ( ) . fallbacks ( ) <EOL> qs . filter ( shared_field = NORMAL [ <NUM_LIT:1> ] . shared_field ) . delete ( ) <EOL> self . assertEqual ( Normal . objects . language ( '<STR_LIT>' ) . count ( ) , self . normal_count - <NUM_LIT:1> ) <EOL> self . assertEqual ( Normal . objects . language ( '<STR_LIT>' ) . count ( ) , self . normal_count - <NUM_LIT:1> ) <EOL> class GetTranslationFromInstanceTests ( HvadTestCase , NormalFixture ) : <EOL> normal_count = <NUM_LIT:1> <EOL> def test_simple ( self ) : <EOL> en = Normal . objects . language ( '<STR_LIT>' ) . get ( ) <EOL> ja_trans = en . translations . get_language ( '<STR_LIT>' ) <EOL> ja = Normal . objects . language ( '<STR_LIT>' ) . get ( pk = en . pk ) <EOL> self . assertEqual ( en . shared_field , NORMAL [ <NUM_LIT:1> ] . shared_field ) <EOL> self . assertEqual ( en . translated_field , NORMAL [ <NUM_LIT:1> ] . translated_field [ '<STR_LIT>' ] ) <EOL> self . assertRaises ( AttributeError , getattr , ja_trans , '<STR_LIT>' ) <EOL> self . assertEqual ( ja_trans . translated_field , NORMAL [ <NUM_LIT:1> ] . translated_field [ '<STR_LIT>' ] ) <EOL> self . assertEqual ( ja . shared_field , NORMAL [ <NUM_LIT:1> ] . shared_field ) <EOL> self . assertEqual ( ja . translated_field , NORMAL [ <NUM_LIT:1> ] . translated_field [ '<STR_LIT>' ] ) <EOL> def test_cached ( self ) : <EOL> en = Normal . objects . untranslated ( ) . prefetch_related ( '<STR_LIT>' ) . get ( ) <EOL> with self . assertNumQueries ( <NUM_LIT:0> ) : <EOL> ja_trans = en . translations . get_language ( '<STR_LIT>' ) <EOL> ja = Normal . objects . language ( '<STR_LIT>' ) . get ( pk = en . pk ) <EOL> self . assertEqual ( en . shared_field , NORMAL [ <NUM_LIT:1> ] . shared_field ) <EOL> self . assertEqual ( en . translated_field , NORMAL [ <NUM_LIT:1> ] . translated_field [ '<STR_LIT>' ] ) <EOL> self . assertRaises ( AttributeError , getattr , ja_trans , '<STR_LIT>' ) <EOL> self . assertEqual ( ja_trans . translated_field , NORMAL [ <NUM_LIT:1> ] . translated_field [ '<STR_LIT>' ] ) <EOL> self . assertEqual ( ja . shared_field , NORMAL [ <NUM_LIT:1> ] . shared_field ) <EOL> self . assertEqual ( ja . translated_field , NORMAL [ <NUM_LIT:1> ] . translated_field [ '<STR_LIT>' ] ) <EOL> def test_not_exist ( self ) : <EOL> en = Normal . objects . untranslated ( ) . get ( ) <EOL> with self . assertRaises ( Normal . DoesNotExist ) : <EOL> en . translations . get_language ( '<STR_LIT>' ) <EOL> en = Normal . objects . untranslated ( ) . prefetch_related ( '<STR_LIT>' ) . get ( ) <EOL> with self . assertRaises ( Normal . DoesNotExist ) : <EOL> en . translations . get_language ( '<STR_LIT>' ) <EOL> class AggregateTests ( HvadTestCase ) : <EOL> def test_aggregate ( self ) : <EOL> from django . db . models import Avg <EOL> AggregateModel . objects . language ( "<STR_LIT>" ) . create ( number = <NUM_LIT:10> , translated_number = <NUM_LIT:20> ) <EOL> AggregateModel . objects . language ( "<STR_LIT>" ) . create ( number = <NUM_LIT:0> , translated_number = <NUM_LIT:0> ) <EOL> self . assertEqual ( AggregateModel . objects . language ( "<STR_LIT>" ) . aggregate ( Avg ( "<STR_LIT>" ) ) , { '<STR_LIT>' : <NUM_LIT:5> } ) <EOL> self . assertEqual ( AggregateModel . objects . language ( "<STR_LIT>" ) . aggregate ( Avg ( "<STR_LIT>" ) ) , { '<STR_LIT>' : <NUM_LIT:10> } ) <EOL> self . assertEqual ( AggregateModel . objects . language ( "<STR_LIT>" ) . aggregate ( num = Avg ( "<STR_LIT>" ) ) , { '<STR_LIT>' : <NUM_LIT:5> } ) <EOL> self . assertEqual ( AggregateModel . objects . language ( "<STR_LIT>" ) . aggregate ( tnum = Avg ( "<STR_LIT>" ) ) , { '<STR_LIT>' : <NUM_LIT:10> } ) <EOL> class AnnotateTests ( HvadTestCase , StandardFixture , NormalFixture ) : <EOL> normal_count = <NUM_LIT:2> <EOL> standard_count = <NUM_LIT:4> <EOL> def test_annotate ( self ) : <EOL> qs = Normal . objects . language ( '<STR_LIT>' ) . annotate ( Count ( '<STR_LIT>' ) ) <EOL> self . assertEqual ( len ( qs ) , self . normal_count ) <EOL> self . assertEqual ( qs [ <NUM_LIT:0> ] . standards__count , <NUM_LIT:2> ) <EOL> self . assertEqual ( qs [ <NUM_LIT:1> ] . standards__count , <NUM_LIT:2> ) <EOL> qs = Normal . objects . language ( '<STR_LIT>' ) . annotate ( foo = Count ( '<STR_LIT>' ) ) <EOL> self . assertEqual ( len ( qs ) , self . normal_count ) <EOL> self . assertEqual ( qs [ <NUM_LIT:0> ] . foo , <NUM_LIT:2> ) <EOL> self . assertEqual ( qs [ <NUM_LIT:1> ] . foo , <NUM_LIT:2> ) <EOL> with self . assertRaises ( ValueError ) : <EOL> qs = Normal . objects . language ( '<STR_LIT>' ) . annotate ( Count ( '<STR_LIT>' ) , standards__count = Count ( '<STR_LIT>' ) ) <EOL> class NotImplementedTests ( HvadTestCase ) : <EOL> def test_notimplemented ( self ) : <EOL> baseqs = SimpleRelated . objects . language ( '<STR_LIT>' ) <EOL> self . assertRaises ( NotImplementedError , baseqs . defer , '<STR_LIT>' ) <EOL> self . assertRaises ( NotImplementedError , baseqs . only ) <EOL> self . assertRaises ( NotImplementedError , baseqs . bulk_create , [ ] ) <EOL> self . assertRaises ( NotImplementedError , baseqs . select_related ) <EOL> if django . VERSION >= ( <NUM_LIT:1> , <NUM_LIT:7> ) : <EOL> self . assertRaises ( NotImplementedError , baseqs . update_or_create ) <EOL> class MinimumVersionTests ( HvadTestCase ) : <EOL> def test_versions ( self ) : <EOL> qs = SimpleRelated . objects . language ( '<STR_LIT>' ) <EOL> if django . VERSION < ( <NUM_LIT:1> , <NUM_LIT:7> ) : <EOL> self . assertRaises ( AttributeError , getattr , qs , '<STR_LIT>' ) <EOL> class ExcludeTests ( HvadTestCase , NormalFixture ) : <EOL> normal_count = <NUM_LIT:1> <EOL> def test_defer ( self ) : <EOL> qs = Normal . objects . language ( '<STR_LIT>' ) . exclude ( translated_field = NORMAL [ <NUM_LIT:1> ] . translated_field [ '<STR_LIT>' ] ) <EOL> self . assertEqual ( qs . count ( ) , <NUM_LIT:0> ) <EOL> def test_fallbacks_exclude ( self ) : <EOL> ( Normal . objects . language ( '<STR_LIT>' ) <EOL> . filter ( shared_field = NORMAL [ <NUM_LIT:1> ] . shared_field ) <EOL> . delete_translations ( ) ) <EOL> qs = ( Normal . objects . language ( '<STR_LIT>' ) <EOL> . fallbacks ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> . exclude ( shared_field = NORMAL [ <NUM_LIT:1> ] . shared_field ) ) <EOL> self . assertEqual ( qs . count ( ) , <NUM_LIT:0> ) <EOL> def test_all_languages_exclude ( self ) : <EOL> qs = Normal . objects . language ( '<STR_LIT:all>' ) . exclude ( translated_field = NORMAL [ <NUM_LIT:1> ] . translated_field [ '<STR_LIT>' ] ) <EOL> self . assertEqual ( qs . count ( ) , <NUM_LIT:1> ) <EOL> self . assertEqual ( qs [ <NUM_LIT:0> ] . translated_field , NORMAL [ <NUM_LIT:1> ] . translated_field [ '<STR_LIT>' ] ) <EOL> def test_invalid_all_languages_exclude ( self ) : <EOL> with self . assertRaises ( ValueError ) : <EOL> Normal . objects . language ( ) . exclude ( language_code = '<STR_LIT:all>' ) <EOL> class ComplexFilterTests ( HvadTestCase , StandardFixture , NormalFixture ) : <EOL> normal_count = <NUM_LIT:2> <EOL> standard_count = <NUM_LIT:2> <EOL> def test_qobject_filter ( self ) : <EOL> shared_contains_one = Q ( shared_field__contains = '<STR_LIT:1>' ) <EOL> shared_contains_two = Q ( shared_field__contains = '<STR_LIT:2>' ) <EOL> qs = Normal . objects . language ( '<STR_LIT>' ) . filter ( shared_contains_two ) <EOL> self . assertEqual ( qs . count ( ) , <NUM_LIT:1> ) <EOL> obj = qs [ <NUM_LIT:0> ] <EOL> self . assertEqual ( obj . shared_field , NORMAL [ <NUM_LIT:2> ] . shared_field ) <EOL> self . assertEqual ( obj . translated_field , NORMAL [ <NUM_LIT:2> ] . translated_field [ '<STR_LIT>' ] ) <EOL> qs = ( Normal . objects . language ( '<STR_LIT>' ) . filter ( Q ( shared_contains_one | shared_contains_two ) ) <EOL> . order_by ( '<STR_LIT>' ) ) <EOL> self . assertEqual ( qs . count ( ) , <NUM_LIT:2> ) <EOL> obj = qs [ <NUM_LIT:0> ] <EOL> self . assertEqual ( obj . shared_field , NORMAL [ <NUM_LIT:1> ] . shared_field ) <EOL> self . assertEqual ( obj . translated_field , NORMAL [ <NUM_LIT:1> ] . translated_field [ '<STR_LIT>' ] ) <EOL> obj = qs [ <NUM_LIT:1> ] <EOL> self . assertEqual ( obj . shared_field , NORMAL [ <NUM_LIT:2> ] . shared_field ) <EOL> self . assertEqual ( obj . translated_field , NORMAL [ <NUM_LIT:2> ] . translated_field [ '<STR_LIT>' ] ) <EOL> def test_aware_qobject_filter ( self ) : <EOL> from hvad . utils import get_translation_aware_manager <EOL> manager = get_translation_aware_manager ( Standard ) <EOL> normal_one = Q ( normal_field = STANDARD [ <NUM_LIT:1> ] . normal_field ) <EOL> normal_two = Q ( normal_field = STANDARD [ <NUM_LIT:2> ] . normal_field ) <EOL> shared_one = Q ( normal__shared_field = NORMAL [ STANDARD [ <NUM_LIT:1> ] . normal ] . shared_field ) <EOL> translated_one_en = Q ( normal__translated_field = NORMAL [ STANDARD [ <NUM_LIT:1> ] . normal ] . translated_field [ '<STR_LIT>' ] ) <EOL> translated_two_en = Q ( normal__translated_field = NORMAL [ STANDARD [ <NUM_LIT:2> ] . normal ] . translated_field [ '<STR_LIT>' ] ) <EOL> with translation . override ( '<STR_LIT>' ) : <EOL> qs = manager . filter ( shared_one ) <EOL> self . assertEqual ( qs . count ( ) , <NUM_LIT:1> ) <EOL> obj = qs [ <NUM_LIT:0> ] <EOL> self . assertEqual ( obj . normal_field , STANDARD [ <NUM_LIT:1> ] . normal_field ) <EOL> qs = manager . filter ( translated_one_en ) <EOL> self . assertEqual ( qs . count ( ) , <NUM_LIT:1> ) <EOL> obj = qs [ <NUM_LIT:0> ] <EOL> self . assertEqual ( obj . normal_field , STANDARD [ <NUM_LIT:1> ] . normal_field ) <EOL> qs = manager . filter ( Q ( normal_one & shared_one & translated_one_en ) ) <EOL> self . assertEqual ( qs . count ( ) , <NUM_LIT:1> ) <EOL> obj = qs [ <NUM_LIT:0> ] <EOL> self . assertEqual ( obj . normal_field , STANDARD [ <NUM_LIT:1> ] . normal_field ) <EOL> qs = manager . filter ( Q ( normal_one & translated_two_en ) ) <EOL> self . assertEqual ( qs . count ( ) , <NUM_LIT:0> ) <EOL> qs = manager . filter ( Q ( shared_one & translated_two_en ) ) <EOL> self . assertEqual ( qs . count ( ) , <NUM_LIT:0> ) <EOL> qs = manager . filter ( Q ( translated_one_en & translated_two_en ) ) <EOL> self . assertEqual ( qs . count ( ) , <NUM_LIT:0> ) <EOL> qs = manager . filter ( Q ( normal_one | translated_one_en ) ) <EOL> self . assertEqual ( qs . count ( ) , <NUM_LIT:1> ) <EOL> qs = manager . filter ( Q ( shared_one | translated_one_en ) ) <EOL> self . assertEqual ( qs . count ( ) , <NUM_LIT:1> ) <EOL> qs = manager . filter ( Q ( normal_one | translated_two_en ) ) <EOL> self . assertEqual ( qs . count ( ) , <NUM_LIT:2> ) <EOL> qs = manager . filter ( Q ( shared_one | translated_two_en ) ) <EOL> self . assertEqual ( qs . count ( ) , <NUM_LIT:2> ) <EOL> qs = manager . filter ( Q ( translated_one_en | translated_two_en ) ) <EOL> self . assertEqual ( qs . count ( ) , <NUM_LIT:2> ) <EOL> qs = manager . filter ( Q ( normal_one & ( translated_one_en | translated_two_en ) ) ) <EOL> self . assertEqual ( qs . count ( ) , <NUM_LIT:1> ) <EOL> qs = manager . filter ( Q ( normal_two & ( translated_one_en | translated_two_en ) ) ) <EOL> self . assertEqual ( qs . count ( ) , <NUM_LIT:1> ) <EOL> qs = manager . filter ( shared_one & ~ translated_one_en ) <EOL> self . assertEqual ( qs . count ( ) , <NUM_LIT:0> ) <EOL> qs = manager . filter ( shared_one & ~ translated_two_en ) <EOL> self . assertEqual ( qs . count ( ) , <NUM_LIT:1> ) <EOL> def test_defer ( self ) : <EOL> qs = Normal . objects . language ( '<STR_LIT>' ) . complex_filter ( { } ) <EOL> self . assertEqual ( qs . count ( ) , self . normal_count ) <EOL> self . assertRaises ( NotImplementedError , <EOL> Normal . objects . language ( '<STR_LIT>' ) . complex_filter , <EOL> Q ( shared_field = NORMAL [ <NUM_LIT:1> ] . shared_field ) ) </s>
<s> import json <EOL> import threading <EOL> import sublime <EOL> import sublime_plugin <EOL> import analytics <EOL> import uuid <EOL> from elasticsearch import Elasticsearch <EOL> from elasticsearch_connections import CustomHeadersConnection <EOL> from abc import ABCMeta , abstractmethod <EOL> from . . panel import IndexListPanel <EOL> from . . panel import DocTypeListPanel <EOL> from . . panel import SwitchServerListPanel <EOL> from . . panel import AnalyzerListPanel <EOL> from . . panel import ScriptListPanel <EOL> from . . panel import SearchTemplateListPanel <EOL> from . . panel import AliasListPanel <EOL> from . . panel import IndexTemplateListPanel <EOL> from . . panel import WarmerListPanel <EOL> from . . panel import FieldListPanel <EOL> from . . panel import RepositoryListPanel <EOL> from . . panel import SnapshotListPanel <EOL> ANALYTICS_WRITE_KEY = "<STR_LIT>" <EOL> def track_command ( user_id , command_name ) : <EOL> analytics . write_key = ANALYTICS_WRITE_KEY <EOL> analytics . identify ( user_id ) <EOL> analytics . track ( user_id , "<STR_LIT>" , { <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT:label>" : command_name , <EOL> } ) <EOL> def track_activate ( user_id ) : <EOL> analytics . write_key = ANALYTICS_WRITE_KEY <EOL> analytics . identify ( user_id ) <EOL> analytics . track ( user_id , "<STR_LIT>" , { <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT:label>" : sublime . platform ( ) , <EOL> } ) <EOL> class Settings ( object ) : <EOL> SETTINGS_FILE = '<STR_LIT>' <EOL> def __init__ ( self ) : <EOL> self . settings = sublime . load_settings ( self . SETTINGS_FILE ) <EOL> @ property <EOL> def base_url ( self ) : <EOL> base_url = self . settings . get ( "<STR_LIT>" , "<STR_LIT>" ) <EOL> if base_url . endswith ( "<STR_LIT:/>" ) : <EOL> return base_url [ : - <NUM_LIT:1> ] <EOL> return base_url <EOL> @ property <EOL> def index ( self ) : <EOL> return self . settings . get ( "<STR_LIT:index>" , "<STR_LIT>" ) <EOL> @ property <EOL> def doc_type ( self ) : <EOL> return self . settings . get ( "<STR_LIT>" , "<STR_LIT>" ) <EOL> @ property <EOL> def scroll_size ( self ) : <EOL> return self . settings . get ( "<STR_LIT>" , "<STR_LIT>" ) <EOL> @ property <EOL> def headers ( self ) : <EOL> return self . settings . get ( "<STR_LIT>" , { } ) <EOL> @ property <EOL> def servers ( self ) : <EOL> def _normalize_servers ( servers ) : <EOL> items = [ ] <EOL> for name , server in servers . items ( ) : <EOL> server [ "<STR_LIT:name>" ] = name <EOL> items . append ( server ) <EOL> servers = sorted ( items , key = lambda k : k [ "<STR_LIT:name>" ] ) <EOL> return servers <EOL> servers = self . settings . get ( "<STR_LIT>" , [ ] ) <EOL> if isinstance ( servers , dict ) : <EOL> servers = _normalize_servers ( servers ) <EOL> return servers <EOL> @ property <EOL> def active_server ( self ) : <EOL> return dict ( <EOL> base_url = self . base_url , <EOL> index = self . index , <EOL> doc_type = self . doc_type , <EOL> scroll_size = self . scroll_size , <EOL> ) <EOL> @ property <EOL> def ab_command ( self ) : <EOL> return self . settings . get ( "<STR_LIT>" ) <EOL> @ property <EOL> def ab_requests ( self ) : <EOL> return str ( self . settings . get ( "<STR_LIT>" ) ) <EOL> @ property <EOL> def ab_concurrency ( self ) : <EOL> return str ( self . settings . get ( "<STR_LIT>" ) ) <EOL> @ property <EOL> def analytics ( self ) : <EOL> return self . settings . get ( "<STR_LIT>" , True ) <EOL> @ property <EOL> def user_id ( self ) : <EOL> return self . settings . get ( "<STR_LIT>" , None ) <EOL> @ property <EOL> def dump_file ( self ) : <EOL> return self . settings . get ( "<STR_LIT>" , "<STR_LIT>" ) <EOL> @ property <EOL> def chunk_size ( self ) : <EOL> return self . settings . get ( "<STR_LIT>" , <NUM_LIT> ) <EOL> def set ( self , key , value ) : <EOL> self . settings . set ( key , value ) <EOL> def save ( self ) : <EOL> sublime . save_settings ( self . SETTINGS_FILE ) <EOL> class BaseCommand ( sublime_plugin . WindowCommand ) : <EOL> __metaclass__ = ABCMeta <EOL> command_name = None <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> self . settings = Settings ( ) <EOL> sublime_plugin . WindowCommand . __init__ ( self , * args , ** kwargs ) <EOL> @ property <EOL> def view ( self ) : <EOL> return self . window . active_view ( ) <EOL> def is_valid_json ( self ) : <EOL> try : <EOL> json . loads ( self . get_text ( ) ) <EOL> except ValueError : <EOL> return False <EOL> return True <EOL> def is_enabled ( self ) : <EOL> return self . is_valid_json ( ) <EOL> def get_text ( self ) : <EOL> return self . view . substr ( sublime . Region ( <NUM_LIT:0> , self . view . size ( ) ) ) <EOL> def init_client ( self ) : <EOL> self . _client = Elasticsearch ( <EOL> self . settings . base_url , <EOL> send_get_body_as = '<STR_LIT:POST>' , <EOL> connection_class = CustomHeadersConnection , <EOL> headers = self . settings . headers <EOL> ) <EOL> return self . _client <EOL> def save_settings ( self ) : <EOL> self . settings . save ( ) <EOL> self . init_client ( ) <EOL> @ property <EOL> def client ( self ) : <EOL> return self . init_client ( ) <EOL> def track_command ( self ) : <EOL> if self . settings . analytics : <EOL> user_id = self . settings . user_id <EOL> if not user_id : <EOL> user_id = str ( uuid . uuid4 ( ) ) <EOL> self . settings . set ( "<STR_LIT>" , user_id ) <EOL> self . settings . save ( ) <EOL> track_activate ( user_id ) <EOL> track_command ( user_id , self . command_name ) <EOL> def show_input_panel ( self , label , default , callback ) : <EOL> self . window . show_input_panel ( label , default , callback , None , None ) <EOL> def show_response ( self , response , title = "<STR_LIT>" ) : <EOL> title = title or self . command_name <EOL> text = json . dumps ( response , indent = <NUM_LIT:2> , ensure_ascii = False ) <EOL> self . window . run_command ( <EOL> "<STR_LIT>" , { "<STR_LIT:title>" : title , "<STR_LIT:text>" : text } ) <EOL> def show_index_list_panel ( self , callback ) : <EOL> list_panel = IndexListPanel ( <EOL> self . window , self . client , self . settings . index ) <EOL> list_panel . show ( callback ) <EOL> def show_doc_type_list_panel ( self , callback ) : <EOL> list_panel = DocTypeListPanel ( <EOL> self . window , self . client , self . settings . index ) <EOL> list_panel . show ( callback ) <EOL> def show_analyzer_list_panel ( self , callback ) : <EOL> list_panel = AnalyzerListPanel ( <EOL> self . window , self . client , self . settings . index ) <EOL> list_panel . show ( callback ) <EOL> def show_switch_server_list_panel ( self , callback ) : <EOL> list_panel = SwitchServerListPanel ( self . window , self . settings . servers ) <EOL> list_panel . show ( callback ) <EOL> def show_script_list_panel ( self , callback ) : <EOL> list_panel = ScriptListPanel ( self . window , self . client ) <EOL> list_panel . show ( callback ) <EOL> def show_search_template_list_panel ( self , callback ) : <EOL> list_panel = SearchTemplateListPanel ( self . window , self . client ) <EOL> list_panel . show ( callback ) <EOL> def show_alias_list_panel ( self , callback ) : <EOL> list_panel = AliasListPanel ( <EOL> self . window , self . client , self . settings . index ) <EOL> list_panel . show ( callback ) <EOL> def show_index_template_list_panel ( self , callback ) : <EOL> list_panel = IndexTemplateListPanel ( self . window , self . client ) <EOL> list_panel . show ( callback ) <EOL> def show_warmer_list_panel ( self , callback ) : <EOL> list_panel = WarmerListPanel ( <EOL> self . window , self . client , self . settings . index ) <EOL> list_panel . show ( callback ) <EOL> def show_field_list_panel ( self , callback ) : <EOL> list_panel = FieldListPanel ( <EOL> self . window , self . client , <EOL> self . settings . index , self . settings . doc_type ) <EOL> list_panel . show ( callback ) <EOL> def show_repository_list_panel ( self , callback ) : <EOL> list_panel = RepositoryListPanel ( self . window , self . client ) <EOL> list_panel . show ( callback ) <EOL> def show_snapshot_list_panel ( self , repository , callback ) : <EOL> list_panel = SnapshotListPanel ( self . window , self . client , repository ) <EOL> list_panel . show ( callback ) <EOL> def show_output_panel ( self , text , syntax = None ) : <EOL> self . window . run_command ( <EOL> "<STR_LIT>" , { "<STR_LIT:text>" : text , "<STR_LIT>" : syntax } ) <EOL> def show_object_output_panel ( self , obj ) : <EOL> options = dict ( <EOL> indent = <NUM_LIT:4> , <EOL> ensure_ascii = False <EOL> ) <EOL> self . show_output_panel ( <EOL> json . dumps ( obj , ** options ) , <EOL> syntax = "<STR_LIT>" ) <EOL> def show_active_server ( self ) : <EOL> self . window . run_command ( "<STR_LIT>" ) <EOL> @ abstractmethod <EOL> def run_request ( self , * args , ** kwargs ) : <EOL> raise NotImplementedError ( ) <EOL> def run_request_wrapper ( self , * args , ** kwargs ) : <EOL> try : <EOL> response = self . run_request ( * args , ** kwargs ) <EOL> except Exception as e : <EOL> sublime . error_message ( "<STR_LIT>" . format ( e ) ) <EOL> return <EOL> if response is not None : <EOL> self . show_response ( response ) <EOL> self . track_command ( ) <EOL> def request_thread ( self , * args , ** kwargs ) : <EOL> thread = threading . Thread ( <EOL> target = self . run_request_wrapper , args = args , kwargs = kwargs ) <EOL> thread . start ( ) <EOL> def run ( self , * args , ** kwargs ) : <EOL> self . request_thread ( * args , ** kwargs ) <EOL> class CreateBaseCommand ( BaseCommand ) : <EOL> def run_request_wrapper ( self , * args , ** kwargs ) : <EOL> try : <EOL> response = self . run_request ( * args , ** kwargs ) <EOL> except Exception as e : <EOL> sublime . error_message ( "<STR_LIT>" . format ( e ) ) <EOL> return <EOL> if response is not None : <EOL> self . show_object_output_panel ( response ) <EOL> self . track_command ( ) <EOL> class DeleteBaseCommand ( CreateBaseCommand ) : <EOL> pass <EOL> class CatBaseCommand ( CreateBaseCommand ) : <EOL> def is_enabled ( self ) : <EOL> return True <EOL> def run_request_wrapper ( self , * args , ** kwargs ) : <EOL> try : <EOL> response = self . run_request ( * args , ** kwargs ) <EOL> except Exception as e : <EOL> sublime . error_message ( "<STR_LIT>" . format ( e ) ) <EOL> return <EOL> if response is not None : <EOL> self . show_output_panel ( response ) <EOL> self . track_command ( ) <EOL> class SearchBaseCommand ( BaseCommand ) : <EOL> def extend_options ( self , options , search_type = None ) : <EOL> if search_type : <EOL> self . command_name = "<STR_LIT>" . format ( <EOL> base = self . command_name , <EOL> search_type = search_type . lower ( ) <EOL> ) <EOL> if search_type == "<STR_LIT>" : <EOL> options [ "<STR_LIT>" ] = dict ( <EOL> search_type = search_type , <EOL> scroll = self . settings . scroll_size <EOL> ) <EOL> elif search_type is not None : <EOL> options [ "<STR_LIT>" ] = dict ( <EOL> search_type = search_type <EOL> ) <EOL> return options <EOL> class SettingsBaseCommand ( BaseCommand ) : <EOL> def is_enabled ( self ) : <EOL> return True </s>
<s> import sublime <EOL> from . base import DeleteBaseCommand <EOL> class DeleteDocumentCommand ( DeleteBaseCommand ) : <EOL> command_name = "<STR_LIT>" <EOL> def is_enabled ( self ) : <EOL> return True <EOL> def run_request ( self , id = None ) : <EOL> if not id : <EOL> self . show_input_panel ( '<STR_LIT>' , '<STR_LIT>' , self . run ) <EOL> return <EOL> options = dict ( <EOL> index = self . settings . index , <EOL> doc_type = self . settings . doc_type , <EOL> id = id <EOL> ) <EOL> if sublime . ok_cancel_dialog ( "<STR_LIT>" , ok_title = '<STR_LIT>' ) : <EOL> return self . client . delete ( ** options ) </s>
<s> import sublime <EOL> from . base import DeleteBaseCommand <EOL> class IndicesDeleteAliasCommand ( DeleteBaseCommand ) : <EOL> command_name = "<STR_LIT>" <EOL> def is_enabled ( self ) : <EOL> return True <EOL> def run_request ( self , index = None , name = None ) : <EOL> if not index or not name : <EOL> self . show_alias_list_panel ( self . run ) <EOL> return <EOL> options = dict ( <EOL> index = index , <EOL> name = name <EOL> ) <EOL> if sublime . ok_cancel_dialog ( "<STR_LIT>" , ok_title = '<STR_LIT>' ) : <EOL> return self . client . indices . delete_alias ( ** options ) </s>
<s> from . base import BaseCommand <EOL> class IndicesStatsCommand ( BaseCommand ) : <EOL> command_name = "<STR_LIT>" <EOL> def is_enabled ( self ) : <EOL> return True <EOL> def run_request ( self , index = None ) : <EOL> if index is None : <EOL> self . show_index_list_panel ( self . run ) <EOL> return <EOL> options = dict ( <EOL> index = index , <EOL> params = dict ( human = True ) <EOL> ) <EOL> return self . client . indices . stats ( ** options ) </s>
<s> import sublime_plugin <EOL> class ShowOutputPanelCommand ( sublime_plugin . WindowCommand ) : <EOL> default_syntax = "<STR_LIT>" <EOL> def run ( self , text , syntax = None ) : <EOL> if syntax is None : <EOL> syntax = self . default_syntax <EOL> panel = self . window . create_output_panel ( "<STR_LIT>" ) <EOL> self . window . run_command ( <EOL> "<STR_LIT>" , { "<STR_LIT>" : "<STR_LIT>" } ) <EOL> panel . set_syntax_file ( syntax ) <EOL> panel . settings ( ) . set ( '<STR_LIT>' , True ) <EOL> panel . settings ( ) . set ( '<STR_LIT>' , False ) <EOL> panel . set_read_only ( False ) <EOL> panel . run_command ( '<STR_LIT>' , { '<STR_LIT>' : text } ) <EOL> panel . set_read_only ( True ) </s>
<s> """<STR_LIT>""" <EOL> import datetime <EOL> __all__ = [ "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ] <EOL> EASTER_JULIAN = <NUM_LIT:1> <EOL> EASTER_ORTHODOX = <NUM_LIT:2> <EOL> EASTER_WESTERN = <NUM_LIT:3> <EOL> def easter ( year , method = EASTER_WESTERN ) : <EOL> """<STR_LIT>""" <EOL> if not ( <NUM_LIT:1> <= method <= <NUM_LIT:3> ) : <EOL> raise ValueError ( "<STR_LIT>" ) <EOL> y = year <EOL> g = y % <NUM_LIT> <EOL> e = <NUM_LIT:0> <EOL> if method < <NUM_LIT:3> : <EOL> i = ( <NUM_LIT> * g + <NUM_LIT:15> ) % <NUM_LIT:30> <EOL> j = ( y + y // <NUM_LIT:4> + i ) % <NUM_LIT:7> <EOL> if method == <NUM_LIT:2> : <EOL> e = <NUM_LIT:10> <EOL> if y > <NUM_LIT> : <EOL> e = e + y // <NUM_LIT:100> - <NUM_LIT:16> - ( y // <NUM_LIT:100> - <NUM_LIT:16> ) // <NUM_LIT:4> <EOL> else : <EOL> c = y // <NUM_LIT:100> <EOL> h = ( c - c // <NUM_LIT:4> - ( <NUM_LIT:8> * c + <NUM_LIT> ) // <NUM_LIT> + <NUM_LIT> * g + <NUM_LIT:15> ) % <NUM_LIT:30> <EOL> i = h - ( h // <NUM_LIT> ) * ( <NUM_LIT:1> - ( h // <NUM_LIT> ) * ( <NUM_LIT> // ( h + <NUM_LIT:1> ) ) * ( ( <NUM_LIT> - g ) // <NUM_LIT:11> ) ) <EOL> j = ( y + y // <NUM_LIT:4> + i + <NUM_LIT:2> - c + c // <NUM_LIT:4> ) % <NUM_LIT:7> <EOL> p = i - j + e <EOL> d = <NUM_LIT:1> + ( p + <NUM_LIT> + ( p + <NUM_LIT:6> ) // <NUM_LIT> ) % <NUM_LIT> <EOL> m = <NUM_LIT:3> + ( p + <NUM_LIT> ) // <NUM_LIT:30> <EOL> return datetime . date ( int ( y ) , int ( m ) , int ( d ) ) </s>
<s> __all__ = [ <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' <EOL> ] <EOL> class ImproperlyConfigured ( Exception ) : <EOL> """<STR_LIT>""" <EOL> class ElasticsearchException ( Exception ) : <EOL> """<STR_LIT>""" <EOL> class SerializationError ( ElasticsearchException ) : <EOL> """<STR_LIT>""" <EOL> class TransportError ( ElasticsearchException ) : <EOL> """<STR_LIT>""" <EOL> @ property <EOL> def status_code ( self ) : <EOL> """<STR_LIT>""" <EOL> return self . args [ <NUM_LIT:0> ] <EOL> @ property <EOL> def error ( self ) : <EOL> """<STR_LIT>""" <EOL> return self . args [ <NUM_LIT:1> ] <EOL> @ property <EOL> def info ( self ) : <EOL> """<STR_LIT>""" <EOL> return self . args [ <NUM_LIT:2> ] <EOL> def __str__ ( self ) : <EOL> return '<STR_LIT>' % ( self . status_code , self . error ) <EOL> class ConnectionError ( TransportError ) : <EOL> """<STR_LIT>""" <EOL> def __str__ ( self ) : <EOL> return '<STR_LIT>' % ( <EOL> self . error , self . info . __class__ . __name__ , self . info ) <EOL> class SSLError ( ConnectionError ) : <EOL> """<STR_LIT>""" <EOL> class ConnectionTimeout ( ConnectionError ) : <EOL> """<STR_LIT>""" <EOL> def __str__ ( self ) : <EOL> return '<STR_LIT>' % ( <EOL> self . info . __class__ . __name__ , self . info ) <EOL> class NotFoundError ( TransportError ) : <EOL> """<STR_LIT>""" <EOL> class ConflictError ( TransportError ) : <EOL> """<STR_LIT>""" <EOL> class RequestError ( TransportError ) : <EOL> """<STR_LIT>""" <EOL> class AuthenticationException ( TransportError ) : <EOL> """<STR_LIT>""" <EOL> class AuthorizationException ( TransportError ) : <EOL> """<STR_LIT>""" <EOL> HTTP_EXCEPTIONS = { <EOL> <NUM_LIT> : RequestError , <EOL> <NUM_LIT> : AuthenticationException , <EOL> <NUM_LIT> : AuthorizationException , <EOL> <NUM_LIT> : NotFoundError , <EOL> <NUM_LIT> : ConflictError , <EOL> } </s>
<s> from . alias_list_panel import AliasListPanel <EOL> from . analyzer_list_panel import AnalyzerListPanel <EOL> from . doc_type_list_panel import DocTypeListPanel <EOL> from . field_list_panel import FieldListPanel <EOL> from . index_list_panel import IndexListPanel <EOL> from . index_template_list_panel import IndexTemplateListPanel <EOL> from . repository_list_panel import RepositoryListPanel <EOL> from . script_list_panel import ScriptListPanel <EOL> from . search_template_list_panel import SearchTemplateListPanel <EOL> from . snapshot_list_panel import SnapshotListPanel <EOL> from . switch_server_list_panel import SwitchServerListPanel <EOL> from . warmer_list_panel import WarmerListPanel <EOL> __all__ = [ <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> ] </s>
<s> import unittest <EOL> from test . asserting . policy import PolicyAssertion , get_fixture_path <EOL> from vint . linting . level import Level <EOL> from vint . linting . policy . prohibit_command_with_unintended_side_effect import ProhibitCommandWithUnintendedSideEffect <EOL> PATH_VALID_VIM_SCRIPT = get_fixture_path ( '<STR_LIT>' ) <EOL> PATH_INVALID_VIM_SCRIPT = get_fixture_path ( '<STR_LIT>' ) <EOL> class TestProhibitCommandWithUnintendedSideEffect ( PolicyAssertion , unittest . TestCase ) : <EOL> def _create_violation_by_line_number ( self , line_number ) : <EOL> return { <EOL> '<STR_LIT:name>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : Level . WARNING , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : line_number , <EOL> '<STR_LIT>' : <NUM_LIT:1> , <EOL> '<STR_LIT:path>' : PATH_INVALID_VIM_SCRIPT <EOL> } <EOL> } <EOL> def test_get_violation_if_found_with_valid_file ( self ) : <EOL> self . assertFoundNoViolations ( PATH_VALID_VIM_SCRIPT , <EOL> ProhibitCommandWithUnintendedSideEffect ) <EOL> def test_get_violation_if_found_with_invalid_file ( self ) : <EOL> expected_violations = [ self . _create_violation_by_line_number ( line_number ) <EOL> for line_number in range ( <NUM_LIT:1> , <NUM_LIT> ) ] <EOL> expected_violations [ <NUM_LIT:3> ] [ '<STR_LIT>' ] [ '<STR_LIT>' ] = <NUM_LIT:2> <EOL> expected_violations [ <NUM_LIT:4> ] [ '<STR_LIT>' ] [ '<STR_LIT>' ] = <NUM_LIT:6> <EOL> self . assertFoundViolationsEqual ( PATH_INVALID_VIM_SCRIPT , <EOL> ProhibitCommandWithUnintendedSideEffect , <EOL> expected_violations ) <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL> unittest . main ( ) </s>
<s> import unittest <EOL> from test . asserting . config_source import ConfigSourceAssertion <EOL> from test . asserting . config_source import get_fixture_path <EOL> from vint . linting . config . config_file_source import ConfigFileSource <EOL> from vint . linting . level import Level <EOL> FIXTURE_CONFIG_FILE = get_fixture_path ( '<STR_LIT>' ) <EOL> class TestConfigFileSource ( ConfigSourceAssertion , unittest . TestCase ) : <EOL> class ConcreteConfigFileSource ( ConfigFileSource ) : <EOL> def get_file_path ( self , env ) : <EOL> return FIXTURE_CONFIG_FILE <EOL> def test_get_config_dict ( self ) : <EOL> expected_config_dict = { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : True , <EOL> '<STR_LIT>' : Level . WARNING , <EOL> '<STR_LIT>' : <NUM_LIT:10> , <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : False , <EOL> } , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : True , <EOL> } , <EOL> } <EOL> } <EOL> config_source = self . initialize_config_source_with_env ( <EOL> TestConfigFileSource . ConcreteConfigFileSource ) <EOL> self . assertConfigDict ( config_source , expected_config_dict ) <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL> unittest . main ( ) </s>
<s> from vint . ast . plugin . scope_plugin . scope_detector import ( <EOL> detect_scope_visibility , <EOL> normalize_variable_name , <EOL> is_builtin_variable , <EOL> ) <EOL> from vint . ast . plugin . scope_plugin . scope_linker import ScopeLinker <EOL> from vint . ast . plugin . scope_plugin . identifier_classifier import ( <EOL> IdentifierClassifier , <EOL> is_function_identifier , <EOL> ) <EOL> REACHABILITY_FLAG = '<STR_LIT>' <EOL> REFERECED_FLAG = '<STR_LIT>' <EOL> class ReferenceReachabilityTester ( object ) : <EOL> """<STR_LIT>""" <EOL> class TwoWayScopeReferenceAttacher ( object ) : <EOL> """<STR_LIT>""" <EOL> @ classmethod <EOL> def attach ( cls , root_scope_tree ) : <EOL> root_scope_tree [ '<STR_LIT>' ] = None <EOL> return cls . _attach_recursively ( root_scope_tree ) <EOL> @ classmethod <EOL> def _attach_recursively ( cls , scope_tree ) : <EOL> for child_scope in scope_tree [ '<STR_LIT>' ] : <EOL> child_scope [ '<STR_LIT>' ] = scope_tree <EOL> cls . _attach_recursively ( child_scope ) <EOL> return scope_tree <EOL> def process ( self , ast ) : <EOL> scope_linker = ScopeLinker ( ) <EOL> scope_linker . process ( ast ) <EOL> id_collector = IdentifierClassifier . IdentifierCollector ( ) <EOL> classified_id_group = id_collector . collect_identifiers ( ast ) <EOL> dec_id_nodes = classified_id_group [ '<STR_LIT>' ] <EOL> ref_id_nodes = classified_id_group [ '<STR_LIT>' ] <EOL> self . _scope_tree = scope_linker . scope_tree <EOL> self . _link_registry = scope_linker . link_registry <EOL> ReferenceReachabilityTester . TwoWayScopeReferenceAttacher . attach ( self . _scope_tree ) <EOL> for dec_id_node in dec_id_nodes : <EOL> dec_id_node [ REFERECED_FLAG ] = False <EOL> for ref_id_node in ref_id_nodes : <EOL> is_reachable = self . check_reachability ( ref_id_node ) <EOL> ref_id_node [ REACHABILITY_FLAG ] = is_reachable <EOL> def get_objective_scope_visibility ( self , node ) : <EOL> """<STR_LIT>""" <EOL> context_scope = self . _link_registry . get_scope_by_referencing_identifier ( node ) <EOL> return detect_scope_visibility ( node , context_scope ) [ '<STR_LIT>' ] <EOL> def _reset_referenced_flag ( self , scope_tree ) : <EOL> for child_scope in scope_tree [ '<STR_LIT>' ] : <EOL> for functions in child_scope [ '<STR_LIT>' ] . values ( ) : <EOL> for function in functions : <EOL> function [ REFERECED_FLAG ] = False <EOL> for variables in child_scope [ '<STR_LIT>' ] . values ( ) : <EOL> for variable in variables : <EOL> variable [ REFERECED_FLAG ] = False <EOL> self . _reset_referenced_flag ( child_scope ) <EOL> def check_reachability ( self , ref_id_node ) : <EOL> scope = self . _link_registry . get_context_scope_by_identifier ( ref_id_node ) <EOL> var_name = normalize_variable_name ( ref_id_node , scope ) <EOL> is_func_id = is_function_identifier ( ref_id_node ) <EOL> while scope is not None : <EOL> if is_func_id : <EOL> functions_list = scope [ '<STR_LIT>' ] <EOL> if var_name in functions_list : <EOL> for variable in functions_list [ var_name ] : <EOL> declaring_id_node = self . _link_registry . get_declarative_identifier_by_variable ( variable ) <EOL> declaring_id_node [ REFERECED_FLAG ] = True <EOL> return True <EOL> else : <EOL> pass <EOL> variables_list = scope [ '<STR_LIT>' ] <EOL> if var_name in variables_list : <EOL> for variable in variables_list [ var_name ] : <EOL> declaring_id_node = self . _link_registry . get_declarative_identifier_by_variable ( variable ) <EOL> declaring_id_node [ REFERECED_FLAG ] = True <EOL> return True <EOL> scope = scope [ '<STR_LIT>' ] <EOL> return is_builtin_variable ( ref_id_node ) <EOL> def is_reference_identifier ( node ) : <EOL> return REACHABILITY_FLAG in node <EOL> def is_reachable_reference_identifier ( node ) : <EOL> return node . get ( REACHABILITY_FLAG , False ) <EOL> def is_declarative_identifier ( node ) : <EOL> return REFERECED_FLAG in node <EOL> def is_referenced_declarative_identifier ( node ) : <EOL> return node . get ( REFERECED_FLAG , False ) </s>
<s> import re <EOL> from vint . ast . node_type import NodeType <EOL> from vint . linting . level import Level <EOL> from vint . linting . policy . abstract_policy import AbstractPolicy <EOL> from vint . linting . policy_registry import register_policy <EOL> from vint . ast . dictionary . abbreviations import ( <EOL> Abbreviations , <EOL> AbbreviationsIncludingInvertPrefix , <EOL> ) <EOL> SetCommandFamily = { <EOL> '<STR_LIT>' : True , <EOL> '<STR_LIT>' : True , <EOL> '<STR_LIT>' : True , <EOL> } <EOL> @ register_policy <EOL> class ProhibitAbbreviationOption ( AbstractPolicy ) : <EOL> def __init__ ( self ) : <EOL> super ( ProhibitAbbreviationOption , self ) . __init__ ( ) <EOL> self . description = '<STR_LIT>' <EOL> self . reference = '<STR_LIT>' <EOL> self . level = Level . STYLE_PROBLEM <EOL> self . was_scriptencoding_found = False <EOL> self . has_encoding_opt_after_scriptencoding = False <EOL> def listen_node_types ( self ) : <EOL> return [ NodeType . EXCMD , NodeType . OPTION ] <EOL> def is_valid ( self , node , lint_context ) : <EOL> """<STR_LIT>""" <EOL> node_type = NodeType ( node [ '<STR_LIT:type>' ] ) <EOL> if node_type is NodeType . OPTION : <EOL> option_name = node [ '<STR_LIT:value>' ] [ <NUM_LIT:1> : ] <EOL> is_valid = option_name not in Abbreviations <EOL> if not is_valid : <EOL> self . _make_description_by_option_name ( option_name ) <EOL> return is_valid <EOL> excmd_node = node <EOL> is_set_cmd = excmd_node [ '<STR_LIT>' ] [ '<STR_LIT>' ] . get ( '<STR_LIT:name>' ) in SetCommandFamily <EOL> if not is_set_cmd : <EOL> return True <EOL> option_expr = excmd_node [ '<STR_LIT:str>' ] . split ( ) [ <NUM_LIT:1> ] <EOL> option_name = re . match ( r'<STR_LIT>' , option_expr ) . group ( <NUM_LIT:0> ) <EOL> is_valid = option_name not in AbbreviationsIncludingInvertPrefix <EOL> if not is_valid : <EOL> self . _make_description_by_option_name ( option_name ) <EOL> return is_valid <EOL> def _make_description_by_option_name ( self , option_name ) : <EOL> param = { <EOL> '<STR_LIT>' : AbbreviationsIncludingInvertPrefix [ option_name ] , <EOL> '<STR_LIT>' : option_name , <EOL> } <EOL> self . description = ( '<STR_LIT>' <EOL> '<STR_LIT>' . format ( ** param ) ) </s>
<s> from serfclient import result <EOL> class TestSerfResult ( object ) : <EOL> def test_initialises_to_none ( self ) : <EOL> r = result . SerfResult ( ) <EOL> assert r . head is None <EOL> assert r . body is None <EOL> def test_provides_a_pretty_printed_form_for_repl_use ( self ) : <EOL> r = result . SerfResult ( head = { "<STR_LIT:a>" : <NUM_LIT:1> } , body = ( '<STR_LIT:foo>' , '<STR_LIT:bar>' ) ) <EOL> assert str ( r ) == "<STR_LIT>" <EOL> def test_can_convert_to_list ( self ) : <EOL> r = result . SerfResult ( head = <NUM_LIT:1> , body = <NUM_LIT:2> ) <EOL> assert sorted ( list ( r ) ) == [ <NUM_LIT:1> , <NUM_LIT:2> ] <EOL> def test_can_convert_to_tuple ( self ) : <EOL> r = result . SerfResult ( head = <NUM_LIT:1> , body = <NUM_LIT:2> ) <EOL> assert sorted ( tuple ( r ) ) == [ <NUM_LIT:1> , <NUM_LIT:2> ] </s>
<s> import os <EOL> import logging <EOL> class AttrDict ( dict ) : <EOL> """<STR_LIT>""" <EOL> def __getattr__ ( self , name ) : <EOL> if name in self : <EOL> return self [ name ] <EOL> raise AttributeError ( '<STR_LIT>' % name ) <EOL> def __setattr__ ( self , name , val ) : <EOL> self [ name ] = val <EOL> def get_logger ( name , level = None ) : <EOL> """<STR_LIT>""" <EOL> logger = logging . getLogger ( name ) <EOL> if not logger . handlers : <EOL> stderr = logging . StreamHandler ( ) <EOL> stderr . setFormatter ( logging . Formatter ( <EOL> '<STR_LIT>' ) ) <EOL> logger . addHandler ( stderr ) <EOL> level = level if level else os . environ . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> logger . setLevel ( getattr ( logging , level ) ) <EOL> return logger </s>
<s> from hacksport . problem import Challenge <EOL> class Problem ( Challenge ) : <EOL> def setup ( self ) : <EOL> self . flag = '<STR_LIT>' </s>
<s> """<STR_LIT>""" <EOL> from math import * <EOL> def AirDensity ( RH , Tc , P = <NUM_LIT> ) : <EOL> Rd = <NUM_LIT> <EOL> q = <NUM_LIT> * ( RH * SatVapor ( Tc ) ) / P <EOL> Tv = ( Tc + <NUM_LIT> ) * ( <NUM_LIT:1.0> + <NUM_LIT> * q ) <EOL> P *= <NUM_LIT> <EOL> rho_a = P / ( Rd * Tv ) <EOL> return rho_a <EOL> def PsychConst ( P , cP = <NUM_LIT> , lambda_v = <NUM_LIT> ) : <EOL> gamma = ( cP * P / ( <NUM_LIT> * lambda_v ) ) <EOL> return gamma <EOL> def SatVaporPress ( Tc ) : <EOL> eSat = <NUM_LIT> * exp ( <NUM_LIT> * Tc / ( <NUM_LIT> + Tc ) ) <EOL> return eSat <EOL> def SlopeSatVaporPress ( Tc ) : <EOL> delta = <NUM_LIT> * SatVaporPress ( Tc ) / ( <NUM_LIT> + Tc ) ** <NUM_LIT:2> <EOL> return delta <EOL> def AeroReist ( um , zm , z0 , d , zmp = zm ) : <EOL> k = <NUM_LIT> <EOL> r_a = <NUM_LIT:1.0> / ( k ** <NUM_LIT:2> * um ) * log ( ( zm - d ) / z0 ) * log ( ( zmp - d ) / ( z0 / <NUM_LIT> ) ) <EOL> return r_a <EOL> def SurfResist ( g0 , S , D , Tc , SM , SM0 ) : <EOL> g_c = Gee_C ( ) <EOL> g_R = Gee_R ( S ) <EOL> g_D = Gee_D ( D ) <EOL> g_T = Gee_T ( Tc + <NUM_LIT> ) <EOL> g_M = Gee_M ( SM , SM0 ) <EOL> g_s = g0 * g_c * g_R * g_D * g_T * g_M <EOL> r_s = <NUM_LIT:1.0> / g_s <EOL> return r_s <EOL> def Gee_c ( ) : <EOL> g_c = <NUM_LIT:1.0> <EOL> return g_c <EOL> def Gee_R ( S , K_R = <NUM_LIT> ) : <EOL> g_R = ( S * ( <NUM_LIT> + K_R ) ) / ( <NUM_LIT> * ( S + K_R ) ) <EOL> return g_R <EOL> def Gee_D ( D , K_D1 = - <NUM_LIT> , K_D2 = <NUM_LIT> ) : <EOL> g_D = <NUM_LIT:1.0> + K_D1 * D + K_D2 * D ** <NUM_LIT:2> <EOL> return g_D <EOL> def Gee_T ( TK , TL = <NUM_LIT> , TH = <NUM_LIT> , T0 = <NUM_LIT> ) : <EOL> alpha_T = ( TH - T0 ) / ( T0 - TL ) <EOL> g_T = ( ( TK - TL ) * ( TH - TK ) ** alpha_T ) / ( ( T0 - TL ) * ( TH - T0 ) ** alpha_T ) <EOL> return g_T <EOL> def Gee_M ( SM , SM0 , K_M1 , K_M2 ) : <EOL> g_SM = <NUM_LIT:1.0> - K_M1 * exp ( K_M2 * ( SM - SM0 ) ) <EOL> return g_SM <EOL> def PenmanMonteithPET ( Tc , RH , Rn , S , SM , um , z0 , d , g0 , SM0 , P = <NUM_LIT> , zm = <NUM_LIT> ) : <EOL> cP = <NUM_LIT> <EOL> rho_a = AirDensity ( RH , Tc , P ) <EOL> D = ( <NUM_LIT:1.0> - RH ) * SatVaporPress ( Tc ) <EOL> delta = SlopeSatVaporPress ( Tc ) <EOL> gamma = PsychConst ( P ) <EOL> r_a = AeroReist ( um , zm , z0 , d ) <EOL> r_s = SurfResist ( g0 , S , D , Tc , SM , SM0 ) <EOL> LE = ( delta * Rn + ( rho_a * cP * D ) / r_a ) / ( delta + gamma * ( <NUM_LIT:1.0> + r_s / r_a ) ) <EOL> return LE </s>
<s> """<STR_LIT>""" <EOL> from contextlib import contextmanager <EOL> from OpenGL . GL import * <EOL> @ contextmanager <EOL> def glSection ( type ) : <EOL> glBegin ( type ) <EOL> yield <EOL> glEnd ( ) <EOL> @ contextmanager <EOL> def glMatrix ( ) : <EOL> glPushMatrix ( ) <EOL> yield <EOL> glPopMatrix ( ) <EOL> @ contextmanager <EOL> def glModeMatrix ( type ) : <EOL> glMatrixMode ( type ) <EOL> glPushMatrix ( ) <EOL> yield <EOL> glMatrixMode ( type ) <EOL> glPopMatrix ( ) <EOL> @ contextmanager <EOL> def attributes ( * glBits ) : <EOL> for bit in glBits : <EOL> glPushAttrib ( bit ) <EOL> yield <EOL> for bit in glBits : <EOL> glPopAttrib ( ) <EOL> @ contextmanager <EOL> def enabled ( * glBits ) : <EOL> for bit in glBits : <EOL> glEnable ( bit ) <EOL> yield <EOL> for bit in glBits : <EOL> glDisable ( bit ) <EOL> @ contextmanager <EOL> def disabled ( * glBits ) : <EOL> for bit in glBits : <EOL> glDisable ( bit ) <EOL> yield <EOL> for bit in glBits : <EOL> glEnable ( bit ) <EOL> @ contextmanager <EOL> def overlays2D ( width , height , background_color ) : <EOL> """<STR_LIT>""" <EOL> glDisable ( GL_LIGHTING ) <EOL> glDisable ( GL_LIGHT0 ) <EOL> glDisable ( GL_BLEND ) <EOL> glEnable ( GL_SCISSOR_TEST ) <EOL> with glModeMatrix ( GL_PROJECTION ) : <EOL> yield <EOL> glViewport ( <NUM_LIT:0> , <NUM_LIT:0> , width , height ) <EOL> glDisable ( GL_SCISSOR_TEST ) <EOL> glMatrixMode ( GL_MODELVIEW ) <EOL> glLoadIdentity ( ) <EOL> glEnable ( GL_LIGHTING ) <EOL> glEnable ( GL_LIGHT0 ) <EOL> glEnable ( GL_BLEND ) <EOL> glClearColor ( * background_color ) <EOL> def setup_overlay2D ( x , y , width , height ) : <EOL> """<STR_LIT>""" <EOL> glMatrixMode ( GL_PROJECTION ) <EOL> glLoadIdentity ( ) <EOL> glScissor ( x , y , width , height ) <EOL> glViewport ( x , y , width , height ) <EOL> glOrtho ( x , x + width , y , y + height , - <NUM_LIT:1> , <NUM_LIT:1> ) <EOL> glMatrixMode ( GL_MODELVIEW ) <EOL> cyltrigs = [ <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ] ; <EOL> def notGlePolyCylinder ( points , color , radius ) : <EOL> trigs = [ radius * x for x in cyltrigs ] ; <EOL> if abs ( points [ <NUM_LIT:1> ] [ <NUM_LIT:0> ] - points [ <NUM_LIT:2> ] [ <NUM_LIT:0> ] ) > <NUM_LIT> : <EOL> with glSection ( GL_QUAD_STRIP ) : <EOL> glNormal3f ( <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:1.> ) <EOL> glVertex ( points [ <NUM_LIT:1> ] [ <NUM_LIT:0> ] , <NUM_LIT:0> , radius ) <EOL> glVertex ( points [ <NUM_LIT:2> ] [ <NUM_LIT:0> ] , <NUM_LIT:0> , radius ) <EOL> glNormal3f ( <NUM_LIT:0> , cyltrigs [ <NUM_LIT:0> ] , cyltrigs [ <NUM_LIT:1> ] ) <EOL> glVertex ( points [ <NUM_LIT:1> ] [ <NUM_LIT:0> ] , trigs [ <NUM_LIT:0> ] , trigs [ <NUM_LIT:1> ] ) <EOL> glVertex ( points [ <NUM_LIT:2> ] [ <NUM_LIT:0> ] , trigs [ <NUM_LIT:0> ] , trigs [ <NUM_LIT:1> ] ) <EOL> glNormal3f ( <NUM_LIT:0> , cyltrigs [ <NUM_LIT:2> ] , cyltrigs [ <NUM_LIT:3> ] ) <EOL> glVertex ( points [ <NUM_LIT:1> ] [ <NUM_LIT:0> ] , trigs [ <NUM_LIT:2> ] , trigs [ <NUM_LIT:3> ] ) <EOL> glVertex ( points [ <NUM_LIT:2> ] [ <NUM_LIT:0> ] , trigs [ <NUM_LIT:2> ] , trigs [ <NUM_LIT:3> ] ) <EOL> glNormal3f ( <NUM_LIT:0> , cyltrigs [ <NUM_LIT:2> ] , - cyltrigs [ <NUM_LIT:3> ] ) <EOL> glVertex ( points [ <NUM_LIT:1> ] [ <NUM_LIT:0> ] , trigs [ <NUM_LIT:2> ] , - trigs [ <NUM_LIT:3> ] ) <EOL> glVertex ( points [ <NUM_LIT:2> ] [ <NUM_LIT:0> ] , trigs [ <NUM_LIT:2> ] , - trigs [ <NUM_LIT:3> ] ) <EOL> glNormal3f ( <NUM_LIT:0> , cyltrigs [ <NUM_LIT:0> ] , - cyltrigs [ <NUM_LIT:1> ] ) <EOL> glVertex ( points [ <NUM_LIT:1> ] [ <NUM_LIT:0> ] , trigs [ <NUM_LIT:0> ] , - trigs [ <NUM_LIT:1> ] ) <EOL> glVertex ( points [ <NUM_LIT:2> ] [ <NUM_LIT:0> ] , trigs [ <NUM_LIT:0> ] , - trigs [ <NUM_LIT:1> ] ) <EOL> glNormal3f ( <NUM_LIT:0> , <NUM_LIT:0> , - <NUM_LIT:1.> ) <EOL> glVertex ( points [ <NUM_LIT:1> ] [ <NUM_LIT:0> ] , <NUM_LIT:0> , - radius ) <EOL> glVertex ( points [ <NUM_LIT:2> ] [ <NUM_LIT:0> ] , <NUM_LIT:0> , - radius ) <EOL> glNormal3f ( <NUM_LIT:0> , - cyltrigs [ <NUM_LIT:0> ] , - cyltrigs [ <NUM_LIT:1> ] ) <EOL> glVertex ( points [ <NUM_LIT:1> ] [ <NUM_LIT:0> ] , - trigs [ <NUM_LIT:0> ] , - trigs [ <NUM_LIT:1> ] ) <EOL> glVertex ( points [ <NUM_LIT:2> ] [ <NUM_LIT:0> ] , - trigs [ <NUM_LIT:0> ] , - trigs [ <NUM_LIT:1> ] ) <EOL> glNormal3f ( <NUM_LIT:0> , - cyltrigs [ <NUM_LIT:2> ] , - cyltrigs [ <NUM_LIT:3> ] ) <EOL> glVertex ( points [ <NUM_LIT:1> ] [ <NUM_LIT:0> ] , - trigs [ <NUM_LIT:2> ] , - trigs [ <NUM_LIT:3> ] ) <EOL> glVertex ( points [ <NUM_LIT:2> ] [ <NUM_LIT:0> ] , - trigs [ <NUM_LIT:2> ] , - trigs [ <NUM_LIT:3> ] ) <EOL> glNormal3f ( <NUM_LIT:0> , - cyltrigs [ <NUM_LIT:2> ] , cyltrigs [ <NUM_LIT:3> ] ) <EOL> glVertex ( points [ <NUM_LIT:1> ] [ <NUM_LIT:0> ] , - trigs [ <NUM_LIT:2> ] , trigs [ <NUM_LIT:3> ] ) <EOL> glVertex ( points [ <NUM_LIT:2> ] [ <NUM_LIT:0> ] , - trigs [ <NUM_LIT:2> ] , trigs [ <NUM_LIT:3> ] ) <EOL> glNormal3f ( <NUM_LIT:0> , - cyltrigs [ <NUM_LIT:0> ] , cyltrigs [ <NUM_LIT:1> ] ) <EOL> glVertex ( points [ <NUM_LIT:1> ] [ <NUM_LIT:0> ] , - trigs [ <NUM_LIT:0> ] , trigs [ <NUM_LIT:1> ] ) <EOL> glVertex ( points [ <NUM_LIT:2> ] [ <NUM_LIT:0> ] , - trigs [ <NUM_LIT:0> ] , trigs [ <NUM_LIT:1> ] ) <EOL> glNormal3f ( <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:1.> ) <EOL> glVertex ( points [ <NUM_LIT:1> ] [ <NUM_LIT:0> ] , <NUM_LIT:0> , radius ) <EOL> glVertex ( points [ <NUM_LIT:2> ] [ <NUM_LIT:0> ] , <NUM_LIT:0> , radius ) <EOL> elif abs ( points [ <NUM_LIT:1> ] [ <NUM_LIT:1> ] - points [ <NUM_LIT:2> ] [ <NUM_LIT:1> ] ) > <NUM_LIT> : <EOL> p1 = points [ <NUM_LIT:1> ] [ <NUM_LIT:1> ] <EOL> p2 = points [ <NUM_LIT:2> ] [ <NUM_LIT:1> ] <EOL> with glSection ( GL_QUAD_STRIP ) : <EOL> glNormal3f ( <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:1.> ) <EOL> glVertex ( <NUM_LIT:0> , p1 , radius ) <EOL> glVertex ( <NUM_LIT:0> , p2 , radius ) <EOL> glNormal3f ( cyltrigs [ <NUM_LIT:0> ] , <NUM_LIT:0> , cyltrigs [ <NUM_LIT:1> ] ) <EOL> glVertex ( trigs [ <NUM_LIT:0> ] , p1 , trigs [ <NUM_LIT:1> ] ) <EOL> glVertex ( trigs [ <NUM_LIT:0> ] , p2 , trigs [ <NUM_LIT:1> ] ) <EOL> glNormal3f ( cyltrigs [ <NUM_LIT:2> ] , <NUM_LIT:0> , cyltrigs [ <NUM_LIT:3> ] ) <EOL> glVertex ( trigs [ <NUM_LIT:2> ] , p1 , trigs [ <NUM_LIT:3> ] ) <EOL> glVertex ( trigs [ <NUM_LIT:2> ] , p2 , trigs [ <NUM_LIT:3> ] ) <EOL> glNormal3f ( cyltrigs [ <NUM_LIT:2> ] , <NUM_LIT:0> , - cyltrigs [ <NUM_LIT:3> ] ) <EOL> glVertex ( trigs [ <NUM_LIT:2> ] , p1 , - trigs [ <NUM_LIT:3> ] ) <EOL> glVertex ( trigs [ <NUM_LIT:2> ] , p2 , - trigs [ <NUM_LIT:3> ] ) <EOL> glNormal3f ( cyltrigs [ <NUM_LIT:0> ] , <NUM_LIT:0> , - cyltrigs [ <NUM_LIT:1> ] ) <EOL> glVertex ( trigs [ <NUM_LIT:0> ] , p1 , - trigs [ <NUM_LIT:1> ] ) <EOL> glVertex ( trigs [ <NUM_LIT:0> ] , p2 , - trigs [ <NUM_LIT:1> ] ) <EOL> glNormal3f ( <NUM_LIT:0> , <NUM_LIT:0> , - <NUM_LIT:1.> ) <EOL> glVertex ( <NUM_LIT:0> , p1 , - radius ) <EOL> glVertex ( <NUM_LIT:0> , p2 , - radius ) <EOL> glNormal3f ( - cyltrigs [ <NUM_LIT:0> ] , <NUM_LIT:0> , - cyltrigs [ <NUM_LIT:1> ] ) <EOL> glVertex ( - trigs [ <NUM_LIT:0> ] , p1 , - trigs [ <NUM_LIT:1> ] ) <EOL> glVertex ( - trigs [ <NUM_LIT:0> ] , p2 , - trigs [ <NUM_LIT:1> ] ) <EOL> glNormal3f ( - cyltrigs [ <NUM_LIT:2> ] , <NUM_LIT:0> , - cyltrigs [ <NUM_LIT:3> ] ) <EOL> glVertex ( - trigs [ <NUM_LIT:2> ] , p1 , - trigs [ <NUM_LIT:3> ] ) <EOL> glVertex ( - trigs [ <NUM_LIT:2> ] , p2 , - trigs [ <NUM_LIT:3> ] ) <EOL> glNormal3f ( - cyltrigs [ <NUM_LIT:2> ] , <NUM_LIT:0> , cyltrigs [ <NUM_LIT:3> ] ) <EOL> glVertex ( - trigs [ <NUM_LIT:2> ] , p1 , trigs [ <NUM_LIT:3> ] ) <EOL> glVertex ( - trigs [ <NUM_LIT:2> ] , p2 , trigs [ <NUM_LIT:3> ] ) <EOL> glNormal3f ( - cyltrigs [ <NUM_LIT:0> ] , <NUM_LIT:0> , cyltrigs [ <NUM_LIT:1> ] ) <EOL> glVertex ( - trigs [ <NUM_LIT:0> ] , p1 , trigs [ <NUM_LIT:1> ] ) <EOL> glVertex ( - trigs [ <NUM_LIT:0> ] , p2 , trigs [ <NUM_LIT:1> ] ) <EOL> glNormal3f ( <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:1.> ) <EOL> glVertex ( <NUM_LIT:0> , p1 , radius ) <EOL> glVertex ( <NUM_LIT:0> , p2 , radius ) <EOL> else : <EOL> p1 = points [ <NUM_LIT:1> ] [ <NUM_LIT:2> ] <EOL> p2 = points [ <NUM_LIT:2> ] [ <NUM_LIT:2> ] <EOL> with glSection ( GL_QUAD_STRIP ) : <EOL> glNormal3f ( <NUM_LIT:0> , <NUM_LIT:1.> , <NUM_LIT:0> ) <EOL> glVertex ( <NUM_LIT:0> , radius , p1 ) <EOL> glVertex ( <NUM_LIT:0> , radius , p2 ) <EOL> glNormal3f ( cyltrigs [ <NUM_LIT:0> ] , cyltrigs [ <NUM_LIT:1> ] , <NUM_LIT:0> ) <EOL> glVertex ( trigs [ <NUM_LIT:0> ] , trigs [ <NUM_LIT:1> ] , p1 ) <EOL> glVertex ( trigs [ <NUM_LIT:0> ] , trigs [ <NUM_LIT:1> ] , p2 ) <EOL> glNormal3f ( cyltrigs [ <NUM_LIT:2> ] , cyltrigs [ <NUM_LIT:3> ] , <NUM_LIT:0> ) <EOL> glVertex ( trigs [ <NUM_LIT:2> ] , trigs [ <NUM_LIT:3> ] , p1 ) <EOL> glVertex ( trigs [ <NUM_LIT:2> ] , trigs [ <NUM_LIT:3> ] , p2 ) <EOL> glNormal3f ( cyltrigs [ <NUM_LIT:2> ] , - cyltrigs [ <NUM_LIT:3> ] , <NUM_LIT:0> ) <EOL> glVertex ( trigs [ <NUM_LIT:2> ] , - trigs [ <NUM_LIT:3> ] , p1 ) <EOL> glVertex ( trigs [ <NUM_LIT:2> ] , - trigs [ <NUM_LIT:3> ] , p2 ) <EOL> glNormal3f ( cyltrigs [ <NUM_LIT:0> ] , - cyltrigs [ <NUM_LIT:1> ] , <NUM_LIT:0> ) <EOL> glVertex ( trigs [ <NUM_LIT:0> ] , - trigs [ <NUM_LIT:1> ] , p1 ) <EOL> glVertex ( trigs [ <NUM_LIT:0> ] , - trigs [ <NUM_LIT:1> ] , p2 ) <EOL> glNormal3f ( <NUM_LIT:0> , - <NUM_LIT:1.> , <NUM_LIT:0> ) <EOL> glVertex ( <NUM_LIT:0> , - radius , p1 ) <EOL> glVertex ( <NUM_LIT:0> , - radius , p2 ) <EOL> glNormal3f ( - cyltrigs [ <NUM_LIT:0> ] , - cyltrigs [ <NUM_LIT:1> ] , <NUM_LIT:0> ) <EOL> glVertex ( - trigs [ <NUM_LIT:0> ] , - trigs [ <NUM_LIT:1> ] , p1 ) <EOL> glVertex ( - trigs [ <NUM_LIT:0> ] , - trigs [ <NUM_LIT:1> ] , p2 ) <EOL> glNormal3f ( - cyltrigs [ <NUM_LIT:2> ] , - cyltrigs [ <NUM_LIT:3> ] , <NUM_LIT:0> ) <EOL> glVertex ( - trigs [ <NUM_LIT:2> ] , - trigs [ <NUM_LIT:3> ] , p1 ) <EOL> glVertex ( - trigs [ <NUM_LIT:2> ] , - trigs [ <NUM_LIT:3> ] , p2 ) <EOL> glNormal3f ( - cyltrigs [ <NUM_LIT:2> ] , cyltrigs [ <NUM_LIT:3> ] , <NUM_LIT:0> ) <EOL> glVertex ( - trigs [ <NUM_LIT:2> ] , trigs [ <NUM_LIT:3> ] , p1 ) <EOL> glVertex ( - trigs [ <NUM_LIT:2> ] , trigs [ <NUM_LIT:3> ] , p2 ) <EOL> glNormal3f ( - cyltrigs [ <NUM_LIT:0> ] , cyltrigs [ <NUM_LIT:1> ] , <NUM_LIT:0> ) <EOL> glVertex ( - trigs [ <NUM_LIT:0> ] , trigs [ <NUM_LIT:1> ] , p1 ) <EOL> glVertex ( - trigs [ <NUM_LIT:0> ] , trigs [ <NUM_LIT:1> ] , p2 ) <EOL> glNormal3f ( <NUM_LIT:0> , <NUM_LIT:1.> , <NUM_LIT:0> ) <EOL> glVertex ( <NUM_LIT:0> , radius , p1 ) <EOL> glVertex ( <NUM_LIT:0> , radius , p2 ) <EOL> def notGlutSolidCube ( size ) : <EOL> p = size / <NUM_LIT:2> <EOL> n = - <NUM_LIT:1> * p <EOL> with glSection ( GL_QUADS ) : <EOL> glNormal3f ( <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:1.> ) <EOL> glVertex ( n , p , n ) <EOL> glVertex ( n , n , n ) <EOL> glVertex ( p , n , n ) <EOL> glVertex ( p , p , n ) <EOL> with glSection ( GL_QUADS ) : <EOL> glNormal3f ( <NUM_LIT:0> , <NUM_LIT:1.> , <NUM_LIT:0> ) <EOL> glVertex ( n , p , p ) <EOL> glVertex ( n , p , n ) <EOL> glVertex ( p , p , n ) <EOL> glVertex ( p , p , p ) <EOL> with glSection ( GL_QUADS ) : <EOL> glNormal3f ( <NUM_LIT:1.> , <NUM_LIT:0> , <NUM_LIT:0> ) <EOL> glVertex ( p , p , n ) <EOL> glVertex ( p , n , n ) <EOL> glVertex ( p , n , p ) <EOL> glVertex ( p , p , p ) <EOL> with glSection ( GL_QUADS ) : <EOL> glNormal3f ( <NUM_LIT:0> , <NUM_LIT:0> , - <NUM_LIT:1.> ) <EOL> glVertex ( p , p , p ) <EOL> glVertex ( p , n , p ) <EOL> glVertex ( n , n , p ) <EOL> glVertex ( n , p , p ) <EOL> with glSection ( GL_QUADS ) : <EOL> glNormal3f ( <NUM_LIT:0> , - <NUM_LIT:1.> , <NUM_LIT:0> ) <EOL> glVertex ( p , n , p ) <EOL> glVertex ( p , n , n ) <EOL> glVertex ( n , n , n ) <EOL> glVertex ( n , n , p ) <EOL> with glSection ( GL_QUADS ) : <EOL> glNormal3f ( - <NUM_LIT:1.> , <NUM_LIT:0> , <NUM_LIT:0> ) <EOL> glVertex ( n , p , p ) <EOL> glVertex ( n , n , p ) <EOL> glVertex ( n , n , n ) <EOL> glVertex ( n , p , n ) <EOL> class DisplayList ( object ) : <EOL> """<STR_LIT>""" <EOL> def __init__ ( self , renderFunction ) : <EOL> self . renderFunction = renderFunction <EOL> self . needsUpdate = True <EOL> self . listId = None <EOL> def update ( self ) : <EOL> self . needsUpdate = True <EOL> def __call__ ( self , * args ) : <EOL> if self . needsUpdate : <EOL> if self . listId : <EOL> glDeleteLists ( self . listId , <NUM_LIT:1> ) <EOL> self . listId = glGenLists ( <NUM_LIT:1> ) <EOL> glNewList ( self . listId , GL_COMPILE_AND_EXECUTE ) <EOL> self . renderFunction ( * args ) <EOL> glEndList ( ) <EOL> self . needsUpdate = False <EOL> else : <EOL> glCallList ( self . listId ) </s>
<s> """<STR_LIT>""" <EOL> from lantz import Q_ <EOL> from lantz . drivers . examples . dummydrivers import DummyOsci , DummyFunGen , DummyShutter <EOL> from myapps import AmplitudeScannerShutter <EOL> fungen = DummyFunGen ( '<STR_LIT>' ) <EOL> osci = DummyOsci ( '<STR_LIT>' ) <EOL> shutter = DummyShutter ( '<STR_LIT>' ) <EOL> with AmplitudeScannerShutter ( fungen = fungen , osci = osci , shutter = shutter ) as app : <EOL> print ( '<STR_LIT>' ) <EOL> data = list ( app . scan_amplitude ( Q_ ( range ( <NUM_LIT:1> , <NUM_LIT:10> ) , '<STR_LIT>' ) ) ) <EOL> print ( data ) </s>
<s> """<STR_LIT>""" <EOL> from . cobolt0601 import Cobolt0601 <EOL> __all__ = [ '<STR_LIT>' ] </s>
<s> """<STR_LIT>""" <EOL> import warnings <EOL> from . import Q_ <EOL> from . log import LOGGER as _LOG <EOL> from stringparser import Parser <EOL> class DimensionalityWarning ( Warning ) : <EOL> pass <EOL> def _do_nothing ( value ) : <EOL> return value <EOL> def _getitem ( a , b ) : <EOL> """<STR_LIT>""" <EOL> try : <EOL> return a [ b ] <EOL> except KeyError : <EOL> return a [ type ( b ) ] <EOL> getitem = _getitem <EOL> def convert_to ( units , on_dimensionless = '<STR_LIT>' , on_incompatible = '<STR_LIT>' , <EOL> return_float = False ) : <EOL> """<STR_LIT>""" <EOL> if on_dimensionless not in ( '<STR_LIT:ignore>' , '<STR_LIT>' , '<STR_LIT>' ) : <EOL> raise ValueError ( "<STR_LIT>" <EOL> "<STR_LIT>" . format ( on_dimensionless ) ) <EOL> if on_incompatible not in ( '<STR_LIT:ignore>' , '<STR_LIT>' , '<STR_LIT>' ) : <EOL> raise ValueError ( "<STR_LIT>" <EOL> "<STR_LIT>" . format ( on_dimensionless ) ) <EOL> if isinstance ( units , str ) : <EOL> units = Q_ ( <NUM_LIT:1> , units ) <EOL> elif not isinstance ( units , Q_ ) : <EOL> raise ValueError ( "<STR_LIT>" <EOL> "<STR_LIT>" ) <EOL> if return_float : <EOL> def _inner ( value ) : <EOL> if isinstance ( value , Q_ ) : <EOL> try : <EOL> return value . to ( units ) . magnitude <EOL> except ValueError as e : <EOL> if on_incompatible == '<STR_LIT>' : <EOL> raise ValueError ( e ) <EOL> elif on_incompatible == '<STR_LIT>' : <EOL> msg = '<STR_LIT>' . format ( value , units ) <EOL> warnings . warn ( msg , DimensionalityWarning ) <EOL> _LOG . warn ( msg ) <EOL> return value . magnitude <EOL> else : <EOL> if not units . dimensionless : <EOL> if on_dimensionless == '<STR_LIT>' : <EOL> raise ValueError ( '<STR_LIT>' . format ( value , units ) ) <EOL> elif on_dimensionless == '<STR_LIT>' : <EOL> msg = '<STR_LIT>' . format ( value , units ) <EOL> warnings . warn ( msg , DimensionalityWarning ) <EOL> _LOG . warn ( msg ) <EOL> return float ( value ) <EOL> return _inner <EOL> else : <EOL> def _inner ( value ) : <EOL> if isinstance ( value , Q_ ) : <EOL> try : <EOL> return value . to ( units ) <EOL> except ValueError as e : <EOL> if on_incompatible == '<STR_LIT>' : <EOL> raise ValueError ( e ) <EOL> elif on_incompatible == '<STR_LIT>' : <EOL> msg = '<STR_LIT>' . format ( value , units ) <EOL> warnings . warn ( msg , DimensionalityWarning ) <EOL> _LOG . warn ( msg ) <EOL> return float ( value . magnitude ) * units <EOL> else : <EOL> if not units . dimensionless : <EOL> if on_dimensionless == '<STR_LIT>' : <EOL> raise ValueError ( '<STR_LIT>' . format ( value , units ) ) <EOL> elif on_dimensionless == '<STR_LIT>' : <EOL> msg = '<STR_LIT>' . format ( value , units ) <EOL> warnings . warn ( msg , DimensionalityWarning ) <EOL> _LOG . warn ( msg ) <EOL> return float ( value ) * units <EOL> return _inner <EOL> class Processor ( object ) : <EOL> """<STR_LIT>""" <EOL> def __new__ ( cls , processors ) : <EOL> if isinstance ( processors , ( tuple , list ) ) : <EOL> if len ( processors ) > <NUM_LIT:1> : <EOL> inst = super ( ) . __new__ ( cls ) <EOL> inst . processors = tuple ( cls . _to_callable ( processor ) <EOL> for processor in processors ) <EOL> return inst <EOL> else : <EOL> return cls . _to_callable ( processors [ <NUM_LIT:0> ] ) <EOL> else : <EOL> return cls . _to_callable ( processors ) <EOL> def __call__ ( self , values ) : <EOL> return tuple ( processor ( value ) <EOL> for processor , value in zip ( self . processors , values ) ) <EOL> @ classmethod <EOL> def _to_callable ( cls , obj ) : <EOL> if callable ( obj ) : <EOL> return obj <EOL> if obj is None : <EOL> return _do_nothing <EOL> return cls . to_callable ( obj ) <EOL> @ classmethod <EOL> def to_callable ( cls , obj ) : <EOL> raise TypeError ( '<STR_LIT>' . format ( obj ) ) <EOL> def __len__ ( self ) : <EOL> if isinstance ( self . processors , tuple ) : <EOL> return len ( self . processors ) <EOL> return <NUM_LIT:1> <EOL> class FromQuantityProcessor ( Processor ) : <EOL> """<STR_LIT>""" <EOL> @ classmethod <EOL> def to_callable ( cls , obj ) : <EOL> if isinstance ( obj , ( str , Q_ ) ) : <EOL> return convert_to ( obj , return_float = True ) <EOL> raise TypeError ( '<STR_LIT>' <EOL> '<STR_LIT>' . format ( obj ) ) <EOL> class ToQuantityProcessor ( Processor ) : <EOL> """<STR_LIT>""" <EOL> @ classmethod <EOL> def to_callable ( cls , obj ) : <EOL> if isinstance ( obj , ( str , Q_ ) ) : <EOL> return convert_to ( obj , on_dimensionless = '<STR_LIT:ignore>' ) <EOL> raise TypeError ( '<STR_LIT>' <EOL> '<STR_LIT>' . format ( obj ) ) <EOL> class ParseProcessor ( Processor ) : <EOL> """<STR_LIT>""" <EOL> @ classmethod <EOL> def to_callable ( cls , obj ) : <EOL> if isinstance ( obj , str ) : <EOL> return Parser ( obj ) <EOL> raise TypeError ( '<STR_LIT>' <EOL> '<STR_LIT>' . format ( obj ) ) <EOL> class MapProcessor ( Processor ) : <EOL> """<STR_LIT>""" <EOL> @ classmethod <EOL> def to_callable ( cls , obj ) : <EOL> if isinstance ( obj , dict ) : <EOL> return get_mapping ( obj ) <EOL> if isinstance ( obj , set ) : <EOL> return check_membership ( obj ) <EOL> raise TypeError ( '<STR_LIT>' <EOL> '<STR_LIT>' . format ( obj ) ) <EOL> class ReverseMapProcessor ( Processor ) : <EOL> """<STR_LIT>""" <EOL> __reversed_cache = { } <EOL> @ classmethod <EOL> def to_callable ( cls , obj ) : <EOL> if isinstance ( obj , dict ) : <EOL> obj = cls . __reversed_cache . setdefault ( id ( obj ) , <EOL> { value : key for key , value <EOL> in obj . items ( ) } ) <EOL> return get_mapping ( obj ) <EOL> if isinstance ( obj , set ) : <EOL> return check_membership ( obj ) <EOL> raise TypeError ( '<STR_LIT>' <EOL> '<STR_LIT>' . format ( obj ) ) <EOL> class RangeProcessor ( Processor ) : <EOL> """<STR_LIT>""" <EOL> @ classmethod <EOL> def to_callable ( cls , obj ) : <EOL> if not isinstance ( obj , ( list , tuple ) ) : <EOL> raise TypeError ( '<STR_LIT>' <EOL> '<STR_LIT>' . format ( obj ) ) <EOL> if not len ( obj ) in ( <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> ) : <EOL> raise TypeError ( '<STR_LIT>' <EOL> '<STR_LIT>' <EOL> '<STR_LIT>' . format ( len ( obj ) ) ) <EOL> if len ( obj ) == <NUM_LIT:1> : <EOL> return check_range_and_coerce_step ( <NUM_LIT:0> , * obj ) <EOL> return check_range_and_coerce_step ( * obj ) <EOL> def check_range_and_coerce_step ( low , high , step = None ) : <EOL> """<STR_LIT>""" <EOL> def _inner ( value ) : <EOL> if not ( low <= value <= high ) : <EOL> raise ValueError ( '<STR_LIT>' . format ( value , low , high ) ) <EOL> if step : <EOL> value = round ( ( value - low ) / step ) * step + low <EOL> return value <EOL> return _inner <EOL> def check_membership ( container ) : <EOL> """<STR_LIT>""" <EOL> def _inner ( value ) : <EOL> if value not in container : <EOL> raise ValueError ( '<STR_LIT>' . format ( value , container ) ) <EOL> return value <EOL> return _inner <EOL> def get_mapping ( container ) : <EOL> """<STR_LIT>""" <EOL> def _inner ( key ) : <EOL> if key not in container : <EOL> raise ValueError ( "<STR_LIT>" . format ( key , tuple ( container . keys ( ) ) ) ) <EOL> return container [ key ] <EOL> return _inner </s>
<s> try : <EOL> from setuptools import setup <EOL> except ImportError : <EOL> print ( '<STR_LIT>' ) <EOL> sys . exit ( <NUM_LIT:1> ) <EOL> import os <EOL> import sys <EOL> import codecs <EOL> def read ( filename ) : <EOL> return codecs . open ( filename , encoding = '<STR_LIT:utf-8>' ) . read ( ) <EOL> long_description = '<STR_LIT>' . join ( [ read ( '<STR_LIT>' ) , <EOL> read ( '<STR_LIT>' ) , <EOL> read ( '<STR_LIT>' ) ] ) <EOL> __doc__ = long_description <EOL> requirements = [ ] <EOL> if sys . version_info < ( <NUM_LIT:3> , <NUM_LIT:4> ) : <EOL> requirements . append ( '<STR_LIT>' ) <EOL> root_folder = os . path . dirname ( os . path . abspath ( __file__ ) ) <EOL> folder = os . path . join ( root_folder , '<STR_LIT>' , '<STR_LIT>' ) <EOL> paths = os . listdir ( folder ) <EOL> companies = [ path for path in paths <EOL> if os . path . isdir ( os . path . join ( folder , path ) ) <EOL> and os . path . exists ( os . path . join ( folder , path , '<STR_LIT>' ) ) ] <EOL> folder = os . path . join ( root_folder , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) <EOL> paths = os . listdir ( folder ) <EOL> legacy_companies = [ path for path in paths <EOL> if os . path . isdir ( os . path . join ( folder , path ) ) <EOL> and os . path . exists ( os . path . join ( folder , path , '<STR_LIT>' ) ) ] <EOL> setup ( name = '<STR_LIT>' , <EOL> version = '<STR_LIT>' , <EOL> license = '<STR_LIT>' , <EOL> description = '<STR_LIT>' , <EOL> long_description = long_description , <EOL> keywords = '<STR_LIT>' , <EOL> author = '<STR_LIT>' , <EOL> author_email = '<STR_LIT>' , <EOL> url = '<STR_LIT>' , <EOL> packages = [ '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' ] + <EOL> [ '<STR_LIT>' + company for company in companies ] + <EOL> [ '<STR_LIT>' + company for company in legacy_companies ] , <EOL> test_suite = '<STR_LIT>' , <EOL> install_requires = [ '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> ] + requirements , <EOL> zip_safe = False , <EOL> platforms = '<STR_LIT>' , <EOL> entry_points = { <EOL> '<STR_LIT>' : [ <EOL> '<STR_LIT>' , <EOL> ] , <EOL> '<STR_LIT>' : [ <EOL> '<STR_LIT>' , <EOL> ] <EOL> } , <EOL> classifiers = [ <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' <EOL> ] , <EOL> scripts = [ '<STR_LIT>' , <EOL> ] , <EOL> ) </s>
<s> __author__ = '<STR_LIT>' <EOL> from learnpy . Problem import Problem <EOL> pro = Problem ( "<STR_LIT>" , "<STR_LIT>" ) <EOL> pro . set_label ( '<STR_LIT:Name>' ) <EOL> pro . set_model ( "<STR_LIT>" ) <EOL> pro . model . fit ( None ) <EOL> pro . set_testing ( "<STR_LIT>" ) <EOL> pro . predict ( ) <EOL> pro2 = Problem ( "<STR_LIT>" , "<STR_LIT>" ) <EOL> pro2 . set_label ( '<STR_LIT:Name>' ) <EOL> pro2 . set_model ( "<STR_LIT>" ) <EOL> pro2 . model . fit ( None ) <EOL> pro2 . set_testing ( "<STR_LIT>" ) <EOL> pro2 . predict ( ) </s>
<s> from collections import OrderedDict <EOL> import theano . tensor as T <EOL> from . . import utils <EOL> __all__ = [ <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> ] <EOL> class Layer ( object ) : <EOL> """<STR_LIT>""" <EOL> def __init__ ( self , incoming , name = None ) : <EOL> if isinstance ( incoming , tuple ) : <EOL> self . input_shape = incoming <EOL> self . input_layer = None <EOL> else : <EOL> self . input_shape = incoming . output_shape <EOL> self . input_layer = incoming <EOL> self . name = name <EOL> self . params = OrderedDict ( ) <EOL> self . get_output_kwargs = [ ] <EOL> if any ( d is not None and d <= <NUM_LIT:0> for d in self . input_shape ) : <EOL> raise ValueError ( ( <EOL> "<STR_LIT>" <EOL> "<STR_LIT>" ) % ( <EOL> self . input_shape , self . name ) ) <EOL> @ property <EOL> def output_shape ( self ) : <EOL> shape = self . get_output_shape_for ( self . input_shape ) <EOL> if any ( isinstance ( s , T . Variable ) for s in shape ) : <EOL> raise ValueError ( "<STR_LIT>" <EOL> "<STR_LIT>" <EOL> "<STR_LIT>" <EOL> "<STR_LIT>" <EOL> "<STR_LIT>" % ( self . __class__ . __name__ , shape ) ) <EOL> return shape <EOL> def get_params ( self , ** tags ) : <EOL> """<STR_LIT>""" <EOL> result = list ( self . params . keys ( ) ) <EOL> only = set ( tag for tag , value in tags . items ( ) if value ) <EOL> if only : <EOL> result = [ param for param in result <EOL> if not ( only - self . params [ param ] ) ] <EOL> exclude = set ( tag for tag , value in tags . items ( ) if not value ) <EOL> if exclude : <EOL> result = [ param for param in result <EOL> if not ( self . params [ param ] & exclude ) ] <EOL> return utils . collect_shared_vars ( result ) <EOL> def get_output_shape_for ( self , input_shape ) : <EOL> """<STR_LIT>""" <EOL> return input_shape <EOL> def get_output_for ( self , input , ** kwargs ) : <EOL> """<STR_LIT>""" <EOL> raise NotImplementedError <EOL> def add_param ( self , spec , shape , name = None , ** tags ) : <EOL> """<STR_LIT>""" <EOL> if name is not None : <EOL> if self . name is not None : <EOL> name = "<STR_LIT>" % ( self . name , name ) <EOL> param = utils . create_param ( spec , shape , name ) <EOL> tags [ '<STR_LIT>' ] = tags . get ( '<STR_LIT>' , True ) <EOL> tags [ '<STR_LIT>' ] = tags . get ( '<STR_LIT>' , True ) <EOL> self . params [ param ] = set ( tag for tag , value in tags . items ( ) if value ) <EOL> return param <EOL> class MergeLayer ( Layer ) : <EOL> """<STR_LIT>""" <EOL> def __init__ ( self , incomings , name = None ) : <EOL> self . input_shapes = [ incoming if isinstance ( incoming , tuple ) <EOL> else incoming . output_shape <EOL> for incoming in incomings ] <EOL> self . input_layers = [ None if isinstance ( incoming , tuple ) <EOL> else incoming <EOL> for incoming in incomings ] <EOL> self . name = name <EOL> self . params = OrderedDict ( ) <EOL> self . get_output_kwargs = [ ] <EOL> @ Layer . output_shape . getter <EOL> def output_shape ( self ) : <EOL> shape = self . get_output_shape_for ( self . input_shapes ) <EOL> if any ( isinstance ( s , T . Variable ) for s in shape ) : <EOL> raise ValueError ( "<STR_LIT>" <EOL> "<STR_LIT>" <EOL> "<STR_LIT>" <EOL> "<STR_LIT>" <EOL> "<STR_LIT>" % ( self . __class__ . __name__ , shape ) ) <EOL> return shape <EOL> def get_output_shape_for ( self , input_shapes ) : <EOL> """<STR_LIT>""" <EOL> raise NotImplementedError <EOL> def get_output_for ( self , inputs , ** kwargs ) : <EOL> """<STR_LIT>""" <EOL> raise NotImplementedError </s>
<s> from mock import Mock <EOL> import numpy <EOL> import pytest <EOL> import theano <EOL> class TestAutocrop : <EOL> def test_autocrop_array_shapes ( self ) : <EOL> from lasagne . layers . merge import autocrop_array_shapes <EOL> crop0 = None <EOL> crop1 = [ None , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> crop2 = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> crop_bad = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> assert autocrop_array_shapes ( <EOL> [ ( <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:4> ) , ( <NUM_LIT:5> , <NUM_LIT:6> , <NUM_LIT:7> , <NUM_LIT:8> ) , ( <NUM_LIT:5> , <NUM_LIT:4> , <NUM_LIT:3> , <NUM_LIT:2> ) ] , crop0 ) == [ ( <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:4> ) , ( <NUM_LIT:5> , <NUM_LIT:6> , <NUM_LIT:7> , <NUM_LIT:8> ) , ( <NUM_LIT:5> , <NUM_LIT:4> , <NUM_LIT:3> , <NUM_LIT:2> ) ] <EOL> assert autocrop_array_shapes ( <EOL> [ ( <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:4> ) , ( <NUM_LIT:5> , <NUM_LIT:6> , <NUM_LIT:7> , <NUM_LIT:8> ) , ( <NUM_LIT:5> , <NUM_LIT:4> , <NUM_LIT:3> , <NUM_LIT:2> ) ] , crop1 ) == [ ( <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:2> ) , ( <NUM_LIT:5> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:2> ) , ( <NUM_LIT:5> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:2> ) ] <EOL> assert autocrop_array_shapes ( <EOL> [ ( <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:4> ) , ( <NUM_LIT:5> , <NUM_LIT:6> , <NUM_LIT:7> , <NUM_LIT:8> ) , ( <NUM_LIT:5> , <NUM_LIT:4> , <NUM_LIT:3> , <NUM_LIT:2> ) ] , crop2 ) == [ ( <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:4> ) , ( <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:7> , <NUM_LIT:8> ) , ( <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:2> ) ] <EOL> with pytest . raises ( ValueError ) : <EOL> autocrop_array_shapes ( <EOL> [ ( <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:4> ) , ( <NUM_LIT:5> , <NUM_LIT:6> , <NUM_LIT:7> , <NUM_LIT:8> ) , ( <NUM_LIT:5> , <NUM_LIT:4> , <NUM_LIT:3> , <NUM_LIT:2> ) ] , crop_bad ) <EOL> with pytest . raises ( ValueError ) : <EOL> autocrop_array_shapes ( <EOL> [ ( <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:4> ) , ( <NUM_LIT:5> , <NUM_LIT:6> , <NUM_LIT:7> ) , ( <NUM_LIT:5> , <NUM_LIT:4> , <NUM_LIT:3> , <NUM_LIT:2> , <NUM_LIT:10> ) ] , crop1 ) <EOL> def test_crop_inputs ( self ) : <EOL> from lasagne . layers . merge import autocrop <EOL> from numpy . testing import assert_array_equal <EOL> crop_0 = None <EOL> crop_1 = [ None , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> crop_l = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> crop_c = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> crop_u = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> crop_x = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> crop_bad = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> x0 = numpy . random . random ( ( <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:5> , <NUM_LIT:7> ) ) <EOL> x1 = numpy . random . random ( ( <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:4> ) ) <EOL> x2 = numpy . random . random ( ( <NUM_LIT:6> , <NUM_LIT:3> , <NUM_LIT:4> , <NUM_LIT:2> ) ) <EOL> def crop_test ( cropping , inputs , expected ) : <EOL> inputs = [ theano . shared ( x ) for x in inputs ] <EOL> outs = autocrop ( inputs , cropping ) <EOL> outs = [ o . eval ( ) for o in outs ] <EOL> assert len ( outs ) == len ( expected ) <EOL> for o , e in zip ( outs , expected ) : <EOL> assert_array_equal ( o , e ) <EOL> crop_test ( crop_0 , [ x0 , x1 ] , <EOL> [ x0 , x1 ] ) <EOL> crop_test ( crop_1 , [ x0 , x1 ] , <EOL> [ x0 [ : , : <NUM_LIT:2> , <NUM_LIT:1> : <NUM_LIT:4> , <NUM_LIT:3> : ] , x1 [ : , : , : , : ] ] ) <EOL> crop_test ( crop_l , [ x0 , x1 ] , <EOL> [ x0 [ : <NUM_LIT:1> , : <NUM_LIT:2> , : <NUM_LIT:3> , : <NUM_LIT:4> ] , x1 [ : , : , : , : ] ] ) <EOL> crop_test ( crop_c , [ x0 , x1 ] , <EOL> [ x0 [ : <NUM_LIT:1> , : <NUM_LIT:2> , <NUM_LIT:1> : <NUM_LIT:4> , <NUM_LIT:1> : <NUM_LIT:5> ] , x1 [ : , : , : , : ] ] ) <EOL> crop_test ( crop_u , [ x0 , x1 ] , <EOL> [ x0 [ <NUM_LIT:1> : , <NUM_LIT:1> : , <NUM_LIT:2> : , <NUM_LIT:3> : ] , x1 [ : , : , : , : ] ] ) <EOL> crop_test ( crop_0 , [ x0 , x2 ] , <EOL> [ x0 , x2 ] ) <EOL> crop_test ( crop_1 , [ x0 , x2 ] , <EOL> [ x0 [ : , : , : <NUM_LIT:4> , <NUM_LIT:5> : ] , x2 [ : , : , : , : ] ] ) <EOL> crop_test ( crop_l , [ x0 , x2 ] , <EOL> [ x0 [ : , : , : <NUM_LIT:4> , : <NUM_LIT:2> ] , x2 [ : <NUM_LIT:2> , : , : , : ] ] ) <EOL> crop_test ( crop_c , [ x0 , x2 ] , <EOL> [ x0 [ : , : , : <NUM_LIT:4> , <NUM_LIT:2> : <NUM_LIT:4> ] , x2 [ <NUM_LIT:2> : <NUM_LIT:4> , : , : , : ] ] ) <EOL> crop_test ( crop_u , [ x0 , x2 ] , <EOL> [ x0 [ : , : , <NUM_LIT:1> : , <NUM_LIT:5> : ] , x2 [ <NUM_LIT:4> : , : , : , : ] ] ) <EOL> crop_test ( crop_0 , [ x0 , x1 , x2 ] , <EOL> [ x0 , x1 , x2 ] ) <EOL> crop_test ( crop_1 , [ x0 , x1 , x2 ] , <EOL> [ x0 [ : , : <NUM_LIT:2> , <NUM_LIT:1> : <NUM_LIT:4> , <NUM_LIT:5> : ] , x1 [ : , : , : , <NUM_LIT:2> : ] , x2 [ : , : <NUM_LIT:2> , : <NUM_LIT:3> , : ] ] ) <EOL> crop_test ( crop_l , [ x0 , x1 , x2 ] , <EOL> [ x0 [ : <NUM_LIT:1> , : <NUM_LIT:2> , : <NUM_LIT:3> , : <NUM_LIT:2> ] , x1 [ : , : , : , : <NUM_LIT:2> ] , x2 [ : <NUM_LIT:1> , : <NUM_LIT:2> , : <NUM_LIT:3> , : ] ] ) <EOL> crop_test ( crop_c , [ x0 , x1 , x2 ] , <EOL> [ x0 [ : <NUM_LIT:1> , : <NUM_LIT:2> , <NUM_LIT:1> : <NUM_LIT:4> , <NUM_LIT:2> : <NUM_LIT:4> ] , x1 [ : , : , : , <NUM_LIT:1> : <NUM_LIT:3> ] , x2 [ <NUM_LIT:2> : <NUM_LIT:3> , : <NUM_LIT:2> , : <NUM_LIT:3> , : ] ] ) <EOL> crop_test ( crop_u , [ x0 , x1 , x2 ] , <EOL> [ x0 [ <NUM_LIT:1> : , <NUM_LIT:1> : , <NUM_LIT:2> : , <NUM_LIT:5> : ] , x1 [ : , : , : , <NUM_LIT:2> : ] , x2 [ <NUM_LIT:5> : , <NUM_LIT:1> : , <NUM_LIT:1> : , : ] ] ) <EOL> crop_test ( crop_x , [ x0 , x1 , x2 ] , <EOL> [ x0 [ : <NUM_LIT:1> , : <NUM_LIT:2> , : , : ] , x1 [ : <NUM_LIT:1> , : <NUM_LIT:2> , : , : ] , x2 [ : <NUM_LIT:1> , : <NUM_LIT:2> , : , : ] ] ) <EOL> crop_test ( crop_x , [ x0 , x1 , x2 , x0 , x1 , x2 ] , <EOL> [ x0 [ : <NUM_LIT:1> , : <NUM_LIT:2> , : , : ] , x1 [ : <NUM_LIT:1> , : <NUM_LIT:2> , : , : ] , x2 [ : <NUM_LIT:1> , : <NUM_LIT:2> , : , : ] , <EOL> x0 [ : <NUM_LIT:1> , : <NUM_LIT:2> , : , : ] , x1 [ : <NUM_LIT:1> , : <NUM_LIT:2> , : , : ] , x2 [ : <NUM_LIT:1> , : <NUM_LIT:2> , : , : ] ] ) <EOL> with pytest . raises ( ValueError ) : <EOL> crop_test ( crop_bad , [ x0 , x1 , x2 ] , <EOL> [ x0 [ : <NUM_LIT:1> , : <NUM_LIT:2> , : , : ] , x1 [ : <NUM_LIT:1> , : <NUM_LIT:2> , : , : ] , x2 [ : <NUM_LIT:1> , : <NUM_LIT:2> , : , : ] ] ) <EOL> with pytest . raises ( ValueError ) : <EOL> crop_test ( crop_bad , [ x0 [ : , : , : , <NUM_LIT:0> ] , x1 , x2 [ : , : , : , : , None ] ] , <EOL> [ x0 [ : <NUM_LIT:1> , : <NUM_LIT:2> , : , : ] , x1 [ : <NUM_LIT:1> , : <NUM_LIT:2> , : , : ] , x2 [ : <NUM_LIT:1> , : <NUM_LIT:2> , : , : ] ] ) <EOL> class TestConcatLayer : <EOL> @ pytest . fixture <EOL> def layer ( self ) : <EOL> from lasagne . layers . merge import ConcatLayer <EOL> return ConcatLayer ( [ Mock ( ) , Mock ( ) ] , axis = <NUM_LIT:1> ) <EOL> @ pytest . fixture <EOL> def crop_layer_0 ( self ) : <EOL> from lasagne . layers . merge import ConcatLayer <EOL> return ConcatLayer ( [ Mock ( ) , Mock ( ) ] , axis = <NUM_LIT:0> , <EOL> cropping = [ '<STR_LIT>' ] * <NUM_LIT:2> ) <EOL> @ pytest . fixture <EOL> def crop_layer_1 ( self ) : <EOL> from lasagne . layers . merge import ConcatLayer <EOL> return ConcatLayer ( [ Mock ( ) , Mock ( ) ] , axis = <NUM_LIT:1> , <EOL> cropping = [ '<STR_LIT>' ] * <NUM_LIT:2> ) <EOL> def test_get_output_shape_for ( self , layer ) : <EOL> assert layer . get_output_shape_for ( [ ( <NUM_LIT:3> , <NUM_LIT:2> ) , ( <NUM_LIT:3> , <NUM_LIT:5> ) ] ) == ( <NUM_LIT:3> , <NUM_LIT:7> ) <EOL> assert layer . get_output_shape_for ( [ ( <NUM_LIT:3> , <NUM_LIT:2> ) , ( <NUM_LIT:3> , None ) ] ) == ( <NUM_LIT:3> , None ) <EOL> assert layer . get_output_shape_for ( [ ( None , <NUM_LIT:2> ) , ( <NUM_LIT:3> , <NUM_LIT:5> ) ] ) == ( <NUM_LIT:3> , <NUM_LIT:7> ) <EOL> assert layer . get_output_shape_for ( [ ( None , <NUM_LIT:2> ) , ( None , <NUM_LIT:5> ) ] ) == ( None , <NUM_LIT:7> ) <EOL> with pytest . raises ( ValueError ) : <EOL> layer . get_output_shape_for ( [ ( <NUM_LIT:4> , None ) , ( <NUM_LIT:3> , <NUM_LIT:5> ) ] ) <EOL> with pytest . raises ( ValueError ) : <EOL> layer . get_output_shape_for ( [ ( <NUM_LIT:3> , <NUM_LIT:2> ) , ( <NUM_LIT:4> , None ) ] ) <EOL> with pytest . raises ( ValueError ) : <EOL> layer . get_output_shape_for ( [ ( None , <NUM_LIT:2> ) , ( <NUM_LIT:3> , <NUM_LIT:5> ) , ( <NUM_LIT:4> , <NUM_LIT:5> ) ] ) <EOL> def test_get_output_shape_for_cropped ( self , crop_layer_0 , crop_layer_1 ) : <EOL> input_shapes = [ ( <NUM_LIT:3> , <NUM_LIT:2> ) , ( <NUM_LIT:4> , <NUM_LIT:5> ) ] <EOL> result_0 = crop_layer_0 . get_output_shape_for ( input_shapes ) <EOL> result_1 = crop_layer_1 . get_output_shape_for ( input_shapes ) <EOL> assert result_0 == ( <NUM_LIT:7> , <NUM_LIT:2> ) <EOL> assert result_1 == ( <NUM_LIT:3> , <NUM_LIT:7> ) <EOL> def test_get_output_for ( self , layer ) : <EOL> inputs = [ theano . shared ( numpy . ones ( ( <NUM_LIT:3> , <NUM_LIT:3> ) ) ) , <EOL> theano . shared ( numpy . ones ( ( <NUM_LIT:3> , <NUM_LIT:2> ) ) ) ] <EOL> result = layer . get_output_for ( inputs ) <EOL> result_eval = result . eval ( ) <EOL> desired_result = numpy . hstack ( [ input . get_value ( ) for input in inputs ] ) <EOL> assert ( result_eval == desired_result ) . all ( ) <EOL> def test_get_output_for_cropped ( self , crop_layer_0 , crop_layer_1 ) : <EOL> x0 = numpy . random . random ( ( <NUM_LIT:5> , <NUM_LIT:3> ) ) <EOL> x1 = numpy . random . random ( ( <NUM_LIT:4> , <NUM_LIT:2> ) ) <EOL> inputs = [ theano . shared ( x0 ) , <EOL> theano . shared ( x1 ) ] <EOL> result_0 = crop_layer_0 . get_output_for ( inputs ) . eval ( ) <EOL> result_1 = crop_layer_1 . get_output_for ( inputs ) . eval ( ) <EOL> desired_result_0 = numpy . concatenate ( [ x0 [ : , : <NUM_LIT:2> ] , x1 [ : , : <NUM_LIT:2> ] ] , axis = <NUM_LIT:0> ) <EOL> desired_result_1 = numpy . concatenate ( [ x0 [ : <NUM_LIT:4> , : ] , x1 [ : <NUM_LIT:4> , : ] ] , axis = <NUM_LIT:1> ) <EOL> assert ( result_0 == desired_result_0 ) . all ( ) <EOL> assert ( result_1 == desired_result_1 ) . all ( ) <EOL> class TestElemwiseSumLayer : <EOL> @ pytest . fixture <EOL> def layer ( self ) : <EOL> from lasagne . layers . merge import ElemwiseSumLayer <EOL> return ElemwiseSumLayer ( [ Mock ( ) , Mock ( ) ] , coeffs = [ <NUM_LIT:2> , - <NUM_LIT:1> ] ) <EOL> @ pytest . fixture <EOL> def crop_layer ( self ) : <EOL> from lasagne . layers . merge import ElemwiseSumLayer <EOL> return ElemwiseSumLayer ( [ Mock ( ) , Mock ( ) ] , coeffs = [ <NUM_LIT:2> , - <NUM_LIT:1> ] , <EOL> cropping = [ '<STR_LIT>' ] * <NUM_LIT:2> ) <EOL> def test_get_output_shape_for ( self , layer ) : <EOL> assert layer . get_output_shape_for ( [ ( <NUM_LIT:3> , <NUM_LIT:2> ) , ( <NUM_LIT:3> , <NUM_LIT:2> ) ] ) == ( <NUM_LIT:3> , <NUM_LIT:2> ) <EOL> assert layer . get_output_shape_for ( [ ( <NUM_LIT:3> , <NUM_LIT:2> ) , ( <NUM_LIT:3> , None ) ] ) == ( <NUM_LIT:3> , <NUM_LIT:2> ) <EOL> assert layer . get_output_shape_for ( [ ( None , <NUM_LIT:2> ) , ( <NUM_LIT:3> , <NUM_LIT:2> ) ] ) == ( <NUM_LIT:3> , <NUM_LIT:2> ) <EOL> assert layer . get_output_shape_for ( [ ( None , <NUM_LIT:2> ) , ( None , <NUM_LIT:2> ) ] ) == ( None , <NUM_LIT:2> ) <EOL> with pytest . raises ( ValueError ) : <EOL> layer . get_output_shape_for ( [ ( <NUM_LIT:3> , None ) , ( <NUM_LIT:4> , <NUM_LIT:2> ) ] ) <EOL> with pytest . raises ( ValueError ) : <EOL> layer . get_output_shape_for ( [ ( <NUM_LIT:3> , <NUM_LIT:2> ) , ( <NUM_LIT:4> , None ) ] ) <EOL> with pytest . raises ( ValueError ) : <EOL> layer . get_output_shape_for ( [ ( None , <NUM_LIT:2> ) , ( <NUM_LIT:3> , <NUM_LIT:2> ) , ( <NUM_LIT:4> , <NUM_LIT:2> ) ] ) <EOL> def test_get_output_for ( self , layer ) : <EOL> a = numpy . array ( [ [ <NUM_LIT:0> , <NUM_LIT:1> ] , [ <NUM_LIT:2> , <NUM_LIT:3> ] ] ) <EOL> b = numpy . array ( [ [ <NUM_LIT:1> , <NUM_LIT:2> ] , [ <NUM_LIT:4> , <NUM_LIT:5> ] ] ) <EOL> inputs = [ theano . shared ( a ) , <EOL> theano . shared ( b ) ] <EOL> result = layer . get_output_for ( inputs ) <EOL> result_eval = result . eval ( ) <EOL> desired_result = <NUM_LIT:2> * a - b <EOL> assert ( result_eval == desired_result ) . all ( ) <EOL> def test_get_output_for_cropped ( self , crop_layer ) : <EOL> from numpy . testing import assert_array_almost_equal as aeq <EOL> x0 = numpy . random . random ( ( <NUM_LIT:5> , <NUM_LIT:3> ) ) <EOL> x1 = numpy . random . random ( ( <NUM_LIT:4> , <NUM_LIT:2> ) ) <EOL> inputs = [ theano . shared ( x0 ) , <EOL> theano . shared ( x1 ) ] <EOL> result = crop_layer . get_output_for ( inputs ) . eval ( ) <EOL> desired_result = <NUM_LIT:2> * x0 [ : <NUM_LIT:4> , : <NUM_LIT:2> ] - x1 [ : <NUM_LIT:4> , : <NUM_LIT:2> ] <EOL> aeq ( result , desired_result ) <EOL> def test_bad_coeffs_fails ( self , layer ) : <EOL> from lasagne . layers . merge import ElemwiseSumLayer <EOL> with pytest . raises ( ValueError ) : <EOL> ElemwiseSumLayer ( [ Mock ( ) , Mock ( ) ] , coeffs = [ <NUM_LIT:2> , <NUM_LIT:3> , - <NUM_LIT:1> ] ) <EOL> class TestElemwiseMergeLayerMul : <EOL> @ pytest . fixture <EOL> def layer ( self ) : <EOL> import theano . tensor as T <EOL> from lasagne . layers . merge import ElemwiseMergeLayer <EOL> return ElemwiseMergeLayer ( [ Mock ( ) , Mock ( ) ] , merge_function = T . mul ) <EOL> def test_get_output_for ( self , layer ) : <EOL> a = numpy . array ( [ [ <NUM_LIT:0> , <NUM_LIT:1> ] , [ <NUM_LIT:2> , <NUM_LIT:3> ] ] ) <EOL> b = numpy . array ( [ [ <NUM_LIT:1> , <NUM_LIT:2> ] , [ <NUM_LIT:4> , <NUM_LIT:5> ] ] ) <EOL> inputs = [ theano . shared ( a ) , <EOL> theano . shared ( b ) ] <EOL> result = layer . get_output_for ( inputs ) <EOL> result_eval = result . eval ( ) <EOL> desired_result = a * b <EOL> assert ( result_eval == desired_result ) . all ( ) <EOL> class TestElemwiseMergeLayerMaximum : <EOL> @ pytest . fixture <EOL> def layer ( self ) : <EOL> import theano . tensor as T <EOL> from lasagne . layers . merge import ElemwiseMergeLayer <EOL> return ElemwiseMergeLayer ( [ Mock ( ) , Mock ( ) ] , merge_function = T . maximum ) <EOL> def test_get_output_for ( self , layer ) : <EOL> a = numpy . array ( [ [ <NUM_LIT:0> , <NUM_LIT:1> ] , [ <NUM_LIT:2> , <NUM_LIT:3> ] ] ) <EOL> b = numpy . array ( [ [ <NUM_LIT:1> , <NUM_LIT:2> ] , [ <NUM_LIT:4> , <NUM_LIT:5> ] ] ) <EOL> inputs = [ theano . shared ( a ) , <EOL> theano . shared ( b ) ] <EOL> result = layer . get_output_for ( inputs ) <EOL> result_eval = result . eval ( ) <EOL> desired_result = numpy . maximum ( a , b ) <EOL> assert ( result_eval == desired_result ) . all ( ) </s>
<s> from gevent import monkey ; monkey . patch_all ( ) <EOL> import gevent <EOL> from ws4py . client . geventclient import WebSocketClient <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL> ws = WebSocketClient ( '<STR_LIT>' , protocols = [ '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> ws . connect ( ) <EOL> ws . send ( "<STR_LIT>" ) <EOL> print ( ( ws . receive ( ) , ) ) <EOL> ws . send ( "<STR_LIT>" ) <EOL> print ( ( ws . receive ( ) , ) ) <EOL> def incoming ( ) : <EOL> while True : <EOL> m = ws . receive ( ) <EOL> if m is not None : <EOL> m = str ( m ) <EOL> print ( ( m , len ( m ) ) ) <EOL> if len ( m ) == <NUM_LIT> : <EOL> ws . close ( ) <EOL> break <EOL> else : <EOL> break <EOL> print ( ( "<STR_LIT>" , ) ) <EOL> def outgoing ( ) : <EOL> for i in range ( <NUM_LIT:0> , <NUM_LIT> , <NUM_LIT:5> ) : <EOL> ws . send ( "<STR_LIT:*>" * i ) <EOL> ws . send ( "<STR_LIT>" ) <EOL> greenlets = [ <EOL> gevent . spawn ( incoming ) , <EOL> gevent . spawn ( outgoing ) , <EOL> ] <EOL> gevent . joinall ( greenlets ) </s>
<s> import os <EOL> import struct <EOL> from ws4py . framing import Frame , OPCODE_CONTINUATION , OPCODE_TEXT , OPCODE_BINARY , OPCODE_CLOSE , OPCODE_PING , OPCODE_PONG <EOL> from ws4py . compat import unicode , py3k <EOL> __all__ = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' , '<STR_LIT>' ] <EOL> class Message ( object ) : <EOL> def __init__ ( self , opcode , data = b'<STR_LIT>' , encoding = '<STR_LIT:utf-8>' ) : <EOL> """<STR_LIT>""" <EOL> self . opcode = opcode <EOL> self . _completed = False <EOL> self . encoding = encoding <EOL> if isinstance ( data , unicode ) : <EOL> if not encoding : <EOL> raise TypeError ( "<STR_LIT>" ) <EOL> data = data . encode ( encoding ) <EOL> elif isinstance ( data , bytearray ) : <EOL> data = bytes ( data ) <EOL> elif not isinstance ( data , bytes ) : <EOL> raise TypeError ( "<STR_LIT>" % type ( data ) ) <EOL> self . data = data <EOL> def single ( self , mask = False ) : <EOL> """<STR_LIT>""" <EOL> mask = os . urandom ( <NUM_LIT:4> ) if mask else None <EOL> return Frame ( body = self . data , opcode = self . opcode , <EOL> masking_key = mask , fin = <NUM_LIT:1> ) . build ( ) <EOL> def fragment ( self , first = False , last = False , mask = False ) : <EOL> """<STR_LIT>""" <EOL> fin = <NUM_LIT:1> if last is True else <NUM_LIT:0> <EOL> opcode = self . opcode if first is True else OPCODE_CONTINUATION <EOL> mask = os . urandom ( <NUM_LIT:4> ) if mask else None <EOL> return Frame ( body = self . data , <EOL> opcode = opcode , masking_key = mask , <EOL> fin = fin ) . build ( ) <EOL> @ property <EOL> def completed ( self ) : <EOL> """<STR_LIT>""" <EOL> return self . _completed <EOL> @ completed . setter <EOL> def completed ( self , state ) : <EOL> """<STR_LIT>""" <EOL> self . _completed = state <EOL> def extend ( self , data ) : <EOL> """<STR_LIT>""" <EOL> if isinstance ( data , bytes ) : <EOL> self . data += data <EOL> elif isinstance ( data , bytearray ) : <EOL> self . data += bytes ( data ) <EOL> elif isinstance ( data , unicode ) : <EOL> self . data += data . encode ( self . encoding ) <EOL> else : <EOL> raise TypeError ( "<STR_LIT>" % type ( data ) ) <EOL> def __len__ ( self ) : <EOL> return len ( self . __unicode__ ( ) ) <EOL> def __str__ ( self ) : <EOL> if py3k : <EOL> return self . data . decode ( self . encoding ) <EOL> return self . data <EOL> def __unicode__ ( self ) : <EOL> return self . data . decode ( self . encoding ) <EOL> class TextMessage ( Message ) : <EOL> def __init__ ( self , text = None ) : <EOL> Message . __init__ ( self , OPCODE_TEXT , text ) <EOL> @ property <EOL> def is_binary ( self ) : <EOL> return False <EOL> @ property <EOL> def is_text ( self ) : <EOL> return True <EOL> class BinaryMessage ( Message ) : <EOL> def __init__ ( self , bytes = None ) : <EOL> Message . __init__ ( self , OPCODE_BINARY , bytes , encoding = None ) <EOL> @ property <EOL> def is_binary ( self ) : <EOL> return True <EOL> @ property <EOL> def is_text ( self ) : <EOL> return False <EOL> def __len__ ( self ) : <EOL> return len ( self . data ) <EOL> class CloseControlMessage ( Message ) : <EOL> def __init__ ( self , code = <NUM_LIT:1000> , reason = '<STR_LIT>' ) : <EOL> data = b"<STR_LIT>" <EOL> if code : <EOL> data += struct . pack ( "<STR_LIT>" , code ) <EOL> if reason is not None : <EOL> if isinstance ( reason , unicode ) : <EOL> reason = reason . encode ( '<STR_LIT:utf-8>' ) <EOL> data += reason <EOL> Message . __init__ ( self , OPCODE_CLOSE , data , '<STR_LIT:utf-8>' ) <EOL> self . code = code <EOL> self . reason = reason <EOL> def __str__ ( self ) : <EOL> if py3k : <EOL> return self . reason . decode ( '<STR_LIT:utf-8>' ) <EOL> return self . reason <EOL> def __unicode__ ( self ) : <EOL> return self . reason . decode ( self . encoding ) <EOL> class PingControlMessage ( Message ) : <EOL> def __init__ ( self , data = None ) : <EOL> Message . __init__ ( self , OPCODE_PING , data ) <EOL> class PongControlMessage ( Message ) : <EOL> def __init__ ( self , data ) : <EOL> Message . __init__ ( self , OPCODE_PONG , data ) </s>
<s> import sys <EOL> import base64 <EOL> import time <EOL> import urllib <EOL> from struct import unpack <EOL> from threading import Lock <EOL> from binascii import hexlify <EOL> from urlparse import urlparse <EOL> from mod_python import apache <EOL> from PyAuthenNTLM2 . ntlm_dc_proxy import NTLM_DC_Proxy <EOL> from PyAuthenNTLM2 . ntlm_ad_proxy import NTLM_AD_Proxy <EOL> use_basic_auth = True <EOL> try : <EOL> from PyAuthenNTLM2 . ntlm_client import NTLM_Client <EOL> except ImportError : <EOL> use_basic_auth = False <EOL> class CacheConnections : <EOL> def __init__ ( self ) : <EOL> self . _mutex = Lock ( ) <EOL> self . _cache = { } <EOL> def __len__ ( self ) : <EOL> return len ( self . _cache ) <EOL> def remove ( self , id ) : <EOL> self . _mutex . acquire ( ) <EOL> ( proxy , ts ) = self . _cache . get ( id , ( None , None ) ) <EOL> if proxy : <EOL> proxy . close ( ) <EOL> del self . _cache [ id ] <EOL> self . _mutex . release ( ) <EOL> def add ( self , id , proxy ) : <EOL> self . _mutex . acquire ( ) <EOL> self . _cache [ id ] = ( proxy , int ( time . time ( ) ) ) <EOL> self . _mutex . release ( ) <EOL> def clean ( self ) : <EOL> now = int ( time . time ( ) ) <EOL> self . _mutex . acquire ( ) <EOL> for id , conn in self . _cache . items ( ) : <EOL> if conn [ <NUM_LIT:1> ] + <NUM_LIT> < now : <EOL> conn [ <NUM_LIT:0> ] . close ( ) <EOL> del self . _cache [ id ] <EOL> self . _mutex . release ( ) <EOL> def has_key ( self , id ) : <EOL> return self . _cache . has_key ( id ) <EOL> def get_proxy ( self , id ) : <EOL> self . _mutex . acquire ( ) <EOL> proxy = self . _cache [ id ] [ <NUM_LIT:0> ] <EOL> self . _mutex . release ( ) <EOL> return proxy <EOL> class CacheGroups : <EOL> def __init__ ( self ) : <EOL> self . _mutex = Lock ( ) <EOL> self . _cache = { } <EOL> def __len__ ( self ) : <EOL> return len ( self . _cache ) <EOL> def add ( self , group , user ) : <EOL> self . _mutex . acquire ( ) <EOL> if not self . _cache . has_key ( group ) : <EOL> self . _cache [ group ] = { } <EOL> self . _cache [ group ] [ user ] = int ( time . time ( ) ) <EOL> self . _mutex . release ( ) <EOL> def clean ( self ) : <EOL> now = int ( time . time ( ) ) <EOL> self . _mutex . acquire ( ) <EOL> old = [ ] <EOL> for group , members in self . _cache . items ( ) : <EOL> for user in members : <EOL> if members [ user ] + <NUM_LIT:3> * <NUM_LIT> * <NUM_LIT> < now : <EOL> old . append ( ( group , user ) ) <EOL> for group , user in old : <EOL> del self . _cache [ group ] [ user ] <EOL> self . _mutex . release ( ) <EOL> def has ( self , group , user ) : <EOL> if not self . _cache . has_key ( group ) : <EOL> return False <EOL> return self . _cache [ group ] . has_key ( user ) <EOL> cache = CacheConnections ( ) <EOL> cacheGroups = CacheGroups ( ) <EOL> def ntlm_message_type ( msg ) : <EOL> if not msg . startswith ( '<STR_LIT>' ) or len ( msg ) < <NUM_LIT:12> : <EOL> raise RuntimeError ( "<STR_LIT>" % hexlify ( msg ) ) <EOL> msg_type = unpack ( '<STR_LIT>' , msg [ <NUM_LIT:8> : <NUM_LIT:8> + <NUM_LIT:4> ] ) [ <NUM_LIT:0> ] <EOL> if msg_type not in ( <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:3> ) : <EOL> raise RuntimeError ( "<STR_LIT>" % msg_type ) <EOL> return msg_type <EOL> def parse_ntlm_authenticate ( msg ) : <EOL> '''<STR_LIT>''' <EOL> NTLMSSP_NEGOTIATE_UNICODE = <NUM_LIT> <EOL> idx = <NUM_LIT> <EOL> length , offset = unpack ( '<STR_LIT>' , msg [ idx : idx + <NUM_LIT:8> ] ) <EOL> domain = msg [ offset : offset + length ] <EOL> idx += <NUM_LIT:8> <EOL> length , offset = unpack ( '<STR_LIT>' , msg [ idx : idx + <NUM_LIT:8> ] ) <EOL> username = msg [ offset : offset + length ] <EOL> idx += <NUM_LIT> <EOL> flags = unpack ( '<STR_LIT>' , msg [ idx : idx + <NUM_LIT:4> ] ) [ <NUM_LIT:0> ] <EOL> if flags & NTLMSSP_NEGOTIATE_UNICODE : <EOL> domain = str ( domain . decode ( '<STR_LIT>' ) ) <EOL> username = str ( username . decode ( '<STR_LIT>' ) ) <EOL> return username , domain <EOL> def set_remote_user ( req , username , domain ) : <EOL> format = req . get_options ( ) . get ( '<STR_LIT>' , '<STR_LIT>' ) . lower ( ) <EOL> if format == '<STR_LIT>' : <EOL> req . user = domain + '<STR_LIT:\\>' + username <EOL> else : <EOL> req . user = username <EOL> def decode_http_authorization_header ( auth ) : <EOL> '''<STR_LIT>''' <EOL> ah = auth . split ( '<STR_LIT:U+0020>' ) <EOL> if len ( ah ) == <NUM_LIT:2> : <EOL> b64 = base64 . b64decode ( ah [ <NUM_LIT:1> ] ) <EOL> if ah [ <NUM_LIT:0> ] == '<STR_LIT>' : <EOL> return ( '<STR_LIT>' , b64 ) <EOL> elif ah [ <NUM_LIT:0> ] == '<STR_LIT>' and use_basic_auth : <EOL> ( user , password ) = b64 . split ( '<STR_LIT::>' ) <EOL> return ( '<STR_LIT>' , user , password ) <EOL> return False <EOL> def handle_unauthorized ( req ) : <EOL> '''<STR_LIT>''' <EOL> req . err_headers_out . add ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> if use_basic_auth : <EOL> req . err_headers_out . add ( '<STR_LIT>' , '<STR_LIT>' % req . auth_name ( ) ) <EOL> req . err_headers_out . add ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> return apache . HTTP_UNAUTHORIZED <EOL> def connect_to_proxy ( req , type1 ) : <EOL> '''<STR_LIT>''' <EOL> try : <EOL> domain = req . get_options ( ) [ '<STR_LIT>' ] <EOL> pdc = req . get_options ( ) [ '<STR_LIT>' ] <EOL> bdc = req . get_options ( ) . get ( '<STR_LIT>' , False ) <EOL> except KeyError , e : <EOL> req . log_error ( '<STR_LIT>' % str ( e ) , apache . APLOG_CRIT ) <EOL> raise <EOL> ntlm_challenge = None <EOL> for server in ( pdc , bdc ) : <EOL> if not server : continue <EOL> try : <EOL> if server . startswith ( '<STR_LIT>' ) : <EOL> url = urlparse ( server ) <EOL> decoded_path = urllib . unquote ( url . path ) [ <NUM_LIT:1> : ] <EOL> req . log_error ( '<STR_LIT>' % <EOL> ( url . netloc , domain , decoded_path ) , apache . APLOG_INFO ) <EOL> proxy = NTLM_AD_Proxy ( url . netloc , domain , base = decoded_path ) <EOL> else : <EOL> req . log_error ( '<STR_LIT>' % <EOL> ( server , domain ) , apache . APLOG_INFO ) <EOL> proxy = NTLM_DC_Proxy ( server , domain ) <EOL> ntlm_challenge = proxy . negotiate ( type1 ) <EOL> except Exception , e : <EOL> req . log_error ( '<STR_LIT>' % ( server , str ( e ) ) , apache . APLOG_CRIT ) <EOL> if ntlm_challenge : break <EOL> proxy . close ( ) <EOL> else : <EOL> raise RuntimeError ( "<STR_LIT>" ) <EOL> return ( proxy , ntlm_challenge ) <EOL> def handle_type1 ( req , ntlm_message ) : <EOL> '''<STR_LIT>''' <EOL> cache . remove ( req . connection . id ) <EOL> cache . clean ( ) <EOL> try : <EOL> ( proxy , ntlm_challenge ) = connect_to_proxy ( req , ntlm_message ) <EOL> except Exception , e : <EOL> return apache . HTTP_INTERNAL_SERVER_ERROR <EOL> cache . add ( req . connection . id , proxy ) <EOL> req . err_headers_out . add ( '<STR_LIT>' , "<STR_LIT>" + base64 . b64encode ( ntlm_challenge ) ) <EOL> return apache . HTTP_UNAUTHORIZED <EOL> def check_authorization ( req , username , proxy ) : <EOL> '''<STR_LIT>''' <EOL> rules = '<STR_LIT>' . join ( req . requires ( ) ) . strip ( ) <EOL> if rules == '<STR_LIT>' or cacheGroups . has ( rules , username ) : <EOL> return True <EOL> groups = [ ] <EOL> for r in req . requires ( ) : <EOL> if r . lower ( ) . startswith ( "<STR_LIT>" ) : <EOL> users = [ u . strip ( ) for u in r [ <NUM_LIT:5> : ] . split ( "<STR_LIT:U+002C>" ) ] <EOL> if username in users : <EOL> req . log_error ( '<STR_LIT>' % <EOL> ( username , req . unparsed_uri ) , apache . APLOG_INFO ) <EOL> return True <EOL> if r . lower ( ) . startswith ( "<STR_LIT>" ) : <EOL> groups += [ g . strip ( ) for g in r [ <NUM_LIT:6> : ] . split ( "<STR_LIT:U+002C>" ) ] <EOL> if groups : <EOL> try : <EOL> res = proxy . check_membership ( username , groups ) <EOL> except Exception , e : <EOL> req . log_error ( '<STR_LIT>' % ( username , str ( groups ) , req . unparsed_uri , str ( e ) ) ) <EOL> if res : <EOL> cacheGroups . add ( rules , username ) <EOL> req . log_error ( '<STR_LIT>' % <EOL> ( username , str ( groups ) , req . unparsed_uri ) , apache . APLOG_INFO ) <EOL> return True <EOL> req . log_error ( '<STR_LIT>' % <EOL> ( username , str ( groups ) , req . unparsed_uri ) ) <EOL> else : <EOL> req . log_error ( '<STR_LIT>' % <EOL> ( username , req . unparsed_uri ) ) <EOL> return False <EOL> def handle_type3 ( req , ntlm_message ) : <EOL> '''<STR_LIT>''' <EOL> proxy = cache . get_proxy ( req . connection . id ) <EOL> try : <EOL> user , domain = parse_ntlm_authenticate ( ntlm_message ) <EOL> if not domain : <EOL> domain = req . get_options ( ) . get ( '<STR_LIT>' , req . auth_name ( ) ) <EOL> result = proxy . authenticate ( ntlm_message ) <EOL> except Exception , e : <EOL> req . log_error ( '<STR_LIT>' % str ( e ) , apache . APLOG_CRIT ) <EOL> user , domain = '<STR_LIT>' , '<STR_LIT>' <EOL> result = False <EOL> if not result : <EOL> cache . remove ( req . connection . id ) <EOL> req . log_error ( '<STR_LIT>' % ( <EOL> domain , user , req . unparsed_uri ) ) <EOL> return handle_unauthorized ( req ) <EOL> req . log_error ( '<STR_LIT>' % ( user , domain , req . unparsed_uri ) , apache . APLOG_NOTICE ) <EOL> set_remote_user ( req , user , domain ) <EOL> result = check_authorization ( req , user , proxy ) <EOL> cache . remove ( req . connection . id ) <EOL> if not result : <EOL> return apache . HTTP_FORBIDDEN <EOL> req . connection . notes . add ( '<STR_LIT>' , req . user ) <EOL> return apache . OK <EOL> def handle_basic ( req , user , password ) : <EOL> '''<STR_LIT>''' <EOL> req . log_error ( '<STR_LIT>' % ( req . unparsed_uri ) ) <EOL> domain = req . get_options ( ) . get ( '<STR_LIT>' , req . auth_name ( ) ) <EOL> client = NTLM_Client ( user , domain , password ) <EOL> type1 = client . make_ntlm_negotiate ( ) <EOL> try : <EOL> ( proxy , type2 ) = connect_to_proxy ( req , type1 ) <EOL> except Exception , e : <EOL> return apache . HTTP_INTERNAL_SERVER_ERROR <EOL> client . parse_ntlm_challenge ( type2 ) <EOL> type3 = client . make_ntlm_authenticate ( ) <EOL> if not proxy . authenticate ( type3 ) : <EOL> proxy . close ( ) <EOL> req . log_error ( '<STR_LIT>' % ( <EOL> user , domain , req . unparsed_uri ) ) <EOL> return handle_unauthorized ( req ) <EOL> req . log_error ( '<STR_LIT>' % ( user , domain , req . unparsed_uri ) , apache . APLOG_NOTICE ) <EOL> set_remote_user ( req , user , domain ) <EOL> result = check_authorization ( req , user , proxy ) <EOL> proxy . close ( ) <EOL> if not result : <EOL> return apache . HTTP_FORBIDDEN <EOL> req . connection . notes . add ( '<STR_LIT>' , user + password ) <EOL> return apache . OK <EOL> def authenhandler ( req ) : <EOL> '''<STR_LIT>''' <EOL> req . log_error ( "<STR_LIT>" % ( <EOL> req . connection . id , req . method , req . unparsed_uri , len ( cache ) ) , apache . APLOG_INFO ) <EOL> auth_headers = req . headers_in . get ( '<STR_LIT>' , [ ] ) <EOL> if not isinstance ( auth_headers , list ) : <EOL> auth_headers = [ auth_headers ] <EOL> user = req . connection . notes . get ( '<STR_LIT>' , None ) <EOL> if user : <EOL> req . user = user <EOL> if auth_headers : <EOL> req . log_error ( '<STR_LIT>' % ( <EOL> req . connection . id , req . method , req . clength , auth_headers ) , apache . APLOG_INFO ) <EOL> if req . method != '<STR_LIT:POST>' or req . clength > <NUM_LIT:0> : <EOL> return apache . OK <EOL> else : <EOL> return apache . OK <EOL> if not auth_headers : <EOL> return handle_unauthorized ( req ) <EOL> try : <EOL> for ah in auth_headers : <EOL> ah_data = decode_http_authorization_header ( ah ) <EOL> if ah_data : <EOL> break <EOL> except : <EOL> ah_data = False <EOL> if not ah_data : <EOL> req . log_error ( '<STR_LIT>' % req . unparsed_uri , apache . APLOG_ERR ) <EOL> return apache . HTTP_BAD_REQUEST <EOL> if ah_data [ <NUM_LIT:0> ] == '<STR_LIT>' : <EOL> userpwd = req . connection . notes . get ( '<STR_LIT>' , None ) <EOL> if userpwd : <EOL> if userpwd != ah_data [ <NUM_LIT:1> ] + ah_data [ <NUM_LIT:2> ] : <EOL> return handle_unauthorized ( req ) <EOL> domain = req . get_options ( ) . get ( '<STR_LIT>' , req . auth_name ( ) ) <EOL> set_remote_user ( req , ah_data [ <NUM_LIT:1> ] , domain ) <EOL> return apache . OK <EOL> return handle_basic ( req , ah_data [ <NUM_LIT:1> ] , ah_data [ <NUM_LIT:2> ] ) <EOL> try : <EOL> ntlm_version = ntlm_message_type ( ah_data [ <NUM_LIT:1> ] ) <EOL> if ntlm_version == <NUM_LIT:1> : <EOL> return handle_type1 ( req , ah_data [ <NUM_LIT:1> ] ) <EOL> if ntlm_version == <NUM_LIT:3> : <EOL> if cache . has_key ( req . connection . id ) : <EOL> return handle_type3 ( req , ah_data [ <NUM_LIT:1> ] ) <EOL> req . log_error ( '<STR_LIT>' % <EOL> ( req . unparsed_uri ) , apache . APLOG_INFO ) <EOL> return handle_unauthorized ( req ) <EOL> error = '<STR_LIT>' <EOL> except Exception , e : <EOL> error = str ( e ) <EOL> req . log_error ( '<STR_LIT>' % <EOL> ( req . unparsed_uri , error ) , apache . APLOG_ERR ) <EOL> return apache . HTTP_BAD_REQUEST </s>
<s> from celery import Celery <EOL> def create_celery_app ( app ) : <EOL> if app . config . get ( '<STR_LIT>' ) : <EOL> app . celery = Celery ( __name__ , broker = app . config [ '<STR_LIT>' ] ) <EOL> app . celery . conf . update ( app . config ) <EOL> taskbase = app . celery . Task <EOL> class ContextTask ( taskbase ) : <EOL> abstract = True <EOL> def __call__ ( self , * args , ** kwargs ) : <EOL> with app . app_context ( ) : <EOL> return taskbase . __call__ ( self , * args , ** kwargs ) <EOL> app . celery . Task = ContextTask </s>
<s> import unittest <EOL> import os <EOL> import sys <EOL> import json <EOL> sys . path . append ( os . path . dirname ( os . path . realpath ( __file__ ) . rsplit ( '<STR_LIT:/>' , <NUM_LIT:2> ) [ <NUM_LIT:0> ] ) ) <EOL> from app import create_app <EOL> app = create_app ( '<STR_LIT>' ) <EOL> add_data = """<STR_LIT>""" <EOL> update_data = """<STR_LIT>""" <EOL> class TestUsers ( unittest . TestCase ) : <EOL> def setUp ( self ) : <EOL> self . app = app . test_client ( ) <EOL> def test_01_add ( self ) : <EOL> rv = self . app . post ( '<STR_LIT>' , data = add_data , <EOL> content_type = "<STR_LIT:application/json>" ) <EOL> assert rv . status_code == <NUM_LIT> <EOL> def test_02_read_update ( self ) : <EOL> request = self . app . get ( '<STR_LIT>' ) <EOL> dict = json . loads ( request . data . decode ( '<STR_LIT:utf-8>' ) ) <EOL> id = dict [ '<STR_LIT:data>' ] [ <NUM_LIT:0> ] [ '<STR_LIT:id>' ] <EOL> rv = self . app . patch ( '<STR_LIT>' . format ( id ) , <EOL> data = update_data , content_type = "<STR_LIT:application/json>" ) <EOL> assert rv . status_code == <NUM_LIT:200> <EOL> def test_03_delete ( self ) : <EOL> request = self . app . get ( '<STR_LIT>' ) <EOL> dict = json . loads ( request . data . decode ( '<STR_LIT:utf-8>' ) ) <EOL> id = dict [ '<STR_LIT:data>' ] [ <NUM_LIT:0> ] [ '<STR_LIT:id>' ] <EOL> rv = self . app . delete ( '<STR_LIT>' . format ( id ) ) <EOL> assert rv . status_code == <NUM_LIT> <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL> unittest . main ( ) </s>
<s> """<STR_LIT>""" <EOL> def tokenProgressFunc ( state = "<STR_LIT>" , action = None , text = None , tick = <NUM_LIT:0> ) : <EOL> """<STR_LIT>""" <EOL> print ( "<STR_LIT>" % ( state , str ( title ) , str ( text ) , str ( tick ) ) ) <EOL> def build ( <EOL> documentPath , <EOL> outputUFOFormatVersion = <NUM_LIT:2> , <EOL> roundGeometry = True , <EOL> verbose = True , <EOL> logPath = None , <EOL> progressFunc = None , <EOL> ) : <EOL> """<STR_LIT>""" <EOL> from mutatorMath . ufo . document import DesignSpaceDocumentReader <EOL> import os , glob <EOL> if os . path . isdir ( documentPath ) : <EOL> todo = glob . glob ( os . path . join ( documentPath , "<STR_LIT>" ) ) <EOL> else : <EOL> todo = [ documentPath ] <EOL> results = [ ] <EOL> for path in todo : <EOL> reader = DesignSpaceDocumentReader ( <EOL> path , <EOL> ufoVersion = outputUFOFormatVersion , <EOL> roundGeometry = roundGeometry , <EOL> verbose = verbose , <EOL> logPath = logPath , <EOL> progressFunc = progressFunc <EOL> ) <EOL> reader . process ( ) <EOL> results . append ( reader . results ) <EOL> reader = None <EOL> return results </s>
<s> from django . core . management . base import BaseCommand <EOL> from chronam . core . management . commands import configure_logging <EOL> from chronam . core . index import index_pages <EOL> configure_logging ( "<STR_LIT>" , "<STR_LIT>" ) <EOL> class Command ( BaseCommand ) : <EOL> def handle ( self , ** options ) : <EOL> index_pages ( ) </s>
<s> import os <EOL> from django . conf import settings <EOL> from django . http import HttpResponse <EOL> class HttpResponseServiceUnavailable ( HttpResponse ) : <EOL> status_code = <NUM_LIT> <EOL> class TooBusyMiddleware ( object ) : <EOL> def process_request ( self , request ) : <EOL> one , five , fifteen = os . getloadavg ( ) <EOL> if one > settings . TOO_BUSY_LOAD_AVERAGE : <EOL> return HttpResponseServiceUnavailable ( """<STR_LIT>""" ) <EOL> return None </s>
<s> from os . path import dirname , join <EOL> from django . test import TestCase <EOL> from chronam . core . ocr_extractor import ocr_extractor <EOL> class OcrExtractorTests ( TestCase ) : <EOL> def test_extractor ( self ) : <EOL> dir = join ( dirname ( dirname ( __file__ ) ) , '<STR_LIT>' ) <EOL> ocr_file = join ( dir , '<STR_LIT>' ) <EOL> text , coord_info = ocr_extractor ( ocr_file ) <EOL> coords = coord_info [ "<STR_LIT>" ] <EOL> expected_text = { "<STR_LIT>" : file ( join ( dir , '<STR_LIT>' ) ) . read ( ) . decode ( '<STR_LIT:utf-8>' ) } <EOL> self . assertEqual ( text , expected_text ) <EOL> self . assertEqual ( len ( coords . keys ( ) ) , <NUM_LIT> ) <EOL> self . assertEqual ( len ( coords [ '<STR_LIT>' ] ) , <NUM_LIT:3> ) <EOL> self . assertTrue ( coords . has_key ( '<STR_LIT>' ) ) <EOL> self . assertTrue ( not coords . has_key ( '<STR_LIT>' ) ) </s>
<s> """<STR_LIT>""" <EOL> import logging <EOL> from . tests import * <EOL> logger = logging . getLogger ( "<STR_LIT>" ) <EOL> logger . setLevel ( logging . DEBUG ) <EOL> handler = logging . StreamHandler ( ) <EOL> formatter = logging . Formatter ( "<STR_LIT>" ) <EOL> handler . setFormatter ( formatter ) <EOL> logger . addHandler ( handler ) </s>
<s> """<STR_LIT>""" <EOL> from __future__ import print_function <EOL> import argparse <EOL> import datetime <EOL> import json <EOL> import multiprocessing <EOL> import os <EOL> import random <EOL> import sys <EOL> import threading <EOL> import time <EOL> import numpy as np <EOL> from PIL import Image <EOL> import six <EOL> import six . moves . cPickle as pickle <EOL> from six . moves import queue <EOL> import chainer <EOL> from chainer import computational_graph <EOL> from chainer import cuda <EOL> from chainer import optimizers <EOL> from chainer import serializers <EOL> parser = argparse . ArgumentParser ( <EOL> description = '<STR_LIT>' ) <EOL> parser . add_argument ( '<STR_LIT:train>' , help = '<STR_LIT>' ) <EOL> parser . add_argument ( '<STR_LIT>' , help = '<STR_LIT>' ) <EOL> parser . add_argument ( '<STR_LIT>' , '<STR_LIT>' , default = '<STR_LIT>' , <EOL> help = '<STR_LIT>' ) <EOL> parser . add_argument ( '<STR_LIT>' , '<STR_LIT>' , default = '<STR_LIT>' , <EOL> help = '<STR_LIT>' ) <EOL> parser . add_argument ( '<STR_LIT>' , '<STR_LIT>' , type = int , default = <NUM_LIT:32> , <EOL> help = '<STR_LIT>' ) <EOL> parser . add_argument ( '<STR_LIT>' , '<STR_LIT>' , type = int , default = <NUM_LIT> , <EOL> help = '<STR_LIT>' ) <EOL> parser . add_argument ( '<STR_LIT>' , '<STR_LIT>' , default = <NUM_LIT:10> , type = int , <EOL> help = '<STR_LIT>' ) <EOL> parser . add_argument ( '<STR_LIT>' , '<STR_LIT>' , default = - <NUM_LIT:1> , type = int , <EOL> help = '<STR_LIT>' ) <EOL> parser . add_argument ( '<STR_LIT>' , '<STR_LIT>' , default = <NUM_LIT:20> , type = int , <EOL> help = '<STR_LIT>' ) <EOL> parser . add_argument ( '<STR_LIT>' , '<STR_LIT>' , default = '<STR_LIT:.>' , <EOL> help = '<STR_LIT>' ) <EOL> parser . add_argument ( '<STR_LIT>' , '<STR_LIT>' , default = '<STR_LIT>' , <EOL> help = '<STR_LIT>' ) <EOL> parser . add_argument ( '<STR_LIT>' , '<STR_LIT>' , default = '<STR_LIT:state>' , <EOL> help = '<STR_LIT>' ) <EOL> parser . add_argument ( '<STR_LIT>' , default = '<STR_LIT>' , <EOL> help = '<STR_LIT>' ) <EOL> parser . add_argument ( '<STR_LIT>' , default = '<STR_LIT>' , <EOL> help = '<STR_LIT>' ) <EOL> args = parser . parse_args ( ) <EOL> if args . gpu >= <NUM_LIT:0> : <EOL> cuda . check_cuda_available ( ) <EOL> xp = cuda . cupy if args . gpu >= <NUM_LIT:0> else np <EOL> assert <NUM_LIT> % args . val_batchsize == <NUM_LIT:0> <EOL> def load_image_list ( path , root ) : <EOL> tuples = [ ] <EOL> for line in open ( path ) : <EOL> pair = line . strip ( ) . split ( ) <EOL> tuples . append ( ( os . path . join ( root , pair [ <NUM_LIT:0> ] ) , np . int32 ( pair [ <NUM_LIT:1> ] ) ) ) <EOL> return tuples <EOL> train_list = load_image_list ( args . train , args . root ) <EOL> val_list = load_image_list ( args . val , args . root ) <EOL> mean_image = pickle . load ( open ( args . mean , '<STR_LIT:rb>' ) ) <EOL> if args . arch == '<STR_LIT>' : <EOL> import nin <EOL> model = nin . NIN ( ) <EOL> elif args . arch == '<STR_LIT>' : <EOL> import alex <EOL> model = alex . Alex ( ) <EOL> elif args . arch == '<STR_LIT>' : <EOL> import alexbn <EOL> model = alexbn . AlexBN ( ) <EOL> elif args . arch == '<STR_LIT>' : <EOL> import googlenet <EOL> model = googlenet . GoogLeNet ( ) <EOL> elif args . arch == '<STR_LIT>' : <EOL> import googlenetbn <EOL> model = googlenetbn . GoogLeNetBN ( ) <EOL> else : <EOL> raise ValueError ( '<STR_LIT>' ) <EOL> if args . gpu >= <NUM_LIT:0> : <EOL> cuda . get_device ( args . gpu ) . use ( ) <EOL> model . to_gpu ( ) <EOL> optimizer = optimizers . MomentumSGD ( lr = <NUM_LIT> , momentum = <NUM_LIT> ) <EOL> optimizer . setup ( model ) <EOL> if args . initmodel : <EOL> print ( '<STR_LIT>' , args . initmodel ) <EOL> serializers . load_hdf5 ( args . initmodel , model ) <EOL> if args . resume : <EOL> print ( '<STR_LIT>' , args . resume ) <EOL> serializers . load_hdf5 ( args . resume , optimizer ) <EOL> data_q = queue . Queue ( maxsize = <NUM_LIT:1> ) <EOL> res_q = queue . Queue ( ) <EOL> cropwidth = <NUM_LIT> - model . insize <EOL> def read_image ( path , center = False , flip = False ) : <EOL> image = np . asarray ( Image . open ( path ) ) . transpose ( <NUM_LIT:2> , <NUM_LIT:0> , <NUM_LIT:1> ) <EOL> if center : <EOL> top = left = cropwidth / <NUM_LIT:2> <EOL> else : <EOL> top = random . randint ( <NUM_LIT:0> , cropwidth - <NUM_LIT:1> ) <EOL> left = random . randint ( <NUM_LIT:0> , cropwidth - <NUM_LIT:1> ) <EOL> bottom = model . insize + top <EOL> right = model . insize + left <EOL> image = image [ : , top : bottom , left : right ] . astype ( np . float32 ) <EOL> image -= mean_image [ : , top : bottom , left : right ] <EOL> image /= <NUM_LIT:255> <EOL> if flip and random . randint ( <NUM_LIT:0> , <NUM_LIT:1> ) == <NUM_LIT:0> : <EOL> return image [ : , : , : : - <NUM_LIT:1> ] <EOL> else : <EOL> return image <EOL> def feed_data ( ) : <EOL> i = <NUM_LIT:0> <EOL> count = <NUM_LIT:0> <EOL> x_batch = np . ndarray ( <EOL> ( args . batchsize , <NUM_LIT:3> , model . insize , model . insize ) , dtype = np . float32 ) <EOL> y_batch = np . ndarray ( ( args . batchsize , ) , dtype = np . int32 ) <EOL> val_x_batch = np . ndarray ( <EOL> ( args . val_batchsize , <NUM_LIT:3> , model . insize , model . insize ) , dtype = np . float32 ) <EOL> val_y_batch = np . ndarray ( ( args . val_batchsize , ) , dtype = np . int32 ) <EOL> batch_pool = [ None ] * args . batchsize <EOL> val_batch_pool = [ None ] * args . val_batchsize <EOL> pool = multiprocessing . Pool ( args . loaderjob ) <EOL> data_q . put ( '<STR_LIT:train>' ) <EOL> for epoch in six . moves . range ( <NUM_LIT:1> , <NUM_LIT:1> + args . epoch ) : <EOL> print ( '<STR_LIT>' , epoch , file = sys . stderr ) <EOL> print ( '<STR_LIT>' , optimizer . lr , file = sys . stderr ) <EOL> perm = np . random . permutation ( len ( train_list ) ) <EOL> for idx in perm : <EOL> path , label = train_list [ idx ] <EOL> batch_pool [ i ] = pool . apply_async ( read_image , ( path , False , True ) ) <EOL> y_batch [ i ] = label <EOL> i += <NUM_LIT:1> <EOL> if i == args . batchsize : <EOL> for j , x in enumerate ( batch_pool ) : <EOL> x_batch [ j ] = x . get ( ) <EOL> data_q . put ( ( x_batch . copy ( ) , y_batch . copy ( ) ) ) <EOL> i = <NUM_LIT:0> <EOL> count += <NUM_LIT:1> <EOL> if count % <NUM_LIT:1000> == <NUM_LIT:0> : <EOL> data_q . put ( '<STR_LIT>' ) <EOL> j = <NUM_LIT:0> <EOL> for path , label in val_list : <EOL> val_batch_pool [ j ] = pool . apply_async ( <EOL> read_image , ( path , True , False ) ) <EOL> val_y_batch [ j ] = label <EOL> j += <NUM_LIT:1> <EOL> if j == args . val_batchsize : <EOL> for k , x in enumerate ( val_batch_pool ) : <EOL> val_x_batch [ k ] = x . get ( ) <EOL> data_q . put ( ( val_x_batch . copy ( ) , val_y_batch . copy ( ) ) ) <EOL> j = <NUM_LIT:0> <EOL> data_q . put ( '<STR_LIT:train>' ) <EOL> optimizer . lr *= <NUM_LIT> <EOL> pool . close ( ) <EOL> pool . join ( ) <EOL> data_q . put ( '<STR_LIT:end>' ) <EOL> def log_result ( ) : <EOL> train_count = <NUM_LIT:0> <EOL> train_cur_loss = <NUM_LIT:0> <EOL> train_cur_accuracy = <NUM_LIT:0> <EOL> begin_at = time . time ( ) <EOL> val_begin_at = None <EOL> while True : <EOL> result = res_q . get ( ) <EOL> if result == '<STR_LIT:end>' : <EOL> print ( file = sys . stderr ) <EOL> break <EOL> elif result == '<STR_LIT:train>' : <EOL> print ( file = sys . stderr ) <EOL> train = True <EOL> if val_begin_at is not None : <EOL> begin_at += time . time ( ) - val_begin_at <EOL> val_begin_at = None <EOL> continue <EOL> elif result == '<STR_LIT>' : <EOL> print ( file = sys . stderr ) <EOL> train = False <EOL> val_count = val_loss = val_accuracy = <NUM_LIT:0> <EOL> val_begin_at = time . time ( ) <EOL> continue <EOL> loss , accuracy = result <EOL> if train : <EOL> train_count += <NUM_LIT:1> <EOL> duration = time . time ( ) - begin_at <EOL> throughput = train_count * args . batchsize / duration <EOL> sys . stderr . write ( <EOL> '<STR_LIT>' <EOL> . format ( train_count , train_count * args . batchsize , <EOL> datetime . timedelta ( seconds = duration ) , throughput ) ) <EOL> train_cur_loss += loss <EOL> train_cur_accuracy += accuracy <EOL> if train_count % <NUM_LIT:1000> == <NUM_LIT:0> : <EOL> mean_loss = train_cur_loss / <NUM_LIT:1000> <EOL> mean_error = <NUM_LIT:1> - train_cur_accuracy / <NUM_LIT:1000> <EOL> print ( file = sys . stderr ) <EOL> print ( json . dumps ( { '<STR_LIT:type>' : '<STR_LIT:train>' , '<STR_LIT>' : train_count , <EOL> '<STR_LIT:error>' : mean_error , '<STR_LIT>' : mean_loss } ) ) <EOL> sys . stdout . flush ( ) <EOL> train_cur_loss = <NUM_LIT:0> <EOL> train_cur_accuracy = <NUM_LIT:0> <EOL> else : <EOL> val_count += args . val_batchsize <EOL> duration = time . time ( ) - val_begin_at <EOL> throughput = val_count / duration <EOL> sys . stderr . write ( <EOL> '<STR_LIT>' <EOL> . format ( val_count / args . val_batchsize , val_count , <EOL> datetime . timedelta ( seconds = duration ) , throughput ) ) <EOL> val_loss += loss <EOL> val_accuracy += accuracy <EOL> if val_count == <NUM_LIT> : <EOL> mean_loss = val_loss * args . val_batchsize / <NUM_LIT> <EOL> mean_error = <NUM_LIT:1> - val_accuracy * args . val_batchsize / <NUM_LIT> <EOL> print ( file = sys . stderr ) <EOL> print ( json . dumps ( { '<STR_LIT:type>' : '<STR_LIT>' , '<STR_LIT>' : train_count , <EOL> '<STR_LIT:error>' : mean_error , '<STR_LIT>' : mean_loss } ) ) <EOL> sys . stdout . flush ( ) <EOL> def train_loop ( ) : <EOL> graph_generated = False <EOL> while True : <EOL> while data_q . empty ( ) : <EOL> time . sleep ( <NUM_LIT:0.1> ) <EOL> inp = data_q . get ( ) <EOL> if inp == '<STR_LIT:end>' : <EOL> res_q . put ( '<STR_LIT:end>' ) <EOL> break <EOL> elif inp == '<STR_LIT:train>' : <EOL> res_q . put ( '<STR_LIT:train>' ) <EOL> model . train = True <EOL> continue <EOL> elif inp == '<STR_LIT>' : <EOL> res_q . put ( '<STR_LIT>' ) <EOL> serializers . save_hdf5 ( args . out , model ) <EOL> serializers . save_hdf5 ( args . outstate , optimizer ) <EOL> model . train = False <EOL> continue <EOL> volatile = '<STR_LIT>' if model . train else '<STR_LIT>' <EOL> x = chainer . Variable ( xp . asarray ( inp [ <NUM_LIT:0> ] ) , volatile = volatile ) <EOL> t = chainer . Variable ( xp . asarray ( inp [ <NUM_LIT:1> ] ) , volatile = volatile ) <EOL> if model . train : <EOL> optimizer . update ( model , x , t ) <EOL> if not graph_generated : <EOL> with open ( '<STR_LIT>' , '<STR_LIT:w>' ) as o : <EOL> o . write ( computational_graph . build_computational_graph ( <EOL> ( model . loss , ) ) . dump ( ) ) <EOL> print ( '<STR_LIT>' , file = sys . stderr ) <EOL> graph_generated = True <EOL> else : <EOL> model ( x , t ) <EOL> res_q . put ( ( float ( model . loss . data ) , float ( model . accuracy . data ) ) ) <EOL> del x , t <EOL> feeder = threading . Thread ( target = feed_data ) <EOL> feeder . daemon = True <EOL> feeder . start ( ) <EOL> logger = threading . Thread ( target = log_result ) <EOL> logger . daemon = True <EOL> logger . start ( ) <EOL> train_loop ( ) <EOL> feeder . join ( ) <EOL> logger . join ( ) <EOL> serializers . save_hdf5 ( args . out , model ) <EOL> serializers . save_hdf5 ( args . outstate , optimizer ) </s>
<s> import sys , os <EOL> sys . path . insert ( <NUM_LIT:0> , os . path . abspath ( '<STR_LIT:..>' ) ) <EOL> import local_settings <EOL> extensions = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> templates_path = [ '<STR_LIT>' ] <EOL> source_suffix = '<STR_LIT>' <EOL> master_doc = '<STR_LIT:index>' <EOL> project = u'<STR_LIT>' <EOL> copyright = u'<STR_LIT>' <EOL> html_show_copyright = False <EOL> import djoauth2 <EOL> version = djoauth2 . __version__ <EOL> release = djoauth2 . __version__ <EOL> exclude_patterns = [ '<STR_LIT>' ] <EOL> pygments_style = '<STR_LIT>' <EOL> html_theme = '<STR_LIT:default>' <EOL> html_static_path = [ '<STR_LIT>' ] <EOL> htmlhelp_basename = '<STR_LIT>' <EOL> latex_elements = { <EOL> } <EOL> latex_documents = [ <EOL> ( '<STR_LIT:index>' , '<STR_LIT>' , u'<STR_LIT>' , <EOL> u'<STR_LIT>' , '<STR_LIT>' ) , <EOL> ] <EOL> man_pages = [ <EOL> ( '<STR_LIT:index>' , '<STR_LIT>' , u'<STR_LIT>' , <EOL> [ u'<STR_LIT>' ] , <NUM_LIT:1> ) <EOL> ] <EOL> texinfo_documents = [ <EOL> ( '<STR_LIT:index>' , '<STR_LIT>' , u'<STR_LIT>' , <EOL> u'<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , <EOL> '<STR_LIT>' ) , <EOL> ] <EOL> epub_title = u'<STR_LIT>' <EOL> epub_author = u'<STR_LIT>' <EOL> epub_publisher = u'<STR_LIT>' <EOL> epub_copyright = u'<STR_LIT>' </s>
<s> import asyncio <EOL> from zeroservices import ZeroMQMedium , ResourceService <EOL> from zeroservices . services import get_http_interface <EOL> from zeroservices . discovery import UdpDiscoveryMedium <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL> loop = asyncio . get_event_loop ( ) <EOL> medium = ZeroMQMedium ( loop , UdpDiscoveryMedium ) <EOL> service = ResourceService ( '<STR_LIT>' , medium ) <EOL> application = get_http_interface ( service , loop , port = <NUM_LIT> , allowed_origins = "<STR_LIT:*>" ) <EOL> application = loop . run_until_complete ( application ) <EOL> loop . run_until_complete ( service . start ( ) ) <EOL> loop . run_forever ( ) </s>
<s> """<STR_LIT>""" <EOL> import argparse <EOL> import sys <EOL> from trello import TrelloClient <EOL> from slugify import slugify <EOL> from matterllo . utils import config <EOL> from matterllo . utils import logger <EOL> SETTINGS = config ( ) <EOL> LOGGING = logger ( ) <EOL> def main ( ) : <EOL> try : <EOL> parser = argparse . ArgumentParser ( description = "<STR_LIT>" ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , action = '<STR_LIT:store_true>' , help = '<STR_LIT>' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , action = '<STR_LIT:store_true>' , help = '<STR_LIT>' ) <EOL> parser . add_argument ( '<STR_LIT>' , dest = '<STR_LIT>' , action = '<STR_LIT:store_true>' , help = '<STR_LIT>' ) <EOL> args = parser . parse_args ( ) <EOL> if not args . cleanup and not args . update and not args . init : <EOL> print parser . print_help ( ) <EOL> sys . exit ( <NUM_LIT:0> ) <EOL> client = TrelloClient ( api_key = SETTINGS [ '<STR_LIT>' ] , token = SETTINGS [ '<STR_LIT>' ] ) <EOL> trello_boards = client . list_boards ( ) <EOL> boards_name = [ slugify ( b [ '<STR_LIT:name>' ] ) for b in SETTINGS . get ( '<STR_LIT>' , { } ) . values ( ) ] <EOL> if args . cleanup or args . init : <EOL> result = [ h . delete ( ) for h in client . list_hooks ( ) ] <EOL> LOGGING . info ( '<STR_LIT>' . format ( len ( result ) ) ) <EOL> if args . update or args . init : <EOL> for board in trello_boards : <EOL> board_name = slugify ( board . name ) <EOL> if board_name not in boards_name : <EOL> continue <EOL> LOGGING . info ( '<STR_LIT>' . format ( board_name ) ) <EOL> url = SETTINGS [ '<STR_LIT>' ] + '<STR_LIT>' <EOL> result = client . create_hook ( url , board . id ) <EOL> LOGGING . info ( '<STR_LIT>' . format ( board_name , result ) ) <EOL> except Exception as e : <EOL> LOGGING . error ( '<STR_LIT>' . format ( e ) ) <EOL> sys . exit ( <NUM_LIT:1> ) <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL> main ( ) </s>
<s> """<STR_LIT>""" <EOL> from contextlib import contextmanager <EOL> import sys <EOL> import zlib <EOL> try : <EOL> from . import ssl_compat <EOL> except ImportError : <EOL> ssl_compat = None <EOL> _ver = sys . version_info <EOL> is_py2 = _ver [ <NUM_LIT:0> ] == <NUM_LIT:2> <EOL> is_py2_7_9_or_later = _ver [ <NUM_LIT:0> ] >= <NUM_LIT:2> and _ver [ <NUM_LIT:1> ] >= <NUM_LIT:7> and _ver [ <NUM_LIT:2> ] >= <NUM_LIT:9> <EOL> is_py3 = _ver [ <NUM_LIT:0> ] == <NUM_LIT:3> <EOL> is_py3_3 = is_py3 and _ver [ <NUM_LIT:1> ] == <NUM_LIT:3> <EOL> @ contextmanager <EOL> def ignore_missing ( ) : <EOL> try : <EOL> yield <EOL> except ( AttributeError , NotImplementedError ) : <EOL> pass <EOL> if is_py2 : <EOL> if is_py2_7_9_or_later : <EOL> import ssl <EOL> else : <EOL> ssl = ssl_compat <EOL> from urllib import urlencode <EOL> from urlparse import urlparse , urlsplit <EOL> from itertools import imap <EOL> def to_byte ( char ) : <EOL> return ord ( char ) <EOL> def decode_hex ( b ) : <EOL> return b . decode ( '<STR_LIT>' ) <EOL> def write_to_stdout ( data ) : <EOL> sys . stdout . write ( data + '<STR_LIT:\n>' ) <EOL> sys . stdout . flush ( ) <EOL> def zlib_compressobj ( level = <NUM_LIT:6> , method = zlib . DEFLATED , wbits = <NUM_LIT:15> , memlevel = <NUM_LIT:8> , <EOL> strategy = zlib . Z_DEFAULT_STRATEGY ) : <EOL> return zlib . compressobj ( level , method , wbits , memlevel , strategy ) <EOL> unicode = unicode <EOL> bytes = str <EOL> elif is_py3 : <EOL> from urllib . parse import urlencode , urlparse , urlsplit <EOL> imap = map <EOL> def to_byte ( char ) : <EOL> return char <EOL> def decode_hex ( b ) : <EOL> return bytes . fromhex ( b ) <EOL> def write_to_stdout ( data ) : <EOL> sys . stdout . buffer . write ( data + b'<STR_LIT:\n>' ) <EOL> sys . stdout . buffer . flush ( ) <EOL> zlib_compressobj = zlib . compressobj <EOL> if is_py3_3 : <EOL> ssl = ssl_compat <EOL> else : <EOL> import ssl <EOL> unicode = str <EOL> bytes = bytes </s>
<s> """<STR_LIT>""" <EOL> import threading <EOL> import socket <EOL> import sys <EOL> from hyper import HTTP20Connection <EOL> from hyper . compat import ssl <EOL> from hyper . http11 . connection import HTTP11Connection <EOL> from hpack . hpack import Encoder <EOL> from hpack . huffman import HuffmanEncoder <EOL> from hpack . huffman_constants import ( <EOL> REQUEST_CODES , REQUEST_CODES_LENGTH <EOL> ) <EOL> from hyper . tls import NPN_PROTOCOL <EOL> class SocketServerThread ( threading . Thread ) : <EOL> """<STR_LIT>""" <EOL> def __init__ ( self , <EOL> socket_handler , <EOL> host = '<STR_LIT:localhost>' , <EOL> ready_event = None , <EOL> h2 = True , <EOL> secure = True ) : <EOL> threading . Thread . __init__ ( self ) <EOL> self . socket_handler = socket_handler <EOL> self . host = host <EOL> self . secure = secure <EOL> self . ready_event = ready_event <EOL> self . daemon = True <EOL> if self . secure : <EOL> self . cxt = ssl . SSLContext ( ssl . PROTOCOL_SSLv23 ) <EOL> if ssl . HAS_NPN and h2 : <EOL> self . cxt . set_npn_protocols ( [ NPN_PROTOCOL ] ) <EOL> self . cxt . load_cert_chain ( certfile = '<STR_LIT>' , <EOL> keyfile = '<STR_LIT>' ) <EOL> def _start_server ( self ) : <EOL> sock = socket . socket ( ) <EOL> if sys . platform != '<STR_LIT:win32>' : <EOL> sock . setsockopt ( socket . SOL_SOCKET , socket . SO_REUSEADDR , <NUM_LIT:1> ) <EOL> if self . secure : <EOL> sock = self . cxt . wrap_socket ( sock , server_side = True ) <EOL> sock . bind ( ( self . host , <NUM_LIT:0> ) ) <EOL> self . port = sock . getsockname ( ) [ <NUM_LIT:1> ] <EOL> sock . listen ( <NUM_LIT:1> ) <EOL> if self . ready_event : <EOL> self . ready_event . set ( ) <EOL> self . socket_handler ( sock ) <EOL> sock . close ( ) <EOL> def _wrap_socket ( self , sock ) : <EOL> raise NotImplementedError ( ) <EOL> def run ( self ) : <EOL> self . server = self . _start_server ( ) <EOL> class SocketLevelTest ( object ) : <EOL> """<STR_LIT>""" <EOL> def set_up ( self , secure = True , proxy = False ) : <EOL> self . host = None <EOL> self . port = None <EOL> self . secure = secure if not proxy else False <EOL> self . proxy = proxy <EOL> self . server_thread = None <EOL> def _start_server ( self , socket_handler ) : <EOL> """<STR_LIT>""" <EOL> ready_event = threading . Event ( ) <EOL> self . server_thread = SocketServerThread ( <EOL> socket_handler = socket_handler , <EOL> ready_event = ready_event , <EOL> h2 = self . h2 , <EOL> secure = self . secure <EOL> ) <EOL> self . server_thread . start ( ) <EOL> ready_event . wait ( ) <EOL> self . host = self . server_thread . host <EOL> self . port = self . server_thread . port <EOL> self . secure = self . server_thread . secure <EOL> def get_connection ( self ) : <EOL> if self . h2 : <EOL> if not self . proxy : <EOL> return HTTP20Connection ( self . host , self . port , self . secure ) <EOL> else : <EOL> return HTTP20Connection ( '<STR_LIT>' , secure = self . secure , <EOL> proxy_host = self . host , <EOL> proxy_port = self . port ) <EOL> else : <EOL> if not self . proxy : <EOL> return HTTP11Connection ( self . host , self . port , self . secure ) <EOL> else : <EOL> return HTTP11Connection ( '<STR_LIT>' , secure = self . secure , <EOL> proxy_host = self . host , <EOL> proxy_port = self . port ) <EOL> def get_encoder ( self ) : <EOL> """<STR_LIT>""" <EOL> e = Encoder ( ) <EOL> e . huffman_coder = HuffmanEncoder ( REQUEST_CODES , REQUEST_CODES_LENGTH ) <EOL> return e <EOL> def tear_down ( self ) : <EOL> """<STR_LIT>""" <EOL> self . server_thread . join ( <NUM_LIT:0.1> ) </s>
<s> import numpy as np <EOL> import lxmls . readers . pos_corpus as pcc <EOL> from os import path <EOL> import pickle <EOL> corpus = pcc . PostagCorpus ( ) <EOL> input_data = path . join ( <EOL> path . dirname ( __file__ ) , <EOL> "<STR_LIT>" ) <EOL> train_seq = corpus . read_sequence_list_conll ( input_data , max_sent_len = <NUM_LIT:15> , max_nr_sent = <NUM_LIT:1000> ) <EOL> pickle . dump ( ( corpus . word_dict , corpus . tag_dict ) , open ( '<STR_LIT>' , '<STR_LIT:w>' ) ) <EOL> with open ( '<STR_LIT>' , '<STR_LIT:w>' ) as output : <EOL> for seq in train_seq : <EOL> words = [ corpus . word_dict . get_label_name ( seq . x [ i ] ) for i in xrange ( len ( seq ) ) ] <EOL> tags = [ corpus . tag_dict . get_label_name ( seq . y [ i ] ) for i in xrange ( len ( seq ) ) ] <EOL> s = '<STR_LIT:U+0020>' . join ( [ '<STR_LIT:_>' . join ( [ word , tag ] ) for word , tag in zip ( words , tags ) ] ) <EOL> output . write ( s + '<STR_LIT:\n>' ) </s>
<s> import sys <EOL> import numpy as np <EOL> from lxmls . parsing . dependency_reader import * <EOL> from lxmls . parsing . dependency_writer import * <EOL> from lxmls . parsing . dependency_features import * <EOL> from lxmls . parsing . dependency_decoder import * <EOL> from lxmls . util . my_math_utils import * <EOL> class DependencyParser ( ) : <EOL> '''<STR_LIT>''' <EOL> def __init__ ( self ) : <EOL> self . trained = False <EOL> self . projective = False <EOL> self . language = "<STR_LIT>" <EOL> self . weights = [ ] <EOL> self . decoder = DependencyDecoder ( ) <EOL> self . reader = DependencyReader ( ) <EOL> self . writer = DependencyWriter ( ) <EOL> self . features = DependencyFeatures ( ) <EOL> def read_data ( self , language ) : <EOL> self . language = language <EOL> self . reader . load ( language ) <EOL> self . features . create_dictionary ( self . reader . train_instances ) <EOL> def train_perceptron ( self , n_epochs ) : <EOL> '''<STR_LIT>''' <EOL> self . weights = np . zeros ( self . features . n_feats ) <EOL> total = np . zeros ( self . features . n_feats ) <EOL> for epoch in range ( n_epochs ) : <EOL> print "<STR_LIT>" . format ( epoch + <NUM_LIT:1> ) <EOL> n_mistakes = <NUM_LIT:0> <EOL> n_tokens = <NUM_LIT:0> <EOL> n_instances = <NUM_LIT:0> <EOL> for instance in self . reader . train_instances : <EOL> feats = self . features . create_features ( instance ) <EOL> scores = self . features . compute_scores ( feats , self . weights ) <EOL> if self . projective : <EOL> heads_pred = self . decoder . parse_proj ( scores ) <EOL> else : <EOL> heads_pred = self . decoder . parse_nonproj ( scores ) <EOL> for m in range ( np . size ( heads_pred ) ) : <EOL> if heads_pred [ m ] != instance . heads [ m ] : <EOL> for f in feats [ instance . heads [ m ] ] [ m ] : <EOL> if f < <NUM_LIT:0> : <EOL> continue <EOL> self . weights [ f ] += <NUM_LIT:1.0> <EOL> for f in feats [ heads_pred [ m ] ] [ m ] : <EOL> if f < <NUM_LIT:0> : <EOL> continue <EOL> self . weights [ f ] -= <NUM_LIT:1.0> <EOL> n_mistakes += <NUM_LIT:1> <EOL> n_tokens += <NUM_LIT:1> <EOL> n_instances += <NUM_LIT:1> <EOL> print "<STR_LIT>" . format ( np . double ( n_tokens - n_mistakes ) / np . double ( n_tokens ) ) <EOL> total += self . weights <EOL> self . weights = total / np . double ( n_epochs ) <EOL> def train_crf_sgd ( self , n_epochs , sigma , eta0 = <NUM_LIT> ) : <EOL> '''<STR_LIT>''' <EOL> self . weights = np . zeros ( self . features . n_feats ) <EOL> t = <NUM_LIT:0> <EOL> t0 = <NUM_LIT:1.0> / ( sigma * eta0 ) <EOL> for epoch in range ( n_epochs ) : <EOL> print "<STR_LIT>" . format ( epoch + <NUM_LIT:1> ) <EOL> n_mistakes = <NUM_LIT:0> <EOL> n_tokens = <NUM_LIT:0> <EOL> n_instances = <NUM_LIT:0> <EOL> objective = <NUM_LIT:0.0> <EOL> for instance in self . reader . train_instances : <EOL> eta = <NUM_LIT:1.0> / ( sigma * ( t + t0 ) ) <EOL> feats = self . features . create_features ( instance ) <EOL> scores = self . features . compute_scores ( feats , self . weights ) <EOL> marginals , logZ = self . decoder . parse_marginals_nonproj ( scores ) <EOL> self . weights -= eta * sigma * self . weights <EOL> for h in range ( np . size ( marginals , <NUM_LIT:0> ) ) : <EOL> for m in range ( <NUM_LIT:1> , np . size ( marginals , <NUM_LIT:1> ) ) : <EOL> if feats [ h ] [ m ] == None : <EOL> continue <EOL> for f in feats [ h ] [ m ] : <EOL> if f < <NUM_LIT:0> : <EOL> continue <EOL> self . weights [ f ] -= eta * marginals [ h , m ] <EOL> score_corr = <NUM_LIT:0.0> <EOL> for m in range ( <NUM_LIT:1> , np . size ( instance . heads ) ) : <EOL> h = instance . heads [ m ] <EOL> score_corr += scores [ h , m ] <EOL> for f in feats [ h ] [ m ] : <EOL> if f < <NUM_LIT:0> : <EOL> continue <EOL> self . weights [ f ] += eta <EOL> objective += <NUM_LIT:0.5> * sigma * np . dot ( self . weights , self . weights ) - score_corr + logZ <EOL> n_instances += <NUM_LIT:1> <EOL> t += <NUM_LIT:1> <EOL> print "<STR_LIT>" . format ( objective / n_instances ) <EOL> def test ( self ) : <EOL> n_mistakes = <NUM_LIT:0> <EOL> n_tokens = <NUM_LIT:0> <EOL> n_instances = <NUM_LIT:0> <EOL> arr_heads_pred = [ ] ; <EOL> for instance in self . reader . test_instances : <EOL> feats = self . features . create_features ( instance ) <EOL> scores = self . features . compute_scores ( feats , self . weights ) <EOL> if self . projective : <EOL> heads_pred = self . decoder . parse_proj ( scores ) <EOL> else : <EOL> heads_pred = self . decoder . parse_nonproj ( scores ) <EOL> for m in range ( np . size ( heads_pred ) ) : <EOL> if heads_pred [ m ] != instance . heads [ m ] : <EOL> for f in feats [ instance . heads [ m ] ] [ m ] : <EOL> if f < <NUM_LIT:0> : <EOL> continue <EOL> for f in feats [ heads_pred [ m ] ] [ m ] : <EOL> if f < <NUM_LIT:0> : <EOL> continue <EOL> n_mistakes += <NUM_LIT:1> <EOL> n_tokens += <NUM_LIT:1> <EOL> n_instances += <NUM_LIT:1> <EOL> arr_heads_pred . append ( heads_pred ) <EOL> print "<STR_LIT>" . format ( n_instances , np . double ( n_tokens - n_mistakes ) / np . double ( n_tokens ) ) <EOL> self . writer . save ( self . language , arr_heads_pred ) </s>
<s> from lxmls . sequences . label_dictionary import * <EOL> import pdb <EOL> class IDFeatures : <EOL> '''<STR_LIT>''' <EOL> def __init__ ( self , dataset ) : <EOL> '''<STR_LIT>''' <EOL> self . feature_dict = LabelDictionary ( ) <EOL> self . feature_list = [ ] <EOL> self . add_features = False <EOL> self . dataset = dataset <EOL> self . node_feature_cache = { } <EOL> self . initial_state_feature_cache = { } <EOL> self . final_state_feature_cache = { } <EOL> self . edge_feature_cache = { } <EOL> def get_num_features ( self ) : <EOL> return len ( self . feature_dict ) <EOL> def build_features ( self ) : <EOL> '''<STR_LIT>''' <EOL> self . add_features = True <EOL> for sequence in self . dataset . seq_list : <EOL> initial_features , transition_features , final_features , emission_features = self . get_sequence_features ( sequence ) <EOL> self . feature_list . append ( [ initial_features , transition_features , final_features , emission_features ] ) <EOL> self . add_features = False <EOL> def get_sequence_features ( self , sequence ) : <EOL> '''<STR_LIT>''' <EOL> emission_features = [ ] <EOL> initial_features = [ ] <EOL> transition_features = [ ] <EOL> final_features = [ ] <EOL> features = [ ] <EOL> features = self . add_initial_features ( sequence , sequence . y [ <NUM_LIT:0> ] , features ) <EOL> initial_features . append ( features ) <EOL> for pos , tag in enumerate ( sequence . y ) : <EOL> features = [ ] <EOL> features = self . add_emission_features ( sequence , pos , sequence . y [ pos ] , features ) <EOL> emission_features . append ( features ) <EOL> if pos > <NUM_LIT:0> : <EOL> prev_tag = sequence . y [ pos - <NUM_LIT:1> ] <EOL> features = [ ] <EOL> features = self . add_transition_features ( sequence , pos - <NUM_LIT:1> , tag , prev_tag , features ) <EOL> transition_features . append ( features ) <EOL> features = [ ] <EOL> features = self . add_final_features ( sequence , sequence . y [ - <NUM_LIT:1> ] , features ) <EOL> final_features . append ( features ) <EOL> return initial_features , transition_features , final_features , emission_features <EOL> def get_emission_features ( self , sequence , pos , y ) : <EOL> all_feat = [ ] <EOL> x = sequence . x [ pos ] <EOL> if ( x not in self . node_feature_cache ) : <EOL> self . node_feature_cache [ x ] = { } <EOL> if ( y not in self . node_feature_cache [ x ] ) : <EOL> node_idx = [ ] <EOL> node_idx = self . add_emission_features ( sequence , pos , y , node_idx ) <EOL> self . node_feature_cache [ x ] [ y ] = node_idx <EOL> idx = self . node_feature_cache [ x ] [ y ] <EOL> all_feat = idx [ : ] <EOL> return all_feat <EOL> def get_transition_features ( self , sequence , pos , y , y_prev ) : <EOL> assert ( pos >= <NUM_LIT:0> and pos < len ( sequence . x ) ) , pdb . set_trace ( ) <EOL> if ( y not in self . edge_feature_cache ) : <EOL> self . edge_feature_cache [ y ] = { } <EOL> if ( y_prev not in self . edge_feature_cache [ y ] ) : <EOL> edge_idx = [ ] <EOL> edge_idx = self . add_transition_features ( sequence , pos , y , y_prev , edge_idx ) <EOL> self . edge_feature_cache [ y ] [ y_prev ] = edge_idx <EOL> return self . edge_feature_cache [ y ] [ y_prev ] <EOL> def get_initial_features ( self , sequence , y ) : <EOL> if ( y not in self . initial_state_feature_cache ) : <EOL> edge_idx = [ ] <EOL> edge_idx = self . add_initial_features ( sequence , y , edge_idx ) <EOL> self . initial_state_feature_cache [ y ] = edge_idx <EOL> return self . initial_state_feature_cache [ y ] <EOL> def get_final_features ( self , sequence , y_prev ) : <EOL> if ( y_prev not in self . final_state_feature_cache ) : <EOL> edge_idx = [ ] <EOL> edge_idx = self . add_final_features ( sequence , y_prev , edge_idx ) <EOL> self . final_state_feature_cache [ y_prev ] = edge_idx <EOL> return self . final_state_feature_cache [ y_prev ] <EOL> def add_initial_features ( self , sequence , y , features ) : <EOL> y_name = self . dataset . y_dict . get_label_name ( y ) <EOL> feat_name = "<STR_LIT>" % ( y_name ) <EOL> feat_id = self . add_feature ( feat_name ) <EOL> if ( feat_id != - <NUM_LIT:1> ) : <EOL> features . append ( feat_id ) <EOL> return features <EOL> def add_final_features ( self , sequence , y_prev , features ) : <EOL> y_name = self . dataset . y_dict . get_label_name ( y_prev ) <EOL> feat_name = "<STR_LIT>" % ( y_name ) <EOL> feat_id = self . add_feature ( feat_name ) <EOL> if ( feat_id != - <NUM_LIT:1> ) : <EOL> features . append ( feat_id ) <EOL> return features <EOL> def add_emission_features ( self , sequence , pos , y , features ) : <EOL> '''<STR_LIT>''' <EOL> x = sequence . x [ pos ] <EOL> y_name = self . dataset . y_dict . get_label_name ( y ) <EOL> x_name = self . dataset . x_dict . get_label_name ( x ) <EOL> feat_name = "<STR_LIT>" % ( x_name , y_name ) <EOL> feat_id = self . add_feature ( feat_name ) <EOL> if feat_id != - <NUM_LIT:1> : <EOL> features . append ( feat_id ) <EOL> return features <EOL> def add_transition_features ( self , sequence , pos , y , y_prev , features ) : <EOL> """<STR_LIT>""" <EOL> assert pos < len ( sequence . x ) - <NUM_LIT:1> , pdb . set_trace ( ) <EOL> y_name = self . dataset . y_dict . get_label_name ( y ) <EOL> y_prev_name = self . dataset . y_dict . get_label_name ( y_prev ) <EOL> feat_name = "<STR_LIT>" % ( y_prev_name , y_name ) <EOL> feat_id = self . add_feature ( feat_name ) <EOL> if ( feat_id != - <NUM_LIT:1> ) : <EOL> features . append ( feat_id ) <EOL> return features <EOL> def add_feature ( self , feat_name ) : <EOL> """<STR_LIT>""" <EOL> if ( feat_name in self . feature_dict ) : <EOL> return self . feature_dict [ feat_name ] <EOL> if not self . add_features : <EOL> return - <NUM_LIT:1> <EOL> return self . feature_dict . add ( feat_name ) </s>
<s> '''<STR_LIT>''' <EOL> import os <EOL> try : <EOL> import ogr <EOL> except ImportError : <EOL> from osgeo import ogr <EOL> line_shp_file = "<STR_LIT>" <EOL> line_datasource = ogr . Open ( line_shp_file ) <EOL> driver = ogr . GetDriverByName ( '<STR_LIT>' ) <EOL> point_shp_file = '<STR_LIT>' <EOL> layer_name = '<STR_LIT>' <EOL> if os . path . exists ( point_shp_file ) : <EOL> driver . DeleteDataSource ( point_shp_file ) <EOL> point_datasource = driver . CreateDataSource ( point_shp_file ) <EOL> layer_count = line_datasource . GetLayerCount ( ) <EOL> for each_layer in range ( layer_count ) : <EOL> layer = line_datasource . GetLayerByIndex ( each_layer ) <EOL> srs = layer . GetSpatialRef ( ) <EOL> point_shp_layer = point_datasource . CreateLayer ( layer_name , srs , ogr . wkbPoint ) <EOL> feature_count = layer . GetFeatureCount ( ) <EOL> for each_feature in range ( feature_count ) : <EOL> line_feature = layer . GetFeature ( each_feature ) <EOL> feature_geom = line_feature . GetGeometryRef ( ) <EOL> if feature_geom . GetGeometryName ( ) != '<STR_LIT>' : <EOL> points = feature_geom . GetPoints ( ) <EOL> for point in points : <EOL> point_geom = ogr . Geometry ( ogr . wkbPoint ) <EOL> point_geom . AddPoint ( point [ <NUM_LIT:0> ] , point [ <NUM_LIT:1> ] ) <EOL> point_feature = ogr . Feature ( point_shp_layer . GetLayerDefn ( ) ) <EOL> point_feature . SetGeometry ( point_geom ) <EOL> point_shp_layer . CreateFeature ( point_feature ) </s>
<s> '''<STR_LIT>''' <EOL> try : <EOL> import ogr <EOL> except ImportError : <EOL> from osgeo import ogr <EOL> latitudes = [ <NUM_LIT:50> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ] <EOL> longitudes = [ <NUM_LIT:100> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ] <EOL> elevation = <NUM_LIT:0> <EOL> points = ogr . Geometry ( ogr . wkbMultiPoint ) <EOL> point_1 = ogr . Geometry ( ogr . wkbPoint ) <EOL> point_1 . AddPoint ( longitudes [ <NUM_LIT:0> ] , latitudes [ <NUM_LIT:0> ] , elevation ) <EOL> points . AddGeometry ( point_1 ) <EOL> point_2 = ogr . Geometry ( ogr . wkbPoint ) <EOL> point_2 . AddPoint ( longitudes [ <NUM_LIT:1> ] , latitudes [ <NUM_LIT:1> ] , elevation ) <EOL> points . AddGeometry ( point_2 ) <EOL> point_3 = ogr . Geometry ( ogr . wkbPoint ) <EOL> point_3 . AddPoint ( longitudes [ <NUM_LIT:2> ] , latitudes [ <NUM_LIT:2> ] , elevation ) <EOL> points . AddGeometry ( point_3 ) <EOL> point_4 = ogr . Geometry ( ogr . wkbPoint ) <EOL> point_4 . AddPoint ( longitudes [ <NUM_LIT:3> ] , latitudes [ <NUM_LIT:3> ] , elevation ) <EOL> points . AddGeometry ( point_4 ) <EOL> point_5 = ogr . Geometry ( ogr . wkbPoint ) <EOL> point_5 . AddPoint ( longitudes [ <NUM_LIT:4> ] , latitudes [ <NUM_LIT:4> ] , elevation ) <EOL> points . AddGeometry ( point_5 ) <EOL> points . ExportToWkt ( ) <EOL> print points </s>
